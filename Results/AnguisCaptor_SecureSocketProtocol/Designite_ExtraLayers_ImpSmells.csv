Implementation smell,Namespace,Class,File,Method,Description
Long Method,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The method has 109 lines of code.
Long Method,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The method has 102 lines of code.
Long Method,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The method has 109 lines of code.
Long Method,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The method has 102 lines of code.
Long Method,SevenZip.Compression.LZMA,Decoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaDecoder.cs,Code,The method has 114 lines of code.
Long Method,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The method has 453 lines of code.
Long Method,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The method has 160 lines of code.
Long Method,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The method has 103 lines of code.
Long Method,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The method has 125 lines of code.
Complex Method,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,Cyclomatic complexity of the method is 58
Complex Method,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,Cyclomatic complexity of the method is 15
Complex Method,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,Cyclomatic complexity of the method is 21
Long Parameter List,ExtraLayers.LZ4,ILZ4Compressor,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\ILZ4Compressor.cs,Compress,The method has 5 parameters. Parameters: source' srcOffset' count' dest' dstOffset
Long Parameter List,ExtraLayers.LZ4,ILZ4Decompressor,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\ILZ4Decompressor.cs,Decompress,The method has 5 parameters. Parameters: compressedBuffer' compressedPosition' decompressedBuffer' decompressedPosition' compressedSize
Long Parameter List,ExtraLayers.LZ4,LZ4,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4.cs,Compress,The method has 5 parameters. Parameters: source' srcOffset' count' dest' dstOffset
Long Parameter List,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The method has 5 parameters. Parameters: source' srcOffset' count' dest' dstOffset
Long Parameter List,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The method has 5 parameters. Parameters: source' srcOffset' count' dest' dstOffset
Long Parameter List,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,Decompress,The method has 5 parameters. Parameters: compressedBuffer' compressedPosition' decompressedBuffer' decompressedPosition' compressedSize
Long Parameter List,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,Decompress,The method has 5 parameters. Parameters: compressedBuffer' compressedPosition' decompressedBuffer' decompressedPosition' compressedSize
Long Parameter List,ExtraLayers.LZ4,Lz4Layer,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\Lz4Layer.cs,ApplyLayer,The method has 6 parameters. Parameters: InData' InOffset' InLen' OutData' OutOffset' OutLen
Long Parameter List,ExtraLayers.LZ4,Lz4Layer,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\Lz4Layer.cs,RemoveLayer,The method has 6 parameters. Parameters: InData' InOffset' InLen' OutData' OutOffset' OutLen
Long Parameter List,SevenZip,ICoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\ICoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,SevenZip.Compression.LZMA,Decoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaDecoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,SevenZip.Compression.RangeCoder,BitTreeEncoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\RangeCoder\RangeCoderBitTree.cs,ReverseEncode,The method has 5 parameters. Parameters: Models' startIndex' rangeEncoder' NumBitLevels' symbol
Long Parameter List,ExtraLayers.LZMA,LzmaLayer,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\LzmaLayer.cs,ApplyLayer,The method has 6 parameters. Parameters: InData' InOffset' InLen' OutData' OutOffset' OutLen
Long Parameter List,ExtraLayers.LZMA,LzmaLayer,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\LzmaLayer.cs,RemoveLayer,The method has 6 parameters. Parameters: InData' InOffset' InLen' OutData' OutOffset' OutLen
Long Identifier,SevenZip.Compression.LZMA,Base,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaBase.cs,,The length of the parameter kNumLitPosStatesBitsEncodingMax is 31.
Long Statement,ExtraLayers.LZ4,LZ4,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4.cs,Decompress,The length of the statement  "            return LZ4DecompressorFactory.CreateNew().Decompress(compressedBuffer' decompressedBuffer' compressedSize' maxDecompressedSize); " is 128.
Long Statement,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The length of the statement  "                    if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; } " is 196.
Long Statement,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The length of the statement  "                    { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; }; " is 167.
Long Statement,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The length of the statement  "                    if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; } " is 222.
Long Statement,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The length of the statement  "                    if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; } " is 203.
Long Statement,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The length of the statement  "                    if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; } " is 196.
Long Statement,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The length of the statement  "                    { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; }; " is 167.
Long Statement,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The length of the statement  "                    if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; } " is 238.
Long Statement,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The length of the statement  "                    if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; } " is 203.
Long Statement,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The length of the statement  "                    if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; } " is 196.
Long Statement,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The length of the statement  "                    if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; } " is 222.
Long Statement,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The length of the statement  "                    if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; } " is 203.
Long Statement,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The length of the statement  "                    if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; } " is 196.
Long Statement,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The length of the statement  "                    if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; } " is 238.
Long Statement,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The length of the statement  "                    if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; } " is 203.
Long Statement,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,DecompressKnownSize,The length of the statement  "                    if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; } " is 129.
Long Statement,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,DecompressKnownSize,The length of the statement  "                    do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy; " is 144.
Long Statement,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,DecompressKnownSize,The length of the statement  "                    if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; } " is 130.
Long Statement,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,DecompressKnownSize,The length of the statement  "                        do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ; " is 136.
Long Statement,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,Decompress,The length of the statement  "                    if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } } " is 141.
Long Statement,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,Decompress,The length of the statement  "                    do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy; " is 144.
Long Statement,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,Decompress,The length of the statement  "                    if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } } " is 150.
Long Statement,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,Decompress,The length of the statement  "                        do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ; " is 136.
Long Statement,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,DecompressKnownSize,The length of the statement  "                    if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; } " is 129.
Long Statement,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,DecompressKnownSize,The length of the statement  "                    if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; } " is 130.
Long Statement,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,DecompressKnownSize,The length of the statement  "                        if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ; " is 131.
Long Statement,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,Decompress,The length of the statement  "                    if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } } " is 141.
Long Statement,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,Decompress,The length of the statement  "                    if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } } " is 150.
Long Statement,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,Decompress,The length of the statement  "                        if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ; " is 131.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1(); " is 126.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1(); " is 126.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,FillDistancesPrices,The length of the statement  "					_posSlotPrices[st + posSlot] += ((((posSlot >> 1) - 1) - Base.kNumAlignBits) << RangeCoder.BitEncoder.kNumBitPriceShiftBits); " is 125.
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,LZ4Compressor32,The following statement contains a magic number: if (m_HashTable.Length % 16 != 0)                  throw new Exception("Hash table size must be divisible by 16");
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,CalculateMaxCompressedLength,The following statement contains a magic number: return uncompressedLength + (uncompressedLength / 255) + 16;
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,CalculateMaxCompressedLength,The following statement contains a magic number: return uncompressedLength + (uncompressedLength / 255) + 16;
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  int basePtr = 0; ;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                              if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; *(uint*)op = *(uint*)anchor; op += 4; anchor += 4; ; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          int diff = (int)(*(int*)(r) ^ *(int*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((uint)((diff & -diff) * 0x077CB531U)) >> 27]; ;                          goto _endCount;                      }                            if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor32.cs,Clear,The following statement contains a magic number: Debug.Assert(count % 16 == 0' "HashTable size must be divisible by 16");
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,LZ4Compressor64,The following statement contains a magic number: if (m_HashTable.Length % 16 != 0)                  throw new Exception("Hash table size must be divisible by 16");
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,CalculateMaxCompressedLength,The following statement contains a magic number: return uncompressedLength + (uncompressedLength / 255) + 16;
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,CalculateMaxCompressedLength,The following statement contains a magic number: return uncompressedLength + (uncompressedLength / 255) + 16;
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(byte*) * HASHTABLESIZE);                  byte** hashTable = (byte**)hashTablePtr;                    byte* ip = (byte*)source;                  long basePtr = (long)ip;                    byte* anchor = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* oend = dest + maxOutputSize;                      byte* op = (byte*)dest;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                      // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                    // Main Loop                  for (; ; )                  {                      uint findMatchAttempts = (1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          uint step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            // LZ4_HASH_VALUE                          forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                          r = hashTable[h] + basePtr;                          hashTable[h] = ip - basePtr;                        } while ((r < ip - MAX_DISTANCE) || (*(uint*)r != *(uint*)ip));                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        //Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                    _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (*(uint *)r == *(uint *)ip)                      //					{                      //						ip+=4; r+=4;                      //						if (ip>matchlimit-4) { r -= ip - (matchlimit-3); ip = matchlimit-3; break; }                      //					}                      //					if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //					if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                          if ((ip < (matchlimit - 1)) && (*(ushort*)(r) == *(ushort*)(ip))) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                        len = (int)(ip - anchor);                      if (op + (1 + LASTLITERALS) + (len >> 8) >= oend) return 0; // Check output limit                      // Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token += (byte)LZ4Util.ML_MASK; len -= (byte)LZ4Util.ML_MASK; for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token += (byte)len;                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - 2 - basePtr;                        // Test next position                      r = basePtr + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG))] = ip - basePtr;                      if ((r > ip - (MAX_DISTANCE + 1)) && (*(uint*)r == *(uint*)ip)) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - HASH_LOG));                  }                _last_literals:                  // Encode Last Literals                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun - 15) / 255) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                    // End                  return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Compress64K,The following statement contains a magic number: fixed (byte* hashTablePtr = m_HashTable)              fixed (byte* deBruijnBytePos = DeBruijnBytePos)              {                  Clear(hashTablePtr' sizeof(ushort) * HASHTABLESIZE * 2);                  ushort* hashTable = (ushort*)hashTablePtr;                    byte* ip = (byte*)source;                  byte* anchor = ip;                  byte* basep = ip;                  byte* iend = ip + isize;                  byte* mflimit = iend - MFLIMIT;                  byte* matchlimit = (iend - LASTLITERALS);                  byte* op = (byte*)dest;                  byte* oend = dest + maxOutputSize;                    int len' length;                  const int skipStrength = SKIPSTRENGTH;                  uint forwardH;                    // Init                  if (isize < MINLENGTH) goto _last_literals;                    // First Byte                  ip++; forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                    // Main Loop                  for (; ; )                  {                      int findMatchAttempts = (int)(1U << skipStrength) + 3;                      byte* forwardIp = ip;                      byte* r;                      byte* token;                        // Find a match                      do                      {                          uint h = forwardH;                          int step = findMatchAttempts++ >> skipStrength;                          ip = forwardIp;                          forwardIp = ip + step;                            if (forwardIp > mflimit) { goto _last_literals; }                            forwardH = (((*(uint*)forwardIp) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                          r = basep + hashTable[h];                          hashTable[h] = (ushort)(ip - basep);                        } while (*(uint*)r != *(uint*)ip);                        // Catch up                      while ((ip > anchor) && (r > (byte*)source) && (ip[-1] == r[-1])) { ip--; r--; }                        // Encode Literal Length                      length = (int)(ip - anchor);                      token = op++;                      if (op + length + (2 + 1 + LASTLITERALS) + (length >> 8) >= oend) return 0; // Check output limit                      if (length >= (int)LZ4Util.RUN_MASK) { *token = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); len = (int)(length - LZ4Util.RUN_MASK); for (; len > 254; len -= 255) *op++ = 255; *op++ = (byte)len; }                      else *token = (byte)(length << LZ4Util.ML_BITS);                        // Copy Literals                      { byte* e = (op) + length; do { *(ulong*)op = *(ulong*)anchor; op += 8; anchor += 8; } while (op < e);; op = e; };                      _next_match:                      // Encode Offset                      *(ushort*)op = (ushort)(ip - r); op += 2;                        // Start Counting                      ip += MINMATCH; r += MINMATCH; // MinMatch verified                      anchor = ip;                      //					while (ip<matchlimit-3)                      //					{                      //						if (*(uint *)r == *(uint *)ip) { ip+=4; r+=4; continue; }                      //						if (*(ushort *)r == *(ushort *)ip) { ip+=2; r+=2; }                      //						if (*r == *ip) ip++;                        while (ip < matchlimit - (STEPSIZE - 1))                      {                          long diff = (long)(*(long*)(r) ^ *(long*)(ip));                          if (diff == 0) { ip += STEPSIZE; r += STEPSIZE; continue; }                          ip += DeBruijnBytePos[((ulong)((diff & -diff) * 0x0218A392CDABBD3F)) >> 58]; ;                          goto _endCount;                      }                        if ((ip < (matchlimit - 3)) && (*(uint*)r == *(uint*)ip)) { ip += 4; r += 4; }                        if ((ip < (matchlimit - 1)) && (*(ushort*)r == *(ushort*)ip)) { ip += 2; r += 2; }                      if ((ip < matchlimit) && (*r == *ip)) ip++;                  _endCount:                      len = (int)(ip - anchor);                        //Encode MatchLength                      if (len >= (int)LZ4Util.ML_MASK) { *token = (byte)(*token + LZ4Util.ML_MASK); len = (int)(len - LZ4Util.ML_MASK); for (; len > 509; len -= 510) { *op++ = 255; *op++ = 255; } if (len > 254) { len -= 255; *op++ = 255; } *op++ = (byte)len; }                      else *token = (byte)(*token + len);                        // Test end of chunk                      if (ip > mflimit) { anchor = ip; break; }                        // Fill table                      hashTable[(((*(uint*)ip - 2) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - 2 - basep);                        // Test next position                      r = basep + hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))];                      hashTable[(((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)))] = (ushort)(ip - basep);                      if (*(uint*)r == *(uint*)ip) { token = op++; *token = 0; goto _next_match; }                        // Prepare next loop                      anchor = ip++;                      forwardH = (((*(uint*)ip) * 2654435761U) >> ((MINMATCH * 8) - (HASH_LOG + 1)));                  }                _last_literals:                  {                      int lastRun = (int)(iend - anchor);                      if (((byte*)op - dest) + lastRun + 1 + ((lastRun) >> 8) >= maxOutputSize) return 0;                      if (lastRun >= (int)LZ4Util.RUN_MASK) { *op++ = (byte)(LZ4Util.RUN_MASK << LZ4Util.ML_BITS); lastRun -= (byte)LZ4Util.RUN_MASK; for (; lastRun > 254; lastRun -= 255) *op++ = 255; *op++ = (byte)lastRun; }                      else *op++ = (byte)(lastRun << LZ4Util.ML_BITS);                      LZ4Util.CopyMemory(op' anchor' iend - anchor);                      op += iend - anchor;                  }                      return (int)(((byte*)op) - dest);              }
Magic Number,ExtraLayers.LZ4,LZ4Compressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Compressor64.cs,Clear,The following statement contains a magic number: Debug.Assert(count % 16 == 0' "HashTable size must be divisible by 16");
Magic Number,ExtraLayers.LZ4,LZ4CompressorFactory,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4CompressorFactory.cs,CreateNew,The following statement contains a magic number: if (IntPtr.Size == 4)                  return new LZ4Compressor32();
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                                *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                                *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                                *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                                *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                                *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                                *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                                *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                                *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                                *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                                *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                                *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                                *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                                *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                                *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                                *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                                *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                                *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                                *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                                *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                                *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                                *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,Decompress,The following statement contains a magic number: const int Multiplier = 4;
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                              *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                              *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                              *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                              *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                              *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                              *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                              *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                              *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                              *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                              *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                              *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                              *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                              *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                              *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                              *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                              *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                              *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                              *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                              *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor32,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor32.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; *(uint*)op = *(uint*)ip; op += 4; ip += 4; ; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                                const int dec2 = 0;                              *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(uint*)op = *(uint*)r; op += 4; r += 4; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      do { *(uint*)op = *(uint*)r; op += 4; r += 4; ; *(uint*)op = *(uint*)r; op += 4; r += 4; ; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)                fixed (sbyte* dec2Ptr = m_Dec2table)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(ulong*)op = *(ulong*)ip; op += 8; ip += 8; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                            var dec2 = dec2Ptr[(int)(op - r)];                                    *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(ulong*)op = *(ulong*)r; op += 8; r += 8; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        if (op < cpy) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)                fixed (sbyte* dec2Ptr = m_Dec2table)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(ulong*)op = *(ulong*)ip; op += 8; ip += 8; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                            var dec2 = dec2Ptr[(int)(op - r)];                                    *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(ulong*)op = *(ulong*)r; op += 8; r += 8; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        if (op < cpy) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)                fixed (sbyte* dec2Ptr = m_Dec2table)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(ulong*)op = *(ulong*)ip; op += 8; ip += 8; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                            var dec2 = dec2Ptr[(int)(op - r)];                                    *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(ulong*)op = *(ulong*)r; op += 8; r += 8; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        if (op < cpy) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)                fixed (sbyte* dec2Ptr = m_Dec2table)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(ulong*)op = *(ulong*)ip; op += 8; ip += 8; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                            var dec2 = dec2Ptr[(int)(op - r)];                                    *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(ulong*)op = *(ulong*)r; op += 8; r += 8; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        if (op < cpy) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)                fixed (sbyte* dec2Ptr = m_Dec2table)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(ulong*)op = *(ulong*)ip; op += 8; ip += 8; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                            var dec2 = dec2Ptr[(int)(op - r)];                                    *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(ulong*)op = *(ulong*)r; op += 8; r += 8; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        if (op < cpy) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)                fixed (sbyte* dec2Ptr = m_Dec2table)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(ulong*)op = *(ulong*)ip; op += 8; ip += 8; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                            var dec2 = dec2Ptr[(int)(op - r)];                                    *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(ulong*)op = *(ulong*)r; op += 8; r += 8; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        if (op < cpy) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)                fixed (sbyte* dec2Ptr = m_Dec2table)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(ulong*)op = *(ulong*)ip; op += 8; ip += 8; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                            var dec2 = dec2Ptr[(int)(op - r)];                                    *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(ulong*)op = *(ulong*)r; op += 8; r += 8; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        if (op < cpy) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)                fixed (sbyte* dec2Ptr = m_Dec2table)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(ulong*)op = *(ulong*)ip; op += 8; ip += 8; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                            var dec2 = dec2Ptr[(int)(op - r)];                                    *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(ulong*)op = *(ulong*)r; op += 8; r += 8; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        if (op < cpy) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)                fixed (sbyte* dec2Ptr = m_Dec2table)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(ulong*)op = *(ulong*)ip; op += 8; ip += 8; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                            var dec2 = dec2Ptr[(int)(op - r)];                                    *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(ulong*)op = *(ulong*)r; op += 8; r += 8; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        if (op < cpy) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)                fixed (sbyte* dec2Ptr = m_Dec2table)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(ulong*)op = *(ulong*)ip; op += 8; ip += 8; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                            var dec2 = dec2Ptr[(int)(op - r)];                                    *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(ulong*)op = *(ulong*)r; op += 8; r += 8; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        if (op < cpy) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)                fixed (sbyte* dec2Ptr = m_Dec2table)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(ulong*)op = *(ulong*)ip; op += 8; ip += 8; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                            var dec2 = dec2Ptr[(int)(op - r)];                                    *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(ulong*)op = *(ulong*)r; op += 8; r += 8; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        if (op < cpy) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)                fixed (sbyte* dec2Ptr = m_Dec2table)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(ulong*)op = *(ulong*)ip; op += 8; ip += 8; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                            var dec2 = dec2Ptr[(int)(op - r)];                                    *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(ulong*)op = *(ulong*)r; op += 8; r += 8; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        if (op < cpy) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)                fixed (sbyte* dec2Ptr = m_Dec2table)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(ulong*)op = *(ulong*)ip; op += 8; ip += 8; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                            var dec2 = dec2Ptr[(int)(op - r)];                                    *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(ulong*)op = *(ulong*)r; op += 8; r += 8; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        if (op < cpy) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)                fixed (sbyte* dec2Ptr = m_Dec2table)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(ulong*)op = *(ulong*)ip; op += 8; ip += 8; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                            var dec2 = dec2Ptr[(int)(op - r)];                                    *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(ulong*)op = *(ulong*)r; op += 8; r += 8; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        if (op < cpy) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,DecompressKnownSize,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)                fixed (sbyte* dec2Ptr = m_Dec2table)              {                  // Local Variables                  byte* ip = (byte*)compressed;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + decompressedSize;                  byte* cpy;                    byte token;                  int len' length;                      // Main Loop                  while (true)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { for (; (len = *ip++) == 255; length += 255) { } length += len; }                          cpy = op + length;                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                          LZ4Util.CopyMemory(op' ip' length);                          ip += length;                          break;                      }                        do { *(ulong*)op = *(ulong*)ip; op += 8; ip += 8; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                          // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchLength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { for (; *ip == 255; length += 255) { ip++; } length += *ip++; }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                            var dec2 = dec2Ptr[(int)(op - r)];                                    *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(ulong*)op = *(ulong*)r; op += 8; r += 8; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) break;                          continue;                      }                        if (op < cpy) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < cpy); ;                      op = cpy; // correction                  }                    // end of decoding                  return (int)(((byte*)ip) - compressed);                    // write overflow error detected              _output_error:                  return (int)(-(((byte*)ip) - compressed));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,Decompress,The following statement contains a magic number: const int Multiplier = 4;
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)                fixed (sbyte* dec2Ptr = m_Dec2table)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(ulong*)op = *(ulong*)ip; op += 8; ip += 8; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                            var dec2 = dec2Ptr[op - r];                                  *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(ulong*)op = *(ulong*)r; op += 8; r += 8; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      if (op < cpy) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)                fixed (sbyte* dec2Ptr = m_Dec2table)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(ulong*)op = *(ulong*)ip; op += 8; ip += 8; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                            var dec2 = dec2Ptr[op - r];                                  *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(ulong*)op = *(ulong*)r; op += 8; r += 8; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      if (op < cpy) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)                fixed (sbyte* dec2Ptr = m_Dec2table)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(ulong*)op = *(ulong*)ip; op += 8; ip += 8; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                            var dec2 = dec2Ptr[op - r];                                  *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(ulong*)op = *(ulong*)r; op += 8; r += 8; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      if (op < cpy) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)                fixed (sbyte* dec2Ptr = m_Dec2table)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(ulong*)op = *(ulong*)ip; op += 8; ip += 8; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                            var dec2 = dec2Ptr[op - r];                                  *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(ulong*)op = *(ulong*)r; op += 8; r += 8; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      if (op < cpy) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)                fixed (sbyte* dec2Ptr = m_Dec2table)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(ulong*)op = *(ulong*)ip; op += 8; ip += 8; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                            var dec2 = dec2Ptr[op - r];                                  *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(ulong*)op = *(ulong*)r; op += 8; r += 8; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      if (op < cpy) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)                fixed (sbyte* dec2Ptr = m_Dec2table)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(ulong*)op = *(ulong*)ip; op += 8; ip += 8; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                            var dec2 = dec2Ptr[op - r];                                  *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(ulong*)op = *(ulong*)r; op += 8; r += 8; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      if (op < cpy) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)                fixed (sbyte* dec2Ptr = m_Dec2table)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(ulong*)op = *(ulong*)ip; op += 8; ip += 8; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                            var dec2 = dec2Ptr[op - r];                                  *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(ulong*)op = *(ulong*)r; op += 8; r += 8; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      if (op < cpy) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)                fixed (sbyte* dec2Ptr = m_Dec2table)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(ulong*)op = *(ulong*)ip; op += 8; ip += 8; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                            var dec2 = dec2Ptr[op - r];                                  *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(ulong*)op = *(ulong*)r; op += 8; r += 8; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      if (op < cpy) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)                fixed (sbyte* dec2Ptr = m_Dec2table)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(ulong*)op = *(ulong*)ip; op += 8; ip += 8; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                            var dec2 = dec2Ptr[op - r];                                  *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(ulong*)op = *(ulong*)r; op += 8; r += 8; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      if (op < cpy) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)                fixed (sbyte* dec2Ptr = m_Dec2table)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(ulong*)op = *(ulong*)ip; op += 8; ip += 8; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                            var dec2 = dec2Ptr[op - r];                                  *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(ulong*)op = *(ulong*)r; op += 8; r += 8; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      if (op < cpy) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)                fixed (sbyte* dec2Ptr = m_Dec2table)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(ulong*)op = *(ulong*)ip; op += 8; ip += 8; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                            var dec2 = dec2Ptr[op - r];                                  *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(ulong*)op = *(ulong*)r; op += 8; r += 8; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      if (op < cpy) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)                fixed (sbyte* dec2Ptr = m_Dec2table)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(ulong*)op = *(ulong*)ip; op += 8; ip += 8; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                            var dec2 = dec2Ptr[op - r];                                  *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(ulong*)op = *(ulong*)r; op += 8; r += 8; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      if (op < cpy) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)                fixed (sbyte* dec2Ptr = m_Dec2table)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(ulong*)op = *(ulong*)ip; op += 8; ip += 8; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                            var dec2 = dec2Ptr[op - r];                                  *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(ulong*)op = *(ulong*)r; op += 8; r += 8; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      if (op < cpy) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4Decompressor64,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Decompressor64.cs,Decompress,The following statement contains a magic number: fixed (sbyte* dec = m_DecArray)                fixed (sbyte* dec2Ptr = m_Dec2table)              {                  // Local Variables                  byte* ip = (byte*)compressedBuffer;                  byte* iend = ip + compressedSize;                  byte* r;                    byte* op = (byte*)decompressedBuffer;                  byte* oend = op + maxDecompressedSize;                  byte* cpy;                    byte token;                  int length;                      // Main Loop                  while (ip < iend)                  {                      // get runLength                      token = *ip++;                      if ((length = (token >> LZ4Util.ML_BITS)) == LZ4Util.RUN_MASK) { int s = 255; while ((ip < iend) && (s == 255)) { s = *ip++; length += s; } }                        // copy literals                      cpy = op + length;                      if ((cpy > oend - LZ4Util.COPYLENGTH) || (ip + length > iend - LZ4Util.COPYLENGTH))                      {                          if (cpy > oend) goto _output_error; // Error : request to write beyond destination buffer                          if (ip + length > iend) goto _output_error; // Error : request to read beyond source buffer                          LZ4Util.CopyMemory(op' ip' length);                          op += length;                          ip += length;                          if (ip < iend) goto _output_error; // Error : LZ4 format violation                          break; //Necessarily EOF                      }                        do { *(ulong*)op = *(ulong*)ip; op += 8; ip += 8; } while (op < cpy); ; ip -= (op - cpy); op = cpy;                        // get offset                      { r = (cpy) - *(ushort*)ip; }; ip += 2;                      if (r < decompressedBuffer) goto _output_error;                        // get matchlength                      if ((length = (int)(token & LZ4Util.ML_MASK)) == LZ4Util.ML_MASK) { while (ip < iend) { int s = *ip++; length += s; if (s == 255) continue; break; } }                        // copy repeated sequence                      if (op - r < STEPSIZE)                      {                            var dec2 = dec2Ptr[op - r];                                  *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          *op++ = *r++;                          r -= dec[op - r];                          *(uint*)op = *(uint*)r; op += STEPSIZE - 4;                          r -= dec2;                      }                      else { *(ulong*)op = *(ulong*)r; op += 8; r += 8; ; }                      cpy = op + length - (STEPSIZE - 4);                      if (cpy > oend - LZ4Util.COPYLENGTH)                      {                          if (cpy > oend) goto _output_error;                            if (op < (oend - LZ4Util.COPYLENGTH)) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < (oend - LZ4Util.COPYLENGTH)); ;                          while (op < cpy) *op++ = *r++;                          op = cpy;                          if (op == oend) goto _output_error; // Check EOF (should never happen' since last 5 bytes are supposed to be literals)                          continue;                      }                      if (op < cpy) do { *(ulong*)op = *(ulong*)r; op += 8; r += 8; } while (op < cpy); ;                      op = cpy; // correction                  }                      return (int)(((byte*)op) - decompressedBuffer);                  _output_error:                  return (int)(-(((byte*)ip) - compressedBuffer));              }
Magic Number,ExtraLayers.LZ4,LZ4DecompressorFactory,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4DecompressorFactory.cs,CreateNew,The following statement contains a magic number: if (IntPtr.Size == 4)                  return new LZ4Decompressor32();
Magic Number,ExtraLayers.LZ4,Lz4Layer,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\Lz4Layer.cs,ApplyLayer,The following statement contains a magic number: OutData = new byte[InLen + (1024 * 16)];
Magic Number,ExtraLayers.LZ4,Lz4Layer,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\Lz4Layer.cs,ApplyLayer,The following statement contains a magic number: OutData = new byte[InLen + (1024 * 16)];
Magic Number,ExtraLayers.LZ4,Lz4Layer,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\Lz4Layer.cs,RemoveLayer,The following statement contains a magic number: OutData = new byte[InLen + (1024 * 16)];
Magic Number,ExtraLayers.LZ4,Lz4Layer,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\Lz4Layer.cs,RemoveLayer,The following statement contains a magic number: OutData = new byte[InLen + (1024 * 16)];
Magic Number,ExtraLayers.LZ4,LZ4Util,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Util.cs,CopyMemory,The following statement contains a magic number: while (length >= 16)              {                  *(ulong*)dst = *(ulong*)src; dst += 8; src += 8;                  *(ulong*)dst = *(ulong*)src; dst += 8; src += 8;                  length -= 16;              }
Magic Number,ExtraLayers.LZ4,LZ4Util,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Util.cs,CopyMemory,The following statement contains a magic number: while (length >= 16)              {                  *(ulong*)dst = *(ulong*)src; dst += 8; src += 8;                  *(ulong*)dst = *(ulong*)src; dst += 8; src += 8;                  length -= 16;              }
Magic Number,ExtraLayers.LZ4,LZ4Util,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Util.cs,CopyMemory,The following statement contains a magic number: while (length >= 16)              {                  *(ulong*)dst = *(ulong*)src; dst += 8; src += 8;                  *(ulong*)dst = *(ulong*)src; dst += 8; src += 8;                  length -= 16;              }
Magic Number,ExtraLayers.LZ4,LZ4Util,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Util.cs,CopyMemory,The following statement contains a magic number: while (length >= 16)              {                  *(ulong*)dst = *(ulong*)src; dst += 8; src += 8;                  *(ulong*)dst = *(ulong*)src; dst += 8; src += 8;                  length -= 16;              }
Magic Number,ExtraLayers.LZ4,LZ4Util,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Util.cs,CopyMemory,The following statement contains a magic number: while (length >= 16)              {                  *(ulong*)dst = *(ulong*)src; dst += 8; src += 8;                  *(ulong*)dst = *(ulong*)src; dst += 8; src += 8;                  length -= 16;              }
Magic Number,ExtraLayers.LZ4,LZ4Util,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Util.cs,CopyMemory,The following statement contains a magic number: while (length >= 16)              {                  *(ulong*)dst = *(ulong*)src; dst += 8; src += 8;                  *(ulong*)dst = *(ulong*)src; dst += 8; src += 8;                  length -= 16;              }
Magic Number,ExtraLayers.LZ4,LZ4Util,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Util.cs,CopyMemory,The following statement contains a magic number: if (length >= 8)              {                  *(ulong*)dst = *(ulong*)src; dst += 8; src += 8;                  length -= 8;              }
Magic Number,ExtraLayers.LZ4,LZ4Util,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Util.cs,CopyMemory,The following statement contains a magic number: if (length >= 8)              {                  *(ulong*)dst = *(ulong*)src; dst += 8; src += 8;                  length -= 8;              }
Magic Number,ExtraLayers.LZ4,LZ4Util,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Util.cs,CopyMemory,The following statement contains a magic number: if (length >= 8)              {                  *(ulong*)dst = *(ulong*)src; dst += 8; src += 8;                  length -= 8;              }
Magic Number,ExtraLayers.LZ4,LZ4Util,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Util.cs,CopyMemory,The following statement contains a magic number: if (length >= 8)              {                  *(ulong*)dst = *(ulong*)src; dst += 8; src += 8;                  length -= 8;              }
Magic Number,ExtraLayers.LZ4,LZ4Util,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Util.cs,CopyMemory,The following statement contains a magic number: if (length >= 4)              {                  *(uint*)dst = *(uint*)src; dst += 4; src += 4;                  length -= 4;              }
Magic Number,ExtraLayers.LZ4,LZ4Util,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Util.cs,CopyMemory,The following statement contains a magic number: if (length >= 4)              {                  *(uint*)dst = *(uint*)src; dst += 4; src += 4;                  length -= 4;              }
Magic Number,ExtraLayers.LZ4,LZ4Util,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Util.cs,CopyMemory,The following statement contains a magic number: if (length >= 4)              {                  *(uint*)dst = *(uint*)src; dst += 4; src += 4;                  length -= 4;              }
Magic Number,ExtraLayers.LZ4,LZ4Util,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Util.cs,CopyMemory,The following statement contains a magic number: if (length >= 4)              {                  *(uint*)dst = *(uint*)src; dst += 4; src += 4;                  length -= 4;              }
Magic Number,ExtraLayers.LZ4,LZ4Util,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Util.cs,CopyMemory,The following statement contains a magic number: if (length >= 2)              {                  *(ushort*)dst = *(ushort*)src; dst += 2; src += 2;                  length -= 2;              }
Magic Number,ExtraLayers.LZ4,LZ4Util,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Util.cs,CopyMemory,The following statement contains a magic number: if (length >= 2)              {                  *(ushort*)dst = *(ushort*)src; dst += 2; src += 2;                  length -= 2;              }
Magic Number,ExtraLayers.LZ4,LZ4Util,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Util.cs,CopyMemory,The following statement contains a magic number: if (length >= 2)              {                  *(ushort*)dst = *(ushort*)src; dst += 2; src += 2;                  length -= 2;              }
Magic Number,ExtraLayers.LZ4,LZ4Util,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZ4\LZ4Util.cs,CopyMemory,The following statement contains a magic number: if (length >= 2)              {                  *(ushort*)dst = *(ushort*)src; dst += 2; src += 2;                  length -= 2;              }
Magic Number,SevenZip,CRC,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Common\CRC.cs,CRC,The following statement contains a magic number: Table = new uint[256];
Magic Number,SevenZip,CRC,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Common\CRC.cs,CRC,The following statement contains a magic number: for (uint i = 0; i < 256; i++)  			{  				uint r = i;  				for (int j = 0; j < 8; j++)  					if ((r & 1) != 0)  						r = (r >> 1) ^ kPoly;  					else  						r >>= 1;  				Table[i] = r;  			}
Magic Number,SevenZip,CRC,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Common\CRC.cs,CRC,The following statement contains a magic number: for (uint i = 0; i < 256; i++)  			{  				uint r = i;  				for (int j = 0; j < 8; j++)  					if ((r & 1) != 0)  						r = (r >> 1) ^ kPoly;  					else  						r >>= 1;  				Table[i] = r;  			}
Magic Number,SevenZip,CRC,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Common\CRC.cs,UpdateByte,The following statement contains a magic number: _value = Table[(((byte)(_value)) ^ b)] ^ (_value >> 8);
Magic Number,SevenZip,CRC,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Common\CRC.cs,Update,The following statement contains a magic number: for (uint i = 0; i < size; i++)  				_value = Table[(((byte)(_value)) ^ data[offset + i])] ^ (_value >> 8);
Magic Number,SevenZip,LZMACompressor,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\LZMACompressor.cs,CompressLZMA,The following statement contains a magic number: lock (encoder)              {                  encoder.WriteCoderProperties(output);                  output.Write(BitConverter.GetBytes(input.Length)' 0' 8);                  encoder.Code(input' output' input.Length' -1' null);                  output.Flush();              }
Magic Number,SevenZip,LZMACompressor,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\LZMACompressor.cs,DecompressLZMA,The following statement contains a magic number: lock (decoder)              {                  byte[] properties = new byte[5];                  input.Read(properties' 0' 5);                    byte[] fileLengthBytes = new byte[8];                  input.Read(fileLengthBytes' 0' 8);                  long fileLength = BitConverter.ToInt64(fileLengthBytes' 0);                    decoder.SetDecoderProperties(properties);                  decoder.Code(input' output' input.Length' fileLength' null);                  output.Flush();              }
Magic Number,SevenZip,LZMACompressor,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\LZMACompressor.cs,DecompressLZMA,The following statement contains a magic number: lock (decoder)              {                  byte[] properties = new byte[5];                  input.Read(properties' 0' 5);                    byte[] fileLengthBytes = new byte[8];                  input.Read(fileLengthBytes' 0' 8);                  long fileLength = BitConverter.ToInt64(fileLengthBytes' 0);                    decoder.SetDecoderProperties(properties);                  decoder.Code(input' output' input.Length' fileLength' null);                  output.Flush();              }
Magic Number,SevenZip,LZMACompressor,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\LZMACompressor.cs,DecompressLZMA,The following statement contains a magic number: lock (decoder)              {                  byte[] properties = new byte[5];                  input.Read(properties' 0' 5);                    byte[] fileLengthBytes = new byte[8];                  input.Read(fileLengthBytes' 0' 8);                  long fileLength = BitConverter.ToInt64(fileLengthBytes' 0);                    decoder.SetDecoderProperties(properties);                  decoder.Code(input' output' input.Length' fileLength' null);                  output.Flush();              }
Magic Number,SevenZip,LZMACompressor,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\LZMACompressor.cs,DecompressLZMA,The following statement contains a magic number: lock (decoder)              {                  byte[] properties = new byte[5];                  input.Read(properties' 0' 5);                    byte[] fileLengthBytes = new byte[8];                  input.Read(fileLengthBytes' 0' 8);                  long fileLength = BitConverter.ToInt64(fileLengthBytes' 0);                    decoder.SetDecoderProperties(properties);                  decoder.Code(input' output' input.Length' fileLength' null);                  output.Flush();              }
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaBase.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;  				else if (Index < 10) Index -= 3;  				else Index -= 6;
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaBase.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;  				else if (Index < 10) Index -= 3;  				else Index -= 6;
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaBase.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;  				else if (Index < 10) Index -= 3;  				else Index -= 6;
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaBase.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;  				else if (Index < 10) Index -= 3;  				else Index -= 6;
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaBase.cs,IsCharState,The following statement contains a magic number: return Index < 7;
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaDecoder.cs,SetDictionarySize,The following statement contains a magic number: if (m_DictionarySize != dictionarySize)  			{  				m_DictionarySize = dictionarySize;  				m_DictionarySizeCheck = Math.Max(m_DictionarySize' 1);  				uint blockSize = Math.Max(m_DictionarySizeCheck' (1 << 12));  				m_OutWindow.Create(blockSize);  			}
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: if (lp > 8)  				throw new InvalidParamException();
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: if (lc > 8)  				throw new InvalidParamException();
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaDecoder.cs,Code,The following statement contains a magic number: while (nowPos64 < outSize64)  			{  				// UInt64 next = Math.Min(nowPos64 + (1 << 18)' outSize64);  					// while(nowPos64 < next)  				{  					uint posState = (uint)nowPos64 & m_PosStateMask;  					if (m_IsMatchDecoders[(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0)  					{  						byte b;  						byte prevByte = m_OutWindow.GetByte(0);  						if (!state.IsCharState())  							b = m_LiteralDecoder.DecodeWithMatchByte(m_RangeDecoder'  								(uint)nowPos64' prevByte' m_OutWindow.GetByte(rep0));  						else  							b = m_LiteralDecoder.DecodeNormal(m_RangeDecoder' (uint)nowPos64' prevByte);  						m_OutWindow.PutByte(b);  						state.UpdateChar();  						nowPos64++;  					}  					else  					{  						uint len;  						if (m_IsRepDecoders[state.Index].Decode(m_RangeDecoder) == 1)  						{  							if (m_IsRepG0Decoders[state.Index].Decode(m_RangeDecoder) == 0)  							{  								if (m_IsRep0LongDecoders[(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0)  								{  									state.UpdateShortRep();  									m_OutWindow.PutByte(m_OutWindow.GetByte(rep0));  									nowPos64++;  									continue;  								}  							}  							else  							{  								UInt32 distance;  								if (m_IsRepG1Decoders[state.Index].Decode(m_RangeDecoder) == 0)  								{  									distance = rep1;  								}  								else  								{  									if (m_IsRepG2Decoders[state.Index].Decode(m_RangeDecoder) == 0)  										distance = rep2;  									else  									{  										distance = rep3;  										rep3 = rep2;  									}  									rep2 = rep1;  								}  								rep1 = rep0;  								rep0 = distance;  							}  							len = m_RepLenDecoder.Decode(m_RangeDecoder' posState) + Base.kMatchMinLen;  							state.UpdateRep();  						}  						else  						{  							rep3 = rep2;  							rep2 = rep1;  							rep1 = rep0;  							len = Base.kMatchMinLen + m_LenDecoder.Decode(m_RangeDecoder' posState);  							state.UpdateMatch();  							uint posSlot = m_PosSlotDecoder[Base.GetLenToPosState(len)].Decode(m_RangeDecoder);  							if (posSlot >= Base.kStartPosModelIndex)  							{  								int numDirectBits = (int)((posSlot >> 1) - 1);  								rep0 = ((2 | (posSlot & 1)) << numDirectBits);  								if (posSlot < Base.kEndPosModelIndex)  									rep0 += BitTreeDecoder.ReverseDecode(m_PosDecoders'  											rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);  								else  								{  									rep0 += (m_RangeDecoder.DecodeDirectBits(  										numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);  									rep0 += m_PosAlignDecoder.ReverseDecode(m_RangeDecoder);  								}  							}  							else  								rep0 = posSlot;  						}  						if (rep0 >= m_OutWindow.TrainSize + nowPos64 || rep0 >= m_DictionarySizeCheck)  						{  							if (rep0 == 0xFFFFFFFF)  								break;  							throw new DataErrorException();  						}  						m_OutWindow.CopyBlock(rep0' len);  						nowPos64 += len;  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: if (properties.Length < 5)  				throw new InvalidParamException();
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int lc = properties[0] % 9;
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int remainder = properties[0] / 9;
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int lp = remainder % 5;
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int pb = remainder / 5;
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
Magic Number,SevenZip.Compression.LZMA,LiteralDecoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaDecoder.cs,GetState,The following statement contains a magic number: return ((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits));
Magic Number,SevenZip.Compression.LZMA,Decoder2,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaDecoder.cs,DecodeWithMatchByte,The following statement contains a magic number: do  					{  						uint matchBit = (uint)(matchByte >> 7) & 1;  						matchByte <<= 1;  						uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);  						symbol = (symbol << 1) | bit;  						if (matchBit != bit)  						{  							while (symbol < 0x100)  								symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);  							break;  						}  					}  					while (symbol < 0x100);
Magic Number,SevenZip.Compression.LZMA,Decoder2,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaDecoder.cs,DecodeWithMatchByte,The following statement contains a magic number: do  					{  						uint matchBit = (uint)(matchByte >> 7) & 1;  						matchByte <<= 1;  						uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);  						symbol = (symbol << 1) | bit;  						if (matchBit != bit)  						{  							while (symbol < 0x100)  								symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);  							break;  						}  					}  					while (symbol < 0x100);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,Encoder,The following statement contains a magic number: const Byte kFastSlots = 22;
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,Encoder,The following statement contains a magic number: int c = 2;
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,Encoder,The following statement contains a magic number: for (Byte slotFast = 2; slotFast < kFastSlots; slotFast++)  			{  				UInt32 k = ((UInt32)1 << ((slotFast >> 1) - 1));  				for (UInt32 j = 0; j < k; j++' c++)  					g_FastPos[c] = slotFast;  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 11))  				return g_FastPos[pos];
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))  				return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))  				return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))  				return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 20] + 40);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 20] + 40);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))  				return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))  				return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))  				return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))  				return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))  				return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))  				return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 26] + 52);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 26] + 52);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,Create,The following statement contains a magic number: if (_matchFinder == null)  			{  				LZ.BinTree bt = new LZ.BinTree();  				int numHashBytes = 4;  				if (_matchFinderType == EMatchFinderType.BT2)  					numHashBytes = 2;  				bt.SetType(numHashBytes);  				_matchFinder = bt;  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,Create,The following statement contains a magic number: if (_matchFinder == null)  			{  				LZ.BinTree bt = new LZ.BinTree();  				int numHashBytes = 4;  				if (_matchFinderType == EMatchFinderType.BT2)  					numHashBytes = 2;  				bt.SetType(numHashBytes);  				_matchFinder = bt;  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,ReadMatchDistances,The following statement contains a magic number: if (numDistancePairs > 0)  			{  				lenRes = _matchDistances[numDistancePairs - 2];  				if (lenRes == _numFastBytes)  					lenRes += _matchFinder.GetMatchLen((int)lenRes - 1' _matchDistances[numDistancePairs - 1]'  						Base.kMatchMaxLen - lenRes);  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPureRepPrice,The following statement contains a magic number: if (repIndex == 0)  			{  				price = _isRepG0[state.Index].GetPrice0();  				price += _isRep0Long[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  			}  			else  			{  				price = _isRepG0[state.Index].GetPrice1();  				if (repIndex == 1)  					price += _isRepG1[state.Index].GetPrice0();  				else  				{  					price += _isRepG1[state.Index].GetPrice1();  					price += _isRepG2[state.Index].GetPrice(repIndex - 2);  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (numAvailableBytes < 2)  			{  				backRes = 0xFFFFFFFF;  				return 1;  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2)  			{  				backRes = (UInt32)0xFFFFFFFF;  				return 1;  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2)  			{  				backRes = (UInt32)0xFFFFFFFF;  				return 1;  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if(lenEnd < 2)  			{  				backRes = _optimum[1].BackPrev;  				return 1;  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum[0].Backs2 = reps[2];
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum[0].Backs3 = reps[3];
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: do  				_optimum[len--].Price = kIfinityPrice;  			while (len >= 2);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++)  			{  				UInt32 repLen = repLens[i];  				if (repLen < 2)  					continue;  				UInt32 price = repMatchPrice + GetPureRepPrice(i' _state' posState);  				do  				{  					UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);  					Optimal optimum = _optimum[repLen];  					if (curAndLenPrice < optimum.Price)  					{  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = 0;  						optimum.BackPrev = i;  						optimum.Prev1IsChar = false;  					}  				}  				while (--repLen >= 2);  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++)  			{  				UInt32 repLen = repLens[i];  				if (repLen < 2)  					continue;  				UInt32 price = repMatchPrice + GetPureRepPrice(i' _state' posState);  				do  				{  					UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);  					Optimal optimum = _optimum[repLen];  					if (curAndLenPrice < optimum.Price)  					{  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = 0;  						optimum.BackPrev = i;  						optimum.Prev1IsChar = false;  					}  				}  				while (--repLen >= 2);  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++)  			{  				UInt32 repLen = repLens[i];  				if (repLen < 2)  					continue;  				UInt32 price = repMatchPrice + GetPureRepPrice(i' _state' posState);  				do  				{  					UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);  					Optimal optimum = _optimum[repLen];  					if (curAndLenPrice < optimum.Price)  					{  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = 0;  						optimum.BackPrev = i;  						optimum.Prev1IsChar = false;  					}  				}  				while (--repLen >= 2);  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (len <= lenMain)  			{  				UInt32 offs = 0;  				while (len > _matchDistances[offs])  					offs += 2;  				for (; ; len++)  				{  					UInt32 distance = _matchDistances[offs + 1];  					UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(distance' len' posState);  					Optimal optimum = _optimum[len];  					if (curAndLenPrice < optimum.Price)  					{  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = 0;  						optimum.BackPrev = distance + Base.kNumRepDistances;  						optimum.Prev1IsChar = false;  					}  					if (len == _matchDistances[offs])  					{  						offs += 2;  						if (offs == numDistancePairs)  							break;  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (len <= lenMain)  			{  				UInt32 offs = 0;  				while (len > _matchDistances[offs])  					offs += 2;  				for (; ; len++)  				{  					UInt32 distance = _matchDistances[offs + 1];  					UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(distance' len' posState);  					Optimal optimum = _optimum[len];  					if (curAndLenPrice < optimum.Price)  					{  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = 0;  						optimum.BackPrev = distance + Base.kNumRepDistances;  						optimum.Prev1IsChar = false;  					}  					if (len == _matchDistances[offs])  					{  						offs += 2;  						if (offs == numDistancePairs)  							break;  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,ChangePair,The following statement contains a magic number: const int kDif = 7;
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,ChangePair,The following statement contains a magic number: return (smallDist < ((UInt32)(1) << (32 - kDif)) && bigDist >= (smallDist << kDif));
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,WriteEndMarker,The following statement contains a magic number: int footerBits = 30;
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true)  			{  				UInt32 pos;  				UInt32 len = GetOptimum((UInt32)nowPos64' out pos);  				  				UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  				UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  				if (len == 1 && pos == 0xFFFFFFFF)  				{  					_isMatch[complexState].Encode(_rangeEncoder' 0);  					Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));  					LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);  					if (!_state.IsCharState())  					{  						Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));  						subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);  					}  					else  						subCoder.Encode(_rangeEncoder' curByte);  					_previousByte = curByte;  					_state.UpdateChar();  				}  				else  				{  					_isMatch[complexState].Encode(_rangeEncoder' 1);  					if (pos < Base.kNumRepDistances)  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 1);  						if (pos == 0)  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 0);  							if (len == 1)  								_isRep0Long[complexState].Encode(_rangeEncoder' 0);  							else  								_isRep0Long[complexState].Encode(_rangeEncoder' 1);  						}  						else  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 1);  							if (pos == 1)  								_isRepG1[_state.Index].Encode(_rangeEncoder' 0);  							else  							{  								_isRepG1[_state.Index].Encode(_rangeEncoder' 1);  								_isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);  							}  						}  						if (len == 1)  							_state.UpdateShortRep();  						else  						{  							_repMatchLenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  							_state.UpdateRep();  						}  						UInt32 distance = _repDistances[pos];  						if (pos != 0)  						{  							for (UInt32 i = pos; i >= 1; i--)  								_repDistances[i] = _repDistances[i - 1];  							_repDistances[0] = distance;  						}  					}  					else  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 0);  						_state.UpdateMatch();  						_lenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  						pos -= Base.kNumRepDistances;  						UInt32 posSlot = GetPosSlot(pos);  						UInt32 lenToPosState = Base.GetLenToPosState(len);  						_posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);    						if (posSlot >= Base.kStartPosModelIndex)  						{  							int footerBits = (int)((posSlot >> 1) - 1);  							UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  							UInt32 posReduced = pos - baseVal;    							if (posSlot < Base.kEndPosModelIndex)  								RangeCoder.BitTreeEncoder.ReverseEncode(_posEncoders'  										baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  							else  							{  								_rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  								_posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & Base.kAlignMask);  								_alignPriceCount++;  							}  						}  						UInt32 distance = pos;  						for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  							_repDistances[i] = _repDistances[i - 1];  						_repDistances[0] = distance;  						_matchPriceCount++;  					}  					_previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));  				}  				_additionalOffset -= len;  				nowPos64 += len;  				if (_additionalOffset == 0)  				{  					// if (!_fastMode)  					if (_matchPriceCount >= (1 << 7))  						FillDistancesPrices();  					if (_alignPriceCount >= Base.kAlignTableSize)  						FillAlignPrices();  					inSize = nowPos64;  					outSize = _rangeEncoder.GetProcessedSizeAdd();  					if (_matchFinder.GetNumAvailableBytes() == 0)  					{  						Flush((UInt32)nowPos64);  						return;  					}    					if (nowPos64 - progressPosValuePrev >= (1 << 12))  					{  						_finished = false;  						finished = false;  						return;  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true)  			{  				UInt32 pos;  				UInt32 len = GetOptimum((UInt32)nowPos64' out pos);  				  				UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  				UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  				if (len == 1 && pos == 0xFFFFFFFF)  				{  					_isMatch[complexState].Encode(_rangeEncoder' 0);  					Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));  					LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);  					if (!_state.IsCharState())  					{  						Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));  						subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);  					}  					else  						subCoder.Encode(_rangeEncoder' curByte);  					_previousByte = curByte;  					_state.UpdateChar();  				}  				else  				{  					_isMatch[complexState].Encode(_rangeEncoder' 1);  					if (pos < Base.kNumRepDistances)  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 1);  						if (pos == 0)  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 0);  							if (len == 1)  								_isRep0Long[complexState].Encode(_rangeEncoder' 0);  							else  								_isRep0Long[complexState].Encode(_rangeEncoder' 1);  						}  						else  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 1);  							if (pos == 1)  								_isRepG1[_state.Index].Encode(_rangeEncoder' 0);  							else  							{  								_isRepG1[_state.Index].Encode(_rangeEncoder' 1);  								_isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);  							}  						}  						if (len == 1)  							_state.UpdateShortRep();  						else  						{  							_repMatchLenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  							_state.UpdateRep();  						}  						UInt32 distance = _repDistances[pos];  						if (pos != 0)  						{  							for (UInt32 i = pos; i >= 1; i--)  								_repDistances[i] = _repDistances[i - 1];  							_repDistances[0] = distance;  						}  					}  					else  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 0);  						_state.UpdateMatch();  						_lenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  						pos -= Base.kNumRepDistances;  						UInt32 posSlot = GetPosSlot(pos);  						UInt32 lenToPosState = Base.GetLenToPosState(len);  						_posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);    						if (posSlot >= Base.kStartPosModelIndex)  						{  							int footerBits = (int)((posSlot >> 1) - 1);  							UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  							UInt32 posReduced = pos - baseVal;    							if (posSlot < Base.kEndPosModelIndex)  								RangeCoder.BitTreeEncoder.ReverseEncode(_posEncoders'  										baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  							else  							{  								_rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  								_posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & Base.kAlignMask);  								_alignPriceCount++;  							}  						}  						UInt32 distance = pos;  						for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  							_repDistances[i] = _repDistances[i - 1];  						_repDistances[0] = distance;  						_matchPriceCount++;  					}  					_previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));  				}  				_additionalOffset -= len;  				nowPos64 += len;  				if (_additionalOffset == 0)  				{  					// if (!_fastMode)  					if (_matchPriceCount >= (1 << 7))  						FillDistancesPrices();  					if (_alignPriceCount >= Base.kAlignTableSize)  						FillAlignPrices();  					inSize = nowPos64;  					outSize = _rangeEncoder.GetProcessedSizeAdd();  					if (_matchFinder.GetNumAvailableBytes() == 0)  					{  						Flush((UInt32)nowPos64);  						return;  					}    					if (nowPos64 - progressPosValuePrev >= (1 << 12))  					{  						_finished = false;  						finished = false;  						return;  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true)  			{  				UInt32 pos;  				UInt32 len = GetOptimum((UInt32)nowPos64' out pos);  				  				UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  				UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  				if (len == 1 && pos == 0xFFFFFFFF)  				{  					_isMatch[complexState].Encode(_rangeEncoder' 0);  					Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));  					LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);  					if (!_state.IsCharState())  					{  						Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));  						subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);  					}  					else  						subCoder.Encode(_rangeEncoder' curByte);  					_previousByte = curByte;  					_state.UpdateChar();  				}  				else  				{  					_isMatch[complexState].Encode(_rangeEncoder' 1);  					if (pos < Base.kNumRepDistances)  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 1);  						if (pos == 0)  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 0);  							if (len == 1)  								_isRep0Long[complexState].Encode(_rangeEncoder' 0);  							else  								_isRep0Long[complexState].Encode(_rangeEncoder' 1);  						}  						else  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 1);  							if (pos == 1)  								_isRepG1[_state.Index].Encode(_rangeEncoder' 0);  							else  							{  								_isRepG1[_state.Index].Encode(_rangeEncoder' 1);  								_isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);  							}  						}  						if (len == 1)  							_state.UpdateShortRep();  						else  						{  							_repMatchLenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  							_state.UpdateRep();  						}  						UInt32 distance = _repDistances[pos];  						if (pos != 0)  						{  							for (UInt32 i = pos; i >= 1; i--)  								_repDistances[i] = _repDistances[i - 1];  							_repDistances[0] = distance;  						}  					}  					else  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 0);  						_state.UpdateMatch();  						_lenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  						pos -= Base.kNumRepDistances;  						UInt32 posSlot = GetPosSlot(pos);  						UInt32 lenToPosState = Base.GetLenToPosState(len);  						_posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);    						if (posSlot >= Base.kStartPosModelIndex)  						{  							int footerBits = (int)((posSlot >> 1) - 1);  							UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  							UInt32 posReduced = pos - baseVal;    							if (posSlot < Base.kEndPosModelIndex)  								RangeCoder.BitTreeEncoder.ReverseEncode(_posEncoders'  										baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  							else  							{  								_rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  								_posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & Base.kAlignMask);  								_alignPriceCount++;  							}  						}  						UInt32 distance = pos;  						for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  							_repDistances[i] = _repDistances[i - 1];  						_repDistances[0] = distance;  						_matchPriceCount++;  					}  					_previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));  				}  				_additionalOffset -= len;  				nowPos64 += len;  				if (_additionalOffset == 0)  				{  					// if (!_fastMode)  					if (_matchPriceCount >= (1 << 7))  						FillDistancesPrices();  					if (_alignPriceCount >= Base.kAlignTableSize)  						FillAlignPrices();  					inSize = nowPos64;  					outSize = _rangeEncoder.GetProcessedSizeAdd();  					if (_matchFinder.GetNumAvailableBytes() == 0)  					{  						Flush((UInt32)nowPos64);  						return;  					}    					if (nowPos64 - progressPosValuePrev >= (1 << 12))  					{  						_finished = false;  						finished = false;  						return;  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true)  			{  				UInt32 pos;  				UInt32 len = GetOptimum((UInt32)nowPos64' out pos);  				  				UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  				UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  				if (len == 1 && pos == 0xFFFFFFFF)  				{  					_isMatch[complexState].Encode(_rangeEncoder' 0);  					Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));  					LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);  					if (!_state.IsCharState())  					{  						Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));  						subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);  					}  					else  						subCoder.Encode(_rangeEncoder' curByte);  					_previousByte = curByte;  					_state.UpdateChar();  				}  				else  				{  					_isMatch[complexState].Encode(_rangeEncoder' 1);  					if (pos < Base.kNumRepDistances)  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 1);  						if (pos == 0)  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 0);  							if (len == 1)  								_isRep0Long[complexState].Encode(_rangeEncoder' 0);  							else  								_isRep0Long[complexState].Encode(_rangeEncoder' 1);  						}  						else  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 1);  							if (pos == 1)  								_isRepG1[_state.Index].Encode(_rangeEncoder' 0);  							else  							{  								_isRepG1[_state.Index].Encode(_rangeEncoder' 1);  								_isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);  							}  						}  						if (len == 1)  							_state.UpdateShortRep();  						else  						{  							_repMatchLenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  							_state.UpdateRep();  						}  						UInt32 distance = _repDistances[pos];  						if (pos != 0)  						{  							for (UInt32 i = pos; i >= 1; i--)  								_repDistances[i] = _repDistances[i - 1];  							_repDistances[0] = distance;  						}  					}  					else  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 0);  						_state.UpdateMatch();  						_lenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  						pos -= Base.kNumRepDistances;  						UInt32 posSlot = GetPosSlot(pos);  						UInt32 lenToPosState = Base.GetLenToPosState(len);  						_posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);    						if (posSlot >= Base.kStartPosModelIndex)  						{  							int footerBits = (int)((posSlot >> 1) - 1);  							UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  							UInt32 posReduced = pos - baseVal;    							if (posSlot < Base.kEndPosModelIndex)  								RangeCoder.BitTreeEncoder.ReverseEncode(_posEncoders'  										baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  							else  							{  								_rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  								_posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & Base.kAlignMask);  								_alignPriceCount++;  							}  						}  						UInt32 distance = pos;  						for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  							_repDistances[i] = _repDistances[i - 1];  						_repDistances[0] = distance;  						_matchPriceCount++;  					}  					_previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));  				}  				_additionalOffset -= len;  				nowPos64 += len;  				if (_additionalOffset == 0)  				{  					// if (!_fastMode)  					if (_matchPriceCount >= (1 << 7))  						FillDistancesPrices();  					if (_alignPriceCount >= Base.kAlignTableSize)  						FillAlignPrices();  					inSize = nowPos64;  					outSize = _rangeEncoder.GetProcessedSizeAdd();  					if (_matchFinder.GetNumAvailableBytes() == 0)  					{  						Flush((UInt32)nowPos64);  						return;  					}    					if (nowPos64 - progressPosValuePrev >= (1 << 12))  					{  						_finished = false;  						finished = false;  						return;  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				properties[1 + i] = (Byte)((_dictionarySize >> (8 * i)) & 0xFF);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				properties[1 + i] = (Byte)((_dictionarySize >> (8 * i)) & 0xFF);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,FillDistancesPrices,The following statement contains a magic number: for (UInt32 i = Base.kStartPosModelIndex; i < Base.kNumFullDistances; i++)  			{   				UInt32 posSlot = GetPosSlot(i);  				int footerBits = (int)((posSlot >> 1) - 1);  				UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  				tempPrices[i] = BitTreeEncoder.ReverseGetPrice(_posEncoders'   					baseVal - posSlot - 1' footerBits' i - baseVal);  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++)  			{  				object prop = properties[i];  				switch (propIDs[i])  				{  					case CoderPropID.NumFastBytes:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 numFastBytes = (Int32)prop;  						if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  							throw new InvalidParamException();  						_numFastBytes = (UInt32)numFastBytes;  						break;  					}  					case CoderPropID.Algorithm:  					{  						/*  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 maximize = (Int32)prop;  						_fastMode = (maximize == 0);  						_maxMode = (maximize >= 2);  						*/  						break;  					}  					case CoderPropID.MatchFinder:  					{  						if (!(prop is String))  							throw new InvalidParamException();  						EMatchFinderType matchFinderIndexPrev = _matchFinderType;  						int m = FindMatchFinder(((string)prop).ToUpper());  						if (m < 0)  							throw new InvalidParamException();  						_matchFinderType = (EMatchFinderType)m;  						if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)  							{  							_dictionarySizePrev = 0xFFFFFFFF;  							_matchFinder = null;  							}  						break;  					}  					case CoderPropID.DictionarySize:  					{  						const int kDicLogSizeMaxCompress = 30;  						if (!(prop is Int32))  							throw new InvalidParamException(); ;  						Int32 dictionarySize = (Int32)prop;  						if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||  							dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  							throw new InvalidParamException();  						_dictionarySize = (UInt32)dictionarySize;  						int dicLogSize;  						for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  							if (dictionarySize <= ((UInt32)(1) << dicLogSize))  								break;  						_distTableSize = (UInt32)dicLogSize * 2;  						break;  					}  					case CoderPropID.PosStateBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_posStateBits = (int)v;  						_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  						break;  					}  					case CoderPropID.LitPosBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_numLiteralPosStateBits = (int)v;  						break;  					}  					case CoderPropID.LitContextBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  							throw new InvalidParamException(); ;  						_numLiteralContextBits = (int)v;  						break;  					}  					case CoderPropID.EndMarker:  					{  						if (!(prop is Boolean))  							throw new InvalidParamException();  						SetWriteEndMarkerMode((Boolean)prop);  						break;  					}  					default:  						throw new InvalidParamException();  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++)  			{  				object prop = properties[i];  				switch (propIDs[i])  				{  					case CoderPropID.NumFastBytes:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 numFastBytes = (Int32)prop;  						if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  							throw new InvalidParamException();  						_numFastBytes = (UInt32)numFastBytes;  						break;  					}  					case CoderPropID.Algorithm:  					{  						/*  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 maximize = (Int32)prop;  						_fastMode = (maximize == 0);  						_maxMode = (maximize >= 2);  						*/  						break;  					}  					case CoderPropID.MatchFinder:  					{  						if (!(prop is String))  							throw new InvalidParamException();  						EMatchFinderType matchFinderIndexPrev = _matchFinderType;  						int m = FindMatchFinder(((string)prop).ToUpper());  						if (m < 0)  							throw new InvalidParamException();  						_matchFinderType = (EMatchFinderType)m;  						if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)  							{  							_dictionarySizePrev = 0xFFFFFFFF;  							_matchFinder = null;  							}  						break;  					}  					case CoderPropID.DictionarySize:  					{  						const int kDicLogSizeMaxCompress = 30;  						if (!(prop is Int32))  							throw new InvalidParamException(); ;  						Int32 dictionarySize = (Int32)prop;  						if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||  							dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  							throw new InvalidParamException();  						_dictionarySize = (UInt32)dictionarySize;  						int dicLogSize;  						for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  							if (dictionarySize <= ((UInt32)(1) << dicLogSize))  								break;  						_distTableSize = (UInt32)dicLogSize * 2;  						break;  					}  					case CoderPropID.PosStateBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_posStateBits = (int)v;  						_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  						break;  					}  					case CoderPropID.LitPosBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_numLiteralPosStateBits = (int)v;  						break;  					}  					case CoderPropID.LitContextBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  							throw new InvalidParamException(); ;  						_numLiteralContextBits = (int)v;  						break;  					}  					case CoderPropID.EndMarker:  					{  						if (!(prop is Boolean))  							throw new InvalidParamException();  						SetWriteEndMarkerMode((Boolean)prop);  						break;  					}  					default:  						throw new InvalidParamException();  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++)  			{  				object prop = properties[i];  				switch (propIDs[i])  				{  					case CoderPropID.NumFastBytes:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 numFastBytes = (Int32)prop;  						if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  							throw new InvalidParamException();  						_numFastBytes = (UInt32)numFastBytes;  						break;  					}  					case CoderPropID.Algorithm:  					{  						/*  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 maximize = (Int32)prop;  						_fastMode = (maximize == 0);  						_maxMode = (maximize >= 2);  						*/  						break;  					}  					case CoderPropID.MatchFinder:  					{  						if (!(prop is String))  							throw new InvalidParamException();  						EMatchFinderType matchFinderIndexPrev = _matchFinderType;  						int m = FindMatchFinder(((string)prop).ToUpper());  						if (m < 0)  							throw new InvalidParamException();  						_matchFinderType = (EMatchFinderType)m;  						if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)  							{  							_dictionarySizePrev = 0xFFFFFFFF;  							_matchFinder = null;  							}  						break;  					}  					case CoderPropID.DictionarySize:  					{  						const int kDicLogSizeMaxCompress = 30;  						if (!(prop is Int32))  							throw new InvalidParamException(); ;  						Int32 dictionarySize = (Int32)prop;  						if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||  							dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  							throw new InvalidParamException();  						_dictionarySize = (UInt32)dictionarySize;  						int dicLogSize;  						for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  							if (dictionarySize <= ((UInt32)(1) << dicLogSize))  								break;  						_distTableSize = (UInt32)dicLogSize * 2;  						break;  					}  					case CoderPropID.PosStateBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_posStateBits = (int)v;  						_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  						break;  					}  					case CoderPropID.LitPosBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_numLiteralPosStateBits = (int)v;  						break;  					}  					case CoderPropID.LitContextBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  							throw new InvalidParamException(); ;  						_numLiteralContextBits = (int)v;  						break;  					}  					case CoderPropID.EndMarker:  					{  						if (!(prop is Boolean))  							throw new InvalidParamException();  						SetWriteEndMarkerMode((Boolean)prop);  						break;  					}  					default:  						throw new InvalidParamException();  				}  			}
Magic Number,SevenZip.Compression.LZMA,LiteralEncoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetSubCoder,The following statement contains a magic number: return m_Coders[((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits))];
Magic Number,SevenZip.Compression.LZMA,Encoder2,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,Encode,The following statement contains a magic number: for (int i = 7; i >= 0; i--)  					{  						uint bit = (uint)((symbol >> i) & 1);  						m_Encoders[context].Encode(rangeEncoder' bit);  						context = (context << 1) | bit;  					}
Magic Number,SevenZip.Compression.LZMA,Encoder2,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,EncodeMatched,The following statement contains a magic number: for (int i = 7; i >= 0; i--)  					{  						uint bit = (uint)((symbol >> i) & 1);  						uint state = context;  						if (same)  						{  							uint matchBit = (uint)((matchByte >> i) & 1);  							state += ((1 + matchBit) << 8);  							same = (matchBit == bit);  						}  						m_Encoders[state].Encode(rangeEncoder' bit);  						context = (context << 1) | bit;  					}
Magic Number,SevenZip.Compression.LZMA,Encoder2,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,EncodeMatched,The following statement contains a magic number: for (int i = 7; i >= 0; i--)  					{  						uint bit = (uint)((symbol >> i) & 1);  						uint state = context;  						if (same)  						{  							uint matchBit = (uint)((matchByte >> i) & 1);  							state += ((1 + matchBit) << 8);  							same = (matchBit == bit);  						}  						m_Encoders[state].Encode(rangeEncoder' bit);  						context = (context << 1) | bit;  					}
Magic Number,SevenZip.Compression.LZMA,Encoder2,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPrice,The following statement contains a magic number: int i = 7;
Magic Number,SevenZip.Compression.LZMA,Encoder2,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPrice,The following statement contains a magic number: if (matchMode)  					{  						for (; i >= 0; i--)  						{  							uint matchBit = (uint)(matchByte >> i) & 1;  							uint bit = (uint)(symbol >> i) & 1;  							price += m_Encoders[((1 + matchBit) << 8) + context].GetPrice(bit);  							context = (context << 1) | bit;  							if (matchBit != bit)  							{  								i--;  								break;  							}  						}  					}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: HASH_ARRAY = (numHashBytes > 2);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY)  			{  				kNumHashDirectBytes = 0;  				kMinMatchCheck = 4;  				kFixHashSize = kHash2Size + kHash3Size;  			}  			else  			{  				kNumHashDirectBytes = 2;  				kMinMatchCheck = 2 + 1;  				kFixHashSize = 0;  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY)  			{  				kNumHashDirectBytes = 0;  				kMinMatchCheck = 4;  				kFixHashSize = kHash2Size + kHash3Size;  			}  			else  			{  				kNumHashDirectBytes = 2;  				kMinMatchCheck = 2 + 1;  				kFixHashSize = 0;  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY)  			{  				kNumHashDirectBytes = 0;  				kMinMatchCheck = 4;  				kFixHashSize = kHash2Size + kHash3Size;  			}  			else  			{  				kNumHashDirectBytes = 2;  				kMinMatchCheck = 2 + 1;  				kFixHashSize = 0;  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (historySize > kMaxValForNormalize - 256)  				throw new Exception();
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: _cutValue = 16 + (matchMaxLen >> 1);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: UInt32 windowReservSize = (historySize + keepAddBufferBefore +  					matchMaxLen + keepAddBufferAfter) / 2 + 256;
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: UInt32 windowReservSize = (historySize + keepAddBufferBefore +  					matchMaxLen + keepAddBufferAfter) / 2 + 256;
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (_cyclicBufferSize != cyclicBufferSize)  				_son = new UInt32[(_cyclicBufferSize = cyclicBufferSize) * 2];
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)  			{  				hs = historySize - 1;  				hs |= (hs >> 1);  				hs |= (hs >> 2);  				hs |= (hs >> 4);  				hs |= (hs >> 8);  				hs >>= 1;  				hs |= 0xFFFF;  				if (hs > (1 << 24))  					hs >>= 1;  				_hashMask = hs;  				hs++;  				hs += kFixHashSize;  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)  			{  				hs = historySize - 1;  				hs |= (hs >> 1);  				hs |= (hs >> 2);  				hs |= (hs >> 4);  				hs |= (hs >> 8);  				hs >>= 1;  				hs |= 0xFFFF;  				if (hs > (1 << 24))  					hs >>= 1;  				_hashMask = hs;  				hs++;  				hs += kFixHashSize;  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)  			{  				hs = historySize - 1;  				hs |= (hs >> 1);  				hs |= (hs >> 2);  				hs |= (hs >> 4);  				hs |= (hs >> 8);  				hs >>= 1;  				hs |= 0xFFFF;  				if (hs > (1 << 24))  					hs >>= 1;  				_hashMask = hs;  				hs++;  				hs += kFixHashSize;  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)  			{  				hs = historySize - 1;  				hs |= (hs >> 1);  				hs |= (hs >> 2);  				hs |= (hs >> 4);  				hs |= (hs >> 8);  				hs >>= 1;  				hs |= 0xFFFF;  				if (hs > (1 << 24))  					hs >>= 1;  				_hashMask = hs;  				hs++;  				hs += kFixHashSize;  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  				hash2Value = temp & (kHash2Size - 1);  				temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  				hash3Value = temp & (kHash3Size - 1);  				hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  			}  			else  				hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  				hash2Value = temp & (kHash2Size - 1);  				temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  				hash3Value = temp & (kHash3Size - 1);  				hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  			}  			else  				hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  				hash2Value = temp & (kHash2Size - 1);  				temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  				hash3Value = temp & (kHash3Size - 1);  				hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  			}  			else  				hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  				hash2Value = temp & (kHash2Size - 1);  				temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  				hash3Value = temp & (kHash3Size - 1);  				hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  			}  			else  				hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  				hash2Value = temp & (kHash2Size - 1);  				temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  				hash3Value = temp & (kHash3Size - 1);  				hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  			}  			else  				hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 curMatch2 = _hash[hash2Value];  				UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];  				_hash[hash2Value] = _pos;  				_hash[kHash3Offset + hash3Value] = _pos;  				if (curMatch2 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])  					{  						distances[offset++] = maxLen = 2;  						distances[offset++] = _pos - curMatch2 - 1;  					}  				if (curMatch3 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])  					{  						if (curMatch3 == curMatch2)  							offset -= 2;  						distances[offset++] = maxLen = 3;  						distances[offset++] = _pos - curMatch3 - 1;  						curMatch2 = curMatch3;  					}  				if (offset != 0 && curMatch2 == curMatch)  				{  					offset -= 2;  					maxLen = kStartMaxLen;  				}  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 curMatch2 = _hash[hash2Value];  				UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];  				_hash[hash2Value] = _pos;  				_hash[kHash3Offset + hash3Value] = _pos;  				if (curMatch2 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])  					{  						distances[offset++] = maxLen = 2;  						distances[offset++] = _pos - curMatch2 - 1;  					}  				if (curMatch3 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])  					{  						if (curMatch3 == curMatch2)  							offset -= 2;  						distances[offset++] = maxLen = 3;  						distances[offset++] = _pos - curMatch3 - 1;  						curMatch2 = curMatch3;  					}  				if (offset != 0 && curMatch2 == curMatch)  				{  					offset -= 2;  					maxLen = kStartMaxLen;  				}  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 curMatch2 = _hash[hash2Value];  				UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];  				_hash[hash2Value] = _pos;  				_hash[kHash3Offset + hash3Value] = _pos;  				if (curMatch2 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])  					{  						distances[offset++] = maxLen = 2;  						distances[offset++] = _pos - curMatch2 - 1;  					}  				if (curMatch3 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])  					{  						if (curMatch3 == curMatch2)  							offset -= 2;  						distances[offset++] = maxLen = 3;  						distances[offset++] = _pos - curMatch3 - 1;  						curMatch2 = curMatch3;  					}  				if (offset != 0 && curMatch2 == curMatch)  				{  					offset -= 2;  					maxLen = kStartMaxLen;  				}  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 curMatch2 = _hash[hash2Value];  				UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];  				_hash[hash2Value] = _pos;  				_hash[kHash3Offset + hash3Value] = _pos;  				if (curMatch2 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])  					{  						distances[offset++] = maxLen = 2;  						distances[offset++] = _pos - curMatch2 - 1;  					}  				if (curMatch3 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])  					{  						if (curMatch3 == curMatch2)  							offset -= 2;  						distances[offset++] = maxLen = 3;  						distances[offset++] = _pos - curMatch3 - 1;  						curMatch2 = curMatch3;  					}  				if (offset != 0 && curMatch2 == curMatch)  				{  					offset -= 2;  					maxLen = kStartMaxLen;  				}  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do  			{  				UInt32 lenLimit;  				if (_pos + _matchMaxLen <= _streamPos)  					lenLimit = _matchMaxLen;  				else  				{  					lenLimit = _streamPos - _pos;  					if (lenLimit < kMinMatchCheck)  					{  						MovePos();  						continue;  					}  				}    				UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  				UInt32 cur = _bufferOffset + _pos;    				UInt32 hashValue;    				if (HASH_ARRAY)  				{  					UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  					UInt32 hash2Value = temp & (kHash2Size - 1);  					_hash[hash2Value] = _pos;  					temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  					UInt32 hash3Value = temp & (kHash3Size - 1);  					_hash[kHash3Offset + hash3Value] = _pos;  					hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  				}  				else  					hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);    				UInt32 curMatch = _hash[kFixHashSize + hashValue];  				_hash[kFixHashSize + hashValue] = _pos;    				UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  				UInt32 ptr1 = (_cyclicBufferPos << 1);    				UInt32 len0' len1;  				len0 = len1 = kNumHashDirectBytes;    				UInt32 count = _cutValue;  				while (true)  				{  					if (curMatch <= matchMinPos || count-- == 0)  					{  						_son[ptr0] = _son[ptr1] = kEmptyHashValue;  						break;  					}    					UInt32 delta = _pos - curMatch;  					UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?  								(_cyclicBufferPos - delta) :  								(_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;    					UInt32 pby1 = _bufferOffset + curMatch;  					UInt32 len = Math.Min(len0' len1);  					if (_bufferBase[pby1 + len] == _bufferBase[cur + len])  					{  						while (++len != lenLimit)  							if (_bufferBase[pby1 + len] != _bufferBase[cur + len])  								break;  						if (len == lenLimit)  						{  							_son[ptr1] = _son[cyclicPos];  							_son[ptr0] = _son[cyclicPos + 1];  							break;  						}  					}  					if (_bufferBase[pby1 + len] < _bufferBase[cur + len])  					{  						_son[ptr1] = curMatch;  						ptr1 = cyclicPos + 1;  						curMatch = _son[ptr1];  						len1 = len;  					}  					else  					{  						_son[ptr0] = curMatch;  						ptr0 = cyclicPos;  						curMatch = _son[ptr0];  						len0 = len;  					}  				}  				MovePos();  			}  			while (--num != 0);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do  			{  				UInt32 lenLimit;  				if (_pos + _matchMaxLen <= _streamPos)  					lenLimit = _matchMaxLen;  				else  				{  					lenLimit = _streamPos - _pos;  					if (lenLimit < kMinMatchCheck)  					{  						MovePos();  						continue;  					}  				}    				UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  				UInt32 cur = _bufferOffset + _pos;    				UInt32 hashValue;    				if (HASH_ARRAY)  				{  					UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  					UInt32 hash2Value = temp & (kHash2Size - 1);  					_hash[hash2Value] = _pos;  					temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  					UInt32 hash3Value = temp & (kHash3Size - 1);  					_hash[kHash3Offset + hash3Value] = _pos;  					hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  				}  				else  					hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);    				UInt32 curMatch = _hash[kFixHashSize + hashValue];  				_hash[kFixHashSize + hashValue] = _pos;    				UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  				UInt32 ptr1 = (_cyclicBufferPos << 1);    				UInt32 len0' len1;  				len0 = len1 = kNumHashDirectBytes;    				UInt32 count = _cutValue;  				while (true)  				{  					if (curMatch <= matchMinPos || count-- == 0)  					{  						_son[ptr0] = _son[ptr1] = kEmptyHashValue;  						break;  					}    					UInt32 delta = _pos - curMatch;  					UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?  								(_cyclicBufferPos - delta) :  								(_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;    					UInt32 pby1 = _bufferOffset + curMatch;  					UInt32 len = Math.Min(len0' len1);  					if (_bufferBase[pby1 + len] == _bufferBase[cur + len])  					{  						while (++len != lenLimit)  							if (_bufferBase[pby1 + len] != _bufferBase[cur + len])  								break;  						if (len == lenLimit)  						{  							_son[ptr1] = _son[cyclicPos];  							_son[ptr0] = _son[cyclicPos + 1];  							break;  						}  					}  					if (_bufferBase[pby1 + len] < _bufferBase[cur + len])  					{  						_son[ptr1] = curMatch;  						ptr1 = cyclicPos + 1;  						curMatch = _son[ptr1];  						len1 = len;  					}  					else  					{  						_son[ptr0] = curMatch;  						ptr0 = cyclicPos;  						curMatch = _son[ptr0];  						len0 = len;  					}  				}  				MovePos();  			}  			while (--num != 0);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do  			{  				UInt32 lenLimit;  				if (_pos + _matchMaxLen <= _streamPos)  					lenLimit = _matchMaxLen;  				else  				{  					lenLimit = _streamPos - _pos;  					if (lenLimit < kMinMatchCheck)  					{  						MovePos();  						continue;  					}  				}    				UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  				UInt32 cur = _bufferOffset + _pos;    				UInt32 hashValue;    				if (HASH_ARRAY)  				{  					UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  					UInt32 hash2Value = temp & (kHash2Size - 1);  					_hash[hash2Value] = _pos;  					temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  					UInt32 hash3Value = temp & (kHash3Size - 1);  					_hash[kHash3Offset + hash3Value] = _pos;  					hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  				}  				else  					hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);    				UInt32 curMatch = _hash[kFixHashSize + hashValue];  				_hash[kFixHashSize + hashValue] = _pos;    				UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  				UInt32 ptr1 = (_cyclicBufferPos << 1);    				UInt32 len0' len1;  				len0 = len1 = kNumHashDirectBytes;    				UInt32 count = _cutValue;  				while (true)  				{  					if (curMatch <= matchMinPos || count-- == 0)  					{  						_son[ptr0] = _son[ptr1] = kEmptyHashValue;  						break;  					}    					UInt32 delta = _pos - curMatch;  					UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?  								(_cyclicBufferPos - delta) :  								(_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;    					UInt32 pby1 = _bufferOffset + curMatch;  					UInt32 len = Math.Min(len0' len1);  					if (_bufferBase[pby1 + len] == _bufferBase[cur + len])  					{  						while (++len != lenLimit)  							if (_bufferBase[pby1 + len] != _bufferBase[cur + len])  								break;  						if (len == lenLimit)  						{  							_son[ptr1] = _son[cyclicPos];  							_son[ptr0] = _son[cyclicPos + 1];  							break;  						}  					}  					if (_bufferBase[pby1 + len] < _bufferBase[cur + len])  					{  						_son[ptr1] = curMatch;  						ptr1 = cyclicPos + 1;  						curMatch = _son[ptr1];  						len1 = len;  					}  					else  					{  						_son[ptr0] = curMatch;  						ptr0 = cyclicPos;  						curMatch = _son[ptr0];  						len0 = len;  					}  				}  				MovePos();  			}  			while (--num != 0);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do  			{  				UInt32 lenLimit;  				if (_pos + _matchMaxLen <= _streamPos)  					lenLimit = _matchMaxLen;  				else  				{  					lenLimit = _streamPos - _pos;  					if (lenLimit < kMinMatchCheck)  					{  						MovePos();  						continue;  					}  				}    				UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  				UInt32 cur = _bufferOffset + _pos;    				UInt32 hashValue;    				if (HASH_ARRAY)  				{  					UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  					UInt32 hash2Value = temp & (kHash2Size - 1);  					_hash[hash2Value] = _pos;  					temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  					UInt32 hash3Value = temp & (kHash3Size - 1);  					_hash[kHash3Offset + hash3Value] = _pos;  					hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  				}  				else  					hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);    				UInt32 curMatch = _hash[kFixHashSize + hashValue];  				_hash[kFixHashSize + hashValue] = _pos;    				UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  				UInt32 ptr1 = (_cyclicBufferPos << 1);    				UInt32 len0' len1;  				len0 = len1 = kNumHashDirectBytes;    				UInt32 count = _cutValue;  				while (true)  				{  					if (curMatch <= matchMinPos || count-- == 0)  					{  						_son[ptr0] = _son[ptr1] = kEmptyHashValue;  						break;  					}    					UInt32 delta = _pos - curMatch;  					UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?  								(_cyclicBufferPos - delta) :  								(_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;    					UInt32 pby1 = _bufferOffset + curMatch;  					UInt32 len = Math.Min(len0' len1);  					if (_bufferBase[pby1 + len] == _bufferBase[cur + len])  					{  						while (++len != lenLimit)  							if (_bufferBase[pby1 + len] != _bufferBase[cur + len])  								break;  						if (len == lenLimit)  						{  							_son[ptr1] = _son[cyclicPos];  							_son[ptr0] = _son[cyclicPos + 1];  							break;  						}  					}  					if (_bufferBase[pby1 + len] < _bufferBase[cur + len])  					{  						_son[ptr1] = curMatch;  						ptr1 = cyclicPos + 1;  						curMatch = _son[ptr1];  						len1 = len;  					}  					else  					{  						_son[ptr0] = curMatch;  						ptr0 = cyclicPos;  						curMatch = _son[ptr0];  						len0 = len;  					}  				}  				MovePos();  			}  			while (--num != 0);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do  			{  				UInt32 lenLimit;  				if (_pos + _matchMaxLen <= _streamPos)  					lenLimit = _matchMaxLen;  				else  				{  					lenLimit = _streamPos - _pos;  					if (lenLimit < kMinMatchCheck)  					{  						MovePos();  						continue;  					}  				}    				UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  				UInt32 cur = _bufferOffset + _pos;    				UInt32 hashValue;    				if (HASH_ARRAY)  				{  					UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  					UInt32 hash2Value = temp & (kHash2Size - 1);  					_hash[hash2Value] = _pos;  					temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  					UInt32 hash3Value = temp & (kHash3Size - 1);  					_hash[kHash3Offset + hash3Value] = _pos;  					hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  				}  				else  					hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);    				UInt32 curMatch = _hash[kFixHashSize + hashValue];  				_hash[kFixHashSize + hashValue] = _pos;    				UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  				UInt32 ptr1 = (_cyclicBufferPos << 1);    				UInt32 len0' len1;  				len0 = len1 = kNumHashDirectBytes;    				UInt32 count = _cutValue;  				while (true)  				{  					if (curMatch <= matchMinPos || count-- == 0)  					{  						_son[ptr0] = _son[ptr1] = kEmptyHashValue;  						break;  					}    					UInt32 delta = _pos - curMatch;  					UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?  								(_cyclicBufferPos - delta) :  								(_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;    					UInt32 pby1 = _bufferOffset + curMatch;  					UInt32 len = Math.Min(len0' len1);  					if (_bufferBase[pby1 + len] == _bufferBase[cur + len])  					{  						while (++len != lenLimit)  							if (_bufferBase[pby1 + len] != _bufferBase[cur + len])  								break;  						if (len == lenLimit)  						{  							_son[ptr1] = _son[cyclicPos];  							_son[ptr0] = _son[cyclicPos + 1];  							break;  						}  					}  					if (_bufferBase[pby1 + len] < _bufferBase[cur + len])  					{  						_son[ptr1] = curMatch;  						ptr1 = cyclicPos + 1;  						curMatch = _son[ptr1];  						len1 = len;  					}  					else  					{  						_son[ptr0] = curMatch;  						ptr0 = cyclicPos;  						curMatch = _son[ptr0];  						len0 = len;  					}  				}  				MovePos();  			}  			while (--num != 0);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\LZ\LzBinTree.cs,Normalize,The following statement contains a magic number: NormalizeLinks(_son' _cyclicBufferSize * 2' subValue);
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\RangeCoder\RangeCoder.cs,FlushData,The following statement contains a magic number: for (int i = 0; i < 5; i++)  				ShiftLow();
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\RangeCoder\RangeCoder.cs,Encode,The following statement contains a magic number: while (Range < kTopValue)  			{  				Range <<= 8;  				ShiftLow();  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1)  			{  				byte temp = _cache;  				do  				{  					Stream.WriteByte((byte)(temp + (Low >> 32)));  					temp = 0xFF;  				}  				while (--_cacheSize != 0);  				_cache = (byte)(((uint)Low) >> 24);  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1)  			{  				byte temp = _cache;  				do  				{  					Stream.WriteByte((byte)(temp + (Low >> 32)));  					temp = 0xFF;  				}  				while (--_cacheSize != 0);  				_cache = (byte)(((uint)Low) >> 24);  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1)  			{  				byte temp = _cache;  				do  				{  					Stream.WriteByte((byte)(temp + (Low >> 32)));  					temp = 0xFF;  				}  				while (--_cacheSize != 0);  				_cache = (byte)(((uint)Low) >> 24);  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: Low = ((uint)Low) << 8;
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\RangeCoder\RangeCoder.cs,EncodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits - 1; i >= 0; i--)  			{  				Range >>= 1;  				if (((v >> i) & 1) == 1)  					Low += Range;  				if (Range < kTopValue)  				{  					Range <<= 8;  					ShiftLow();  				}  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\RangeCoder\RangeCoder.cs,EncodeBit,The following statement contains a magic number: while (Range < kTopValue)  			{  				Range <<= 8;  				ShiftLow();  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\RangeCoder\RangeCoder.cs,GetProcessedSizeAdd,The following statement contains a magic number: return _cacheSize +  				Stream.Position - StartPosition + 4;
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)  				Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)  				Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue)  			{  				Code = (Code << 8) | (byte)Stream.ReadByte();  				Range <<= 8;  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue)  			{  				Code = (Code << 8) | (byte)Stream.ReadByte();  				Range <<= 8;  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue)  			{  				Code = (Code << 8) | (byte)Stream.ReadByte();  				Range <<= 8;  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue)  			{  				Code = (Code << 8) | (byte)Stream.ReadByte();  				Range <<= 8;  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)  			{  				range >>= 1;  				/*  				result <<= 1;  				if (code >= range)  				{  					code -= range;  					result |= 1;  				}  				*/  				uint t = (code - range) >> 31;  				code -= range & (t - 1);  				result = (result << 1) | (1 - t);    				if (range < kTopValue)  				{  					code = (code << 8) | (byte)Stream.ReadByte();  					range <<= 8;  				}  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)  			{  				range >>= 1;  				/*  				result <<= 1;  				if (code >= range)  				{  					code -= range;  					result |= 1;  				}  				*/  				uint t = (code - range) >> 31;  				code -= range & (t - 1);  				result = (result << 1) | (1 - t);    				if (range < kTopValue)  				{  					code = (code << 8) | (byte)Stream.ReadByte();  					range <<= 8;  				}  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)  			{  				range >>= 1;  				/*  				result <<= 1;  				if (code >= range)  				{  					code -= range;  					result |= 1;  				}  				*/  				uint t = (code - range) >> 31;  				code -= range & (t - 1);  				result = (result << 1) | (1 - t);    				if (range < kTopValue)  				{  					code = (code << 8) | (byte)Stream.ReadByte();  					range <<= 8;  				}  			}
Magic Number,SevenZip.Compression.RangeCoder,BitEncoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\RangeCoder\RangeCoderBit.cs,Encode,The following statement contains a magic number: if (encoder.Range < Encoder.kTopValue)  			{  				encoder.Range <<= 8;  				encoder.ShiftLow();  			}
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)  			{  				rangeDecoder.Range = newBound;  				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 0;  			}  			else  			{  				rangeDecoder.Range -= newBound;  				rangeDecoder.Code -= newBound;  				Prob -= (Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 1;  			}
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)  			{  				rangeDecoder.Range = newBound;  				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 0;  			}  			else  			{  				rangeDecoder.Range -= newBound;  				rangeDecoder.Code -= newBound;  				Prob -= (Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 1;  			}
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)  			{  				rangeDecoder.Range = newBound;  				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 0;  			}  			else  			{  				rangeDecoder.Range -= newBound;  				rangeDecoder.Code -= newBound;  				Prob -= (Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 1;  			}
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\AnguisCaptor_SecureSocketProtocol\ExtraLayers\LZMA\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)  			{  				rangeDecoder.Range = newBound;  				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 0;  			}  			else  			{  				rangeDecoder.Range -= newBound;  				rangeDecoder.Code -= newBound;  				Prob -= (Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 1;  			}
