Implementation smell,Namespace,Class,File,Method,Description
Long Method,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The method has 75 lines of code.
Long Method,Sounds,SoundBase,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundBase.cs,Save_WAV,The method has 64 lines of code.
Long Method,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The method has 134 lines of code.
Long Method,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The method has 77 lines of code.
Long Method,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The method has 97 lines of code.
Complex Method,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Read_File,Cyclomatic complexity of the method is 15
Complex Method,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,Cyclomatic complexity of the method is 14
Complex Method,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,Cyclomatic complexity of the method is 11
Complex Method,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,Cyclomatic complexity of the method is 10
Complex Method,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,Cyclomatic complexity of the method is 12
Complex Method,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,Cyclomatic complexity of the method is 13
Complex Method,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,Cyclomatic complexity of the method is 16
Long Parameter List,Sounds,SoundBase,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundBase.cs,SoundBase,The method has 5 parameters.
Long Parameter List,Sounds,WAV,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\WAV.cs,Create,The method has 4 parameters.
Long Parameter List,Sounds.Compression,Procyon,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\Procyon.cs,Decode,The method has 5 parameters.
Long Statement,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Initialize_Decode,The length of the statement  "	a = Math.Sqrt (2.0) - Math.Cos (2.0 * Math.Acos (-1.0) * ((double)adx_header.highpass_frequency / adx_header.sample_rate)); " is 123.
Long Statement,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The length of the statement  "		ulong started_at = (ulong)(adx_header.copyright_offset + 4 + sample_index / samples_per_block * adx_header.block_size * adx_header.channel_count) * 8; " is 150.
Long Statement,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,The length of the statement  "	XElement xml = XElement.Load (Application.StartupPath + Path.DirectorySeparatorChar + "Plugins" + Path.DirectorySeparatorChar + "SoundLang.xml"); " is 145.
Long Statement,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Encode,The length of the statement  "		throw new NotImplementedException ("Only implemented sample rate 16364 and 32728.\n" + "This audio has " + this.SampleRate.ToString () + ". Please convert it."); " is 161.
Long Statement,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Encode,The length of the statement  "		throw new NotImplementedException ("Only sample of 16 bits is allowed.\n" + "This audio has " + this.SampleBitDepth.ToString () + ". Please convert it."); " is 154.
Long Statement,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,ReadLanguage,The length of the statement  "		XElement xml = XElement.Load (Application.StartupPath + Path.DirectorySeparatorChar + "Plugins" + Path.DirectorySeparatorChar + "SoundLang.xml"); " is 145.
Long Statement,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,btnExport_Click,The length of the statement  "		XElement xml = XElement.Load (Application.StartupPath + Path.DirectorySeparatorChar + "Plugins" + Path.DirectorySeparatorChar + "SoundLang.xml"); " is 145.
Long Statement,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,btnExport_Click,The length of the statement  "				string path = Path.GetDirectoryName (o.FileName) + Path.DirectorySeparatorChar + Path.GetFileNameWithoutExtension (o.FileName) + "_loop.wav"; " is 141.
Long Statement,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The length of the statement  "	}' -1' System.Drawing.Color.Empty' System.Drawing.Color.Empty' new System.Drawing.Font ("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0)))); " is 199.
Long Statement,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The length of the statement  "	}' -1' System.Drawing.Color.Empty' System.Drawing.Color.Empty' new System.Drawing.Font ("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0)))); " is 202.
Long Statement,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The length of the statement  "	}' -1' System.Drawing.Color.Empty' System.Drawing.Color.Empty' new System.Drawing.Font ("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0)))); " is 202.
Long Statement,Sounds.Compression,Procyon,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\Procyon.cs,Decode,The length of the statement  "		int sample = (int)((i & 1) != 0 ? Helper.get_high_nibble_signed ((byte)sample_byte) : Helper.get_low_nibble_signed ((byte)sample_byte)) * 64 * 64; " is 146.
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Read_File,The following statement contains a magic number: switch (adx_header.version) {  case 3:  	adx_header.loop_enabled = Helper.Get_uint (ref br);  	adx_header.loop_begin_sample_index = Helper.Get_uint (ref br);  	adx_header.loop_begin_byte_index = Helper.Get_uint (ref br);  	adx_header.loop_end_sample_index = Helper.Get_uint (ref br);  	adx_header.loop_end_byte_index = Helper.Get_uint (ref br);  	break;  case 4:  	br.BaseStream.Position += 0x0C;  	adx_header.loop_enabled = Helper.Get_uint (ref br);  	adx_header.loop_begin_sample_index = Helper.Get_uint (ref br);  	adx_header.loop_begin_byte_index = Helper.Get_uint (ref br);  	adx_header.loop_end_sample_index = Helper.Get_uint (ref br);  	adx_header.loop_end_byte_index = Helper.Get_uint (ref br);  	break;  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Read_File,The following statement contains a magic number: switch (adx_header.version) {  case 3:  	adx_header.loop_enabled = Helper.Get_uint (ref br);  	adx_header.loop_begin_sample_index = Helper.Get_uint (ref br);  	adx_header.loop_begin_byte_index = Helper.Get_uint (ref br);  	adx_header.loop_end_sample_index = Helper.Get_uint (ref br);  	adx_header.loop_end_byte_index = Helper.Get_uint (ref br);  	break;  case 4:  	br.BaseStream.Position += 0x0C;  	adx_header.loop_enabled = Helper.Get_uint (ref br);  	adx_header.loop_begin_sample_index = Helper.Get_uint (ref br);  	adx_header.loop_begin_byte_index = Helper.Get_uint (ref br);  	adx_header.loop_end_sample_index = Helper.Get_uint (ref br);  	adx_header.loop_end_byte_index = Helper.Get_uint (ref br);  	break;  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Read_File,The following statement contains a magic number: br.BaseStream.Position = adx_header.copyright_offset - 2;  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Read_File,The following statement contains a magic number: adx_header.copyright = br.ReadChars (6);  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Initialize_Decode,The following statement contains a magic number: a = Math.Sqrt (2.0) - Math.Cos (2.0 * Math.Acos (-1.0) * ((double)adx_header.highpass_frequency / adx_header.sample_rate));  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Initialize_Decode,The following statement contains a magic number: a = Math.Sqrt (2.0) - Math.Cos (2.0 * Math.Acos (-1.0) * ((double)adx_header.highpass_frequency / adx_header.sample_rate));  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Initialize_Decode,The following statement contains a magic number: b = Math.Sqrt (2.0) - 1.0;  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Initialize_Decode,The following statement contains a magic number: coefficient = new double[2];  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Initialize_Decode,The following statement contains a magic number: coefficient [0] = c * 2.0;  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Initialize_Decode,The following statement contains a magic number: past_samples = new int[2 * adx_header.channel_count];  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: while (samples_needed > 0 && sample_index < adx_header.total_samples) {  	// Calculate the number of samples that are left to be decoded in the current block  	uint sample_offset = sample_index % samples_per_block;  	uint samples_can_get = samples_per_block - sample_offset;  	// Clamp the samples we can get during this run if they won't fit in the buffer  	if (samples_can_get > samples_needed)  		samples_can_get = samples_needed;  	// Clamp the number of samples to be acquired if the stream isn't long enough or the loop trigger is nearby  	if (looping_enabled && sample_index + samples_can_get > adx_header.loop_end_sample_index)  		samples_can_get = adx_header.loop_end_sample_index - sample_index;  	else if (sample_index + samples_can_get > adx_header.total_samples)  		samples_can_get = adx_header.total_samples - sample_index;  	// Calculate the bit address of the start of the frame that sample_index resides in and record that location  	ulong started_at = (ulong)(adx_header.copyright_offset + 4 + sample_index / samples_per_block * adx_header.block_size * adx_header.channel_count) * 8;  	// Read the scale values from the start of each block in this frame  	for (uint i = 0; i < adx_header.channel_count; ++i) {  		bit_reader.Seek ((int)(started_at + adx_header.block_size * i * 8));  		scale [i] = bit_reader.Read_Short ();  	}  	// Pre-calculate the stop value for sample_offset  	uint sample_endoffset = sample_offset + samples_can_get;  	// Save the bitstream address of the first sample immediately after the scale in the first block of the frame  	started_at += 16;  	while (sample_offset < sample_endoffset) {  		for (uint i = 0; i < adx_header.channel_count; ++i) {  			// Predict the next sample  			double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  			// Seek to the sample offset' read and sign extend it to a 32bit integer  			bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  			int sample_error = 0;  			if (adx_header.sample_bitdepth == 4)  				sample_error = bit_reader.Read_4Bits ();  			// Scale the error correction value  			sample_error *= scale [i];  			// Calculate the sample by combining the prediction with the error correction  			int sample = sample_error + (int)sample_prediction;  			// Update the past samples with the newer sample  			past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  			past_samples [i * 2 + 0] = sample;  			// Clamp the decoded sample to the valid range for a 16bit integer  			if (sample > 32767)  				sample = 32767;  			else if (sample < -32768)  				sample = -32768;  			bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  		}  		++sample_offset;  		// We've decoded one sample from every block' advance block offset by 1  		++sample_index;  		// This also means we're one sample further into the stream  		--samples_needed;  		// And so there is one less set of samples that need to be decoded  	}  	// Check if we hit the loop end marker' if we did we need to jump to the loop start  	if (looping_enabled && sample_index == adx_header.loop_end_sample_index)  		//sample_index = adx_header.loop_begin_sample_index;  		break;  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: while (samples_needed > 0 && sample_index < adx_header.total_samples) {  	// Calculate the number of samples that are left to be decoded in the current block  	uint sample_offset = sample_index % samples_per_block;  	uint samples_can_get = samples_per_block - sample_offset;  	// Clamp the samples we can get during this run if they won't fit in the buffer  	if (samples_can_get > samples_needed)  		samples_can_get = samples_needed;  	// Clamp the number of samples to be acquired if the stream isn't long enough or the loop trigger is nearby  	if (looping_enabled && sample_index + samples_can_get > adx_header.loop_end_sample_index)  		samples_can_get = adx_header.loop_end_sample_index - sample_index;  	else if (sample_index + samples_can_get > adx_header.total_samples)  		samples_can_get = adx_header.total_samples - sample_index;  	// Calculate the bit address of the start of the frame that sample_index resides in and record that location  	ulong started_at = (ulong)(adx_header.copyright_offset + 4 + sample_index / samples_per_block * adx_header.block_size * adx_header.channel_count) * 8;  	// Read the scale values from the start of each block in this frame  	for (uint i = 0; i < adx_header.channel_count; ++i) {  		bit_reader.Seek ((int)(started_at + adx_header.block_size * i * 8));  		scale [i] = bit_reader.Read_Short ();  	}  	// Pre-calculate the stop value for sample_offset  	uint sample_endoffset = sample_offset + samples_can_get;  	// Save the bitstream address of the first sample immediately after the scale in the first block of the frame  	started_at += 16;  	while (sample_offset < sample_endoffset) {  		for (uint i = 0; i < adx_header.channel_count; ++i) {  			// Predict the next sample  			double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  			// Seek to the sample offset' read and sign extend it to a 32bit integer  			bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  			int sample_error = 0;  			if (adx_header.sample_bitdepth == 4)  				sample_error = bit_reader.Read_4Bits ();  			// Scale the error correction value  			sample_error *= scale [i];  			// Calculate the sample by combining the prediction with the error correction  			int sample = sample_error + (int)sample_prediction;  			// Update the past samples with the newer sample  			past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  			past_samples [i * 2 + 0] = sample;  			// Clamp the decoded sample to the valid range for a 16bit integer  			if (sample > 32767)  				sample = 32767;  			else if (sample < -32768)  				sample = -32768;  			bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  		}  		++sample_offset;  		// We've decoded one sample from every block' advance block offset by 1  		++sample_index;  		// This also means we're one sample further into the stream  		--samples_needed;  		// And so there is one less set of samples that need to be decoded  	}  	// Check if we hit the loop end marker' if we did we need to jump to the loop start  	if (looping_enabled && sample_index == adx_header.loop_end_sample_index)  		//sample_index = adx_header.loop_begin_sample_index;  		break;  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: while (samples_needed > 0 && sample_index < adx_header.total_samples) {  	// Calculate the number of samples that are left to be decoded in the current block  	uint sample_offset = sample_index % samples_per_block;  	uint samples_can_get = samples_per_block - sample_offset;  	// Clamp the samples we can get during this run if they won't fit in the buffer  	if (samples_can_get > samples_needed)  		samples_can_get = samples_needed;  	// Clamp the number of samples to be acquired if the stream isn't long enough or the loop trigger is nearby  	if (looping_enabled && sample_index + samples_can_get > adx_header.loop_end_sample_index)  		samples_can_get = adx_header.loop_end_sample_index - sample_index;  	else if (sample_index + samples_can_get > adx_header.total_samples)  		samples_can_get = adx_header.total_samples - sample_index;  	// Calculate the bit address of the start of the frame that sample_index resides in and record that location  	ulong started_at = (ulong)(adx_header.copyright_offset + 4 + sample_index / samples_per_block * adx_header.block_size * adx_header.channel_count) * 8;  	// Read the scale values from the start of each block in this frame  	for (uint i = 0; i < adx_header.channel_count; ++i) {  		bit_reader.Seek ((int)(started_at + adx_header.block_size * i * 8));  		scale [i] = bit_reader.Read_Short ();  	}  	// Pre-calculate the stop value for sample_offset  	uint sample_endoffset = sample_offset + samples_can_get;  	// Save the bitstream address of the first sample immediately after the scale in the first block of the frame  	started_at += 16;  	while (sample_offset < sample_endoffset) {  		for (uint i = 0; i < adx_header.channel_count; ++i) {  			// Predict the next sample  			double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  			// Seek to the sample offset' read and sign extend it to a 32bit integer  			bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  			int sample_error = 0;  			if (adx_header.sample_bitdepth == 4)  				sample_error = bit_reader.Read_4Bits ();  			// Scale the error correction value  			sample_error *= scale [i];  			// Calculate the sample by combining the prediction with the error correction  			int sample = sample_error + (int)sample_prediction;  			// Update the past samples with the newer sample  			past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  			past_samples [i * 2 + 0] = sample;  			// Clamp the decoded sample to the valid range for a 16bit integer  			if (sample > 32767)  				sample = 32767;  			else if (sample < -32768)  				sample = -32768;  			bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  		}  		++sample_offset;  		// We've decoded one sample from every block' advance block offset by 1  		++sample_index;  		// This also means we're one sample further into the stream  		--samples_needed;  		// And so there is one less set of samples that need to be decoded  	}  	// Check if we hit the loop end marker' if we did we need to jump to the loop start  	if (looping_enabled && sample_index == adx_header.loop_end_sample_index)  		//sample_index = adx_header.loop_begin_sample_index;  		break;  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: while (samples_needed > 0 && sample_index < adx_header.total_samples) {  	// Calculate the number of samples that are left to be decoded in the current block  	uint sample_offset = sample_index % samples_per_block;  	uint samples_can_get = samples_per_block - sample_offset;  	// Clamp the samples we can get during this run if they won't fit in the buffer  	if (samples_can_get > samples_needed)  		samples_can_get = samples_needed;  	// Clamp the number of samples to be acquired if the stream isn't long enough or the loop trigger is nearby  	if (looping_enabled && sample_index + samples_can_get > adx_header.loop_end_sample_index)  		samples_can_get = adx_header.loop_end_sample_index - sample_index;  	else if (sample_index + samples_can_get > adx_header.total_samples)  		samples_can_get = adx_header.total_samples - sample_index;  	// Calculate the bit address of the start of the frame that sample_index resides in and record that location  	ulong started_at = (ulong)(adx_header.copyright_offset + 4 + sample_index / samples_per_block * adx_header.block_size * adx_header.channel_count) * 8;  	// Read the scale values from the start of each block in this frame  	for (uint i = 0; i < adx_header.channel_count; ++i) {  		bit_reader.Seek ((int)(started_at + adx_header.block_size * i * 8));  		scale [i] = bit_reader.Read_Short ();  	}  	// Pre-calculate the stop value for sample_offset  	uint sample_endoffset = sample_offset + samples_can_get;  	// Save the bitstream address of the first sample immediately after the scale in the first block of the frame  	started_at += 16;  	while (sample_offset < sample_endoffset) {  		for (uint i = 0; i < adx_header.channel_count; ++i) {  			// Predict the next sample  			double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  			// Seek to the sample offset' read and sign extend it to a 32bit integer  			bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  			int sample_error = 0;  			if (adx_header.sample_bitdepth == 4)  				sample_error = bit_reader.Read_4Bits ();  			// Scale the error correction value  			sample_error *= scale [i];  			// Calculate the sample by combining the prediction with the error correction  			int sample = sample_error + (int)sample_prediction;  			// Update the past samples with the newer sample  			past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  			past_samples [i * 2 + 0] = sample;  			// Clamp the decoded sample to the valid range for a 16bit integer  			if (sample > 32767)  				sample = 32767;  			else if (sample < -32768)  				sample = -32768;  			bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  		}  		++sample_offset;  		// We've decoded one sample from every block' advance block offset by 1  		++sample_index;  		// This also means we're one sample further into the stream  		--samples_needed;  		// And so there is one less set of samples that need to be decoded  	}  	// Check if we hit the loop end marker' if we did we need to jump to the loop start  	if (looping_enabled && sample_index == adx_header.loop_end_sample_index)  		//sample_index = adx_header.loop_begin_sample_index;  		break;  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: while (samples_needed > 0 && sample_index < adx_header.total_samples) {  	// Calculate the number of samples that are left to be decoded in the current block  	uint sample_offset = sample_index % samples_per_block;  	uint samples_can_get = samples_per_block - sample_offset;  	// Clamp the samples we can get during this run if they won't fit in the buffer  	if (samples_can_get > samples_needed)  		samples_can_get = samples_needed;  	// Clamp the number of samples to be acquired if the stream isn't long enough or the loop trigger is nearby  	if (looping_enabled && sample_index + samples_can_get > adx_header.loop_end_sample_index)  		samples_can_get = adx_header.loop_end_sample_index - sample_index;  	else if (sample_index + samples_can_get > adx_header.total_samples)  		samples_can_get = adx_header.total_samples - sample_index;  	// Calculate the bit address of the start of the frame that sample_index resides in and record that location  	ulong started_at = (ulong)(adx_header.copyright_offset + 4 + sample_index / samples_per_block * adx_header.block_size * adx_header.channel_count) * 8;  	// Read the scale values from the start of each block in this frame  	for (uint i = 0; i < adx_header.channel_count; ++i) {  		bit_reader.Seek ((int)(started_at + adx_header.block_size * i * 8));  		scale [i] = bit_reader.Read_Short ();  	}  	// Pre-calculate the stop value for sample_offset  	uint sample_endoffset = sample_offset + samples_can_get;  	// Save the bitstream address of the first sample immediately after the scale in the first block of the frame  	started_at += 16;  	while (sample_offset < sample_endoffset) {  		for (uint i = 0; i < adx_header.channel_count; ++i) {  			// Predict the next sample  			double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  			// Seek to the sample offset' read and sign extend it to a 32bit integer  			bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  			int sample_error = 0;  			if (adx_header.sample_bitdepth == 4)  				sample_error = bit_reader.Read_4Bits ();  			// Scale the error correction value  			sample_error *= scale [i];  			// Calculate the sample by combining the prediction with the error correction  			int sample = sample_error + (int)sample_prediction;  			// Update the past samples with the newer sample  			past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  			past_samples [i * 2 + 0] = sample;  			// Clamp the decoded sample to the valid range for a 16bit integer  			if (sample > 32767)  				sample = 32767;  			else if (sample < -32768)  				sample = -32768;  			bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  		}  		++sample_offset;  		// We've decoded one sample from every block' advance block offset by 1  		++sample_index;  		// This also means we're one sample further into the stream  		--samples_needed;  		// And so there is one less set of samples that need to be decoded  	}  	// Check if we hit the loop end marker' if we did we need to jump to the loop start  	if (looping_enabled && sample_index == adx_header.loop_end_sample_index)  		//sample_index = adx_header.loop_begin_sample_index;  		break;  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: while (samples_needed > 0 && sample_index < adx_header.total_samples) {  	// Calculate the number of samples that are left to be decoded in the current block  	uint sample_offset = sample_index % samples_per_block;  	uint samples_can_get = samples_per_block - sample_offset;  	// Clamp the samples we can get during this run if they won't fit in the buffer  	if (samples_can_get > samples_needed)  		samples_can_get = samples_needed;  	// Clamp the number of samples to be acquired if the stream isn't long enough or the loop trigger is nearby  	if (looping_enabled && sample_index + samples_can_get > adx_header.loop_end_sample_index)  		samples_can_get = adx_header.loop_end_sample_index - sample_index;  	else if (sample_index + samples_can_get > adx_header.total_samples)  		samples_can_get = adx_header.total_samples - sample_index;  	// Calculate the bit address of the start of the frame that sample_index resides in and record that location  	ulong started_at = (ulong)(adx_header.copyright_offset + 4 + sample_index / samples_per_block * adx_header.block_size * adx_header.channel_count) * 8;  	// Read the scale values from the start of each block in this frame  	for (uint i = 0; i < adx_header.channel_count; ++i) {  		bit_reader.Seek ((int)(started_at + adx_header.block_size * i * 8));  		scale [i] = bit_reader.Read_Short ();  	}  	// Pre-calculate the stop value for sample_offset  	uint sample_endoffset = sample_offset + samples_can_get;  	// Save the bitstream address of the first sample immediately after the scale in the first block of the frame  	started_at += 16;  	while (sample_offset < sample_endoffset) {  		for (uint i = 0; i < adx_header.channel_count; ++i) {  			// Predict the next sample  			double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  			// Seek to the sample offset' read and sign extend it to a 32bit integer  			bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  			int sample_error = 0;  			if (adx_header.sample_bitdepth == 4)  				sample_error = bit_reader.Read_4Bits ();  			// Scale the error correction value  			sample_error *= scale [i];  			// Calculate the sample by combining the prediction with the error correction  			int sample = sample_error + (int)sample_prediction;  			// Update the past samples with the newer sample  			past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  			past_samples [i * 2 + 0] = sample;  			// Clamp the decoded sample to the valid range for a 16bit integer  			if (sample > 32767)  				sample = 32767;  			else if (sample < -32768)  				sample = -32768;  			bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  		}  		++sample_offset;  		// We've decoded one sample from every block' advance block offset by 1  		++sample_index;  		// This also means we're one sample further into the stream  		--samples_needed;  		// And so there is one less set of samples that need to be decoded  	}  	// Check if we hit the loop end marker' if we did we need to jump to the loop start  	if (looping_enabled && sample_index == adx_header.loop_end_sample_index)  		//sample_index = adx_header.loop_begin_sample_index;  		break;  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: while (samples_needed > 0 && sample_index < adx_header.total_samples) {  	// Calculate the number of samples that are left to be decoded in the current block  	uint sample_offset = sample_index % samples_per_block;  	uint samples_can_get = samples_per_block - sample_offset;  	// Clamp the samples we can get during this run if they won't fit in the buffer  	if (samples_can_get > samples_needed)  		samples_can_get = samples_needed;  	// Clamp the number of samples to be acquired if the stream isn't long enough or the loop trigger is nearby  	if (looping_enabled && sample_index + samples_can_get > adx_header.loop_end_sample_index)  		samples_can_get = adx_header.loop_end_sample_index - sample_index;  	else if (sample_index + samples_can_get > adx_header.total_samples)  		samples_can_get = adx_header.total_samples - sample_index;  	// Calculate the bit address of the start of the frame that sample_index resides in and record that location  	ulong started_at = (ulong)(adx_header.copyright_offset + 4 + sample_index / samples_per_block * adx_header.block_size * adx_header.channel_count) * 8;  	// Read the scale values from the start of each block in this frame  	for (uint i = 0; i < adx_header.channel_count; ++i) {  		bit_reader.Seek ((int)(started_at + adx_header.block_size * i * 8));  		scale [i] = bit_reader.Read_Short ();  	}  	// Pre-calculate the stop value for sample_offset  	uint sample_endoffset = sample_offset + samples_can_get;  	// Save the bitstream address of the first sample immediately after the scale in the first block of the frame  	started_at += 16;  	while (sample_offset < sample_endoffset) {  		for (uint i = 0; i < adx_header.channel_count; ++i) {  			// Predict the next sample  			double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  			// Seek to the sample offset' read and sign extend it to a 32bit integer  			bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  			int sample_error = 0;  			if (adx_header.sample_bitdepth == 4)  				sample_error = bit_reader.Read_4Bits ();  			// Scale the error correction value  			sample_error *= scale [i];  			// Calculate the sample by combining the prediction with the error correction  			int sample = sample_error + (int)sample_prediction;  			// Update the past samples with the newer sample  			past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  			past_samples [i * 2 + 0] = sample;  			// Clamp the decoded sample to the valid range for a 16bit integer  			if (sample > 32767)  				sample = 32767;  			else if (sample < -32768)  				sample = -32768;  			bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  		}  		++sample_offset;  		// We've decoded one sample from every block' advance block offset by 1  		++sample_index;  		// This also means we're one sample further into the stream  		--samples_needed;  		// And so there is one less set of samples that need to be decoded  	}  	// Check if we hit the loop end marker' if we did we need to jump to the loop start  	if (looping_enabled && sample_index == adx_header.loop_end_sample_index)  		//sample_index = adx_header.loop_begin_sample_index;  		break;  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: while (samples_needed > 0 && sample_index < adx_header.total_samples) {  	// Calculate the number of samples that are left to be decoded in the current block  	uint sample_offset = sample_index % samples_per_block;  	uint samples_can_get = samples_per_block - sample_offset;  	// Clamp the samples we can get during this run if they won't fit in the buffer  	if (samples_can_get > samples_needed)  		samples_can_get = samples_needed;  	// Clamp the number of samples to be acquired if the stream isn't long enough or the loop trigger is nearby  	if (looping_enabled && sample_index + samples_can_get > adx_header.loop_end_sample_index)  		samples_can_get = adx_header.loop_end_sample_index - sample_index;  	else if (sample_index + samples_can_get > adx_header.total_samples)  		samples_can_get = adx_header.total_samples - sample_index;  	// Calculate the bit address of the start of the frame that sample_index resides in and record that location  	ulong started_at = (ulong)(adx_header.copyright_offset + 4 + sample_index / samples_per_block * adx_header.block_size * adx_header.channel_count) * 8;  	// Read the scale values from the start of each block in this frame  	for (uint i = 0; i < adx_header.channel_count; ++i) {  		bit_reader.Seek ((int)(started_at + adx_header.block_size * i * 8));  		scale [i] = bit_reader.Read_Short ();  	}  	// Pre-calculate the stop value for sample_offset  	uint sample_endoffset = sample_offset + samples_can_get;  	// Save the bitstream address of the first sample immediately after the scale in the first block of the frame  	started_at += 16;  	while (sample_offset < sample_endoffset) {  		for (uint i = 0; i < adx_header.channel_count; ++i) {  			// Predict the next sample  			double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  			// Seek to the sample offset' read and sign extend it to a 32bit integer  			bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  			int sample_error = 0;  			if (adx_header.sample_bitdepth == 4)  				sample_error = bit_reader.Read_4Bits ();  			// Scale the error correction value  			sample_error *= scale [i];  			// Calculate the sample by combining the prediction with the error correction  			int sample = sample_error + (int)sample_prediction;  			// Update the past samples with the newer sample  			past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  			past_samples [i * 2 + 0] = sample;  			// Clamp the decoded sample to the valid range for a 16bit integer  			if (sample > 32767)  				sample = 32767;  			else if (sample < -32768)  				sample = -32768;  			bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  		}  		++sample_offset;  		// We've decoded one sample from every block' advance block offset by 1  		++sample_index;  		// This also means we're one sample further into the stream  		--samples_needed;  		// And so there is one less set of samples that need to be decoded  	}  	// Check if we hit the loop end marker' if we did we need to jump to the loop start  	if (looping_enabled && sample_index == adx_header.loop_end_sample_index)  		//sample_index = adx_header.loop_begin_sample_index;  		break;  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: while (samples_needed > 0 && sample_index < adx_header.total_samples) {  	// Calculate the number of samples that are left to be decoded in the current block  	uint sample_offset = sample_index % samples_per_block;  	uint samples_can_get = samples_per_block - sample_offset;  	// Clamp the samples we can get during this run if they won't fit in the buffer  	if (samples_can_get > samples_needed)  		samples_can_get = samples_needed;  	// Clamp the number of samples to be acquired if the stream isn't long enough or the loop trigger is nearby  	if (looping_enabled && sample_index + samples_can_get > adx_header.loop_end_sample_index)  		samples_can_get = adx_header.loop_end_sample_index - sample_index;  	else if (sample_index + samples_can_get > adx_header.total_samples)  		samples_can_get = adx_header.total_samples - sample_index;  	// Calculate the bit address of the start of the frame that sample_index resides in and record that location  	ulong started_at = (ulong)(adx_header.copyright_offset + 4 + sample_index / samples_per_block * adx_header.block_size * adx_header.channel_count) * 8;  	// Read the scale values from the start of each block in this frame  	for (uint i = 0; i < adx_header.channel_count; ++i) {  		bit_reader.Seek ((int)(started_at + adx_header.block_size * i * 8));  		scale [i] = bit_reader.Read_Short ();  	}  	// Pre-calculate the stop value for sample_offset  	uint sample_endoffset = sample_offset + samples_can_get;  	// Save the bitstream address of the first sample immediately after the scale in the first block of the frame  	started_at += 16;  	while (sample_offset < sample_endoffset) {  		for (uint i = 0; i < adx_header.channel_count; ++i) {  			// Predict the next sample  			double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  			// Seek to the sample offset' read and sign extend it to a 32bit integer  			bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  			int sample_error = 0;  			if (adx_header.sample_bitdepth == 4)  				sample_error = bit_reader.Read_4Bits ();  			// Scale the error correction value  			sample_error *= scale [i];  			// Calculate the sample by combining the prediction with the error correction  			int sample = sample_error + (int)sample_prediction;  			// Update the past samples with the newer sample  			past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  			past_samples [i * 2 + 0] = sample;  			// Clamp the decoded sample to the valid range for a 16bit integer  			if (sample > 32767)  				sample = 32767;  			else if (sample < -32768)  				sample = -32768;  			bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  		}  		++sample_offset;  		// We've decoded one sample from every block' advance block offset by 1  		++sample_index;  		// This also means we're one sample further into the stream  		--samples_needed;  		// And so there is one less set of samples that need to be decoded  	}  	// Check if we hit the loop end marker' if we did we need to jump to the loop start  	if (looping_enabled && sample_index == adx_header.loop_end_sample_index)  		//sample_index = adx_header.loop_begin_sample_index;  		break;  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: while (samples_needed > 0 && sample_index < adx_header.total_samples) {  	// Calculate the number of samples that are left to be decoded in the current block  	uint sample_offset = sample_index % samples_per_block;  	uint samples_can_get = samples_per_block - sample_offset;  	// Clamp the samples we can get during this run if they won't fit in the buffer  	if (samples_can_get > samples_needed)  		samples_can_get = samples_needed;  	// Clamp the number of samples to be acquired if the stream isn't long enough or the loop trigger is nearby  	if (looping_enabled && sample_index + samples_can_get > adx_header.loop_end_sample_index)  		samples_can_get = adx_header.loop_end_sample_index - sample_index;  	else if (sample_index + samples_can_get > adx_header.total_samples)  		samples_can_get = adx_header.total_samples - sample_index;  	// Calculate the bit address of the start of the frame that sample_index resides in and record that location  	ulong started_at = (ulong)(adx_header.copyright_offset + 4 + sample_index / samples_per_block * adx_header.block_size * adx_header.channel_count) * 8;  	// Read the scale values from the start of each block in this frame  	for (uint i = 0; i < adx_header.channel_count; ++i) {  		bit_reader.Seek ((int)(started_at + adx_header.block_size * i * 8));  		scale [i] = bit_reader.Read_Short ();  	}  	// Pre-calculate the stop value for sample_offset  	uint sample_endoffset = sample_offset + samples_can_get;  	// Save the bitstream address of the first sample immediately after the scale in the first block of the frame  	started_at += 16;  	while (sample_offset < sample_endoffset) {  		for (uint i = 0; i < adx_header.channel_count; ++i) {  			// Predict the next sample  			double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  			// Seek to the sample offset' read and sign extend it to a 32bit integer  			bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  			int sample_error = 0;  			if (adx_header.sample_bitdepth == 4)  				sample_error = bit_reader.Read_4Bits ();  			// Scale the error correction value  			sample_error *= scale [i];  			// Calculate the sample by combining the prediction with the error correction  			int sample = sample_error + (int)sample_prediction;  			// Update the past samples with the newer sample  			past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  			past_samples [i * 2 + 0] = sample;  			// Clamp the decoded sample to the valid range for a 16bit integer  			if (sample > 32767)  				sample = 32767;  			else if (sample < -32768)  				sample = -32768;  			bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  		}  		++sample_offset;  		// We've decoded one sample from every block' advance block offset by 1  		++sample_index;  		// This also means we're one sample further into the stream  		--samples_needed;  		// And so there is one less set of samples that need to be decoded  	}  	// Check if we hit the loop end marker' if we did we need to jump to the loop start  	if (looping_enabled && sample_index == adx_header.loop_end_sample_index)  		//sample_index = adx_header.loop_begin_sample_index;  		break;  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: while (samples_needed > 0 && sample_index < adx_header.total_samples) {  	// Calculate the number of samples that are left to be decoded in the current block  	uint sample_offset = sample_index % samples_per_block;  	uint samples_can_get = samples_per_block - sample_offset;  	// Clamp the samples we can get during this run if they won't fit in the buffer  	if (samples_can_get > samples_needed)  		samples_can_get = samples_needed;  	// Clamp the number of samples to be acquired if the stream isn't long enough or the loop trigger is nearby  	if (looping_enabled && sample_index + samples_can_get > adx_header.loop_end_sample_index)  		samples_can_get = adx_header.loop_end_sample_index - sample_index;  	else if (sample_index + samples_can_get > adx_header.total_samples)  		samples_can_get = adx_header.total_samples - sample_index;  	// Calculate the bit address of the start of the frame that sample_index resides in and record that location  	ulong started_at = (ulong)(adx_header.copyright_offset + 4 + sample_index / samples_per_block * adx_header.block_size * adx_header.channel_count) * 8;  	// Read the scale values from the start of each block in this frame  	for (uint i = 0; i < adx_header.channel_count; ++i) {  		bit_reader.Seek ((int)(started_at + adx_header.block_size * i * 8));  		scale [i] = bit_reader.Read_Short ();  	}  	// Pre-calculate the stop value for sample_offset  	uint sample_endoffset = sample_offset + samples_can_get;  	// Save the bitstream address of the first sample immediately after the scale in the first block of the frame  	started_at += 16;  	while (sample_offset < sample_endoffset) {  		for (uint i = 0; i < adx_header.channel_count; ++i) {  			// Predict the next sample  			double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  			// Seek to the sample offset' read and sign extend it to a 32bit integer  			bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  			int sample_error = 0;  			if (adx_header.sample_bitdepth == 4)  				sample_error = bit_reader.Read_4Bits ();  			// Scale the error correction value  			sample_error *= scale [i];  			// Calculate the sample by combining the prediction with the error correction  			int sample = sample_error + (int)sample_prediction;  			// Update the past samples with the newer sample  			past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  			past_samples [i * 2 + 0] = sample;  			// Clamp the decoded sample to the valid range for a 16bit integer  			if (sample > 32767)  				sample = 32767;  			else if (sample < -32768)  				sample = -32768;  			bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  		}  		++sample_offset;  		// We've decoded one sample from every block' advance block offset by 1  		++sample_index;  		// This also means we're one sample further into the stream  		--samples_needed;  		// And so there is one less set of samples that need to be decoded  	}  	// Check if we hit the loop end marker' if we did we need to jump to the loop start  	if (looping_enabled && sample_index == adx_header.loop_end_sample_index)  		//sample_index = adx_header.loop_begin_sample_index;  		break;  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: while (samples_needed > 0 && sample_index < adx_header.total_samples) {  	// Calculate the number of samples that are left to be decoded in the current block  	uint sample_offset = sample_index % samples_per_block;  	uint samples_can_get = samples_per_block - sample_offset;  	// Clamp the samples we can get during this run if they won't fit in the buffer  	if (samples_can_get > samples_needed)  		samples_can_get = samples_needed;  	// Clamp the number of samples to be acquired if the stream isn't long enough or the loop trigger is nearby  	if (looping_enabled && sample_index + samples_can_get > adx_header.loop_end_sample_index)  		samples_can_get = adx_header.loop_end_sample_index - sample_index;  	else if (sample_index + samples_can_get > adx_header.total_samples)  		samples_can_get = adx_header.total_samples - sample_index;  	// Calculate the bit address of the start of the frame that sample_index resides in and record that location  	ulong started_at = (ulong)(adx_header.copyright_offset + 4 + sample_index / samples_per_block * adx_header.block_size * adx_header.channel_count) * 8;  	// Read the scale values from the start of each block in this frame  	for (uint i = 0; i < adx_header.channel_count; ++i) {  		bit_reader.Seek ((int)(started_at + adx_header.block_size * i * 8));  		scale [i] = bit_reader.Read_Short ();  	}  	// Pre-calculate the stop value for sample_offset  	uint sample_endoffset = sample_offset + samples_can_get;  	// Save the bitstream address of the first sample immediately after the scale in the first block of the frame  	started_at += 16;  	while (sample_offset < sample_endoffset) {  		for (uint i = 0; i < adx_header.channel_count; ++i) {  			// Predict the next sample  			double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  			// Seek to the sample offset' read and sign extend it to a 32bit integer  			bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  			int sample_error = 0;  			if (adx_header.sample_bitdepth == 4)  				sample_error = bit_reader.Read_4Bits ();  			// Scale the error correction value  			sample_error *= scale [i];  			// Calculate the sample by combining the prediction with the error correction  			int sample = sample_error + (int)sample_prediction;  			// Update the past samples with the newer sample  			past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  			past_samples [i * 2 + 0] = sample;  			// Clamp the decoded sample to the valid range for a 16bit integer  			if (sample > 32767)  				sample = 32767;  			else if (sample < -32768)  				sample = -32768;  			bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  		}  		++sample_offset;  		// We've decoded one sample from every block' advance block offset by 1  		++sample_index;  		// This also means we're one sample further into the stream  		--samples_needed;  		// And so there is one less set of samples that need to be decoded  	}  	// Check if we hit the loop end marker' if we did we need to jump to the loop start  	if (looping_enabled && sample_index == adx_header.loop_end_sample_index)  		//sample_index = adx_header.loop_begin_sample_index;  		break;  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: while (samples_needed > 0 && sample_index < adx_header.total_samples) {  	// Calculate the number of samples that are left to be decoded in the current block  	uint sample_offset = sample_index % samples_per_block;  	uint samples_can_get = samples_per_block - sample_offset;  	// Clamp the samples we can get during this run if they won't fit in the buffer  	if (samples_can_get > samples_needed)  		samples_can_get = samples_needed;  	// Clamp the number of samples to be acquired if the stream isn't long enough or the loop trigger is nearby  	if (looping_enabled && sample_index + samples_can_get > adx_header.loop_end_sample_index)  		samples_can_get = adx_header.loop_end_sample_index - sample_index;  	else if (sample_index + samples_can_get > adx_header.total_samples)  		samples_can_get = adx_header.total_samples - sample_index;  	// Calculate the bit address of the start of the frame that sample_index resides in and record that location  	ulong started_at = (ulong)(adx_header.copyright_offset + 4 + sample_index / samples_per_block * adx_header.block_size * adx_header.channel_count) * 8;  	// Read the scale values from the start of each block in this frame  	for (uint i = 0; i < adx_header.channel_count; ++i) {  		bit_reader.Seek ((int)(started_at + adx_header.block_size * i * 8));  		scale [i] = bit_reader.Read_Short ();  	}  	// Pre-calculate the stop value for sample_offset  	uint sample_endoffset = sample_offset + samples_can_get;  	// Save the bitstream address of the first sample immediately after the scale in the first block of the frame  	started_at += 16;  	while (sample_offset < sample_endoffset) {  		for (uint i = 0; i < adx_header.channel_count; ++i) {  			// Predict the next sample  			double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  			// Seek to the sample offset' read and sign extend it to a 32bit integer  			bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  			int sample_error = 0;  			if (adx_header.sample_bitdepth == 4)  				sample_error = bit_reader.Read_4Bits ();  			// Scale the error correction value  			sample_error *= scale [i];  			// Calculate the sample by combining the prediction with the error correction  			int sample = sample_error + (int)sample_prediction;  			// Update the past samples with the newer sample  			past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  			past_samples [i * 2 + 0] = sample;  			// Clamp the decoded sample to the valid range for a 16bit integer  			if (sample > 32767)  				sample = 32767;  			else if (sample < -32768)  				sample = -32768;  			bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  		}  		++sample_offset;  		// We've decoded one sample from every block' advance block offset by 1  		++sample_index;  		// This also means we're one sample further into the stream  		--samples_needed;  		// And so there is one less set of samples that need to be decoded  	}  	// Check if we hit the loop end marker' if we did we need to jump to the loop start  	if (looping_enabled && sample_index == adx_header.loop_end_sample_index)  		//sample_index = adx_header.loop_begin_sample_index;  		break;  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: while (samples_needed > 0 && sample_index < adx_header.total_samples) {  	// Calculate the number of samples that are left to be decoded in the current block  	uint sample_offset = sample_index % samples_per_block;  	uint samples_can_get = samples_per_block - sample_offset;  	// Clamp the samples we can get during this run if they won't fit in the buffer  	if (samples_can_get > samples_needed)  		samples_can_get = samples_needed;  	// Clamp the number of samples to be acquired if the stream isn't long enough or the loop trigger is nearby  	if (looping_enabled && sample_index + samples_can_get > adx_header.loop_end_sample_index)  		samples_can_get = adx_header.loop_end_sample_index - sample_index;  	else if (sample_index + samples_can_get > adx_header.total_samples)  		samples_can_get = adx_header.total_samples - sample_index;  	// Calculate the bit address of the start of the frame that sample_index resides in and record that location  	ulong started_at = (ulong)(adx_header.copyright_offset + 4 + sample_index / samples_per_block * adx_header.block_size * adx_header.channel_count) * 8;  	// Read the scale values from the start of each block in this frame  	for (uint i = 0; i < adx_header.channel_count; ++i) {  		bit_reader.Seek ((int)(started_at + adx_header.block_size * i * 8));  		scale [i] = bit_reader.Read_Short ();  	}  	// Pre-calculate the stop value for sample_offset  	uint sample_endoffset = sample_offset + samples_can_get;  	// Save the bitstream address of the first sample immediately after the scale in the first block of the frame  	started_at += 16;  	while (sample_offset < sample_endoffset) {  		for (uint i = 0; i < adx_header.channel_count; ++i) {  			// Predict the next sample  			double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  			// Seek to the sample offset' read and sign extend it to a 32bit integer  			bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  			int sample_error = 0;  			if (adx_header.sample_bitdepth == 4)  				sample_error = bit_reader.Read_4Bits ();  			// Scale the error correction value  			sample_error *= scale [i];  			// Calculate the sample by combining the prediction with the error correction  			int sample = sample_error + (int)sample_prediction;  			// Update the past samples with the newer sample  			past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  			past_samples [i * 2 + 0] = sample;  			// Clamp the decoded sample to the valid range for a 16bit integer  			if (sample > 32767)  				sample = 32767;  			else if (sample < -32768)  				sample = -32768;  			bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  		}  		++sample_offset;  		// We've decoded one sample from every block' advance block offset by 1  		++sample_index;  		// This also means we're one sample further into the stream  		--samples_needed;  		// And so there is one less set of samples that need to be decoded  	}  	// Check if we hit the loop end marker' if we did we need to jump to the loop start  	if (looping_enabled && sample_index == adx_header.loop_end_sample_index)  		//sample_index = adx_header.loop_begin_sample_index;  		break;  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: while (samples_needed > 0 && sample_index < adx_header.total_samples) {  	// Calculate the number of samples that are left to be decoded in the current block  	uint sample_offset = sample_index % samples_per_block;  	uint samples_can_get = samples_per_block - sample_offset;  	// Clamp the samples we can get during this run if they won't fit in the buffer  	if (samples_can_get > samples_needed)  		samples_can_get = samples_needed;  	// Clamp the number of samples to be acquired if the stream isn't long enough or the loop trigger is nearby  	if (looping_enabled && sample_index + samples_can_get > adx_header.loop_end_sample_index)  		samples_can_get = adx_header.loop_end_sample_index - sample_index;  	else if (sample_index + samples_can_get > adx_header.total_samples)  		samples_can_get = adx_header.total_samples - sample_index;  	// Calculate the bit address of the start of the frame that sample_index resides in and record that location  	ulong started_at = (ulong)(adx_header.copyright_offset + 4 + sample_index / samples_per_block * adx_header.block_size * adx_header.channel_count) * 8;  	// Read the scale values from the start of each block in this frame  	for (uint i = 0; i < adx_header.channel_count; ++i) {  		bit_reader.Seek ((int)(started_at + adx_header.block_size * i * 8));  		scale [i] = bit_reader.Read_Short ();  	}  	// Pre-calculate the stop value for sample_offset  	uint sample_endoffset = sample_offset + samples_can_get;  	// Save the bitstream address of the first sample immediately after the scale in the first block of the frame  	started_at += 16;  	while (sample_offset < sample_endoffset) {  		for (uint i = 0; i < adx_header.channel_count; ++i) {  			// Predict the next sample  			double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  			// Seek to the sample offset' read and sign extend it to a 32bit integer  			bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  			int sample_error = 0;  			if (adx_header.sample_bitdepth == 4)  				sample_error = bit_reader.Read_4Bits ();  			// Scale the error correction value  			sample_error *= scale [i];  			// Calculate the sample by combining the prediction with the error correction  			int sample = sample_error + (int)sample_prediction;  			// Update the past samples with the newer sample  			past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  			past_samples [i * 2 + 0] = sample;  			// Clamp the decoded sample to the valid range for a 16bit integer  			if (sample > 32767)  				sample = 32767;  			else if (sample < -32768)  				sample = -32768;  			bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  		}  		++sample_offset;  		// We've decoded one sample from every block' advance block offset by 1  		++sample_index;  		// This also means we're one sample further into the stream  		--samples_needed;  		// And so there is one less set of samples that need to be decoded  	}  	// Check if we hit the loop end marker' if we did we need to jump to the loop start  	if (looping_enabled && sample_index == adx_header.loop_end_sample_index)  		//sample_index = adx_header.loop_begin_sample_index;  		break;  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: for (uint i = 0; i < adx_header.channel_count; ++i) {  	bit_reader.Seek ((int)(started_at + adx_header.block_size * i * 8));  	scale [i] = bit_reader.Read_Short ();  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: bit_reader.Seek ((int)(started_at + adx_header.block_size * i * 8));  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: started_at += 16;  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: while (sample_offset < sample_endoffset) {  	for (uint i = 0; i < adx_header.channel_count; ++i) {  		// Predict the next sample  		double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  		// Seek to the sample offset' read and sign extend it to a 32bit integer  		bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  		int sample_error = 0;  		if (adx_header.sample_bitdepth == 4)  			sample_error = bit_reader.Read_4Bits ();  		// Scale the error correction value  		sample_error *= scale [i];  		// Calculate the sample by combining the prediction with the error correction  		int sample = sample_error + (int)sample_prediction;  		// Update the past samples with the newer sample  		past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  		past_samples [i * 2 + 0] = sample;  		// Clamp the decoded sample to the valid range for a 16bit integer  		if (sample > 32767)  			sample = 32767;  		else if (sample < -32768)  			sample = -32768;  		bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  	}  	++sample_offset;  	// We've decoded one sample from every block' advance block offset by 1  	++sample_index;  	// This also means we're one sample further into the stream  	--samples_needed;  	// And so there is one less set of samples that need to be decoded  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: while (sample_offset < sample_endoffset) {  	for (uint i = 0; i < adx_header.channel_count; ++i) {  		// Predict the next sample  		double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  		// Seek to the sample offset' read and sign extend it to a 32bit integer  		bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  		int sample_error = 0;  		if (adx_header.sample_bitdepth == 4)  			sample_error = bit_reader.Read_4Bits ();  		// Scale the error correction value  		sample_error *= scale [i];  		// Calculate the sample by combining the prediction with the error correction  		int sample = sample_error + (int)sample_prediction;  		// Update the past samples with the newer sample  		past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  		past_samples [i * 2 + 0] = sample;  		// Clamp the decoded sample to the valid range for a 16bit integer  		if (sample > 32767)  			sample = 32767;  		else if (sample < -32768)  			sample = -32768;  		bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  	}  	++sample_offset;  	// We've decoded one sample from every block' advance block offset by 1  	++sample_index;  	// This also means we're one sample further into the stream  	--samples_needed;  	// And so there is one less set of samples that need to be decoded  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: while (sample_offset < sample_endoffset) {  	for (uint i = 0; i < adx_header.channel_count; ++i) {  		// Predict the next sample  		double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  		// Seek to the sample offset' read and sign extend it to a 32bit integer  		bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  		int sample_error = 0;  		if (adx_header.sample_bitdepth == 4)  			sample_error = bit_reader.Read_4Bits ();  		// Scale the error correction value  		sample_error *= scale [i];  		// Calculate the sample by combining the prediction with the error correction  		int sample = sample_error + (int)sample_prediction;  		// Update the past samples with the newer sample  		past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  		past_samples [i * 2 + 0] = sample;  		// Clamp the decoded sample to the valid range for a 16bit integer  		if (sample > 32767)  			sample = 32767;  		else if (sample < -32768)  			sample = -32768;  		bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  	}  	++sample_offset;  	// We've decoded one sample from every block' advance block offset by 1  	++sample_index;  	// This also means we're one sample further into the stream  	--samples_needed;  	// And so there is one less set of samples that need to be decoded  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: while (sample_offset < sample_endoffset) {  	for (uint i = 0; i < adx_header.channel_count; ++i) {  		// Predict the next sample  		double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  		// Seek to the sample offset' read and sign extend it to a 32bit integer  		bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  		int sample_error = 0;  		if (adx_header.sample_bitdepth == 4)  			sample_error = bit_reader.Read_4Bits ();  		// Scale the error correction value  		sample_error *= scale [i];  		// Calculate the sample by combining the prediction with the error correction  		int sample = sample_error + (int)sample_prediction;  		// Update the past samples with the newer sample  		past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  		past_samples [i * 2 + 0] = sample;  		// Clamp the decoded sample to the valid range for a 16bit integer  		if (sample > 32767)  			sample = 32767;  		else if (sample < -32768)  			sample = -32768;  		bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  	}  	++sample_offset;  	// We've decoded one sample from every block' advance block offset by 1  	++sample_index;  	// This also means we're one sample further into the stream  	--samples_needed;  	// And so there is one less set of samples that need to be decoded  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: while (sample_offset < sample_endoffset) {  	for (uint i = 0; i < adx_header.channel_count; ++i) {  		// Predict the next sample  		double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  		// Seek to the sample offset' read and sign extend it to a 32bit integer  		bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  		int sample_error = 0;  		if (adx_header.sample_bitdepth == 4)  			sample_error = bit_reader.Read_4Bits ();  		// Scale the error correction value  		sample_error *= scale [i];  		// Calculate the sample by combining the prediction with the error correction  		int sample = sample_error + (int)sample_prediction;  		// Update the past samples with the newer sample  		past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  		past_samples [i * 2 + 0] = sample;  		// Clamp the decoded sample to the valid range for a 16bit integer  		if (sample > 32767)  			sample = 32767;  		else if (sample < -32768)  			sample = -32768;  		bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  	}  	++sample_offset;  	// We've decoded one sample from every block' advance block offset by 1  	++sample_index;  	// This also means we're one sample further into the stream  	--samples_needed;  	// And so there is one less set of samples that need to be decoded  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: while (sample_offset < sample_endoffset) {  	for (uint i = 0; i < adx_header.channel_count; ++i) {  		// Predict the next sample  		double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  		// Seek to the sample offset' read and sign extend it to a 32bit integer  		bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  		int sample_error = 0;  		if (adx_header.sample_bitdepth == 4)  			sample_error = bit_reader.Read_4Bits ();  		// Scale the error correction value  		sample_error *= scale [i];  		// Calculate the sample by combining the prediction with the error correction  		int sample = sample_error + (int)sample_prediction;  		// Update the past samples with the newer sample  		past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  		past_samples [i * 2 + 0] = sample;  		// Clamp the decoded sample to the valid range for a 16bit integer  		if (sample > 32767)  			sample = 32767;  		else if (sample < -32768)  			sample = -32768;  		bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  	}  	++sample_offset;  	// We've decoded one sample from every block' advance block offset by 1  	++sample_index;  	// This also means we're one sample further into the stream  	--samples_needed;  	// And so there is one less set of samples that need to be decoded  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: while (sample_offset < sample_endoffset) {  	for (uint i = 0; i < adx_header.channel_count; ++i) {  		// Predict the next sample  		double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  		// Seek to the sample offset' read and sign extend it to a 32bit integer  		bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  		int sample_error = 0;  		if (adx_header.sample_bitdepth == 4)  			sample_error = bit_reader.Read_4Bits ();  		// Scale the error correction value  		sample_error *= scale [i];  		// Calculate the sample by combining the prediction with the error correction  		int sample = sample_error + (int)sample_prediction;  		// Update the past samples with the newer sample  		past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  		past_samples [i * 2 + 0] = sample;  		// Clamp the decoded sample to the valid range for a 16bit integer  		if (sample > 32767)  			sample = 32767;  		else if (sample < -32768)  			sample = -32768;  		bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  	}  	++sample_offset;  	// We've decoded one sample from every block' advance block offset by 1  	++sample_index;  	// This also means we're one sample further into the stream  	--samples_needed;  	// And so there is one less set of samples that need to be decoded  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: while (sample_offset < sample_endoffset) {  	for (uint i = 0; i < adx_header.channel_count; ++i) {  		// Predict the next sample  		double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  		// Seek to the sample offset' read and sign extend it to a 32bit integer  		bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  		int sample_error = 0;  		if (adx_header.sample_bitdepth == 4)  			sample_error = bit_reader.Read_4Bits ();  		// Scale the error correction value  		sample_error *= scale [i];  		// Calculate the sample by combining the prediction with the error correction  		int sample = sample_error + (int)sample_prediction;  		// Update the past samples with the newer sample  		past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  		past_samples [i * 2 + 0] = sample;  		// Clamp the decoded sample to the valid range for a 16bit integer  		if (sample > 32767)  			sample = 32767;  		else if (sample < -32768)  			sample = -32768;  		bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  	}  	++sample_offset;  	// We've decoded one sample from every block' advance block offset by 1  	++sample_index;  	// This also means we're one sample further into the stream  	--samples_needed;  	// And so there is one less set of samples that need to be decoded  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: while (sample_offset < sample_endoffset) {  	for (uint i = 0; i < adx_header.channel_count; ++i) {  		// Predict the next sample  		double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  		// Seek to the sample offset' read and sign extend it to a 32bit integer  		bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  		int sample_error = 0;  		if (adx_header.sample_bitdepth == 4)  			sample_error = bit_reader.Read_4Bits ();  		// Scale the error correction value  		sample_error *= scale [i];  		// Calculate the sample by combining the prediction with the error correction  		int sample = sample_error + (int)sample_prediction;  		// Update the past samples with the newer sample  		past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  		past_samples [i * 2 + 0] = sample;  		// Clamp the decoded sample to the valid range for a 16bit integer  		if (sample > 32767)  			sample = 32767;  		else if (sample < -32768)  			sample = -32768;  		bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  	}  	++sample_offset;  	// We've decoded one sample from every block' advance block offset by 1  	++sample_index;  	// This also means we're one sample further into the stream  	--samples_needed;  	// And so there is one less set of samples that need to be decoded  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: while (sample_offset < sample_endoffset) {  	for (uint i = 0; i < adx_header.channel_count; ++i) {  		// Predict the next sample  		double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  		// Seek to the sample offset' read and sign extend it to a 32bit integer  		bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  		int sample_error = 0;  		if (adx_header.sample_bitdepth == 4)  			sample_error = bit_reader.Read_4Bits ();  		// Scale the error correction value  		sample_error *= scale [i];  		// Calculate the sample by combining the prediction with the error correction  		int sample = sample_error + (int)sample_prediction;  		// Update the past samples with the newer sample  		past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  		past_samples [i * 2 + 0] = sample;  		// Clamp the decoded sample to the valid range for a 16bit integer  		if (sample > 32767)  			sample = 32767;  		else if (sample < -32768)  			sample = -32768;  		bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  	}  	++sample_offset;  	// We've decoded one sample from every block' advance block offset by 1  	++sample_index;  	// This also means we're one sample further into the stream  	--samples_needed;  	// And so there is one less set of samples that need to be decoded  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: while (sample_offset < sample_endoffset) {  	for (uint i = 0; i < adx_header.channel_count; ++i) {  		// Predict the next sample  		double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  		// Seek to the sample offset' read and sign extend it to a 32bit integer  		bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  		int sample_error = 0;  		if (adx_header.sample_bitdepth == 4)  			sample_error = bit_reader.Read_4Bits ();  		// Scale the error correction value  		sample_error *= scale [i];  		// Calculate the sample by combining the prediction with the error correction  		int sample = sample_error + (int)sample_prediction;  		// Update the past samples with the newer sample  		past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  		past_samples [i * 2 + 0] = sample;  		// Clamp the decoded sample to the valid range for a 16bit integer  		if (sample > 32767)  			sample = 32767;  		else if (sample < -32768)  			sample = -32768;  		bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  	}  	++sample_offset;  	// We've decoded one sample from every block' advance block offset by 1  	++sample_index;  	// This also means we're one sample further into the stream  	--samples_needed;  	// And so there is one less set of samples that need to be decoded  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: for (uint i = 0; i < adx_header.channel_count; ++i) {  	// Predict the next sample  	double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  	// Seek to the sample offset' read and sign extend it to a 32bit integer  	bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  	int sample_error = 0;  	if (adx_header.sample_bitdepth == 4)  		sample_error = bit_reader.Read_4Bits ();  	// Scale the error correction value  	sample_error *= scale [i];  	// Calculate the sample by combining the prediction with the error correction  	int sample = sample_error + (int)sample_prediction;  	// Update the past samples with the newer sample  	past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  	past_samples [i * 2 + 0] = sample;  	// Clamp the decoded sample to the valid range for a 16bit integer  	if (sample > 32767)  		sample = 32767;  	else if (sample < -32768)  		sample = -32768;  	bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: for (uint i = 0; i < adx_header.channel_count; ++i) {  	// Predict the next sample  	double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  	// Seek to the sample offset' read and sign extend it to a 32bit integer  	bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  	int sample_error = 0;  	if (adx_header.sample_bitdepth == 4)  		sample_error = bit_reader.Read_4Bits ();  	// Scale the error correction value  	sample_error *= scale [i];  	// Calculate the sample by combining the prediction with the error correction  	int sample = sample_error + (int)sample_prediction;  	// Update the past samples with the newer sample  	past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  	past_samples [i * 2 + 0] = sample;  	// Clamp the decoded sample to the valid range for a 16bit integer  	if (sample > 32767)  		sample = 32767;  	else if (sample < -32768)  		sample = -32768;  	bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: for (uint i = 0; i < adx_header.channel_count; ++i) {  	// Predict the next sample  	double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  	// Seek to the sample offset' read and sign extend it to a 32bit integer  	bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  	int sample_error = 0;  	if (adx_header.sample_bitdepth == 4)  		sample_error = bit_reader.Read_4Bits ();  	// Scale the error correction value  	sample_error *= scale [i];  	// Calculate the sample by combining the prediction with the error correction  	int sample = sample_error + (int)sample_prediction;  	// Update the past samples with the newer sample  	past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  	past_samples [i * 2 + 0] = sample;  	// Clamp the decoded sample to the valid range for a 16bit integer  	if (sample > 32767)  		sample = 32767;  	else if (sample < -32768)  		sample = -32768;  	bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: for (uint i = 0; i < adx_header.channel_count; ++i) {  	// Predict the next sample  	double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  	// Seek to the sample offset' read and sign extend it to a 32bit integer  	bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  	int sample_error = 0;  	if (adx_header.sample_bitdepth == 4)  		sample_error = bit_reader.Read_4Bits ();  	// Scale the error correction value  	sample_error *= scale [i];  	// Calculate the sample by combining the prediction with the error correction  	int sample = sample_error + (int)sample_prediction;  	// Update the past samples with the newer sample  	past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  	past_samples [i * 2 + 0] = sample;  	// Clamp the decoded sample to the valid range for a 16bit integer  	if (sample > 32767)  		sample = 32767;  	else if (sample < -32768)  		sample = -32768;  	bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: for (uint i = 0; i < adx_header.channel_count; ++i) {  	// Predict the next sample  	double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  	// Seek to the sample offset' read and sign extend it to a 32bit integer  	bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  	int sample_error = 0;  	if (adx_header.sample_bitdepth == 4)  		sample_error = bit_reader.Read_4Bits ();  	// Scale the error correction value  	sample_error *= scale [i];  	// Calculate the sample by combining the prediction with the error correction  	int sample = sample_error + (int)sample_prediction;  	// Update the past samples with the newer sample  	past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  	past_samples [i * 2 + 0] = sample;  	// Clamp the decoded sample to the valid range for a 16bit integer  	if (sample > 32767)  		sample = 32767;  	else if (sample < -32768)  		sample = -32768;  	bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: for (uint i = 0; i < adx_header.channel_count; ++i) {  	// Predict the next sample  	double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  	// Seek to the sample offset' read and sign extend it to a 32bit integer  	bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  	int sample_error = 0;  	if (adx_header.sample_bitdepth == 4)  		sample_error = bit_reader.Read_4Bits ();  	// Scale the error correction value  	sample_error *= scale [i];  	// Calculate the sample by combining the prediction with the error correction  	int sample = sample_error + (int)sample_prediction;  	// Update the past samples with the newer sample  	past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  	past_samples [i * 2 + 0] = sample;  	// Clamp the decoded sample to the valid range for a 16bit integer  	if (sample > 32767)  		sample = 32767;  	else if (sample < -32768)  		sample = -32768;  	bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: for (uint i = 0; i < adx_header.channel_count; ++i) {  	// Predict the next sample  	double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  	// Seek to the sample offset' read and sign extend it to a 32bit integer  	bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  	int sample_error = 0;  	if (adx_header.sample_bitdepth == 4)  		sample_error = bit_reader.Read_4Bits ();  	// Scale the error correction value  	sample_error *= scale [i];  	// Calculate the sample by combining the prediction with the error correction  	int sample = sample_error + (int)sample_prediction;  	// Update the past samples with the newer sample  	past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  	past_samples [i * 2 + 0] = sample;  	// Clamp the decoded sample to the valid range for a 16bit integer  	if (sample > 32767)  		sample = 32767;  	else if (sample < -32768)  		sample = -32768;  	bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: for (uint i = 0; i < adx_header.channel_count; ++i) {  	// Predict the next sample  	double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  	// Seek to the sample offset' read and sign extend it to a 32bit integer  	bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  	int sample_error = 0;  	if (adx_header.sample_bitdepth == 4)  		sample_error = bit_reader.Read_4Bits ();  	// Scale the error correction value  	sample_error *= scale [i];  	// Calculate the sample by combining the prediction with the error correction  	int sample = sample_error + (int)sample_prediction;  	// Update the past samples with the newer sample  	past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  	past_samples [i * 2 + 0] = sample;  	// Clamp the decoded sample to the valid range for a 16bit integer  	if (sample > 32767)  		sample = 32767;  	else if (sample < -32768)  		sample = -32768;  	bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: for (uint i = 0; i < adx_header.channel_count; ++i) {  	// Predict the next sample  	double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  	// Seek to the sample offset' read and sign extend it to a 32bit integer  	bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  	int sample_error = 0;  	if (adx_header.sample_bitdepth == 4)  		sample_error = bit_reader.Read_4Bits ();  	// Scale the error correction value  	sample_error *= scale [i];  	// Calculate the sample by combining the prediction with the error correction  	int sample = sample_error + (int)sample_prediction;  	// Update the past samples with the newer sample  	past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  	past_samples [i * 2 + 0] = sample;  	// Clamp the decoded sample to the valid range for a 16bit integer  	if (sample > 32767)  		sample = 32767;  	else if (sample < -32768)  		sample = -32768;  	bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: for (uint i = 0; i < adx_header.channel_count; ++i) {  	// Predict the next sample  	double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  	// Seek to the sample offset' read and sign extend it to a 32bit integer  	bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  	int sample_error = 0;  	if (adx_header.sample_bitdepth == 4)  		sample_error = bit_reader.Read_4Bits ();  	// Scale the error correction value  	sample_error *= scale [i];  	// Calculate the sample by combining the prediction with the error correction  	int sample = sample_error + (int)sample_prediction;  	// Update the past samples with the newer sample  	past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  	past_samples [i * 2 + 0] = sample;  	// Clamp the decoded sample to the valid range for a 16bit integer  	if (sample > 32767)  		sample = 32767;  	else if (sample < -32768)  		sample = -32768;  	bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: for (uint i = 0; i < adx_header.channel_count; ++i) {  	// Predict the next sample  	double sample_prediction = coefficient [0] * past_samples [i * 2 + 0] + coefficient [1] * past_samples [i * 2 + 1];  	// Seek to the sample offset' read and sign extend it to a 32bit integer  	bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  	int sample_error = 0;  	if (adx_header.sample_bitdepth == 4)  		sample_error = bit_reader.Read_4Bits ();  	// Scale the error correction value  	sample_error *= scale [i];  	// Calculate the sample by combining the prediction with the error correction  	int sample = sample_error + (int)sample_prediction;  	// Update the past samples with the newer sample  	past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  	past_samples [i * 2 + 0] = sample;  	// Clamp the decoded sample to the valid range for a 16bit integer  	if (sample > 32767)  		sample = 32767;  	else if (sample < -32768)  		sample = -32768;  	bufferOut.AddRange (BitConverter.GetBytes ((short)sample));  }  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: bit_reader.Seek ((int)((int)started_at + adx_header.sample_bitdepth * sample_offset + adx_header.block_size * 8 * i));  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: if (adx_header.sample_bitdepth == 4)  	sample_error = bit_reader.Read_4Bits ();  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: past_samples [i * 2 + 1] = past_samples [i * 2 + 0];  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: past_samples [i * 2 + 0] = sample;  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: if (sample > 32767)  	sample = 32767;  else if (sample < -32768)  	sample = -32768;  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: if (sample > 32767)  	sample = 32767;  else if (sample < -32768)  	sample = -32768;  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: if (sample > 32767)  	sample = 32767;  else if (sample < -32768)  	sample = -32768;  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: if (sample > 32767)  	sample = 32767;  else if (sample < -32768)  	sample = -32768;  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: sample = 32767;  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: if (sample < -32768)  	sample = -32768;  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: if (sample < -32768)  	sample = -32768;  
Magic Number,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Decode,The following statement contains a magic number: sample = -32768;  
Magic Number,Sounds,Helper,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,MergeChannels,The following statement contains a magic number: for (int i = loopSample; i < leftChannel.Length; i += 2) {  	resultado.Add (leftChannel [i]);  	if (i + 1 < leftChannel.Length)  		resultado.Add (leftChannel [i + 1]);  	resultado.Add (rightChannel [i]);  	if (i + 1 < leftChannel.Length)  		resultado.Add (rightChannel [i + 1]);  }  
Magic Number,Sounds,Helper,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,MergeChannels,The following statement contains a magic number: i += 2
Magic Number,Sounds,Helper,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,DividieChannels,The following statement contains a magic number: for (int i = 0; i < data.Length / 4; i += 4) {  	leftChannel.Add (data [i]);  	leftChannel.Add (data [i + 1]);  	rightChannel.Add (data [i + 2]);  	rightChannel.Add (data [i + 3]);  }  
Magic Number,Sounds,Helper,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,DividieChannels,The following statement contains a magic number: for (int i = 0; i < data.Length / 4; i += 4) {  	leftChannel.Add (data [i]);  	leftChannel.Add (data [i + 1]);  	rightChannel.Add (data [i + 2]);  	rightChannel.Add (data [i + 3]);  }  
Magic Number,Sounds,Helper,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,DividieChannels,The following statement contains a magic number: for (int i = 0; i < data.Length / 4; i += 4) {  	leftChannel.Add (data [i]);  	leftChannel.Add (data [i + 1]);  	rightChannel.Add (data [i + 2]);  	rightChannel.Add (data [i + 3]);  }  
Magic Number,Sounds,Helper,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,DividieChannels,The following statement contains a magic number: for (int i = 0; i < data.Length / 4; i += 4) {  	leftChannel.Add (data [i]);  	leftChannel.Add (data [i + 1]);  	rightChannel.Add (data [i + 2]);  	rightChannel.Add (data [i + 3]);  }  
Magic Number,Sounds,Helper,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,DividieChannels,The following statement contains a magic number: i += 4
Magic Number,Sounds,Helper,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,DividieChannels,The following statement contains a magic number: rightChannel.Add (data [i + 2]);  
Magic Number,Sounds,Helper,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,DividieChannels,The following statement contains a magic number: rightChannel.Add (data [i + 3]);  
Magic Number,Sounds,Helper,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,Bit8ToBit4,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  	bit4.Add ((byte)(data [i] & 0x0F));  	bit4.Add ((byte)((data [i] & 0xF0) >> 4));  }  
Magic Number,Sounds,Helper,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,Bit8ToBit4,The following statement contains a magic number: bit4.Add ((byte)((data [i] & 0xF0) >> 4));  
Magic Number,Sounds,Helper,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,Get_ushort,The following statement contains a magic number: return BitConverter.ToUInt16 (br.ReadBytes (2).Reverse ().ToArray ()' 0);  
Magic Number,Sounds,Helper,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,Get_uint,The following statement contains a magic number: return BitConverter.ToUInt32 (br.ReadBytes (4).Reverse ().ToArray ()' 0);  
Magic Number,Sounds,Helper,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,get_high_nibble_signed,The following statement contains a magic number: return nibble_to_int [n >> 4];  
Magic Number,Sounds,Helper,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,clamp16,The following statement contains a magic number: if (val > 32767)  	return 32767;  
Magic Number,Sounds,Helper,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,clamp16,The following statement contains a magic number: if (val > 32767)  	return 32767;  
Magic Number,Sounds,Helper,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,clamp16,The following statement contains a magic number: return 32767;  
Magic Number,Sounds,Helper,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,clamp16,The following statement contains a magic number: if (val < -32768)  	return -32768;  
Magic Number,Sounds,Helper,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,clamp16,The following statement contains a magic number: if (val < -32768)  	return -32768;  
Magic Number,Sounds,Helper,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,clamp16,The following statement contains a magic number: return -32768;  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,Read_Short,The following statement contains a magic number: if (big_endian)  	return BitsToShort_BigEndian (Read (16));  else  	return BitsToShort (Read (16));  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,Read_Short,The following statement contains a magic number: if (big_endian)  	return BitsToShort_BigEndian (Read (16));  else  	return BitsToShort (Read (16));  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,Read_Short,The following statement contains a magic number: return BitsToShort_BigEndian (Read (16));  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,Read_Short,The following statement contains a magic number: return BitsToShort (Read (16));  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,Read_Int,The following statement contains a magic number: if (big_endian)  	return BitsToInt_BigEndian (Read (32));  else  	return BitsToInt (Read (32));  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,Read_Int,The following statement contains a magic number: if (big_endian)  	return BitsToInt_BigEndian (Read (32));  else  	return BitsToInt (Read (32));  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,Read_Int,The following statement contains a magic number: return BitsToInt_BigEndian (Read (32));  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,Read_Int,The following statement contains a magic number: return BitsToInt (Read (32));  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,Read_4Bits,The following statement contains a magic number: b += (byte)(bits [1] << 2);  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,Read_4Bits,The following statement contains a magic number: b += (byte)(bits [2] << 1);  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,Read_4Bits,The following statement contains a magic number: b += (byte)bits [3];  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,Read_4Bits,The following statement contains a magic number: if (bits [0] == 1)  	return b - 16;  else  	return b;  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,Read_4Bits,The following statement contains a magic number: return b - 16;  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToShort_BigEndian,The following statement contains a magic number: for (int i = 0; i < 16; i += 8) {  	Byte newByte = 0;  	int b = 0;  	for (int j = 7; j >= 0; j--' b++) {  		newByte += (byte)(bits [i + b] << j);  	}  	bytes [i / 8] = newByte;  }  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToShort_BigEndian,The following statement contains a magic number: for (int i = 0; i < 16; i += 8) {  	Byte newByte = 0;  	int b = 0;  	for (int j = 7; j >= 0; j--' b++) {  		newByte += (byte)(bits [i + b] << j);  	}  	bytes [i / 8] = newByte;  }  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToShort_BigEndian,The following statement contains a magic number: for (int i = 0; i < 16; i += 8) {  	Byte newByte = 0;  	int b = 0;  	for (int j = 7; j >= 0; j--' b++) {  		newByte += (byte)(bits [i + b] << j);  	}  	bytes [i / 8] = newByte;  }  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToShort_BigEndian,The following statement contains a magic number: for (int i = 0; i < 16; i += 8) {  	Byte newByte = 0;  	int b = 0;  	for (int j = 7; j >= 0; j--' b++) {  		newByte += (byte)(bits [i + b] << j);  	}  	bytes [i / 8] = newByte;  }  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToShort_BigEndian,The following statement contains a magic number: i += 8
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToShort_BigEndian,The following statement contains a magic number: for (int j = 7; j >= 0; j--' b++) {  	newByte += (byte)(bits [i + b] << j);  }  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToShort_BigEndian,The following statement contains a magic number: bytes [i / 8] = newByte;  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToShort,The following statement contains a magic number: for (int i = 0; i < 16; i += 8) {  	Byte newByte = 0;  	int b = 0;  	for (int j = 7; j >= 0; j--' b++) {  		newByte += (byte)(bits [i + b] << j);  	}  	bytes [i / 8] = newByte;  }  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToShort,The following statement contains a magic number: for (int i = 0; i < 16; i += 8) {  	Byte newByte = 0;  	int b = 0;  	for (int j = 7; j >= 0; j--' b++) {  		newByte += (byte)(bits [i + b] << j);  	}  	bytes [i / 8] = newByte;  }  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToShort,The following statement contains a magic number: for (int i = 0; i < 16; i += 8) {  	Byte newByte = 0;  	int b = 0;  	for (int j = 7; j >= 0; j--' b++) {  		newByte += (byte)(bits [i + b] << j);  	}  	bytes [i / 8] = newByte;  }  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToShort,The following statement contains a magic number: for (int i = 0; i < 16; i += 8) {  	Byte newByte = 0;  	int b = 0;  	for (int j = 7; j >= 0; j--' b++) {  		newByte += (byte)(bits [i + b] << j);  	}  	bytes [i / 8] = newByte;  }  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToShort,The following statement contains a magic number: i += 8
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToShort,The following statement contains a magic number: for (int j = 7; j >= 0; j--' b++) {  	newByte += (byte)(bits [i + b] << j);  }  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToShort,The following statement contains a magic number: bytes [i / 8] = newByte;  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToInt,The following statement contains a magic number: for (int i = 0; i < 32; i += 8) {  	Byte newByte = 0;  	int b = 0;  	for (int j = 7; j >= 0; j--' b++) {  		newByte += (byte)(bits [i + b] << j);  	}  	bytes [i / 8] = newByte;  }  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToInt,The following statement contains a magic number: for (int i = 0; i < 32; i += 8) {  	Byte newByte = 0;  	int b = 0;  	for (int j = 7; j >= 0; j--' b++) {  		newByte += (byte)(bits [i + b] << j);  	}  	bytes [i / 8] = newByte;  }  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToInt,The following statement contains a magic number: for (int i = 0; i < 32; i += 8) {  	Byte newByte = 0;  	int b = 0;  	for (int j = 7; j >= 0; j--' b++) {  		newByte += (byte)(bits [i + b] << j);  	}  	bytes [i / 8] = newByte;  }  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToInt,The following statement contains a magic number: for (int i = 0; i < 32; i += 8) {  	Byte newByte = 0;  	int b = 0;  	for (int j = 7; j >= 0; j--' b++) {  		newByte += (byte)(bits [i + b] << j);  	}  	bytes [i / 8] = newByte;  }  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToInt,The following statement contains a magic number: i += 8
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToInt,The following statement contains a magic number: for (int j = 7; j >= 0; j--' b++) {  	newByte += (byte)(bits [i + b] << j);  }  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToInt,The following statement contains a magic number: bytes [i / 8] = newByte;  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToInt_BigEndian,The following statement contains a magic number: for (int i = 0; i < 32; i += 8) {  	Byte newByte = 0;  	int b = 0;  	for (int j = 7; j >= 0; j--' b++) {  		newByte += (byte)(bits [i + b] << j);  	}  	bytes [i / 8] = newByte;  }  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToInt_BigEndian,The following statement contains a magic number: for (int i = 0; i < 32; i += 8) {  	Byte newByte = 0;  	int b = 0;  	for (int j = 7; j >= 0; j--' b++) {  		newByte += (byte)(bits [i + b] << j);  	}  	bytes [i / 8] = newByte;  }  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToInt_BigEndian,The following statement contains a magic number: for (int i = 0; i < 32; i += 8) {  	Byte newByte = 0;  	int b = 0;  	for (int j = 7; j >= 0; j--' b++) {  		newByte += (byte)(bits [i + b] << j);  	}  	bytes [i / 8] = newByte;  }  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToInt_BigEndian,The following statement contains a magic number: for (int i = 0; i < 32; i += 8) {  	Byte newByte = 0;  	int b = 0;  	for (int j = 7; j >= 0; j--' b++) {  		newByte += (byte)(bits [i + b] << j);  	}  	bytes [i / 8] = newByte;  }  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToInt_BigEndian,The following statement contains a magic number: i += 8
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToInt_BigEndian,The following statement contains a magic number: for (int j = 7; j >= 0; j--' b++) {  	newByte += (byte)(bits [i + b] << j);  }  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToInt_BigEndian,The following statement contains a magic number: bytes [i / 8] = newByte;  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BytesToBits,The following statement contains a magic number: for (int i = 0; i < bytes.Length; i++)  	for (int j = 7; j >= 0; j--)  		bits.Add ((byte)((bytes [i] >> j) & 1));  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BytesToBits,The following statement contains a magic number: for (int j = 7; j >= 0; j--)  	bits.Add ((byte)((bytes [i] >> j) & 1));  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToBytes,The following statement contains a magic number: for (int i = 0; i < bits.Length; i += 8) {  	Byte newByte = 0;  	int b = 0;  	for (int j = 7; j >= 0; j--' b++) {  		newByte += (byte)(bits [i + b] << j);  	}  	bytes.Add (newByte);  }  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToBytes,The following statement contains a magic number: for (int i = 0; i < bits.Length; i += 8) {  	Byte newByte = 0;  	int b = 0;  	for (int j = 7; j >= 0; j--' b++) {  		newByte += (byte)(bits [i + b] << j);  	}  	bytes.Add (newByte);  }  
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToBytes,The following statement contains a magic number: i += 8
Magic Number,Sounds,BitReader,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Helper.cs,BitsToBytes,The following statement contains a magic number: for (int j = 7; j >= 0; j--' b++) {  	newByte += (byte)(bits [i + b] << j);  }  
Magic Number,Sounds,Main,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Main.cs,Get_Format,The following statement contains a magic number: if (file.name.ToUpper ().EndsWith (".ADX")) {  	if (magic [0] != 0x80 || magic [1] != 00)  		// Constant  		return Format.Unknown;  	byte[] checkBytes = pluginHost.Get_Bytes (file.path' (int)file.offset + 4' 0xF);  	// Version and encoding flags  	if (checkBytes [0] == 0x03 && (checkBytes [0xE] == 0x03 || checkBytes [0xE] == 0x04)) {  		byte[] offset =  {  			magic [3]'  			magic [2]  		};  		byte[] copyright = pluginHost.Get_Bytes (file.path' (int)file.offset + BitConverter.ToUInt16 (offset' 0) - 2' 6);  		if (new String (Encoding.ASCII.GetChars (copyright)) == "(c)CRI")  			return Format.Sound;  	}  }  
Magic Number,Sounds,Main,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Main.cs,Get_Format,The following statement contains a magic number: if (file.name.ToUpper ().EndsWith (".ADX")) {  	if (magic [0] != 0x80 || magic [1] != 00)  		// Constant  		return Format.Unknown;  	byte[] checkBytes = pluginHost.Get_Bytes (file.path' (int)file.offset + 4' 0xF);  	// Version and encoding flags  	if (checkBytes [0] == 0x03 && (checkBytes [0xE] == 0x03 || checkBytes [0xE] == 0x04)) {  		byte[] offset =  {  			magic [3]'  			magic [2]  		};  		byte[] copyright = pluginHost.Get_Bytes (file.path' (int)file.offset + BitConverter.ToUInt16 (offset' 0) - 2' 6);  		if (new String (Encoding.ASCII.GetChars (copyright)) == "(c)CRI")  			return Format.Sound;  	}  }  
Magic Number,Sounds,Main,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Main.cs,Get_Format,The following statement contains a magic number: if (file.name.ToUpper ().EndsWith (".ADX")) {  	if (magic [0] != 0x80 || magic [1] != 00)  		// Constant  		return Format.Unknown;  	byte[] checkBytes = pluginHost.Get_Bytes (file.path' (int)file.offset + 4' 0xF);  	// Version and encoding flags  	if (checkBytes [0] == 0x03 && (checkBytes [0xE] == 0x03 || checkBytes [0xE] == 0x04)) {  		byte[] offset =  {  			magic [3]'  			magic [2]  		};  		byte[] copyright = pluginHost.Get_Bytes (file.path' (int)file.offset + BitConverter.ToUInt16 (offset' 0) - 2' 6);  		if (new String (Encoding.ASCII.GetChars (copyright)) == "(c)CRI")  			return Format.Sound;  	}  }  
Magic Number,Sounds,Main,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Main.cs,Get_Format,The following statement contains a magic number: if (file.name.ToUpper ().EndsWith (".ADX")) {  	if (magic [0] != 0x80 || magic [1] != 00)  		// Constant  		return Format.Unknown;  	byte[] checkBytes = pluginHost.Get_Bytes (file.path' (int)file.offset + 4' 0xF);  	// Version and encoding flags  	if (checkBytes [0] == 0x03 && (checkBytes [0xE] == 0x03 || checkBytes [0xE] == 0x04)) {  		byte[] offset =  {  			magic [3]'  			magic [2]  		};  		byte[] copyright = pluginHost.Get_Bytes (file.path' (int)file.offset + BitConverter.ToUInt16 (offset' 0) - 2' 6);  		if (new String (Encoding.ASCII.GetChars (copyright)) == "(c)CRI")  			return Format.Sound;  	}  }  
Magic Number,Sounds,Main,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Main.cs,Get_Format,The following statement contains a magic number: if (file.name.ToUpper ().EndsWith (".ADX")) {  	if (magic [0] != 0x80 || magic [1] != 00)  		// Constant  		return Format.Unknown;  	byte[] checkBytes = pluginHost.Get_Bytes (file.path' (int)file.offset + 4' 0xF);  	// Version and encoding flags  	if (checkBytes [0] == 0x03 && (checkBytes [0xE] == 0x03 || checkBytes [0xE] == 0x04)) {  		byte[] offset =  {  			magic [3]'  			magic [2]  		};  		byte[] copyright = pluginHost.Get_Bytes (file.path' (int)file.offset + BitConverter.ToUInt16 (offset' 0) - 2' 6);  		if (new String (Encoding.ASCII.GetChars (copyright)) == "(c)CRI")  			return Format.Sound;  	}  }  
Magic Number,Sounds,Main,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Main.cs,Get_Format,The following statement contains a magic number: if (checkBytes [0] == 0x03 && (checkBytes [0xE] == 0x03 || checkBytes [0xE] == 0x04)) {  	byte[] offset =  {  		magic [3]'  		magic [2]  	};  	byte[] copyright = pluginHost.Get_Bytes (file.path' (int)file.offset + BitConverter.ToUInt16 (offset' 0) - 2' 6);  	if (new String (Encoding.ASCII.GetChars (copyright)) == "(c)CRI")  		return Format.Sound;  }  
Magic Number,Sounds,Main,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Main.cs,Get_Format,The following statement contains a magic number: if (checkBytes [0] == 0x03 && (checkBytes [0xE] == 0x03 || checkBytes [0xE] == 0x04)) {  	byte[] offset =  {  		magic [3]'  		magic [2]  	};  	byte[] copyright = pluginHost.Get_Bytes (file.path' (int)file.offset + BitConverter.ToUInt16 (offset' 0) - 2' 6);  	if (new String (Encoding.ASCII.GetChars (copyright)) == "(c)CRI")  		return Format.Sound;  }  
Magic Number,Sounds,Main,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Main.cs,Get_Format,The following statement contains a magic number: if (checkBytes [0] == 0x03 && (checkBytes [0xE] == 0x03 || checkBytes [0xE] == 0x04)) {  	byte[] offset =  {  		magic [3]'  		magic [2]  	};  	byte[] copyright = pluginHost.Get_Bytes (file.path' (int)file.offset + BitConverter.ToUInt16 (offset' 0) - 2' 6);  	if (new String (Encoding.ASCII.GetChars (copyright)) == "(c)CRI")  		return Format.Sound;  }  
Magic Number,Sounds,Main,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Main.cs,Get_Format,The following statement contains a magic number: if (checkBytes [0] == 0x03 && (checkBytes [0xE] == 0x03 || checkBytes [0xE] == 0x04)) {  	byte[] offset =  {  		magic [3]'  		magic [2]  	};  	byte[] copyright = pluginHost.Get_Bytes (file.path' (int)file.offset + BitConverter.ToUInt16 (offset' 0) - 2' 6);  	if (new String (Encoding.ASCII.GetChars (copyright)) == "(c)CRI")  		return Format.Sound;  }  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,The following statement contains a magic number: sadl.id = br.ReadChars (4);  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,The following statement contains a magic number: switch (coding & 0x06) {  case 4:  	sadl.sample_rate = 32728;  	break;  case 2:  	sadl.sample_rate = 16364;  	break;  }  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,The following statement contains a magic number: switch (coding & 0x06) {  case 4:  	sadl.sample_rate = 32728;  	break;  case 2:  	sadl.sample_rate = 16364;  	break;  }  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,The following statement contains a magic number: switch (coding & 0x06) {  case 4:  	sadl.sample_rate = 32728;  	break;  case 2:  	sadl.sample_rate = 16364;  	break;  }  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,The following statement contains a magic number: switch (coding & 0x06) {  case 4:  	sadl.sample_rate = 32728;  	break;  case 2:  	sadl.sample_rate = 16364;  	break;  }  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,The following statement contains a magic number: sadl.sample_rate = 32728;  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,The following statement contains a magic number: sadl.sample_rate = 16364;  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,The following statement contains a magic number: if (sadl.coding == Coding.INT_IMA)  	sadl.num_samples = (sadl.file_size - startOffset) / sadl.channel * 2;  else if (sadl.coding == Coding.NDS_PROCYON)  	sadl.num_samples = (sadl.file_size - startOffset) / sadl.channel / 16 * 30;  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,The following statement contains a magic number: if (sadl.coding == Coding.INT_IMA)  	sadl.num_samples = (sadl.file_size - startOffset) / sadl.channel * 2;  else if (sadl.coding == Coding.NDS_PROCYON)  	sadl.num_samples = (sadl.file_size - startOffset) / sadl.channel / 16 * 30;  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,The following statement contains a magic number: if (sadl.coding == Coding.INT_IMA)  	sadl.num_samples = (sadl.file_size - startOffset) / sadl.channel * 2;  else if (sadl.coding == Coding.NDS_PROCYON)  	sadl.num_samples = (sadl.file_size - startOffset) / sadl.channel / 16 * 30;  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,The following statement contains a magic number: sadl.num_samples = (sadl.file_size - startOffset) / sadl.channel * 2;  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,The following statement contains a magic number: if (sadl.coding == Coding.NDS_PROCYON)  	sadl.num_samples = (sadl.file_size - startOffset) / sadl.channel / 16 * 30;  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,The following statement contains a magic number: if (sadl.coding == Coding.NDS_PROCYON)  	sadl.num_samples = (sadl.file_size - startOffset) / sadl.channel / 16 * 30;  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,The following statement contains a magic number: sadl.num_samples = (sadl.file_size - startOffset) / sadl.channel / 16 * 30;  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,The following statement contains a magic number: sadl.num_samples = (sadl.file_size - startOffset) / sadl.channel / 16 * 30;  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,The following statement contains a magic number: if (sadl.loopFlag != 0) {  	if (sadl.coding == Coding.INT_IMA)  		sadl.loopOffset = (br.ReadUInt32 () - startOffset) / sadl.channel * 2;  	else if (sadl.coding == Coding.NDS_PROCYON)  		sadl.loopOffset = (br.ReadUInt32 () - startOffset) / sadl.channel / 16 * 30;  }  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,The following statement contains a magic number: if (sadl.loopFlag != 0) {  	if (sadl.coding == Coding.INT_IMA)  		sadl.loopOffset = (br.ReadUInt32 () - startOffset) / sadl.channel * 2;  	else if (sadl.coding == Coding.NDS_PROCYON)  		sadl.loopOffset = (br.ReadUInt32 () - startOffset) / sadl.channel / 16 * 30;  }  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,The following statement contains a magic number: if (sadl.loopFlag != 0) {  	if (sadl.coding == Coding.INT_IMA)  		sadl.loopOffset = (br.ReadUInt32 () - startOffset) / sadl.channel * 2;  	else if (sadl.coding == Coding.NDS_PROCYON)  		sadl.loopOffset = (br.ReadUInt32 () - startOffset) / sadl.channel / 16 * 30;  }  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,The following statement contains a magic number: if (sadl.coding == Coding.INT_IMA)  	sadl.loopOffset = (br.ReadUInt32 () - startOffset) / sadl.channel * 2;  else if (sadl.coding == Coding.NDS_PROCYON)  	sadl.loopOffset = (br.ReadUInt32 () - startOffset) / sadl.channel / 16 * 30;  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,The following statement contains a magic number: if (sadl.coding == Coding.INT_IMA)  	sadl.loopOffset = (br.ReadUInt32 () - startOffset) / sadl.channel * 2;  else if (sadl.coding == Coding.NDS_PROCYON)  	sadl.loopOffset = (br.ReadUInt32 () - startOffset) / sadl.channel / 16 * 30;  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,The following statement contains a magic number: if (sadl.coding == Coding.INT_IMA)  	sadl.loopOffset = (br.ReadUInt32 () - startOffset) / sadl.channel * 2;  else if (sadl.coding == Coding.NDS_PROCYON)  	sadl.loopOffset = (br.ReadUInt32 () - startOffset) / sadl.channel / 16 * 30;  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,The following statement contains a magic number: sadl.loopOffset = (br.ReadUInt32 () - startOffset) / sadl.channel * 2;  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,The following statement contains a magic number: if (sadl.coding == Coding.NDS_PROCYON)  	sadl.loopOffset = (br.ReadUInt32 () - startOffset) / sadl.channel / 16 * 30;  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,The following statement contains a magic number: if (sadl.coding == Coding.NDS_PROCYON)  	sadl.loopOffset = (br.ReadUInt32 () - startOffset) / sadl.channel / 16 * 30;  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,The following statement contains a magic number: sadl.loopOffset = (br.ReadUInt32 () - startOffset) / sadl.channel / 16 * 30;  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,The following statement contains a magic number: sadl.loopOffset = (br.ReadUInt32 () - startOffset) / sadl.channel / 16 * 30;  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,The following statement contains a magic number: sample_bitdepth = 4;  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Decode,The following statement contains a magic number: if (!loop_enabled)  	pos = start_offset;  else  	pos = (int)(start_offset + loop_begin_sample * 2 * block_size);  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Decode,The following statement contains a magic number: pos = (int)(start_offset + loop_begin_sample * 2 * block_size);  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Decode,The following statement contains a magic number: for (; pos < encoded.Length;) {  	if (sadl.channel == 2)// Stereo  	 {  		Byte[] buffer = new byte[sadl.interleave_block_size];  		Array.Copy (encoded' pos' buffer' 0' buffer.Length);  		pos += buffer.Length;  		left_channel.AddRange (buffer);  		Array.Copy (encoded' pos' buffer' 0' buffer.Length);  		pos += buffer.Length;  		right_channel.AddRange (buffer);  		buffer = null;  	} else// Mono  	 {  		Byte[] buffer = new byte[sadl.interleave_block_size * 2];  		Array.Copy (encoded' pos' buffer' 0' buffer.Length);  		pos += buffer.Length;  		data.AddRange (buffer);  		buffer = null;  	}  }  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Decode,The following statement contains a magic number: for (; pos < encoded.Length;) {  	if (sadl.channel == 2)// Stereo  	 {  		Byte[] buffer = new byte[sadl.interleave_block_size];  		Array.Copy (encoded' pos' buffer' 0' buffer.Length);  		pos += buffer.Length;  		left_channel.AddRange (buffer);  		Array.Copy (encoded' pos' buffer' 0' buffer.Length);  		pos += buffer.Length;  		right_channel.AddRange (buffer);  		buffer = null;  	} else// Mono  	 {  		Byte[] buffer = new byte[sadl.interleave_block_size * 2];  		Array.Copy (encoded' pos' buffer' 0' buffer.Length);  		pos += buffer.Length;  		data.AddRange (buffer);  		buffer = null;  	}  }  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Decode,The following statement contains a magic number: if (sadl.channel == 2)// Stereo   {  	Byte[] buffer = new byte[sadl.interleave_block_size];  	Array.Copy (encoded' pos' buffer' 0' buffer.Length);  	pos += buffer.Length;  	left_channel.AddRange (buffer);  	Array.Copy (encoded' pos' buffer' 0' buffer.Length);  	pos += buffer.Length;  	right_channel.AddRange (buffer);  	buffer = null;  } else// Mono   {  	Byte[] buffer = new byte[sadl.interleave_block_size * 2];  	Array.Copy (encoded' pos' buffer' 0' buffer.Length);  	pos += buffer.Length;  	data.AddRange (buffer);  	buffer = null;  }  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Decode,The following statement contains a magic number: if (sadl.channel == 2)// Stereo   {  	Byte[] buffer = new byte[sadl.interleave_block_size];  	Array.Copy (encoded' pos' buffer' 0' buffer.Length);  	pos += buffer.Length;  	left_channel.AddRange (buffer);  	Array.Copy (encoded' pos' buffer' 0' buffer.Length);  	pos += buffer.Length;  	right_channel.AddRange (buffer);  	buffer = null;  } else// Mono   {  	Byte[] buffer = new byte[sadl.interleave_block_size * 2];  	Array.Copy (encoded' pos' buffer' 0' buffer.Length);  	pos += buffer.Length;  	data.AddRange (buffer);  	buffer = null;  }  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Decode,The following statement contains a magic number: if (sadl.coding == Coding.INT_IMA) {  	if (sadl.channel == 2) {  		Byte[] dLeft_channel = new Byte[1];  		// Make the compiler happy :)  		Byte[] dRight_channel = new Byte[1];  		dLeft_channel = Compression.IMA_ADPCM.Decompress (left_channel.ToArray ());  		dRight_channel = Compression.IMA_ADPCM.Decompress (right_channel.ToArray ());  		data.AddRange (Helper.MergeChannels (dLeft_channel' dRight_channel));  		dLeft_channel = null;  		dRight_channel = null;  	} else {  		Byte[] buffer = Compression.IMA_ADPCM.Decompress (data.ToArray ());  		data.Clear ();  		data.AddRange (buffer);  		buffer = null;  	}  }  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Decode,The following statement contains a magic number: if (sadl.channel == 2) {  	Byte[] dLeft_channel = new Byte[1];  	// Make the compiler happy :)  	Byte[] dRight_channel = new Byte[1];  	dLeft_channel = Compression.IMA_ADPCM.Decompress (left_channel.ToArray ());  	dRight_channel = Compression.IMA_ADPCM.Decompress (right_channel.ToArray ());  	data.AddRange (Helper.MergeChannels (dLeft_channel' dRight_channel));  	dLeft_channel = null;  	dRight_channel = null;  } else {  	Byte[] buffer = Compression.IMA_ADPCM.Decompress (data.ToArray ());  	data.Clear ();  	data.AddRange (buffer);  	buffer = null;  }  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Decode_Procyon,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	offset [i] = (int)(start_offset + block_size * i);  	buffer [i] = new byte[NumberSamples * 2];  	length [i] = 0;  	hist [i] = new int[2];  }  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Decode_Procyon,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	offset [i] = (int)(start_offset + block_size * i);  	buffer [i] = new byte[NumberSamples * 2];  	length [i] = 0;  	hist [i] = new int[2];  }  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Decode_Procyon,The following statement contains a magic number: buffer [i] = new byte[NumberSamples * 2];  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Decode_Procyon,The following statement contains a magic number: hist [i] = new int[2];  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Decode_Procyon,The following statement contains a magic number: while (samples_written < NumberSamples) {  	samples_to_do = 30;  	if (samples_written + samples_to_do > NumberSamples)  		samples_to_do = (int)total_samples - samples_written;  	for (int chan = 0; chan < channels; chan++) {  		byte[] temp = Compression.Procyon.Decode (encoded' offset [chan]' samples_to_do' ref hist [chan]' (int)channels);  		Array.Copy (temp' 0' buffer [chan]' length [chan]' temp.Length);  		length [chan] += temp.Length;  		offset [chan] += (int)(block_size * channels);  	}  	samples_written += samples_to_do;  }  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Decode_Procyon,The following statement contains a magic number: samples_to_do = 30;  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Write_File,The following statement contains a magic number: cod |= (byte)(this.SampleRate == 16364 ? 2 : 4);  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Write_File,The following statement contains a magic number: cod |= (byte)(this.SampleRate == 16364 ? 2 : 4);  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Write_File,The following statement contains a magic number: cod |= (byte)(this.SampleRate == 16364 ? 2 : 4);  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Encode,The following statement contains a magic number: if (this.SampleRate != 16364 && this.SampleRate != 32728)  	throw new NotImplementedException ("Only implemented sample rate 16364 and 32728.\n" + "This audio has " + this.SampleRate.ToString () + ". Please convert it.");  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Encode,The following statement contains a magic number: if (this.SampleRate != 16364 && this.SampleRate != 32728)  	throw new NotImplementedException ("Only implemented sample rate 16364 and 32728.\n" + "This audio has " + this.SampleRate.ToString () + ". Please convert it.");  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Encode,The following statement contains a magic number: if (this.SampleBitDepth != 16)  	throw new NotImplementedException ("Only sample of 16 bits is allowed.\n" + "This audio has " + this.SampleBitDepth.ToString () + ". Please convert it.");  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Encode,The following statement contains a magic number: if (rest != 0)  	Array.Resize (ref encoded' encoded.Length + (int)((sadl.interleave_block_size * 2) - rest));  
Magic Number,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Encode,The following statement contains a magic number: Array.Resize (ref encoded' encoded.Length + (int)((sadl.interleave_block_size * 2) - rest));  
Magic Number,Sounds,SoundBase,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundBase.cs,Import,The following statement contains a magic number: total_samples = (uint)(wav.wave.data.data.Length / ((wav.wave.fmt.bitsPerSample / 8) * wav.wave.fmt.numChannels));  
Magic Number,Sounds,SoundBase,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundBase.cs,Read_WAV,The following statement contains a magic number: wav.chunkID = br.ReadChars (4);  
Magic Number,Sounds,SoundBase,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundBase.cs,Read_WAV,The following statement contains a magic number: wav.format = br.ReadChars (4);  
Magic Number,Sounds,SoundBase,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundBase.cs,Read_WAV,The following statement contains a magic number: wav.wave.fmt.chunkID = br.ReadChars (4);  
Magic Number,Sounds,SoundBase,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundBase.cs,Read_WAV,The following statement contains a magic number: while (dataID != "data") {  	br.BaseStream.Position += br.ReadUInt32 () + 0x04;  	dataID = new String (br.ReadChars (4));  }  
Magic Number,Sounds,SoundBase,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundBase.cs,Read_WAV,The following statement contains a magic number: dataID = new String (br.ReadChars (4));  
Magic Number,Sounds,SoundBase,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundBase.cs,Read_WAV,The following statement contains a magic number: br.BaseStream.Position -= 4;  
Magic Number,Sounds,SoundBase,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundBase.cs,Read_WAV,The following statement contains a magic number: wav.wave.data.chunkID = br.ReadChars (4);  
Magic Number,Sounds,SoundBase,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundBase.cs,Read_WAV,The following statement contains a magic number: if (wav.wave.fmt.audioFormat == WaveFormat.WAVE_FORMAT_PCM && wav.wave.fmt.bitsPerSample == 0x08)// PCM8   {  	wav.wave.fmt.bitsPerSample = 0x10;  	wav.wave.fmt.blockAlign = (ushort)(wav.wave.fmt.numChannels * wav.wave.fmt.bitsPerSample / (ushort)(8));  	wav.wave.fmt.byteRate = wav.wave.fmt.sampleRate * wav.wave.fmt.bitsPerSample * wav.wave.fmt.numChannels / 8;  	wav.wave.data.data = Compression.PCM.PCM8UnsignedToPCM16 (wav.wave.data.data);  }  
Magic Number,Sounds,SoundBase,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundBase.cs,Read_WAV,The following statement contains a magic number: if (wav.wave.fmt.audioFormat == WaveFormat.WAVE_FORMAT_PCM && wav.wave.fmt.bitsPerSample == 0x08)// PCM8   {  	wav.wave.fmt.bitsPerSample = 0x10;  	wav.wave.fmt.blockAlign = (ushort)(wav.wave.fmt.numChannels * wav.wave.fmt.bitsPerSample / (ushort)(8));  	wav.wave.fmt.byteRate = wav.wave.fmt.sampleRate * wav.wave.fmt.bitsPerSample * wav.wave.fmt.numChannels / 8;  	wav.wave.data.data = Compression.PCM.PCM8UnsignedToPCM16 (wav.wave.data.data);  }  
Magic Number,Sounds,SoundBase,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundBase.cs,Read_WAV,The following statement contains a magic number: wav.wave.fmt.blockAlign = (ushort)(wav.wave.fmt.numChannels * wav.wave.fmt.bitsPerSample / (ushort)(8));  
Magic Number,Sounds,SoundBase,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundBase.cs,Read_WAV,The following statement contains a magic number: wav.wave.fmt.byteRate = wav.wave.fmt.sampleRate * wav.wave.fmt.bitsPerSample * wav.wave.fmt.numChannels / 8;  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,ReadLanguage,The following statement contains a magic number: try {  	XElement xml = XElement.Load (Application.StartupPath + Path.DirectorySeparatorChar + "Plugins" + Path.DirectorySeparatorChar + "SoundLang.xml");  	xml = xml.Element (pluginHost.Get_Language ()).Element ("SoundControl");  	columnProper.Text = xml.Element ("S00").Value;  	columnValue.Text = xml.Element ("S01").Value;  	btnExport.Text = xml.Element ("S02").Value;  	btnImport.Text = xml.Element ("S03").Value;  	checkLoop.Text = xml.Element ("S04").Value;  	listProp.Items [0].Text = xml.Element ("S06").Value;  	listProp.Items [1].Text = xml.Element ("S07").Value;  	listProp.Items [2].Text = xml.Element ("S08").Value;  	listProp.Items [3].Text = xml.Element ("S09").Value;  	listProp.Items [4].Text = xml.Element ("S0A").Value;  	listProp.Items [5].Text = xml.Element ("S0B").Value;  	listProp.Items [6].Text = xml.Element ("S0C").Value;  	listProp.Items [7].Text = xml.Element ("S0D").Value;  	listProp.Items [8].Text = xml.Element ("S0E").Value;  	listProp.Items [9].Text = xml.Element ("S0F").Value;  } catch {  	throw new Exception ("There was an error reading the XML file of language.");  }  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,ReadLanguage,The following statement contains a magic number: try {  	XElement xml = XElement.Load (Application.StartupPath + Path.DirectorySeparatorChar + "Plugins" + Path.DirectorySeparatorChar + "SoundLang.xml");  	xml = xml.Element (pluginHost.Get_Language ()).Element ("SoundControl");  	columnProper.Text = xml.Element ("S00").Value;  	columnValue.Text = xml.Element ("S01").Value;  	btnExport.Text = xml.Element ("S02").Value;  	btnImport.Text = xml.Element ("S03").Value;  	checkLoop.Text = xml.Element ("S04").Value;  	listProp.Items [0].Text = xml.Element ("S06").Value;  	listProp.Items [1].Text = xml.Element ("S07").Value;  	listProp.Items [2].Text = xml.Element ("S08").Value;  	listProp.Items [3].Text = xml.Element ("S09").Value;  	listProp.Items [4].Text = xml.Element ("S0A").Value;  	listProp.Items [5].Text = xml.Element ("S0B").Value;  	listProp.Items [6].Text = xml.Element ("S0C").Value;  	listProp.Items [7].Text = xml.Element ("S0D").Value;  	listProp.Items [8].Text = xml.Element ("S0E").Value;  	listProp.Items [9].Text = xml.Element ("S0F").Value;  } catch {  	throw new Exception ("There was an error reading the XML file of language.");  }  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,ReadLanguage,The following statement contains a magic number: try {  	XElement xml = XElement.Load (Application.StartupPath + Path.DirectorySeparatorChar + "Plugins" + Path.DirectorySeparatorChar + "SoundLang.xml");  	xml = xml.Element (pluginHost.Get_Language ()).Element ("SoundControl");  	columnProper.Text = xml.Element ("S00").Value;  	columnValue.Text = xml.Element ("S01").Value;  	btnExport.Text = xml.Element ("S02").Value;  	btnImport.Text = xml.Element ("S03").Value;  	checkLoop.Text = xml.Element ("S04").Value;  	listProp.Items [0].Text = xml.Element ("S06").Value;  	listProp.Items [1].Text = xml.Element ("S07").Value;  	listProp.Items [2].Text = xml.Element ("S08").Value;  	listProp.Items [3].Text = xml.Element ("S09").Value;  	listProp.Items [4].Text = xml.Element ("S0A").Value;  	listProp.Items [5].Text = xml.Element ("S0B").Value;  	listProp.Items [6].Text = xml.Element ("S0C").Value;  	listProp.Items [7].Text = xml.Element ("S0D").Value;  	listProp.Items [8].Text = xml.Element ("S0E").Value;  	listProp.Items [9].Text = xml.Element ("S0F").Value;  } catch {  	throw new Exception ("There was an error reading the XML file of language.");  }  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,ReadLanguage,The following statement contains a magic number: try {  	XElement xml = XElement.Load (Application.StartupPath + Path.DirectorySeparatorChar + "Plugins" + Path.DirectorySeparatorChar + "SoundLang.xml");  	xml = xml.Element (pluginHost.Get_Language ()).Element ("SoundControl");  	columnProper.Text = xml.Element ("S00").Value;  	columnValue.Text = xml.Element ("S01").Value;  	btnExport.Text = xml.Element ("S02").Value;  	btnImport.Text = xml.Element ("S03").Value;  	checkLoop.Text = xml.Element ("S04").Value;  	listProp.Items [0].Text = xml.Element ("S06").Value;  	listProp.Items [1].Text = xml.Element ("S07").Value;  	listProp.Items [2].Text = xml.Element ("S08").Value;  	listProp.Items [3].Text = xml.Element ("S09").Value;  	listProp.Items [4].Text = xml.Element ("S0A").Value;  	listProp.Items [5].Text = xml.Element ("S0B").Value;  	listProp.Items [6].Text = xml.Element ("S0C").Value;  	listProp.Items [7].Text = xml.Element ("S0D").Value;  	listProp.Items [8].Text = xml.Element ("S0E").Value;  	listProp.Items [9].Text = xml.Element ("S0F").Value;  } catch {  	throw new Exception ("There was an error reading the XML file of language.");  }  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,ReadLanguage,The following statement contains a magic number: try {  	XElement xml = XElement.Load (Application.StartupPath + Path.DirectorySeparatorChar + "Plugins" + Path.DirectorySeparatorChar + "SoundLang.xml");  	xml = xml.Element (pluginHost.Get_Language ()).Element ("SoundControl");  	columnProper.Text = xml.Element ("S00").Value;  	columnValue.Text = xml.Element ("S01").Value;  	btnExport.Text = xml.Element ("S02").Value;  	btnImport.Text = xml.Element ("S03").Value;  	checkLoop.Text = xml.Element ("S04").Value;  	listProp.Items [0].Text = xml.Element ("S06").Value;  	listProp.Items [1].Text = xml.Element ("S07").Value;  	listProp.Items [2].Text = xml.Element ("S08").Value;  	listProp.Items [3].Text = xml.Element ("S09").Value;  	listProp.Items [4].Text = xml.Element ("S0A").Value;  	listProp.Items [5].Text = xml.Element ("S0B").Value;  	listProp.Items [6].Text = xml.Element ("S0C").Value;  	listProp.Items [7].Text = xml.Element ("S0D").Value;  	listProp.Items [8].Text = xml.Element ("S0E").Value;  	listProp.Items [9].Text = xml.Element ("S0F").Value;  } catch {  	throw new Exception ("There was an error reading the XML file of language.");  }  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,ReadLanguage,The following statement contains a magic number: try {  	XElement xml = XElement.Load (Application.StartupPath + Path.DirectorySeparatorChar + "Plugins" + Path.DirectorySeparatorChar + "SoundLang.xml");  	xml = xml.Element (pluginHost.Get_Language ()).Element ("SoundControl");  	columnProper.Text = xml.Element ("S00").Value;  	columnValue.Text = xml.Element ("S01").Value;  	btnExport.Text = xml.Element ("S02").Value;  	btnImport.Text = xml.Element ("S03").Value;  	checkLoop.Text = xml.Element ("S04").Value;  	listProp.Items [0].Text = xml.Element ("S06").Value;  	listProp.Items [1].Text = xml.Element ("S07").Value;  	listProp.Items [2].Text = xml.Element ("S08").Value;  	listProp.Items [3].Text = xml.Element ("S09").Value;  	listProp.Items [4].Text = xml.Element ("S0A").Value;  	listProp.Items [5].Text = xml.Element ("S0B").Value;  	listProp.Items [6].Text = xml.Element ("S0C").Value;  	listProp.Items [7].Text = xml.Element ("S0D").Value;  	listProp.Items [8].Text = xml.Element ("S0E").Value;  	listProp.Items [9].Text = xml.Element ("S0F").Value;  } catch {  	throw new Exception ("There was an error reading the XML file of language.");  }  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,ReadLanguage,The following statement contains a magic number: try {  	XElement xml = XElement.Load (Application.StartupPath + Path.DirectorySeparatorChar + "Plugins" + Path.DirectorySeparatorChar + "SoundLang.xml");  	xml = xml.Element (pluginHost.Get_Language ()).Element ("SoundControl");  	columnProper.Text = xml.Element ("S00").Value;  	columnValue.Text = xml.Element ("S01").Value;  	btnExport.Text = xml.Element ("S02").Value;  	btnImport.Text = xml.Element ("S03").Value;  	checkLoop.Text = xml.Element ("S04").Value;  	listProp.Items [0].Text = xml.Element ("S06").Value;  	listProp.Items [1].Text = xml.Element ("S07").Value;  	listProp.Items [2].Text = xml.Element ("S08").Value;  	listProp.Items [3].Text = xml.Element ("S09").Value;  	listProp.Items [4].Text = xml.Element ("S0A").Value;  	listProp.Items [5].Text = xml.Element ("S0B").Value;  	listProp.Items [6].Text = xml.Element ("S0C").Value;  	listProp.Items [7].Text = xml.Element ("S0D").Value;  	listProp.Items [8].Text = xml.Element ("S0E").Value;  	listProp.Items [9].Text = xml.Element ("S0F").Value;  } catch {  	throw new Exception ("There was an error reading the XML file of language.");  }  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,ReadLanguage,The following statement contains a magic number: try {  	XElement xml = XElement.Load (Application.StartupPath + Path.DirectorySeparatorChar + "Plugins" + Path.DirectorySeparatorChar + "SoundLang.xml");  	xml = xml.Element (pluginHost.Get_Language ()).Element ("SoundControl");  	columnProper.Text = xml.Element ("S00").Value;  	columnValue.Text = xml.Element ("S01").Value;  	btnExport.Text = xml.Element ("S02").Value;  	btnImport.Text = xml.Element ("S03").Value;  	checkLoop.Text = xml.Element ("S04").Value;  	listProp.Items [0].Text = xml.Element ("S06").Value;  	listProp.Items [1].Text = xml.Element ("S07").Value;  	listProp.Items [2].Text = xml.Element ("S08").Value;  	listProp.Items [3].Text = xml.Element ("S09").Value;  	listProp.Items [4].Text = xml.Element ("S0A").Value;  	listProp.Items [5].Text = xml.Element ("S0B").Value;  	listProp.Items [6].Text = xml.Element ("S0C").Value;  	listProp.Items [7].Text = xml.Element ("S0D").Value;  	listProp.Items [8].Text = xml.Element ("S0E").Value;  	listProp.Items [9].Text = xml.Element ("S0F").Value;  } catch {  	throw new Exception ("There was an error reading the XML file of language.");  }  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,ReadLanguage,The following statement contains a magic number: listProp.Items [2].Text = xml.Element ("S08").Value;  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,ReadLanguage,The following statement contains a magic number: listProp.Items [3].Text = xml.Element ("S09").Value;  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,ReadLanguage,The following statement contains a magic number: listProp.Items [4].Text = xml.Element ("S0A").Value;  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,ReadLanguage,The following statement contains a magic number: listProp.Items [5].Text = xml.Element ("S0B").Value;  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,ReadLanguage,The following statement contains a magic number: listProp.Items [6].Text = xml.Element ("S0C").Value;  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,ReadLanguage,The following statement contains a magic number: listProp.Items [7].Text = xml.Element ("S0D").Value;  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,ReadLanguage,The following statement contains a magic number: listProp.Items [8].Text = xml.Element ("S0E").Value;  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,ReadLanguage,The following statement contains a magic number: listProp.Items [9].Text = xml.Element ("S0F").Value;  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,Information,The following statement contains a magic number: if (listProp.Items [0].SubItems.Count == 2)  	for (int i = 0; i < listProp.Items.Count; i++)  		listProp.Items [i].SubItems.RemoveAt (1);  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,Information,The following statement contains a magic number: listProp.Items [2].SubItems.Add (soundBase.CanLoop.ToString ());  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,Information,The following statement contains a magic number: if (soundBase.CanLoop) {  	listProp.Items [3].SubItems.Add ("0x" + soundBase.LoopBegin.ToString ("x"));  	listProp.Items [4].SubItems.Add ("0x" + soundBase.LoopEnd.ToString ("x"));  }  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,Information,The following statement contains a magic number: if (soundBase.CanLoop) {  	listProp.Items [3].SubItems.Add ("0x" + soundBase.LoopBegin.ToString ("x"));  	listProp.Items [4].SubItems.Add ("0x" + soundBase.LoopEnd.ToString ("x"));  }  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,Information,The following statement contains a magic number: listProp.Items [3].SubItems.Add ("0x" + soundBase.LoopBegin.ToString ("x"));  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,Information,The following statement contains a magic number: listProp.Items [4].SubItems.Add ("0x" + soundBase.LoopEnd.ToString ("x"));  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,Information,The following statement contains a magic number: listProp.Items [5].SubItems.Add (soundBase.SampleRate + " Hz");  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,Information,The following statement contains a magic number: listProp.Items [6].SubItems.Add ("0x" + soundBase.NumberSamples.ToString ("x"));  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,Information,The following statement contains a magic number: listProp.Items [7].SubItems.Add ("0x" + soundBase.BlockSize.ToString ("x"));  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,Information,The following statement contains a magic number: listProp.Items [8].SubItems.Add ("0x" + soundBase.SampleBitDepth.ToString ("x"));  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,Information,The following statement contains a magic number: listProp.Items [9].SubItems.Add (soundBase.Copyright);  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.listProp.Location = new System.Drawing.Point (297' 0);  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.listProp.Size = new System.Drawing.Size (215' 512);  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.listProp.Size = new System.Drawing.Size (215' 512);  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.columnProper.Width = 102;  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.columnValue.Width = 105;  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.btnExport.Location = new System.Drawing.Point (3' 49);  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.btnExport.Location = new System.Drawing.Point (3' 49);  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.btnExport.Size = new System.Drawing.Size (90' 40);  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.btnExport.Size = new System.Drawing.Size (90' 40);  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.btnExport.TabIndex = 3;  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.btnImport.Location = new System.Drawing.Point (3' 3);  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.btnImport.Location = new System.Drawing.Point (3' 3);  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.btnImport.Size = new System.Drawing.Size (90' 40);  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.btnImport.Size = new System.Drawing.Size (90' 40);  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.btnImport.TabIndex = 4;  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.checkLoop.Location = new System.Drawing.Point (145' 16);  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.checkLoop.Location = new System.Drawing.Point (145' 16);  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.checkLoop.Size = new System.Drawing.Size (45' 17);  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.checkLoop.Size = new System.Drawing.Size (45' 17);  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.checkLoop.TabIndex = 5;  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.btnStop.Location = new System.Drawing.Point (99' 49);  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.btnStop.Location = new System.Drawing.Point (99' 49);  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.btnStop.Size = new System.Drawing.Size (40' 40);  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.btnStop.Size = new System.Drawing.Size (40' 40);  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.btnStop.TabIndex = 2;  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.btnPlay.Location = new System.Drawing.Point (99' 3);  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.btnPlay.Location = new System.Drawing.Point (99' 3);  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.btnPlay.Size = new System.Drawing.Size (40' 40);  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.btnPlay.Size = new System.Drawing.Size (40' 40);  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size (512' 512);  
Magic Number,Sounds,SoundControl,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SoundControl.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size (512' 512);  
Magic Number,Sounds,Waiting,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Waiting.cs,InitializeComponent,The following statement contains a magic number: this.lblText.Location = new System.Drawing.Point (12' 9);  
Magic Number,Sounds,Waiting,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Waiting.cs,InitializeComponent,The following statement contains a magic number: this.lblText.Location = new System.Drawing.Point (12' 9);  
Magic Number,Sounds,Waiting,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Waiting.cs,InitializeComponent,The following statement contains a magic number: this.lblText.Size = new System.Drawing.Size (40' 13);  
Magic Number,Sounds,Waiting,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Waiting.cs,InitializeComponent,The following statement contains a magic number: this.lblText.Size = new System.Drawing.Size (40' 13);  
Magic Number,Sounds,Waiting,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Waiting.cs,InitializeComponent,The following statement contains a magic number: this.progress.Location = new System.Drawing.Point (15' 50);  
Magic Number,Sounds,Waiting,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Waiting.cs,InitializeComponent,The following statement contains a magic number: this.progress.Location = new System.Drawing.Point (15' 50);  
Magic Number,Sounds,Waiting,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Waiting.cs,InitializeComponent,The following statement contains a magic number: this.progress.Size = new System.Drawing.Size (257' 23);  
Magic Number,Sounds,Waiting,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Waiting.cs,InitializeComponent,The following statement contains a magic number: this.progress.Size = new System.Drawing.Size (257' 23);  
Magic Number,Sounds,Waiting,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Waiting.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (280' 76);  
Magic Number,Sounds,Waiting,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Waiting.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (280' 76);  
Magic Number,Sounds,WAV,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\WAV.cs,Read,The following statement contains a magic number: wav.chunkID = br.ReadChars (4);  
Magic Number,Sounds,WAV,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\WAV.cs,Read,The following statement contains a magic number: wav.format = br.ReadChars (4);  
Magic Number,Sounds,WAV,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\WAV.cs,Read,The following statement contains a magic number: wav.wave.fmt.chunkID = br.ReadChars (4);  
Magic Number,Sounds,WAV,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\WAV.cs,Read,The following statement contains a magic number: wav.wave.data.chunkID = br.ReadChars (4);  
Magic Number,Sounds,WAV,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\WAV.cs,Write_Loop,The following statement contains a magic number: try {  	// Get the loop data  	if (wav.wave.fmt.numChannels == 1) {  		Byte[] data = new Byte[wav.wave.data.data.Length - (int)wav.loopOffset];  		Array.Copy (wav.wave.data.data' wav.loopOffset' data' 0' data.Length);  		wav.wave.data.data = data;  	} else {  		Byte[][] channels = Helper.DividieChannels (wav.wave.data.data);  		wav.wave.data.data = Helper.MergeChannels (channels [0]' channels [1]' (int)wav.loopOffset * 2);  	}  	fs = new FileStream (fileout' System.IO.FileMode.Create);  	bw = new BinaryWriter (fs);  	bw.Write (Encoding.ASCII.GetBytes (wav.chunkID));  	bw.Write (wav.chunkSize);  	bw.Write (Encoding.ASCII.GetBytes (wav.format));  	bw.Write (Encoding.ASCII.GetBytes (wav.wave.fmt.chunkID));  	bw.Write (wav.wave.fmt.chunkSize);  	bw.Write (Convert.ToUInt16 (wav.wave.fmt.audioFormat));  	bw.Write (wav.wave.fmt.numChannels);  	bw.Write (wav.wave.fmt.sampleRate);  	bw.Write (wav.wave.fmt.byteRate);  	bw.Write (wav.wave.fmt.blockAlign);  	bw.Write (wav.wave.fmt.bitsPerSample);  	bw.Write (Encoding.ASCII.GetBytes (wav.wave.data.chunkID));  	bw.Write (wav.wave.data.chunkSize);  	bw.Write (wav.wave.data.data);  	bw.Flush ();  } catch (Exception ex) {  	Console.WriteLine (ex.Message.ToString ());  } finally {  	if (fs != null)  		fs.Close ();  	if (bw != null)  		bw.Close ();  }  
Magic Number,Sounds,WAV,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\WAV.cs,Write_Loop,The following statement contains a magic number: if (wav.wave.fmt.numChannels == 1) {  	Byte[] data = new Byte[wav.wave.data.data.Length - (int)wav.loopOffset];  	Array.Copy (wav.wave.data.data' wav.loopOffset' data' 0' data.Length);  	wav.wave.data.data = data;  } else {  	Byte[][] channels = Helper.DividieChannels (wav.wave.data.data);  	wav.wave.data.data = Helper.MergeChannels (channels [0]' channels [1]' (int)wav.loopOffset * 2);  }  
Magic Number,Sounds,WAV,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\WAV.cs,Write_Loop,The following statement contains a magic number: wav.wave.data.data = Helper.MergeChannels (channels [0]' channels [1]' (int)wav.loopOffset * 2);  
Magic Number,Sounds,WAV,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\WAV.cs,Create,The following statement contains a magic number: wav.wave.fmt.chunkSize = 16;  
Magic Number,Sounds,WAV,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\WAV.cs,Create,The following statement contains a magic number: wav.wave.fmt.byteRate = wav.wave.fmt.sampleRate * wav.wave.fmt.bitsPerSample * wav.wave.fmt.numChannels / 8;  
Magic Number,Sounds,WAV,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\WAV.cs,Create,The following statement contains a magic number: wav.wave.fmt.blockAlign = (ushort)(wav.wave.fmt.numChannels * wav.wave.fmt.bitsPerSample / (ushort)(8));  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  	difference = 0;  	if ((data [i] & 4) != 0)  		difference += stepsize;  	if ((data [i] & 2) != 0)  		difference += stepsize >> 1;  	if ((data [i] & 1) != 0)  		difference += stepsize >> 2;  	difference += stepsize >> 3;  	if ((data [i] & 8) != 0)  		difference = -difference;  	newSample += difference;  	if (newSample > 32767)  		newSample = 32767;  	else if (newSample < -32768)  		newSample = -32768;  	resul.AddRange (BitConverter.GetBytes ((short)newSample));  	index += indexTable [data [i]];  	if (index < 0)  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  	difference = 0;  	if ((data [i] & 4) != 0)  		difference += stepsize;  	if ((data [i] & 2) != 0)  		difference += stepsize >> 1;  	if ((data [i] & 1) != 0)  		difference += stepsize >> 2;  	difference += stepsize >> 3;  	if ((data [i] & 8) != 0)  		difference = -difference;  	newSample += difference;  	if (newSample > 32767)  		newSample = 32767;  	else if (newSample < -32768)  		newSample = -32768;  	resul.AddRange (BitConverter.GetBytes ((short)newSample));  	index += indexTable [data [i]];  	if (index < 0)  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  	difference = 0;  	if ((data [i] & 4) != 0)  		difference += stepsize;  	if ((data [i] & 2) != 0)  		difference += stepsize >> 1;  	if ((data [i] & 1) != 0)  		difference += stepsize >> 2;  	difference += stepsize >> 3;  	if ((data [i] & 8) != 0)  		difference = -difference;  	newSample += difference;  	if (newSample > 32767)  		newSample = 32767;  	else if (newSample < -32768)  		newSample = -32768;  	resul.AddRange (BitConverter.GetBytes ((short)newSample));  	index += indexTable [data [i]];  	if (index < 0)  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  	difference = 0;  	if ((data [i] & 4) != 0)  		difference += stepsize;  	if ((data [i] & 2) != 0)  		difference += stepsize >> 1;  	if ((data [i] & 1) != 0)  		difference += stepsize >> 2;  	difference += stepsize >> 3;  	if ((data [i] & 8) != 0)  		difference = -difference;  	newSample += difference;  	if (newSample > 32767)  		newSample = 32767;  	else if (newSample < -32768)  		newSample = -32768;  	resul.AddRange (BitConverter.GetBytes ((short)newSample));  	index += indexTable [data [i]];  	if (index < 0)  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  	difference = 0;  	if ((data [i] & 4) != 0)  		difference += stepsize;  	if ((data [i] & 2) != 0)  		difference += stepsize >> 1;  	if ((data [i] & 1) != 0)  		difference += stepsize >> 2;  	difference += stepsize >> 3;  	if ((data [i] & 8) != 0)  		difference = -difference;  	newSample += difference;  	if (newSample > 32767)  		newSample = 32767;  	else if (newSample < -32768)  		newSample = -32768;  	resul.AddRange (BitConverter.GetBytes ((short)newSample));  	index += indexTable [data [i]];  	if (index < 0)  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  	difference = 0;  	if ((data [i] & 4) != 0)  		difference += stepsize;  	if ((data [i] & 2) != 0)  		difference += stepsize >> 1;  	if ((data [i] & 1) != 0)  		difference += stepsize >> 2;  	difference += stepsize >> 3;  	if ((data [i] & 8) != 0)  		difference = -difference;  	newSample += difference;  	if (newSample > 32767)  		newSample = 32767;  	else if (newSample < -32768)  		newSample = -32768;  	resul.AddRange (BitConverter.GetBytes ((short)newSample));  	index += indexTable [data [i]];  	if (index < 0)  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  	difference = 0;  	if ((data [i] & 4) != 0)  		difference += stepsize;  	if ((data [i] & 2) != 0)  		difference += stepsize >> 1;  	if ((data [i] & 1) != 0)  		difference += stepsize >> 2;  	difference += stepsize >> 3;  	if ((data [i] & 8) != 0)  		difference = -difference;  	newSample += difference;  	if (newSample > 32767)  		newSample = 32767;  	else if (newSample < -32768)  		newSample = -32768;  	resul.AddRange (BitConverter.GetBytes ((short)newSample));  	index += indexTable [data [i]];  	if (index < 0)  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  	difference = 0;  	if ((data [i] & 4) != 0)  		difference += stepsize;  	if ((data [i] & 2) != 0)  		difference += stepsize >> 1;  	if ((data [i] & 1) != 0)  		difference += stepsize >> 2;  	difference += stepsize >> 3;  	if ((data [i] & 8) != 0)  		difference = -difference;  	newSample += difference;  	if (newSample > 32767)  		newSample = 32767;  	else if (newSample < -32768)  		newSample = -32768;  	resul.AddRange (BitConverter.GetBytes ((short)newSample));  	index += indexTable [data [i]];  	if (index < 0)  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  	difference = 0;  	if ((data [i] & 4) != 0)  		difference += stepsize;  	if ((data [i] & 2) != 0)  		difference += stepsize >> 1;  	if ((data [i] & 1) != 0)  		difference += stepsize >> 2;  	difference += stepsize >> 3;  	if ((data [i] & 8) != 0)  		difference = -difference;  	newSample += difference;  	if (newSample > 32767)  		newSample = 32767;  	else if (newSample < -32768)  		newSample = -32768;  	resul.AddRange (BitConverter.GetBytes ((short)newSample));  	index += indexTable [data [i]];  	if (index < 0)  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  	difference = 0;  	if ((data [i] & 4) != 0)  		difference += stepsize;  	if ((data [i] & 2) != 0)  		difference += stepsize >> 1;  	if ((data [i] & 1) != 0)  		difference += stepsize >> 2;  	difference += stepsize >> 3;  	if ((data [i] & 8) != 0)  		difference = -difference;  	newSample += difference;  	if (newSample > 32767)  		newSample = 32767;  	else if (newSample < -32768)  		newSample = -32768;  	resul.AddRange (BitConverter.GetBytes ((short)newSample));  	index += indexTable [data [i]];  	if (index < 0)  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  	difference = 0;  	if ((data [i] & 4) != 0)  		difference += stepsize;  	if ((data [i] & 2) != 0)  		difference += stepsize >> 1;  	if ((data [i] & 1) != 0)  		difference += stepsize >> 2;  	difference += stepsize >> 3;  	if ((data [i] & 8) != 0)  		difference = -difference;  	newSample += difference;  	if (newSample > 32767)  		newSample = 32767;  	else if (newSample < -32768)  		newSample = -32768;  	resul.AddRange (BitConverter.GetBytes ((short)newSample));  	index += indexTable [data [i]];  	if (index < 0)  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if ((data [i] & 4) != 0)  	difference += stepsize;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if ((data [i] & 2) != 0)  	difference += stepsize >> 1;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if ((data [i] & 1) != 0)  	difference += stepsize >> 2;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: difference += stepsize >> 2;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: difference += stepsize >> 3;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if ((data [i] & 8) != 0)  	difference = -difference;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if (newSample > 32767)  	newSample = 32767;  else if (newSample < -32768)  	newSample = -32768;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if (newSample > 32767)  	newSample = 32767;  else if (newSample < -32768)  	newSample = -32768;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if (newSample > 32767)  	newSample = 32767;  else if (newSample < -32768)  	newSample = -32768;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if (newSample > 32767)  	newSample = 32767;  else if (newSample < -32768)  	newSample = -32768;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: newSample = 32767;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if (newSample < -32768)  	newSample = -32768;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if (newSample < -32768)  	newSample = -32768;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: newSample = -32768;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if (index < 0)  	index = 0;  else if (index > 88)  	index = 88;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if (index < 0)  	index = 0;  else if (index > 88)  	index = 88;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if (index > 88)  	index = 88;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if (index > 88)  	index = 88;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: index = 88;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if (datos.Length < 4)  	return datos;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if (index < 0)  	index = 0;  else if (index > 88)  	index = 88;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if (index < 0)  	index = 0;  else if (index > 88)  	index = 88;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if (index > 88)  	index = 88;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if (index > 88)  	index = 88;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: index = 88;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: Array.Copy (datos' 4' data' 0' data.Length);  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  	difference = 0;  	if ((data [i] & 4) != 0)  		difference += stepsize;  	if ((data [i] & 2) != 0)  		difference += stepsize >> 1;  	if ((data [i] & 1) != 0)  		difference += stepsize >> 2;  	difference += stepsize >> 3;  	if ((data [i] & 8) != 0)  		difference = -difference;  	newSample += difference;  	if (newSample > 32767)  		newSample = 32767;  	else if (newSample < -32768)  		newSample = -32768;  	resul.AddRange (BitConverter.GetBytes ((short)newSample));  	index += indexTable [data [i]];  	if (index < 0)  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  	difference = 0;  	if ((data [i] & 4) != 0)  		difference += stepsize;  	if ((data [i] & 2) != 0)  		difference += stepsize >> 1;  	if ((data [i] & 1) != 0)  		difference += stepsize >> 2;  	difference += stepsize >> 3;  	if ((data [i] & 8) != 0)  		difference = -difference;  	newSample += difference;  	if (newSample > 32767)  		newSample = 32767;  	else if (newSample < -32768)  		newSample = -32768;  	resul.AddRange (BitConverter.GetBytes ((short)newSample));  	index += indexTable [data [i]];  	if (index < 0)  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  	difference = 0;  	if ((data [i] & 4) != 0)  		difference += stepsize;  	if ((data [i] & 2) != 0)  		difference += stepsize >> 1;  	if ((data [i] & 1) != 0)  		difference += stepsize >> 2;  	difference += stepsize >> 3;  	if ((data [i] & 8) != 0)  		difference = -difference;  	newSample += difference;  	if (newSample > 32767)  		newSample = 32767;  	else if (newSample < -32768)  		newSample = -32768;  	resul.AddRange (BitConverter.GetBytes ((short)newSample));  	index += indexTable [data [i]];  	if (index < 0)  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  	difference = 0;  	if ((data [i] & 4) != 0)  		difference += stepsize;  	if ((data [i] & 2) != 0)  		difference += stepsize >> 1;  	if ((data [i] & 1) != 0)  		difference += stepsize >> 2;  	difference += stepsize >> 3;  	if ((data [i] & 8) != 0)  		difference = -difference;  	newSample += difference;  	if (newSample > 32767)  		newSample = 32767;  	else if (newSample < -32768)  		newSample = -32768;  	resul.AddRange (BitConverter.GetBytes ((short)newSample));  	index += indexTable [data [i]];  	if (index < 0)  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  	difference = 0;  	if ((data [i] & 4) != 0)  		difference += stepsize;  	if ((data [i] & 2) != 0)  		difference += stepsize >> 1;  	if ((data [i] & 1) != 0)  		difference += stepsize >> 2;  	difference += stepsize >> 3;  	if ((data [i] & 8) != 0)  		difference = -difference;  	newSample += difference;  	if (newSample > 32767)  		newSample = 32767;  	else if (newSample < -32768)  		newSample = -32768;  	resul.AddRange (BitConverter.GetBytes ((short)newSample));  	index += indexTable [data [i]];  	if (index < 0)  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  	difference = 0;  	if ((data [i] & 4) != 0)  		difference += stepsize;  	if ((data [i] & 2) != 0)  		difference += stepsize >> 1;  	if ((data [i] & 1) != 0)  		difference += stepsize >> 2;  	difference += stepsize >> 3;  	if ((data [i] & 8) != 0)  		difference = -difference;  	newSample += difference;  	if (newSample > 32767)  		newSample = 32767;  	else if (newSample < -32768)  		newSample = -32768;  	resul.AddRange (BitConverter.GetBytes ((short)newSample));  	index += indexTable [data [i]];  	if (index < 0)  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  	difference = 0;  	if ((data [i] & 4) != 0)  		difference += stepsize;  	if ((data [i] & 2) != 0)  		difference += stepsize >> 1;  	if ((data [i] & 1) != 0)  		difference += stepsize >> 2;  	difference += stepsize >> 3;  	if ((data [i] & 8) != 0)  		difference = -difference;  	newSample += difference;  	if (newSample > 32767)  		newSample = 32767;  	else if (newSample < -32768)  		newSample = -32768;  	resul.AddRange (BitConverter.GetBytes ((short)newSample));  	index += indexTable [data [i]];  	if (index < 0)  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  	difference = 0;  	if ((data [i] & 4) != 0)  		difference += stepsize;  	if ((data [i] & 2) != 0)  		difference += stepsize >> 1;  	if ((data [i] & 1) != 0)  		difference += stepsize >> 2;  	difference += stepsize >> 3;  	if ((data [i] & 8) != 0)  		difference = -difference;  	newSample += difference;  	if (newSample > 32767)  		newSample = 32767;  	else if (newSample < -32768)  		newSample = -32768;  	resul.AddRange (BitConverter.GetBytes ((short)newSample));  	index += indexTable [data [i]];  	if (index < 0)  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  	difference = 0;  	if ((data [i] & 4) != 0)  		difference += stepsize;  	if ((data [i] & 2) != 0)  		difference += stepsize >> 1;  	if ((data [i] & 1) != 0)  		difference += stepsize >> 2;  	difference += stepsize >> 3;  	if ((data [i] & 8) != 0)  		difference = -difference;  	newSample += difference;  	if (newSample > 32767)  		newSample = 32767;  	else if (newSample < -32768)  		newSample = -32768;  	resul.AddRange (BitConverter.GetBytes ((short)newSample));  	index += indexTable [data [i]];  	if (index < 0)  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  	difference = 0;  	if ((data [i] & 4) != 0)  		difference += stepsize;  	if ((data [i] & 2) != 0)  		difference += stepsize >> 1;  	if ((data [i] & 1) != 0)  		difference += stepsize >> 2;  	difference += stepsize >> 3;  	if ((data [i] & 8) != 0)  		difference = -difference;  	newSample += difference;  	if (newSample > 32767)  		newSample = 32767;  	else if (newSample < -32768)  		newSample = -32768;  	resul.AddRange (BitConverter.GetBytes ((short)newSample));  	index += indexTable [data [i]];  	if (index < 0)  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  	difference = 0;  	if ((data [i] & 4) != 0)  		difference += stepsize;  	if ((data [i] & 2) != 0)  		difference += stepsize >> 1;  	if ((data [i] & 1) != 0)  		difference += stepsize >> 2;  	difference += stepsize >> 3;  	if ((data [i] & 8) != 0)  		difference = -difference;  	newSample += difference;  	if (newSample > 32767)  		newSample = 32767;  	else if (newSample < -32768)  		newSample = -32768;  	resul.AddRange (BitConverter.GetBytes ((short)newSample));  	index += indexTable [data [i]];  	if (index < 0)  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if ((data [i] & 4) != 0)  	difference += stepsize;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if ((data [i] & 2) != 0)  	difference += stepsize >> 1;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if ((data [i] & 1) != 0)  	difference += stepsize >> 2;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: difference += stepsize >> 2;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: difference += stepsize >> 3;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if ((data [i] & 8) != 0)  	difference = -difference;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if (newSample > 32767)  	newSample = 32767;  else if (newSample < -32768)  	newSample = -32768;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if (newSample > 32767)  	newSample = 32767;  else if (newSample < -32768)  	newSample = -32768;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if (newSample > 32767)  	newSample = 32767;  else if (newSample < -32768)  	newSample = -32768;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if (newSample > 32767)  	newSample = 32767;  else if (newSample < -32768)  	newSample = -32768;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: newSample = 32767;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if (newSample < -32768)  	newSample = -32768;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if (newSample < -32768)  	newSample = -32768;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: newSample = -32768;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if (index < 0)  	index = 0;  else if (index > 88)  	index = 88;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if (index < 0)  	index = 0;  else if (index > 88)  	index = 88;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if (index > 88)  	index = 88;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: if (index > 88)  	index = 88;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Decompress,The following statement contains a magic number: index = 88;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	result.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	result.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	result.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	result.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	result.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	result.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	result.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	result.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	result.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	result.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	result.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	result.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	result.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	result.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	result.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: i += 2
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: if (different >= 0)// Set sign bit and find absolute value of difference   {  	newSample = 0;  	// Set sign bit (newSample[3]) to 0  } else {  	newSample = 8;  	// Set sign bit(newSample[3]) to one  	different = -different;  	// Absolute value of negative difference  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: newSample = 8;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: mask = 4;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: for (int j = 0; j < 3; j++)// Quantize difference down to four bits   {  	if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  	 {  		newSample |= mask;  		// perfom division...  		different -= tempStepsize;  		// ...through repeated subtraction  	}  	tempStepsize >>= 1;  	// adjust comparator for next iteration  	mask >>= 1;  	// adjust bit-set mask for next iteration  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: if ((newSample & 4) != 0)  	// perform multiplication through repetitive addition  	different += stepsize;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: if ((newSample & 2) != 0)  	different += stepsize >> 1;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: if ((newSample & 1) != 0)  	different += stepsize >> 2;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: different += stepsize >> 2;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: different += stepsize >> 3;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: if ((newSample & 8) != 0)  	// account for sign bit  	different = -different;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: if (predictedSample > 32767)  	// check for overflow  	predictedSample = 32767;  else if (predictedSample < -32768)  	predictedSample = -32768;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: if (predictedSample > 32767)  	// check for overflow  	predictedSample = 32767;  else if (predictedSample < -32768)  	predictedSample = -32768;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: if (predictedSample > 32767)  	// check for overflow  	predictedSample = 32767;  else if (predictedSample < -32768)  	predictedSample = -32768;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: if (predictedSample > 32767)  	// check for overflow  	predictedSample = 32767;  else if (predictedSample < -32768)  	predictedSample = -32768;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: predictedSample = 32767;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: if (predictedSample < -32768)  	predictedSample = -32768;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: if (predictedSample < -32768)  	predictedSample = -32768;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: predictedSample = -32768;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: if (index < 0)  	// check for index overflow  	index = 0;  else if (index > 88)  	index = 88;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: if (index < 0)  	// check for index overflow  	index = 0;  else if (index > 88)  	index = 88;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: if (index > 88)  	index = 88;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: if (index > 88)  	index = 88;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Compress,The following statement contains a magic number: index = 88;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	if (i % blockSize == 0) {  		if (i != 0) {  			Byte[] blockData = Bit4ToBit8 (block.GetRange (4' block.Count - 4).ToArray ());  			List<byte> newBlock = new List<byte> ();  			newBlock.AddRange (block.GetRange (0' 4));  			newBlock.AddRange (blockData);  			result.Add (newBlock.ToArray ());  		}  		block = new List<byte> ();  		block.AddRange (BitConverter.GetBytes ((short)predictedSample));  		block.AddRange (BitConverter.GetBytes ((short)index));  	}  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	block.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	if (i % blockSize == 0) {  		if (i != 0) {  			Byte[] blockData = Bit4ToBit8 (block.GetRange (4' block.Count - 4).ToArray ());  			List<byte> newBlock = new List<byte> ();  			newBlock.AddRange (block.GetRange (0' 4));  			newBlock.AddRange (blockData);  			result.Add (newBlock.ToArray ());  		}  		block = new List<byte> ();  		block.AddRange (BitConverter.GetBytes ((short)predictedSample));  		block.AddRange (BitConverter.GetBytes ((short)index));  	}  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	block.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	if (i % blockSize == 0) {  		if (i != 0) {  			Byte[] blockData = Bit4ToBit8 (block.GetRange (4' block.Count - 4).ToArray ());  			List<byte> newBlock = new List<byte> ();  			newBlock.AddRange (block.GetRange (0' 4));  			newBlock.AddRange (blockData);  			result.Add (newBlock.ToArray ());  		}  		block = new List<byte> ();  		block.AddRange (BitConverter.GetBytes ((short)predictedSample));  		block.AddRange (BitConverter.GetBytes ((short)index));  	}  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	block.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	if (i % blockSize == 0) {  		if (i != 0) {  			Byte[] blockData = Bit4ToBit8 (block.GetRange (4' block.Count - 4).ToArray ());  			List<byte> newBlock = new List<byte> ();  			newBlock.AddRange (block.GetRange (0' 4));  			newBlock.AddRange (blockData);  			result.Add (newBlock.ToArray ());  		}  		block = new List<byte> ();  		block.AddRange (BitConverter.GetBytes ((short)predictedSample));  		block.AddRange (BitConverter.GetBytes ((short)index));  	}  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	block.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	if (i % blockSize == 0) {  		if (i != 0) {  			Byte[] blockData = Bit4ToBit8 (block.GetRange (4' block.Count - 4).ToArray ());  			List<byte> newBlock = new List<byte> ();  			newBlock.AddRange (block.GetRange (0' 4));  			newBlock.AddRange (blockData);  			result.Add (newBlock.ToArray ());  		}  		block = new List<byte> ();  		block.AddRange (BitConverter.GetBytes ((short)predictedSample));  		block.AddRange (BitConverter.GetBytes ((short)index));  	}  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	block.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	if (i % blockSize == 0) {  		if (i != 0) {  			Byte[] blockData = Bit4ToBit8 (block.GetRange (4' block.Count - 4).ToArray ());  			List<byte> newBlock = new List<byte> ();  			newBlock.AddRange (block.GetRange (0' 4));  			newBlock.AddRange (blockData);  			result.Add (newBlock.ToArray ());  		}  		block = new List<byte> ();  		block.AddRange (BitConverter.GetBytes ((short)predictedSample));  		block.AddRange (BitConverter.GetBytes ((short)index));  	}  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	block.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	if (i % blockSize == 0) {  		if (i != 0) {  			Byte[] blockData = Bit4ToBit8 (block.GetRange (4' block.Count - 4).ToArray ());  			List<byte> newBlock = new List<byte> ();  			newBlock.AddRange (block.GetRange (0' 4));  			newBlock.AddRange (blockData);  			result.Add (newBlock.ToArray ());  		}  		block = new List<byte> ();  		block.AddRange (BitConverter.GetBytes ((short)predictedSample));  		block.AddRange (BitConverter.GetBytes ((short)index));  	}  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	block.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	if (i % blockSize == 0) {  		if (i != 0) {  			Byte[] blockData = Bit4ToBit8 (block.GetRange (4' block.Count - 4).ToArray ());  			List<byte> newBlock = new List<byte> ();  			newBlock.AddRange (block.GetRange (0' 4));  			newBlock.AddRange (blockData);  			result.Add (newBlock.ToArray ());  		}  		block = new List<byte> ();  		block.AddRange (BitConverter.GetBytes ((short)predictedSample));  		block.AddRange (BitConverter.GetBytes ((short)index));  	}  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	block.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	if (i % blockSize == 0) {  		if (i != 0) {  			Byte[] blockData = Bit4ToBit8 (block.GetRange (4' block.Count - 4).ToArray ());  			List<byte> newBlock = new List<byte> ();  			newBlock.AddRange (block.GetRange (0' 4));  			newBlock.AddRange (blockData);  			result.Add (newBlock.ToArray ());  		}  		block = new List<byte> ();  		block.AddRange (BitConverter.GetBytes ((short)predictedSample));  		block.AddRange (BitConverter.GetBytes ((short)index));  	}  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	block.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	if (i % blockSize == 0) {  		if (i != 0) {  			Byte[] blockData = Bit4ToBit8 (block.GetRange (4' block.Count - 4).ToArray ());  			List<byte> newBlock = new List<byte> ();  			newBlock.AddRange (block.GetRange (0' 4));  			newBlock.AddRange (blockData);  			result.Add (newBlock.ToArray ());  		}  		block = new List<byte> ();  		block.AddRange (BitConverter.GetBytes ((short)predictedSample));  		block.AddRange (BitConverter.GetBytes ((short)index));  	}  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	block.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	if (i % blockSize == 0) {  		if (i != 0) {  			Byte[] blockData = Bit4ToBit8 (block.GetRange (4' block.Count - 4).ToArray ());  			List<byte> newBlock = new List<byte> ();  			newBlock.AddRange (block.GetRange (0' 4));  			newBlock.AddRange (blockData);  			result.Add (newBlock.ToArray ());  		}  		block = new List<byte> ();  		block.AddRange (BitConverter.GetBytes ((short)predictedSample));  		block.AddRange (BitConverter.GetBytes ((short)index));  	}  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	block.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	if (i % blockSize == 0) {  		if (i != 0) {  			Byte[] blockData = Bit4ToBit8 (block.GetRange (4' block.Count - 4).ToArray ());  			List<byte> newBlock = new List<byte> ();  			newBlock.AddRange (block.GetRange (0' 4));  			newBlock.AddRange (blockData);  			result.Add (newBlock.ToArray ());  		}  		block = new List<byte> ();  		block.AddRange (BitConverter.GetBytes ((short)predictedSample));  		block.AddRange (BitConverter.GetBytes ((short)index));  	}  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	block.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	if (i % blockSize == 0) {  		if (i != 0) {  			Byte[] blockData = Bit4ToBit8 (block.GetRange (4' block.Count - 4).ToArray ());  			List<byte> newBlock = new List<byte> ();  			newBlock.AddRange (block.GetRange (0' 4));  			newBlock.AddRange (blockData);  			result.Add (newBlock.ToArray ());  		}  		block = new List<byte> ();  		block.AddRange (BitConverter.GetBytes ((short)predictedSample));  		block.AddRange (BitConverter.GetBytes ((short)index));  	}  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	block.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	if (i % blockSize == 0) {  		if (i != 0) {  			Byte[] blockData = Bit4ToBit8 (block.GetRange (4' block.Count - 4).ToArray ());  			List<byte> newBlock = new List<byte> ();  			newBlock.AddRange (block.GetRange (0' 4));  			newBlock.AddRange (blockData);  			result.Add (newBlock.ToArray ());  		}  		block = new List<byte> ();  		block.AddRange (BitConverter.GetBytes ((short)predictedSample));  		block.AddRange (BitConverter.GetBytes ((short)index));  	}  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	block.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	if (i % blockSize == 0) {  		if (i != 0) {  			Byte[] blockData = Bit4ToBit8 (block.GetRange (4' block.Count - 4).ToArray ());  			List<byte> newBlock = new List<byte> ();  			newBlock.AddRange (block.GetRange (0' 4));  			newBlock.AddRange (blockData);  			result.Add (newBlock.ToArray ());  		}  		block = new List<byte> ();  		block.AddRange (BitConverter.GetBytes ((short)predictedSample));  		block.AddRange (BitConverter.GetBytes ((short)index));  	}  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	block.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	if (i % blockSize == 0) {  		if (i != 0) {  			Byte[] blockData = Bit4ToBit8 (block.GetRange (4' block.Count - 4).ToArray ());  			List<byte> newBlock = new List<byte> ();  			newBlock.AddRange (block.GetRange (0' 4));  			newBlock.AddRange (blockData);  			result.Add (newBlock.ToArray ());  		}  		block = new List<byte> ();  		block.AddRange (BitConverter.GetBytes ((short)predictedSample));  		block.AddRange (BitConverter.GetBytes ((short)index));  	}  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	block.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	if (i % blockSize == 0) {  		if (i != 0) {  			Byte[] blockData = Bit4ToBit8 (block.GetRange (4' block.Count - 4).ToArray ());  			List<byte> newBlock = new List<byte> ();  			newBlock.AddRange (block.GetRange (0' 4));  			newBlock.AddRange (blockData);  			result.Add (newBlock.ToArray ());  		}  		block = new List<byte> ();  		block.AddRange (BitConverter.GetBytes ((short)predictedSample));  		block.AddRange (BitConverter.GetBytes ((short)index));  	}  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	block.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	if (i % blockSize == 0) {  		if (i != 0) {  			Byte[] blockData = Bit4ToBit8 (block.GetRange (4' block.Count - 4).ToArray ());  			List<byte> newBlock = new List<byte> ();  			newBlock.AddRange (block.GetRange (0' 4));  			newBlock.AddRange (blockData);  			result.Add (newBlock.ToArray ());  		}  		block = new List<byte> ();  		block.AddRange (BitConverter.GetBytes ((short)predictedSample));  		block.AddRange (BitConverter.GetBytes ((short)index));  	}  	short originalSample = BitConverter.ToInt16 (data' i);  	different = originalSample - predictedSample;  	// find difference from predicted sample  	if (different >= 0)// Set sign bit and find absolute value of difference  	 {  		newSample = 0;  		// Set sign bit (newSample[3]) to 0  	} else {  		newSample = 8;  		// Set sign bit(newSample[3]) to one  		different = -different;  		// Absolute value of negative difference  	}  	mask = 4;  	// Used to set bits in newSample  	tempStepsize = stepsize;  	// Store quantizer stepsize for later use  	for (int j = 0; j < 3; j++)// Quantize difference down to four bits  	 {  		if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  		 {  			newSample |= mask;  			// perfom division...  			different -= tempStepsize;  			// ...through repeated subtraction  		}  		tempStepsize >>= 1;  		// adjust comparator for next iteration  		mask >>= 1;  		// adjust bit-set mask for next iteration  	}  	block.Add ((byte)newSample);  	// Store 4-bit newSample  	// Compute new sample estimate predictedSample  	different = 0;  	// Calculate difference = (newSample + 1/2) * stepsize / 4  	if ((newSample & 4) != 0)  		// perform multiplication through repetitive addition  		different += stepsize;  	if ((newSample & 2) != 0)  		different += stepsize >> 1;  	if ((newSample & 1) != 0)  		different += stepsize >> 2;  	different += stepsize >> 3;  	// (newSample + 1/2) * stepsize / 4 = newSample * stepsize / 4 + stepsize / 8  	if ((newSample & 8) != 0)  		// account for sign bit  		different = -different;  	// adjust predicted sample based on calculated difference  	predictedSample += different;  	if (predictedSample > 32767)  		// check for overflow  		predictedSample = 32767;  	else if (predictedSample < -32768)  		predictedSample = -32768;  	// compute new stepsize  	index += indexTable [newSample];  	// adjust index into stepsize lookup table using newSample  	if (index < 0)  		// check for index overflow  		index = 0;  	else if (index > 88)  		index = 88;  	stepsize = stepsizeTable [index];  	// find new quantizer stepsize  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: i += 2
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: if (i % blockSize == 0) {  	if (i != 0) {  		Byte[] blockData = Bit4ToBit8 (block.GetRange (4' block.Count - 4).ToArray ());  		List<byte> newBlock = new List<byte> ();  		newBlock.AddRange (block.GetRange (0' 4));  		newBlock.AddRange (blockData);  		result.Add (newBlock.ToArray ());  	}  	block = new List<byte> ();  	block.AddRange (BitConverter.GetBytes ((short)predictedSample));  	block.AddRange (BitConverter.GetBytes ((short)index));  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: if (i % blockSize == 0) {  	if (i != 0) {  		Byte[] blockData = Bit4ToBit8 (block.GetRange (4' block.Count - 4).ToArray ());  		List<byte> newBlock = new List<byte> ();  		newBlock.AddRange (block.GetRange (0' 4));  		newBlock.AddRange (blockData);  		result.Add (newBlock.ToArray ());  	}  	block = new List<byte> ();  	block.AddRange (BitConverter.GetBytes ((short)predictedSample));  	block.AddRange (BitConverter.GetBytes ((short)index));  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: if (i % blockSize == 0) {  	if (i != 0) {  		Byte[] blockData = Bit4ToBit8 (block.GetRange (4' block.Count - 4).ToArray ());  		List<byte> newBlock = new List<byte> ();  		newBlock.AddRange (block.GetRange (0' 4));  		newBlock.AddRange (blockData);  		result.Add (newBlock.ToArray ());  	}  	block = new List<byte> ();  	block.AddRange (BitConverter.GetBytes ((short)predictedSample));  	block.AddRange (BitConverter.GetBytes ((short)index));  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: if (i != 0) {  	Byte[] blockData = Bit4ToBit8 (block.GetRange (4' block.Count - 4).ToArray ());  	List<byte> newBlock = new List<byte> ();  	newBlock.AddRange (block.GetRange (0' 4));  	newBlock.AddRange (blockData);  	result.Add (newBlock.ToArray ());  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: if (i != 0) {  	Byte[] blockData = Bit4ToBit8 (block.GetRange (4' block.Count - 4).ToArray ());  	List<byte> newBlock = new List<byte> ();  	newBlock.AddRange (block.GetRange (0' 4));  	newBlock.AddRange (blockData);  	result.Add (newBlock.ToArray ());  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: if (i != 0) {  	Byte[] blockData = Bit4ToBit8 (block.GetRange (4' block.Count - 4).ToArray ());  	List<byte> newBlock = new List<byte> ();  	newBlock.AddRange (block.GetRange (0' 4));  	newBlock.AddRange (blockData);  	result.Add (newBlock.ToArray ());  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: newBlock.AddRange (block.GetRange (0' 4));  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: if (different >= 0)// Set sign bit and find absolute value of difference   {  	newSample = 0;  	// Set sign bit (newSample[3]) to 0  } else {  	newSample = 8;  	// Set sign bit(newSample[3]) to one  	different = -different;  	// Absolute value of negative difference  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: newSample = 8;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: mask = 4;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: for (int j = 0; j < 3; j++)// Quantize difference down to four bits   {  	if (different >= tempStepsize)// newSample[2:0] = 4 * (difference / stepsize)  	 {  		newSample |= mask;  		// perfom division...  		different -= tempStepsize;  		// ...through repeated subtraction  	}  	tempStepsize >>= 1;  	// adjust comparator for next iteration  	mask >>= 1;  	// adjust bit-set mask for next iteration  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: if ((newSample & 4) != 0)  	// perform multiplication through repetitive addition  	different += stepsize;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: if ((newSample & 2) != 0)  	different += stepsize >> 1;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: if ((newSample & 1) != 0)  	different += stepsize >> 2;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: different += stepsize >> 2;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: different += stepsize >> 3;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: if ((newSample & 8) != 0)  	// account for sign bit  	different = -different;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: if (predictedSample > 32767)  	// check for overflow  	predictedSample = 32767;  else if (predictedSample < -32768)  	predictedSample = -32768;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: if (predictedSample > 32767)  	// check for overflow  	predictedSample = 32767;  else if (predictedSample < -32768)  	predictedSample = -32768;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: if (predictedSample > 32767)  	// check for overflow  	predictedSample = 32767;  else if (predictedSample < -32768)  	predictedSample = -32768;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: if (predictedSample > 32767)  	// check for overflow  	predictedSample = 32767;  else if (predictedSample < -32768)  	predictedSample = -32768;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: predictedSample = 32767;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: if (predictedSample < -32768)  	predictedSample = -32768;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: if (predictedSample < -32768)  	predictedSample = -32768;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: predictedSample = -32768;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: if (index < 0)  	// check for index overflow  	index = 0;  else if (index > 88)  	index = 88;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: if (index < 0)  	// check for index overflow  	index = 0;  else if (index > 88)  	index = 88;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: if (index > 88)  	index = 88;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: if (index > 88)  	index = 88;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: index = 88;  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: if (block.Count > 4) {  	Byte[] blockData = Bit4ToBit8 (block.GetRange (4' block.Count - 4).ToArray ());  	List<byte> newBlock = new List<byte> ();  	newBlock.AddRange (block.GetRange (0' 4));  	newBlock.AddRange (blockData);  	result.Add (newBlock.ToArray ());  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: if (block.Count > 4) {  	Byte[] blockData = Bit4ToBit8 (block.GetRange (4' block.Count - 4).ToArray ());  	List<byte> newBlock = new List<byte> ();  	newBlock.AddRange (block.GetRange (0' 4));  	newBlock.AddRange (blockData);  	result.Add (newBlock.ToArray ());  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: if (block.Count > 4) {  	Byte[] blockData = Bit4ToBit8 (block.GetRange (4' block.Count - 4).ToArray ());  	List<byte> newBlock = new List<byte> ();  	newBlock.AddRange (block.GetRange (0' 4));  	newBlock.AddRange (blockData);  	result.Add (newBlock.ToArray ());  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: if (block.Count > 4) {  	Byte[] blockData = Bit4ToBit8 (block.GetRange (4' block.Count - 4).ToArray ());  	List<byte> newBlock = new List<byte> ();  	newBlock.AddRange (block.GetRange (0' 4));  	newBlock.AddRange (blockData);  	result.Add (newBlock.ToArray ());  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,CompressBlock,The following statement contains a magic number: newBlock.AddRange (block.GetRange (0' 4));  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Bit8ToBit4,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  	bit4.Add ((byte)(data [i] & 0x0F));  	bit4.Add ((byte)((data [i] & 0xF0) >> 4));  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Bit8ToBit4,The following statement contains a magic number: bit4.Add ((byte)((data [i] & 0xF0) >> 4));  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Bit4ToBit8,The following statement contains a magic number: for (int i = 0; i < bytes.Length; i += 2) {  	byte byte1 = bytes [i];  	byte byte2 = 0;  	if (i + 1 < bytes.Length)  		byte2 = (byte)(bytes [i + 1] << 4);  	bit8.Add ((byte)(byte1 + byte2));  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Bit4ToBit8,The following statement contains a magic number: for (int i = 0; i < bytes.Length; i += 2) {  	byte byte1 = bytes [i];  	byte byte2 = 0;  	if (i + 1 < bytes.Length)  		byte2 = (byte)(bytes [i + 1] << 4);  	bit8.Add ((byte)(byte1 + byte2));  }  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Bit4ToBit8,The following statement contains a magic number: i += 2
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Bit4ToBit8,The following statement contains a magic number: if (i + 1 < bytes.Length)  	byte2 = (byte)(bytes [i + 1] << 4);  
Magic Number,Sounds.Compression,IMA_ADPCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\IMA-ADPCM.cs,Bit4ToBit8,The following statement contains a magic number: byte2 = (byte)(bytes [i + 1] << 4);  
Magic Number,Sounds.Compression,PCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\PCM.cs,PCM8SignedToPCM16,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	short sample = BitConverter.ToInt16 (data' i);  	short pcm16 = (short)(sample & 0x7F);  	pcm16 <<= 8;  	if ((sample >> 7) != 0)  		pcm16 -= 0x7FFF;  	resul.AddRange (BitConverter.GetBytes ((short)pcm16));  }  
Magic Number,Sounds.Compression,PCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\PCM.cs,PCM8SignedToPCM16,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	short sample = BitConverter.ToInt16 (data' i);  	short pcm16 = (short)(sample & 0x7F);  	pcm16 <<= 8;  	if ((sample >> 7) != 0)  		pcm16 -= 0x7FFF;  	resul.AddRange (BitConverter.GetBytes ((short)pcm16));  }  
Magic Number,Sounds.Compression,PCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\PCM.cs,PCM8SignedToPCM16,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	short sample = BitConverter.ToInt16 (data' i);  	short pcm16 = (short)(sample & 0x7F);  	pcm16 <<= 8;  	if ((sample >> 7) != 0)  		pcm16 -= 0x7FFF;  	resul.AddRange (BitConverter.GetBytes ((short)pcm16));  }  
Magic Number,Sounds.Compression,PCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\PCM.cs,PCM8SignedToPCM16,The following statement contains a magic number: i += 2
Magic Number,Sounds.Compression,PCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\PCM.cs,PCM8SignedToPCM16,The following statement contains a magic number: pcm16 <<= 8;  
Magic Number,Sounds.Compression,PCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\PCM.cs,PCM8SignedToPCM16,The following statement contains a magic number: if ((sample >> 7) != 0)  	pcm16 -= 0x7FFF;  
Magic Number,Sounds.Compression,PCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\PCM.cs,PCM8UnsignedToPCM16,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	short sample = BitConverter.ToInt16 (data' i);  	short pcm16 = (short)(sample & 0xFF);  	pcm16 <<= 8;  	pcm16 += 0x7FFF;  	resul.AddRange (BitConverter.GetBytes ((short)pcm16));  }  
Magic Number,Sounds.Compression,PCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\PCM.cs,PCM8UnsignedToPCM16,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	short sample = BitConverter.ToInt16 (data' i);  	short pcm16 = (short)(sample & 0xFF);  	pcm16 <<= 8;  	pcm16 += 0x7FFF;  	resul.AddRange (BitConverter.GetBytes ((short)pcm16));  }  
Magic Number,Sounds.Compression,PCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\PCM.cs,PCM8UnsignedToPCM16,The following statement contains a magic number: i += 2
Magic Number,Sounds.Compression,PCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\PCM.cs,PCM8UnsignedToPCM16,The following statement contains a magic number: pcm16 <<= 8;  
Magic Number,Sounds.Compression,PCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\PCM.cs,PCM16ToPCM8,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	short pcm16 = BitConverter.ToInt16 (data' i);  	bool negative = (pcm16 < 0 ? true : false);  	if (negative)  		pcm16 += 0x7FFF;  	pcm16 >>= 8;  	if (negative)  		pcm16 += 0x80;  	result.Add ((byte)pcm16);  }  
Magic Number,Sounds.Compression,PCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\PCM.cs,PCM16ToPCM8,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2) {  	short pcm16 = BitConverter.ToInt16 (data' i);  	bool negative = (pcm16 < 0 ? true : false);  	if (negative)  		pcm16 += 0x7FFF;  	pcm16 >>= 8;  	if (negative)  		pcm16 += 0x80;  	result.Add ((byte)pcm16);  }  
Magic Number,Sounds.Compression,PCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\PCM.cs,PCM16ToPCM8,The following statement contains a magic number: i += 2
Magic Number,Sounds.Compression,PCM,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\PCM.cs,PCM16ToPCM8,The following statement contains a magic number: pcm16 >>= 8;  
Magic Number,Sounds.Compression,Procyon,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\Procyon.cs,Decode,The following statement contains a magic number: pos = framesin * 16 + 15 + offset;  
Magic Number,Sounds.Compression,Procyon,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\Procyon.cs,Decode,The following statement contains a magic number: pos = framesin * 16 + 15 + offset;  
Magic Number,Sounds.Compression,Procyon,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\Procyon.cs,Decode,The following statement contains a magic number: if (coef_index > 4)  	coef_index = 0;  
Magic Number,Sounds.Compression,Procyon,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\Procyon.cs,Decode,The following statement contains a magic number: first_sample = first_sample % 30;  
Magic Number,Sounds.Compression,Procyon,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\Procyon.cs,Decode,The following statement contains a magic number: for (i = first_sample' sample_count = 0; i < first_sample + samples_to_do; i++' sample_count += (int)channels) {  	pos = framesin * 16 + offset + i / 2;  	int sample_byte = ((sbyte)decoded [pos] ^ 0x80);  	int sample = (int)((i & 1) != 0 ? Helper.get_high_nibble_signed ((byte)sample_byte) : Helper.get_low_nibble_signed ((byte)sample_byte)) * 64 * 64;  	if (scale < 0)  		sample <<= -scale;  	else  		sample >>= scale;  	sample = (hist1 * coef1 + hist2 * coef2 + 32) / 64 + (sample * 64);  	hist2 = hist1;  	hist1 = sample;  	short clamp = (short)(Helper.clamp16 ((sample + 32) / 64) / 64 * 64);  	buffer.AddRange (BitConverter.GetBytes (clamp));  }  
Magic Number,Sounds.Compression,Procyon,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\Procyon.cs,Decode,The following statement contains a magic number: for (i = first_sample' sample_count = 0; i < first_sample + samples_to_do; i++' sample_count += (int)channels) {  	pos = framesin * 16 + offset + i / 2;  	int sample_byte = ((sbyte)decoded [pos] ^ 0x80);  	int sample = (int)((i & 1) != 0 ? Helper.get_high_nibble_signed ((byte)sample_byte) : Helper.get_low_nibble_signed ((byte)sample_byte)) * 64 * 64;  	if (scale < 0)  		sample <<= -scale;  	else  		sample >>= scale;  	sample = (hist1 * coef1 + hist2 * coef2 + 32) / 64 + (sample * 64);  	hist2 = hist1;  	hist1 = sample;  	short clamp = (short)(Helper.clamp16 ((sample + 32) / 64) / 64 * 64);  	buffer.AddRange (BitConverter.GetBytes (clamp));  }  
Magic Number,Sounds.Compression,Procyon,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\Procyon.cs,Decode,The following statement contains a magic number: for (i = first_sample' sample_count = 0; i < first_sample + samples_to_do; i++' sample_count += (int)channels) {  	pos = framesin * 16 + offset + i / 2;  	int sample_byte = ((sbyte)decoded [pos] ^ 0x80);  	int sample = (int)((i & 1) != 0 ? Helper.get_high_nibble_signed ((byte)sample_byte) : Helper.get_low_nibble_signed ((byte)sample_byte)) * 64 * 64;  	if (scale < 0)  		sample <<= -scale;  	else  		sample >>= scale;  	sample = (hist1 * coef1 + hist2 * coef2 + 32) / 64 + (sample * 64);  	hist2 = hist1;  	hist1 = sample;  	short clamp = (short)(Helper.clamp16 ((sample + 32) / 64) / 64 * 64);  	buffer.AddRange (BitConverter.GetBytes (clamp));  }  
Magic Number,Sounds.Compression,Procyon,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\Procyon.cs,Decode,The following statement contains a magic number: for (i = first_sample' sample_count = 0; i < first_sample + samples_to_do; i++' sample_count += (int)channels) {  	pos = framesin * 16 + offset + i / 2;  	int sample_byte = ((sbyte)decoded [pos] ^ 0x80);  	int sample = (int)((i & 1) != 0 ? Helper.get_high_nibble_signed ((byte)sample_byte) : Helper.get_low_nibble_signed ((byte)sample_byte)) * 64 * 64;  	if (scale < 0)  		sample <<= -scale;  	else  		sample >>= scale;  	sample = (hist1 * coef1 + hist2 * coef2 + 32) / 64 + (sample * 64);  	hist2 = hist1;  	hist1 = sample;  	short clamp = (short)(Helper.clamp16 ((sample + 32) / 64) / 64 * 64);  	buffer.AddRange (BitConverter.GetBytes (clamp));  }  
Magic Number,Sounds.Compression,Procyon,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\Procyon.cs,Decode,The following statement contains a magic number: for (i = first_sample' sample_count = 0; i < first_sample + samples_to_do; i++' sample_count += (int)channels) {  	pos = framesin * 16 + offset + i / 2;  	int sample_byte = ((sbyte)decoded [pos] ^ 0x80);  	int sample = (int)((i & 1) != 0 ? Helper.get_high_nibble_signed ((byte)sample_byte) : Helper.get_low_nibble_signed ((byte)sample_byte)) * 64 * 64;  	if (scale < 0)  		sample <<= -scale;  	else  		sample >>= scale;  	sample = (hist1 * coef1 + hist2 * coef2 + 32) / 64 + (sample * 64);  	hist2 = hist1;  	hist1 = sample;  	short clamp = (short)(Helper.clamp16 ((sample + 32) / 64) / 64 * 64);  	buffer.AddRange (BitConverter.GetBytes (clamp));  }  
Magic Number,Sounds.Compression,Procyon,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\Procyon.cs,Decode,The following statement contains a magic number: for (i = first_sample' sample_count = 0; i < first_sample + samples_to_do; i++' sample_count += (int)channels) {  	pos = framesin * 16 + offset + i / 2;  	int sample_byte = ((sbyte)decoded [pos] ^ 0x80);  	int sample = (int)((i & 1) != 0 ? Helper.get_high_nibble_signed ((byte)sample_byte) : Helper.get_low_nibble_signed ((byte)sample_byte)) * 64 * 64;  	if (scale < 0)  		sample <<= -scale;  	else  		sample >>= scale;  	sample = (hist1 * coef1 + hist2 * coef2 + 32) / 64 + (sample * 64);  	hist2 = hist1;  	hist1 = sample;  	short clamp = (short)(Helper.clamp16 ((sample + 32) / 64) / 64 * 64);  	buffer.AddRange (BitConverter.GetBytes (clamp));  }  
Magic Number,Sounds.Compression,Procyon,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\Procyon.cs,Decode,The following statement contains a magic number: for (i = first_sample' sample_count = 0; i < first_sample + samples_to_do; i++' sample_count += (int)channels) {  	pos = framesin * 16 + offset + i / 2;  	int sample_byte = ((sbyte)decoded [pos] ^ 0x80);  	int sample = (int)((i & 1) != 0 ? Helper.get_high_nibble_signed ((byte)sample_byte) : Helper.get_low_nibble_signed ((byte)sample_byte)) * 64 * 64;  	if (scale < 0)  		sample <<= -scale;  	else  		sample >>= scale;  	sample = (hist1 * coef1 + hist2 * coef2 + 32) / 64 + (sample * 64);  	hist2 = hist1;  	hist1 = sample;  	short clamp = (short)(Helper.clamp16 ((sample + 32) / 64) / 64 * 64);  	buffer.AddRange (BitConverter.GetBytes (clamp));  }  
Magic Number,Sounds.Compression,Procyon,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\Procyon.cs,Decode,The following statement contains a magic number: for (i = first_sample' sample_count = 0; i < first_sample + samples_to_do; i++' sample_count += (int)channels) {  	pos = framesin * 16 + offset + i / 2;  	int sample_byte = ((sbyte)decoded [pos] ^ 0x80);  	int sample = (int)((i & 1) != 0 ? Helper.get_high_nibble_signed ((byte)sample_byte) : Helper.get_low_nibble_signed ((byte)sample_byte)) * 64 * 64;  	if (scale < 0)  		sample <<= -scale;  	else  		sample >>= scale;  	sample = (hist1 * coef1 + hist2 * coef2 + 32) / 64 + (sample * 64);  	hist2 = hist1;  	hist1 = sample;  	short clamp = (short)(Helper.clamp16 ((sample + 32) / 64) / 64 * 64);  	buffer.AddRange (BitConverter.GetBytes (clamp));  }  
Magic Number,Sounds.Compression,Procyon,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\Procyon.cs,Decode,The following statement contains a magic number: for (i = first_sample' sample_count = 0; i < first_sample + samples_to_do; i++' sample_count += (int)channels) {  	pos = framesin * 16 + offset + i / 2;  	int sample_byte = ((sbyte)decoded [pos] ^ 0x80);  	int sample = (int)((i & 1) != 0 ? Helper.get_high_nibble_signed ((byte)sample_byte) : Helper.get_low_nibble_signed ((byte)sample_byte)) * 64 * 64;  	if (scale < 0)  		sample <<= -scale;  	else  		sample >>= scale;  	sample = (hist1 * coef1 + hist2 * coef2 + 32) / 64 + (sample * 64);  	hist2 = hist1;  	hist1 = sample;  	short clamp = (short)(Helper.clamp16 ((sample + 32) / 64) / 64 * 64);  	buffer.AddRange (BitConverter.GetBytes (clamp));  }  
Magic Number,Sounds.Compression,Procyon,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\Procyon.cs,Decode,The following statement contains a magic number: for (i = first_sample' sample_count = 0; i < first_sample + samples_to_do; i++' sample_count += (int)channels) {  	pos = framesin * 16 + offset + i / 2;  	int sample_byte = ((sbyte)decoded [pos] ^ 0x80);  	int sample = (int)((i & 1) != 0 ? Helper.get_high_nibble_signed ((byte)sample_byte) : Helper.get_low_nibble_signed ((byte)sample_byte)) * 64 * 64;  	if (scale < 0)  		sample <<= -scale;  	else  		sample >>= scale;  	sample = (hist1 * coef1 + hist2 * coef2 + 32) / 64 + (sample * 64);  	hist2 = hist1;  	hist1 = sample;  	short clamp = (short)(Helper.clamp16 ((sample + 32) / 64) / 64 * 64);  	buffer.AddRange (BitConverter.GetBytes (clamp));  }  
Magic Number,Sounds.Compression,Procyon,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\Procyon.cs,Decode,The following statement contains a magic number: for (i = first_sample' sample_count = 0; i < first_sample + samples_to_do; i++' sample_count += (int)channels) {  	pos = framesin * 16 + offset + i / 2;  	int sample_byte = ((sbyte)decoded [pos] ^ 0x80);  	int sample = (int)((i & 1) != 0 ? Helper.get_high_nibble_signed ((byte)sample_byte) : Helper.get_low_nibble_signed ((byte)sample_byte)) * 64 * 64;  	if (scale < 0)  		sample <<= -scale;  	else  		sample >>= scale;  	sample = (hist1 * coef1 + hist2 * coef2 + 32) / 64 + (sample * 64);  	hist2 = hist1;  	hist1 = sample;  	short clamp = (short)(Helper.clamp16 ((sample + 32) / 64) / 64 * 64);  	buffer.AddRange (BitConverter.GetBytes (clamp));  }  
Magic Number,Sounds.Compression,Procyon,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\Procyon.cs,Decode,The following statement contains a magic number: pos = framesin * 16 + offset + i / 2;  
Magic Number,Sounds.Compression,Procyon,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\Procyon.cs,Decode,The following statement contains a magic number: pos = framesin * 16 + offset + i / 2;  
Magic Number,Sounds.Compression,Procyon,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\Procyon.cs,Decode,The following statement contains a magic number: sample = (hist1 * coef1 + hist2 * coef2 + 32) / 64 + (sample * 64);  
Magic Number,Sounds.Compression,Procyon,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\Procyon.cs,Decode,The following statement contains a magic number: sample = (hist1 * coef1 + hist2 * coef2 + 32) / 64 + (sample * 64);  
Magic Number,Sounds.Compression,Procyon,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\Compression\Procyon.cs,Decode,The following statement contains a magic number: sample = (hist1 * coef1 + hist2 * coef2 + 32) / 64 + (sample * 64);  
Missing Default,Sounds,ADX,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\ADX.cs,Read_File,The following switch statement is missing a default case: switch (adx_header.version) {  case 3:  	adx_header.loop_enabled = Helper.Get_uint (ref br);  	adx_header.loop_begin_sample_index = Helper.Get_uint (ref br);  	adx_header.loop_begin_byte_index = Helper.Get_uint (ref br);  	adx_header.loop_end_sample_index = Helper.Get_uint (ref br);  	adx_header.loop_end_byte_index = Helper.Get_uint (ref br);  	break;  case 4:  	br.BaseStream.Position += 0x0C;  	adx_header.loop_enabled = Helper.Get_uint (ref br);  	adx_header.loop_begin_sample_index = Helper.Get_uint (ref br);  	adx_header.loop_begin_byte_index = Helper.Get_uint (ref br);  	adx_header.loop_end_sample_index = Helper.Get_uint (ref br);  	adx_header.loop_end_byte_index = Helper.Get_uint (ref br);  	break;  }  
Missing Default,Sounds,SADL,D:\newReposJune17\pleonex_tinke\Plugins\Sounds\Sounds\SADL.cs,Read_File,The following switch statement is missing a default case: switch (coding & 0x06) {  case 4:  	sadl.sample_rate = 32728;  	break;  case 2:  	sadl.sample_rate = 16364;  	break;  }  
