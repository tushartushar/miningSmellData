Implementation smell,Namespace,Class,File,Method,Description
Long Method,Ekona.Helper,LNK,C:\repos\pleonex_tinke\Ekona\Helper\LNK.cs,Read_Extra,The method has 106 lines of code.
Long Method,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The method has 100 lines of code.
Long Method,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The method has 477 lines of code.
Long Method,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The method has 167 lines of code.
Long Method,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The method has 181 lines of code.
Long Method,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The method has 136 lines of code.
Long Method,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The method has 431 lines of code.
Long Method,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The method has 242 lines of code.
Long Method,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The method has 803 lines of code.
Complex Method,Ekona.Helper,LNK,C:\repos\pleonex_tinke\Ekona\Helper\LNK.cs,Read_LinkInfo,Cyclomatic complexity of the method is 11
Complex Method,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Indexed_Image,Cyclomatic complexity of the method is 9
Complex Method,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Apply_Map,Cyclomatic complexity of the method is 8
Complex Method,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Create_Map,Cyclomatic complexity of the method is 11
Complex Method,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,Cyclomatic complexity of the method is 16
Complex Method,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,Cyclomatic complexity of the method is 24
Complex Method,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,Cyclomatic complexity of the method is 18
Complex Method,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,Import_File,Cyclomatic complexity of the method is 13
Complex Method,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,Save_Files,Cyclomatic complexity of the method is 10
Long Parameter List,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The method has 7 parameters. Parameters: tiles' tile_pal' palette' format' width' height' start
Long Parameter List,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,HorizontalToLineal,The method has 5 parameters. Parameters: horizontal' width' height' bpp' tile_size
Long Parameter List,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,LinealToHorizontal,The method has 5 parameters. Parameters: lineal' width' height' bpp' tile_size
Long Parameter List,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Swap_Color,The method has 5 parameters. Parameters: tiles' palette' oldIndex' newIndex' format
Long Parameter List,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Swap_Palette,The method has 5 parameters. Parameters: tiles' newp' oldp' format' threshold
Long Parameter List,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Add_Image,The method has 6 parameters. Parameters: data' newData' partOffset' partSize' blockSize' addedLength
Long Parameter List,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Apply_Map,The method has 6 parameters. Parameters: map' tiles' tile_pal' bpp' tile_size' startInfo
Long Parameter List,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The method has 14 parameters. Parameters: bank' blockSize' img' pal' max_width' max_height' draw_grid' draw_cells' draw_numbers' trans' image' currOAM' zoom' index
Long Parameter List,Ekona.Images,ImageBase,C:\repos\pleonex_tinke\Ekona\Images\ImageBase.cs,ImageBase,The method has 7 parameters. Parameters: tiles' width' height' format' tileForm' editable' fileName
Long Parameter List,Ekona.Images,ImageBase,C:\repos\pleonex_tinke\Ekona\Images\ImageBase.cs,Set_Tiles,The method has 7 parameters. Parameters: tiles' width' height' format' form' editable' tile_size
Long Parameter List,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Error,The method has 5 parameters. Parameters: inputPoints' mask' a' b' hasAlpha
Long Parameter List,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The method has 7 parameters. Parameters: colors' uniqueFlags' count' aIndex' bIndex' dxtBoundColors' hasAlpha
Long Parameter List,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The method has 6 parameters. Parameters: block' mask' compressColors' c0' c1' texels
Long Parameter List,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The method has 6 parameters. Parameters: bgra' width' height' boundaryApprox' onlyInterpolatedPalettes' palette
Long Parameter List,Ekona.Images,MapBase,C:\repos\pleonex_tinke\Ekona\Images\MapBase.cs,MapBase,The method has 5 parameters. Parameters: mapInfo' editable' width' height' fileName
Long Parameter List,Ekona.Images,SpriteBase,C:\repos\pleonex_tinke\Ekona\Images\SpriteBase.cs,Get_Image,The method has 10 parameters. Parameters: image' pal' index' width' height' grid' cell' number' trans' img
Long Parameter List,Ekona.Images,SpriteBase,C:\repos\pleonex_tinke\Ekona\Images\SpriteBase.cs,Get_Image,The method has 10 parameters. Parameters: image' pal' bank' width' height' grid' cell' number' trans' img
Long Parameter List,Ekona.Images,SpriteBase,C:\repos\pleonex_tinke\Ekona\Images\SpriteBase.cs,Get_Image,The method has 11 parameters. Parameters: image' pal' bank' width' height' grid' cell' number' trans' img' currOAM
Long Parameter List,Ekona.Images,SpriteBase,C:\repos\pleonex_tinke\Ekona\Images\SpriteBase.cs,Get_Image,The method has 11 parameters. Parameters: image' pal' index' width' height' grid' cell' number' trans' img' currOAM
Long Parameter List,Ekona.Images,SpriteBase,C:\repos\pleonex_tinke\Ekona\Images\SpriteBase.cs,Get_Image,The method has 12 parameters. Parameters: image' pal' index' width' height' grid' cell' number' trans' img' currOAM' draw_index
Long Parameter List,Ekona.Images,RawPalette,C:\repos\pleonex_tinke\Ekona\Images\RawData.cs,RawPalette,The method has 7 parameters. Parameters: file' id' editable' depth' offset' size' fileName
Long Parameter List,Ekona.Images,RawPalette,C:\repos\pleonex_tinke\Ekona\Images\RawData.cs,RawPalette,The method has 6 parameters. Parameters: file' id' editable' offset' size' fileName
Long Parameter List,Ekona.Images,RawPalette,C:\repos\pleonex_tinke\Ekona\Images\RawData.cs,Read,The method has 5 parameters. Parameters: fileIn' editable' depth' offset' fileSize
Long Parameter List,Ekona.Images,RawImage,C:\repos\pleonex_tinke\Ekona\Images\RawData.cs,RawImage,The method has 8 parameters. Parameters: file' id' form' format' editable' offset' size' fileName
Long Parameter List,Ekona.Images,RawImage,C:\repos\pleonex_tinke\Ekona\Images\RawData.cs,RawImage,The method has 10 parameters. Parameters: file' id' form' format' width' height' editable' offset' size' fileName
Long Parameter List,Ekona.Images,RawImage,C:\repos\pleonex_tinke\Ekona\Images\RawData.cs,RawImage,The method has 7 parameters. Parameters: tiles' form' format' width' height' editable' fileName
Long Parameter List,Ekona.Images,RawImage,C:\repos\pleonex_tinke\Ekona\Images\RawData.cs,Read,The method has 6 parameters. Parameters: fileIn' form' format' editable' offset' fileSize
Long Parameter List,Ekona.Images,RawMap,C:\repos\pleonex_tinke\Ekona\Images\RawData.cs,RawMap,The method has 6 parameters. Parameters: file' id' offset' size' editable' fileName
Long Parameter List,Ekona.Images,RawMap,C:\repos\pleonex_tinke\Ekona\Images\RawData.cs,RawMap,The method has 5 parameters. Parameters: map' width' height' editable' fileName
Long Parameter List,Ekona.Images.Formats,APNG,C:\repos\pleonex_tinke\Ekona\Images\Formats\APNG.cs,Write,The method has 8 parameters. Parameters: apng' signature' ihdr' actl' idat' fctl' fdat' iend
Long Parameter List,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,OAMEditor,The method has 5 parameters. Parameters: langxml' bank' sprite' image' palette
Long Parameter List,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,OAMEditor,The method has 5 parameters. Parameters: langxml' bank' sprite' image' palette
Long Identifier,Ekona.Helper,LINKINFO,C:\repos\pleonex_tinke\Ekona\Helper\LNK.cs,,The length of the parameter commonNetworkRelativeLinkAndPathSuffix is 38.
Long Identifier,Ekona.Helper,LINKINFO,C:\repos\pleonex_tinke\Ekona\Helper\LNK.cs,,The length of the parameter commonNetworkRelativeLinkOffset is 31.
Long Statement,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The length of the statement  "                    //    cells[i] = ((Bitmap)img.Get_Image(pal)).Clone(new Rectangle(posX * zoom' posY * zoom' bank.oams[i].width * zoom' bank.oams[i].height * zoom)' " is 147.
Long Statement,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The length of the statement  "                    graphic.DrawImageUnscaled(cell' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom); " is 135.
Long Statement,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The length of the statement  "                    graphic.DrawRectangle(Pens.Black' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom' " is 136.
Long Statement,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The length of the statement  "                    graphic.DrawRectangle(new Pen(Color.Red' 3)' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom' " is 147.
Long Statement,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The length of the statement  "                    graphic.DrawString(bank.oams[i].num_cell.ToString()' SystemFonts.CaptionFont' Brushes.Black' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' " is 143.
Long Statement,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,btnImport_Click,The length of the statement  "                map.Set_Map(Actions.Create_Map(ref tiles' image.BPP' image.TileSize' (byte)numPal.Value)' map.CanEdit' bitmap.Width' bitmap.Height); " is 132.
Long Statement,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,Save_Files,The length of the statement  "                    string imageFile = pluginHost.Get_TempFolder() + Path.DirectorySeparatorChar + Path.GetRandomFileName() + image.FileName; " is 121.
Long Statement,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,Save_Files,The length of the statement  "                    string paletteFile = pluginHost.Get_TempFolder() + Path.DirectorySeparatorChar + Path.GetRandomFileName() + palette.FileName; " is 125.
Long Statement,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,SetTransFromImage,The length of the statement  "            int pal_index = sprite.Banks[comboBank.SelectedIndex].oams[0].obj2.index_palette;  // How can I know that? yeah' I'm too lazy to do a new windows ;) " is 148.
Long Statement,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,Import_File,The length of the statement  "                    try { Actions.Swap_Palette(ref cellImg' palette.Palette[oams[i].obj2.index_palette]' pal' image.FormatColor' numThreshold.Value); } " is 131.
Long Statement,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,Import_File,The length of the statement  "                    uint offset = Actions.Add_Image(ref imgData' cellImg' sprite.Banks[banki].data_offset' size' (uint)(0x20 << (int)sprite.BlockSize)' out added) - sprite.Banks[banki].data_offset; " is 177.
Long Statement,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,Import_File,The length of the statement  "                            "The characters data size has exceeded the boundaries of what is permitted!\r\nSome characters will not be displayed."); " is 120.
Long Statement,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,btnOAMeditor_Click,The length of the statement  "                editor = new Dialogs.OAMEditor(pluginHost.Get_LangXML()' sprite.Banks[comboBank.SelectedIndex]' sprite' image' palette); " is 120.
Long Statement,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,btnOAMeditor_Click,The length of the statement  "                editor = new Dialogs.OAMEditor(lang.Element("OAMEditor")' sprite.Banks[comboBank.SelectedIndex]' sprite' image' palette); " is 121.
Long Statement,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(OAMEditor)); " is 129.
Long Statement,Ekona.Mathematics,Vector3,C:\repos\pleonex_tinke\Ekona\Mathematics\Vector3.cs,Equals,The length of the statement  "            return ((Math.Abs(x - vector.X) < tolerance) && (Math.Abs(y - vector.Y) < tolerance) && (Math.Abs(z - vector.Z) < tolerance)); " is 126.
Complex Conditional,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,btnSetTrans_Click,The conditional expression  "(palette.Depth == ColorFormat.colors256 && palette.NumberOfColors == 256) ||                  (palette.Depth == ColorFormat.colors16 && palette.NumberOfColors == 16)"  is complex.
Complex Conditional,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CalcSecondBoundColor,The conditional expression  "r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255"  is complex.
Complex Conditional,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The conditional expression  "(uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B)"  is complex.
Complex Conditional,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The conditional expression  "(uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B)"  is complex.
Virtual Method Call from Constructor,Ekona.Images,ImageBase,C:\repos\pleonex_tinke\Ekona\Images\ImageBase.cs,ImageBase,The constructor "ImageBase" calls a virtual method "Read".
Virtual Method Call from Constructor,Ekona.Images,ImageBase,C:\repos\pleonex_tinke\Ekona\Images\ImageBase.cs,ImageBase,The constructor "ImageBase" calls a virtual method "Read".
Virtual Method Call from Constructor,Ekona.Images,MapBase,C:\repos\pleonex_tinke\Ekona\Images\MapBase.cs,MapBase,The constructor "MapBase" calls a virtual method "Read".
Virtual Method Call from Constructor,Ekona.Images,MapBase,C:\repos\pleonex_tinke\Ekona\Images\MapBase.cs,MapBase,The constructor "MapBase" calls a virtual method "Read".
Virtual Method Call from Constructor,Ekona.Images,SpriteBase,C:\repos\pleonex_tinke\Ekona\Images\SpriteBase.cs,SpriteBase,The constructor "SpriteBase" calls a virtual method "Read".
Virtual Method Call from Constructor,Ekona.Images,SpriteBase,C:\repos\pleonex_tinke\Ekona\Images\SpriteBase.cs,SpriteBase,The constructor "SpriteBase" calls a virtual method "Read".
Virtual Method Call from Constructor,Ekona.Images,PaletteBase,C:\repos\pleonex_tinke\Ekona\Images\PaletteBase.cs,PaletteBase,The constructor "PaletteBase" calls a virtual method "Read".
Virtual Method Call from Constructor,Ekona.Images,PaletteBase,C:\repos\pleonex_tinke\Ekona\Images\PaletteBase.cs,PaletteBase,The constructor "PaletteBase" calls a virtual method "Read".
Magic Number,Ekona.Helper,BinaryReaderBE,C:\repos\pleonex_tinke\Ekona\Helper\BinaryReaderBE.cs,ReadUInt16,The following statement contains a magic number: return BitConverter.ToUInt16(ReadBytes(2).Reverse().ToArray()' 0);
Magic Number,Ekona.Helper,BitsConverter,C:\repos\pleonex_tinke\Ekona\Helper\BitsConverter.cs,ByteToBits,The following statement contains a magic number: for (int j = 7; j >= 0; j--)                  bits.Add((byte)((data >> j) & 1));
Magic Number,Ekona.Helper,BitsConverter,C:\repos\pleonex_tinke\Ekona\Helper\BitsConverter.cs,ByteToBit2,The following statement contains a magic number: Byte[] bit2 = new byte[4];
Magic Number,Ekona.Helper,BitsConverter,C:\repos\pleonex_tinke\Ekona\Helper\BitsConverter.cs,ByteToBit2,The following statement contains a magic number: bit2[1] = (byte)((data >> 2) & 0x3);
Magic Number,Ekona.Helper,BitsConverter,C:\repos\pleonex_tinke\Ekona\Helper\BitsConverter.cs,ByteToBit2,The following statement contains a magic number: bit2[2] = (byte)((data >> 4) & 0x3);
Magic Number,Ekona.Helper,BitsConverter,C:\repos\pleonex_tinke\Ekona\Helper\BitsConverter.cs,ByteToBit2,The following statement contains a magic number: bit2[2] = (byte)((data >> 4) & 0x3);
Magic Number,Ekona.Helper,BitsConverter,C:\repos\pleonex_tinke\Ekona\Helper\BitsConverter.cs,ByteToBit2,The following statement contains a magic number: bit2[3] = (byte)((data >> 6) & 0x3);
Magic Number,Ekona.Helper,BitsConverter,C:\repos\pleonex_tinke\Ekona\Helper\BitsConverter.cs,ByteToBit2,The following statement contains a magic number: bit2[3] = (byte)((data >> 6) & 0x3);
Magic Number,Ekona.Helper,BitsConverter,C:\repos\pleonex_tinke\Ekona\Helper\BitsConverter.cs,ByteToBit4,The following statement contains a magic number: Byte[] bit4 = new Byte[2];
Magic Number,Ekona.Helper,BitsConverter,C:\repos\pleonex_tinke\Ekona\Helper\BitsConverter.cs,ByteToBit4,The following statement contains a magic number: bit4[1] = (byte)((data & 0xF0) >> 4);
Magic Number,Ekona.Helper,BitsConverter,C:\repos\pleonex_tinke\Ekona\Helper\BitsConverter.cs,BytesToBit4,The following statement contains a magic number: byte[] bit4 = new byte[data.Length * 2];
Magic Number,Ekona.Helper,BitsConverter,C:\repos\pleonex_tinke\Ekona\Helper\BitsConverter.cs,BytesToBit4,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  byte[] b4 = ByteToBit4(data[i]);                  bit4[i * 2] = b4[0];                  bit4[i * 2 + 1] = b4[1];              }
Magic Number,Ekona.Helper,BitsConverter,C:\repos\pleonex_tinke\Ekona\Helper\BitsConverter.cs,BytesToBit4,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  byte[] b4 = ByteToBit4(data[i]);                  bit4[i * 2] = b4[0];                  bit4[i * 2 + 1] = b4[1];              }
Magic Number,Ekona.Helper,BitsConverter,C:\repos\pleonex_tinke\Ekona\Helper\BitsConverter.cs,BitsToBytes,The following statement contains a magic number: for (int i = 0; i < bits.Length; i += 8)              {                  Byte newByte = 0;                  int b = 0;                  for (int j = 7; j >= 0; j--' b++)                  {                      newByte += (byte)(bits[i + b] << j);                  }                  bytes.Add(newByte);              }
Magic Number,Ekona.Helper,BitsConverter,C:\repos\pleonex_tinke\Ekona\Helper\BitsConverter.cs,BitsToBytes,The following statement contains a magic number: for (int i = 0; i < bits.Length; i += 8)              {                  Byte newByte = 0;                  int b = 0;                  for (int j = 7; j >= 0; j--' b++)                  {                      newByte += (byte)(bits[i + b] << j);                  }                  bytes.Add(newByte);              }
Magic Number,Ekona.Helper,BitsConverter,C:\repos\pleonex_tinke\Ekona\Helper\BitsConverter.cs,Bit4ToByte,The following statement contains a magic number: return (byte)(data[0] + (data[1] << 4));
Magic Number,Ekona.Helper,BitsConverter,C:\repos\pleonex_tinke\Ekona\Helper\BitsConverter.cs,Bit4ToByte,The following statement contains a magic number: return (byte)(b1 + (b2 << 4));
Magic Number,Ekona.Helper,BitsConverter,C:\repos\pleonex_tinke\Ekona\Helper\BitsConverter.cs,Bits4ToByte,The following statement contains a magic number: byte[] b = new byte[data.Length / 2];
Magic Number,Ekona.Helper,BitsConverter,C:\repos\pleonex_tinke\Ekona\Helper\BitsConverter.cs,Bits4ToByte,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2)                  b[i / 2] = Bit4ToByte(data[i]' data[i + 1]);
Magic Number,Ekona.Helper,BitsConverter,C:\repos\pleonex_tinke\Ekona\Helper\BitsConverter.cs,Bits4ToByte,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 2)                  b[i / 2] = Bit4ToByte(data[i]' data[i + 1]);
Magic Number,Ekona.Helper,BitsConverter,C:\repos\pleonex_tinke\Ekona\Helper\BitsConverter.cs,StringToBytes,The following statement contains a magic number: hexText = hexText.PadRight(num_bytes * 2' '0');
Magic Number,Ekona.Helper,BitsConverter,C:\repos\pleonex_tinke\Ekona\Helper\BitsConverter.cs,StringToBytes,The following statement contains a magic number: for (int i = 0; i < hexText.Length; i += 2)                  hex.Add(Convert.ToByte(hexText.Substring(i' 2)' 16));
Magic Number,Ekona.Helper,BitsConverter,C:\repos\pleonex_tinke\Ekona\Helper\BitsConverter.cs,StringToBytes,The following statement contains a magic number: for (int i = 0; i < hexText.Length; i += 2)                  hex.Add(Convert.ToByte(hexText.Substring(i' 2)' 16));
Magic Number,Ekona.Helper,BitsConverter,C:\repos\pleonex_tinke\Ekona\Helper\BitsConverter.cs,StringToBytes,The following statement contains a magic number: for (int i = 0; i < hexText.Length; i += 2)                  hex.Add(Convert.ToByte(hexText.Substring(i' 2)' 16));
Magic Number,Ekona.Helper,CRC16,C:\repos\pleonex_tinke\Ekona\Helper\CRC.cs,Calculate,The following statement contains a magic number: for (int i = 0; i < bytes.Length; i++)              {                  crc = (crc >> 8) ^ crc16tab[(crc ^ bytes[i]) & 0xFF];              }
Magic Number,Ekona.Helper,CRC32,C:\repos\pleonex_tinke\Ekona\Helper\CRC.cs,CreateCrcTable,The following statement contains a magic number: for (n = 0; n < 256; n++)              {                  c = (uint)n;                    for (k = 0; k < 8; k++)                  {                      if ((c & 1) == 1)                      {                          c = 0xedb88320 ^ (c >> 1);                      }                      else                      {                          c = c >> 1;                      }                  }                  CrcTable[n] = c;              }
Magic Number,Ekona.Helper,CRC32,C:\repos\pleonex_tinke\Ekona\Helper\CRC.cs,CreateCrcTable,The following statement contains a magic number: for (n = 0; n < 256; n++)              {                  c = (uint)n;                    for (k = 0; k < 8; k++)                  {                      if ((c & 1) == 1)                      {                          c = 0xedb88320 ^ (c >> 1);                      }                      else                      {                          c = c >> 1;                      }                  }                  CrcTable[n] = c;              }
Magic Number,Ekona.Helper,CRC32,C:\repos\pleonex_tinke\Ekona\Helper\CRC.cs,Calculate,The following statement contains a magic number: for (n = 0; n < buffer.Length; n++)                  data = CrcTable[(data ^ buffer[n]) & 0xff] ^ (data >> 8);
Magic Number,Ekona.Helper,CRC32,C:\repos\pleonex_tinke\Ekona\Helper\CRC.cs,Calculate,The following statement contains a magic number: byte b1 = Convert.ToByte(data >> 24);
Magic Number,Ekona.Helper,CRC32,C:\repos\pleonex_tinke\Ekona\Helper\CRC.cs,Calculate,The following statement contains a magic number: byte b2 = Convert.ToByte(b1 << 8 ^ data >> 16);
Magic Number,Ekona.Helper,CRC32,C:\repos\pleonex_tinke\Ekona\Helper\CRC.cs,Calculate,The following statement contains a magic number: byte b2 = Convert.ToByte(b1 << 8 ^ data >> 16);
Magic Number,Ekona.Helper,CRC32,C:\repos\pleonex_tinke\Ekona\Helper\CRC.cs,Calculate,The following statement contains a magic number: byte b3 = Convert.ToByte(((data >> 16 << 16) ^ (data >> 8 << 8)) >> 8);
Magic Number,Ekona.Helper,CRC32,C:\repos\pleonex_tinke\Ekona\Helper\CRC.cs,Calculate,The following statement contains a magic number: byte b3 = Convert.ToByte(((data >> 16 << 16) ^ (data >> 8 << 8)) >> 8);
Magic Number,Ekona.Helper,CRC32,C:\repos\pleonex_tinke\Ekona\Helper\CRC.cs,Calculate,The following statement contains a magic number: byte b3 = Convert.ToByte(((data >> 16 << 16) ^ (data >> 8 << 8)) >> 8);
Magic Number,Ekona.Helper,CRC32,C:\repos\pleonex_tinke\Ekona\Helper\CRC.cs,Calculate,The following statement contains a magic number: byte b3 = Convert.ToByte(((data >> 16 << 16) ^ (data >> 8 << 8)) >> 8);
Magic Number,Ekona.Helper,CRC32,C:\repos\pleonex_tinke\Ekona\Helper\CRC.cs,Calculate,The following statement contains a magic number: byte b3 = Convert.ToByte(((data >> 16 << 16) ^ (data >> 8 << 8)) >> 8);
Magic Number,Ekona.Helper,CRC32,C:\repos\pleonex_tinke\Ekona\Helper\CRC.cs,Calculate,The following statement contains a magic number: byte b4 = Convert.ToByte((data >> 8 << 8) ^ data);
Magic Number,Ekona.Helper,CRC32,C:\repos\pleonex_tinke\Ekona\Helper\CRC.cs,Calculate,The following statement contains a magic number: byte b4 = Convert.ToByte((data >> 8 << 8) ^ data);
Magic Number,Ekona.Helper,LNK,C:\repos\pleonex_tinke\Ekona\Helper\LNK.cs,Read_IDList,The following statement contains a magic number: while (size != 0)              {                  ITEM_IDLIST item = new ITEM_IDLIST();                  item.itemIDSize = size;                  item.data = br.ReadBytes(size - 2);                  idlist.itemIDList.Add(item);                    size = br.ReadUInt16();              }
Magic Number,Ekona.Helper,LNK,C:\repos\pleonex_tinke\Ekona\Helper\LNK.cs,Read_Extra,The following statement contains a magic number: for (; ; )              {                  uint size = br.ReadUInt32();                  if (size < 0x04)                  {                      extra.terminal.terminal = size;                      return extra;                  }                    uint sign = br.ReadUInt32();                  switch (sign)                  {                      case 0xA0000001:                          extra.environment.blockSize = size;                          extra.environment.blockSignature = sign;                          extra.environment.targetAnsi = Get_String(br' 260' false);                          extra.environment.targetUnicode = Get_String(br' 260' true);                          break;                        case 0xA0000002:                          CONSOLE_PROPS cp = new CONSOLE_PROPS();                          cp.blockSize = size;                          cp.blockSignature = sign;                          cp.fillAttributes = (FILL_ATTRIBUTES)br.ReadUInt16();                          cp.popupFillAttributes = br.ReadUInt16();                          cp.screenBufferSizeX = br.ReadUInt16();                          cp.screenBufferSizeY = br.ReadUInt16();                          cp.windowSizeX = br.ReadUInt16();                          cp.windowSizeY = br.ReadUInt16();                          cp.windowOriginX = br.ReadUInt16();                          cp.windowOriginY = br.ReadUInt16();                          cp.unused1 = br.ReadUInt32();                          cp.unused2 = br.ReadUInt32();                          cp.fontSize = br.ReadUInt32();                          cp.fontFamily = (FONT_FAMILY)br.ReadUInt32();                          cp.fontWeight = br.ReadUInt32();                          cp.faceName = Get_String(br' 32' true);                          cp.cursorSize = br.ReadUInt32();                          cp.fullScreen = br.ReadUInt32();                          cp.quickEdit = br.ReadUInt32();                          cp.insertMode = br.ReadUInt32();                          cp.autoPosition = br.ReadUInt32();                          cp.historyBufferSize = br.ReadUInt32();                          cp.numberOfHistoryBuffer = br.ReadUInt32();                          cp.historyNoDup = br.ReadUInt32();                          cp.colorTable = new uint[0x10];                          for (int i = 0; i < 0x10; i++)                              cp.colorTable[i] = br.ReadUInt32();                          extra.console = cp;                          break;                        case 0xA0000003:                          extra.tracker.blockSize = size;                          extra.tracker.blockSignature = sign;                          extra.tracker.length = br.ReadUInt32();                          extra.tracker.version = br.ReadUInt32();                          extra.tracker.machineID = Get_String(br' 0x10' false);                          extra.tracker.droid = br.ReadBytes(0x20);                          extra.tracker.droidBirth = br.ReadBytes(0x20);                          break;                        case 0xA0000004:                          extra.consoleFe.blockSize = size;                          extra.consoleFe.blockSignature = sign;                          extra.consoleFe.codePage = br.ReadUInt32();                          break;                        case 0xA0000005:                          extra.specialFolder.blockSize = size;                          extra.specialFolder.blockSignature = sign;                          extra.specialFolder.specialFolderID = br.ReadUInt32();                          extra.specialFolder.offset = br.ReadUInt32();                          break;                        case 0xA0000006:                          extra.darwin.blockSize = size;                          extra.darwin.blockSignature = sign;                          extra.darwin.darwinDataAnsi = Get_String(br' 260' false);                          extra.darwin.darwinDataUnicode = Get_String(br' 260' true);                          break;                        case 0xA0000007:                          extra.iconEnvironment.blockSize = size;                          extra.iconEnvironment.blockSignature = sign;                          extra.iconEnvironment.targetAnsi = Get_String(br' 260' false);                          extra.iconEnvironment.targetUnicode = Get_String(br' 260' true);                          break;                        case 0xA0000008:                          extra.shim.blockSize = size;                          extra.shim.blockSignature = sign;                          extra.shim.layerName = Get_String(br' (int)extra.shim.blockSize - 8'  true);                          break;                        case 0xA0000009:                          extra.propertyStore.blockSize = size;                          extra.propertyStore.blockSignature = sign;                          extra.propertyStore.propertyStore = null;                          break;                        case 0xA000000B:                          extra.knownFolder.blockSize = size;                          extra.knownFolder.blockSignature = sign;                          extra.knownFolder.knownFolderID = br.ReadBytes(0x10);                          extra.knownFolder.offset = br.ReadUInt32();                          break;                        case 0xA000000C:                          extra.vistaIDList.blockSize = size;                          extra.vistaIDList.blockSignature = sign;                          extra.vistaIDList.idlist = Read_IDList(br);                          break;                  }              }
Magic Number,Ekona.Helper,LNK,C:\repos\pleonex_tinke\Ekona\Helper\LNK.cs,Read_Extra,The following statement contains a magic number: for (; ; )              {                  uint size = br.ReadUInt32();                  if (size < 0x04)                  {                      extra.terminal.terminal = size;                      return extra;                  }                    uint sign = br.ReadUInt32();                  switch (sign)                  {                      case 0xA0000001:                          extra.environment.blockSize = size;                          extra.environment.blockSignature = sign;                          extra.environment.targetAnsi = Get_String(br' 260' false);                          extra.environment.targetUnicode = Get_String(br' 260' true);                          break;                        case 0xA0000002:                          CONSOLE_PROPS cp = new CONSOLE_PROPS();                          cp.blockSize = size;                          cp.blockSignature = sign;                          cp.fillAttributes = (FILL_ATTRIBUTES)br.ReadUInt16();                          cp.popupFillAttributes = br.ReadUInt16();                          cp.screenBufferSizeX = br.ReadUInt16();                          cp.screenBufferSizeY = br.ReadUInt16();                          cp.windowSizeX = br.ReadUInt16();                          cp.windowSizeY = br.ReadUInt16();                          cp.windowOriginX = br.ReadUInt16();                          cp.windowOriginY = br.ReadUInt16();                          cp.unused1 = br.ReadUInt32();                          cp.unused2 = br.ReadUInt32();                          cp.fontSize = br.ReadUInt32();                          cp.fontFamily = (FONT_FAMILY)br.ReadUInt32();                          cp.fontWeight = br.ReadUInt32();                          cp.faceName = Get_String(br' 32' true);                          cp.cursorSize = br.ReadUInt32();                          cp.fullScreen = br.ReadUInt32();                          cp.quickEdit = br.ReadUInt32();                          cp.insertMode = br.ReadUInt32();                          cp.autoPosition = br.ReadUInt32();                          cp.historyBufferSize = br.ReadUInt32();                          cp.numberOfHistoryBuffer = br.ReadUInt32();                          cp.historyNoDup = br.ReadUInt32();                          cp.colorTable = new uint[0x10];                          for (int i = 0; i < 0x10; i++)                              cp.colorTable[i] = br.ReadUInt32();                          extra.console = cp;                          break;                        case 0xA0000003:                          extra.tracker.blockSize = size;                          extra.tracker.blockSignature = sign;                          extra.tracker.length = br.ReadUInt32();                          extra.tracker.version = br.ReadUInt32();                          extra.tracker.machineID = Get_String(br' 0x10' false);                          extra.tracker.droid = br.ReadBytes(0x20);                          extra.tracker.droidBirth = br.ReadBytes(0x20);                          break;                        case 0xA0000004:                          extra.consoleFe.blockSize = size;                          extra.consoleFe.blockSignature = sign;                          extra.consoleFe.codePage = br.ReadUInt32();                          break;                        case 0xA0000005:                          extra.specialFolder.blockSize = size;                          extra.specialFolder.blockSignature = sign;                          extra.specialFolder.specialFolderID = br.ReadUInt32();                          extra.specialFolder.offset = br.ReadUInt32();                          break;                        case 0xA0000006:                          extra.darwin.blockSize = size;                          extra.darwin.blockSignature = sign;                          extra.darwin.darwinDataAnsi = Get_String(br' 260' false);                          extra.darwin.darwinDataUnicode = Get_String(br' 260' true);                          break;                        case 0xA0000007:                          extra.iconEnvironment.blockSize = size;                          extra.iconEnvironment.blockSignature = sign;                          extra.iconEnvironment.targetAnsi = Get_String(br' 260' false);                          extra.iconEnvironment.targetUnicode = Get_String(br' 260' true);                          break;                        case 0xA0000008:                          extra.shim.blockSize = size;                          extra.shim.blockSignature = sign;                          extra.shim.layerName = Get_String(br' (int)extra.shim.blockSize - 8'  true);                          break;                        case 0xA0000009:                          extra.propertyStore.blockSize = size;                          extra.propertyStore.blockSignature = sign;                          extra.propertyStore.propertyStore = null;                          break;                        case 0xA000000B:                          extra.knownFolder.blockSize = size;                          extra.knownFolder.blockSignature = sign;                          extra.knownFolder.knownFolderID = br.ReadBytes(0x10);                          extra.knownFolder.offset = br.ReadUInt32();                          break;                        case 0xA000000C:                          extra.vistaIDList.blockSize = size;                          extra.vistaIDList.blockSignature = sign;                          extra.vistaIDList.idlist = Read_IDList(br);                          break;                  }              }
Magic Number,Ekona.Helper,LNK,C:\repos\pleonex_tinke\Ekona\Helper\LNK.cs,Read_Extra,The following statement contains a magic number: for (; ; )              {                  uint size = br.ReadUInt32();                  if (size < 0x04)                  {                      extra.terminal.terminal = size;                      return extra;                  }                    uint sign = br.ReadUInt32();                  switch (sign)                  {                      case 0xA0000001:                          extra.environment.blockSize = size;                          extra.environment.blockSignature = sign;                          extra.environment.targetAnsi = Get_String(br' 260' false);                          extra.environment.targetUnicode = Get_String(br' 260' true);                          break;                        case 0xA0000002:                          CONSOLE_PROPS cp = new CONSOLE_PROPS();                          cp.blockSize = size;                          cp.blockSignature = sign;                          cp.fillAttributes = (FILL_ATTRIBUTES)br.ReadUInt16();                          cp.popupFillAttributes = br.ReadUInt16();                          cp.screenBufferSizeX = br.ReadUInt16();                          cp.screenBufferSizeY = br.ReadUInt16();                          cp.windowSizeX = br.ReadUInt16();                          cp.windowSizeY = br.ReadUInt16();                          cp.windowOriginX = br.ReadUInt16();                          cp.windowOriginY = br.ReadUInt16();                          cp.unused1 = br.ReadUInt32();                          cp.unused2 = br.ReadUInt32();                          cp.fontSize = br.ReadUInt32();                          cp.fontFamily = (FONT_FAMILY)br.ReadUInt32();                          cp.fontWeight = br.ReadUInt32();                          cp.faceName = Get_String(br' 32' true);                          cp.cursorSize = br.ReadUInt32();                          cp.fullScreen = br.ReadUInt32();                          cp.quickEdit = br.ReadUInt32();                          cp.insertMode = br.ReadUInt32();                          cp.autoPosition = br.ReadUInt32();                          cp.historyBufferSize = br.ReadUInt32();                          cp.numberOfHistoryBuffer = br.ReadUInt32();                          cp.historyNoDup = br.ReadUInt32();                          cp.colorTable = new uint[0x10];                          for (int i = 0; i < 0x10; i++)                              cp.colorTable[i] = br.ReadUInt32();                          extra.console = cp;                          break;                        case 0xA0000003:                          extra.tracker.blockSize = size;                          extra.tracker.blockSignature = sign;                          extra.tracker.length = br.ReadUInt32();                          extra.tracker.version = br.ReadUInt32();                          extra.tracker.machineID = Get_String(br' 0x10' false);                          extra.tracker.droid = br.ReadBytes(0x20);                          extra.tracker.droidBirth = br.ReadBytes(0x20);                          break;                        case 0xA0000004:                          extra.consoleFe.blockSize = size;                          extra.consoleFe.blockSignature = sign;                          extra.consoleFe.codePage = br.ReadUInt32();                          break;                        case 0xA0000005:                          extra.specialFolder.blockSize = size;                          extra.specialFolder.blockSignature = sign;                          extra.specialFolder.specialFolderID = br.ReadUInt32();                          extra.specialFolder.offset = br.ReadUInt32();                          break;                        case 0xA0000006:                          extra.darwin.blockSize = size;                          extra.darwin.blockSignature = sign;                          extra.darwin.darwinDataAnsi = Get_String(br' 260' false);                          extra.darwin.darwinDataUnicode = Get_String(br' 260' true);                          break;                        case 0xA0000007:                          extra.iconEnvironment.blockSize = size;                          extra.iconEnvironment.blockSignature = sign;                          extra.iconEnvironment.targetAnsi = Get_String(br' 260' false);                          extra.iconEnvironment.targetUnicode = Get_String(br' 260' true);                          break;                        case 0xA0000008:                          extra.shim.blockSize = size;                          extra.shim.blockSignature = sign;                          extra.shim.layerName = Get_String(br' (int)extra.shim.blockSize - 8'  true);                          break;                        case 0xA0000009:                          extra.propertyStore.blockSize = size;                          extra.propertyStore.blockSignature = sign;                          extra.propertyStore.propertyStore = null;                          break;                        case 0xA000000B:                          extra.knownFolder.blockSize = size;                          extra.knownFolder.blockSignature = sign;                          extra.knownFolder.knownFolderID = br.ReadBytes(0x10);                          extra.knownFolder.offset = br.ReadUInt32();                          break;                        case 0xA000000C:                          extra.vistaIDList.blockSize = size;                          extra.vistaIDList.blockSignature = sign;                          extra.vistaIDList.idlist = Read_IDList(br);                          break;                  }              }
Magic Number,Ekona.Helper,LNK,C:\repos\pleonex_tinke\Ekona\Helper\LNK.cs,Read_Extra,The following statement contains a magic number: for (; ; )              {                  uint size = br.ReadUInt32();                  if (size < 0x04)                  {                      extra.terminal.terminal = size;                      return extra;                  }                    uint sign = br.ReadUInt32();                  switch (sign)                  {                      case 0xA0000001:                          extra.environment.blockSize = size;                          extra.environment.blockSignature = sign;                          extra.environment.targetAnsi = Get_String(br' 260' false);                          extra.environment.targetUnicode = Get_String(br' 260' true);                          break;                        case 0xA0000002:                          CONSOLE_PROPS cp = new CONSOLE_PROPS();                          cp.blockSize = size;                          cp.blockSignature = sign;                          cp.fillAttributes = (FILL_ATTRIBUTES)br.ReadUInt16();                          cp.popupFillAttributes = br.ReadUInt16();                          cp.screenBufferSizeX = br.ReadUInt16();                          cp.screenBufferSizeY = br.ReadUInt16();                          cp.windowSizeX = br.ReadUInt16();                          cp.windowSizeY = br.ReadUInt16();                          cp.windowOriginX = br.ReadUInt16();                          cp.windowOriginY = br.ReadUInt16();                          cp.unused1 = br.ReadUInt32();                          cp.unused2 = br.ReadUInt32();                          cp.fontSize = br.ReadUInt32();                          cp.fontFamily = (FONT_FAMILY)br.ReadUInt32();                          cp.fontWeight = br.ReadUInt32();                          cp.faceName = Get_String(br' 32' true);                          cp.cursorSize = br.ReadUInt32();                          cp.fullScreen = br.ReadUInt32();                          cp.quickEdit = br.ReadUInt32();                          cp.insertMode = br.ReadUInt32();                          cp.autoPosition = br.ReadUInt32();                          cp.historyBufferSize = br.ReadUInt32();                          cp.numberOfHistoryBuffer = br.ReadUInt32();                          cp.historyNoDup = br.ReadUInt32();                          cp.colorTable = new uint[0x10];                          for (int i = 0; i < 0x10; i++)                              cp.colorTable[i] = br.ReadUInt32();                          extra.console = cp;                          break;                        case 0xA0000003:                          extra.tracker.blockSize = size;                          extra.tracker.blockSignature = sign;                          extra.tracker.length = br.ReadUInt32();                          extra.tracker.version = br.ReadUInt32();                          extra.tracker.machineID = Get_String(br' 0x10' false);                          extra.tracker.droid = br.ReadBytes(0x20);                          extra.tracker.droidBirth = br.ReadBytes(0x20);                          break;                        case 0xA0000004:                          extra.consoleFe.blockSize = size;                          extra.consoleFe.blockSignature = sign;                          extra.consoleFe.codePage = br.ReadUInt32();                          break;                        case 0xA0000005:                          extra.specialFolder.blockSize = size;                          extra.specialFolder.blockSignature = sign;                          extra.specialFolder.specialFolderID = br.ReadUInt32();                          extra.specialFolder.offset = br.ReadUInt32();                          break;                        case 0xA0000006:                          extra.darwin.blockSize = size;                          extra.darwin.blockSignature = sign;                          extra.darwin.darwinDataAnsi = Get_String(br' 260' false);                          extra.darwin.darwinDataUnicode = Get_String(br' 260' true);                          break;                        case 0xA0000007:                          extra.iconEnvironment.blockSize = size;                          extra.iconEnvironment.blockSignature = sign;                          extra.iconEnvironment.targetAnsi = Get_String(br' 260' false);                          extra.iconEnvironment.targetUnicode = Get_String(br' 260' true);                          break;                        case 0xA0000008:                          extra.shim.blockSize = size;                          extra.shim.blockSignature = sign;                          extra.shim.layerName = Get_String(br' (int)extra.shim.blockSize - 8'  true);                          break;                        case 0xA0000009:                          extra.propertyStore.blockSize = size;                          extra.propertyStore.blockSignature = sign;                          extra.propertyStore.propertyStore = null;                          break;                        case 0xA000000B:                          extra.knownFolder.blockSize = size;                          extra.knownFolder.blockSignature = sign;                          extra.knownFolder.knownFolderID = br.ReadBytes(0x10);                          extra.knownFolder.offset = br.ReadUInt32();                          break;                        case 0xA000000C:                          extra.vistaIDList.blockSize = size;                          extra.vistaIDList.blockSignature = sign;                          extra.vistaIDList.idlist = Read_IDList(br);                          break;                  }              }
Magic Number,Ekona.Helper,LNK,C:\repos\pleonex_tinke\Ekona\Helper\LNK.cs,Read_Extra,The following statement contains a magic number: for (; ; )              {                  uint size = br.ReadUInt32();                  if (size < 0x04)                  {                      extra.terminal.terminal = size;                      return extra;                  }                    uint sign = br.ReadUInt32();                  switch (sign)                  {                      case 0xA0000001:                          extra.environment.blockSize = size;                          extra.environment.blockSignature = sign;                          extra.environment.targetAnsi = Get_String(br' 260' false);                          extra.environment.targetUnicode = Get_String(br' 260' true);                          break;                        case 0xA0000002:                          CONSOLE_PROPS cp = new CONSOLE_PROPS();                          cp.blockSize = size;                          cp.blockSignature = sign;                          cp.fillAttributes = (FILL_ATTRIBUTES)br.ReadUInt16();                          cp.popupFillAttributes = br.ReadUInt16();                          cp.screenBufferSizeX = br.ReadUInt16();                          cp.screenBufferSizeY = br.ReadUInt16();                          cp.windowSizeX = br.ReadUInt16();                          cp.windowSizeY = br.ReadUInt16();                          cp.windowOriginX = br.ReadUInt16();                          cp.windowOriginY = br.ReadUInt16();                          cp.unused1 = br.ReadUInt32();                          cp.unused2 = br.ReadUInt32();                          cp.fontSize = br.ReadUInt32();                          cp.fontFamily = (FONT_FAMILY)br.ReadUInt32();                          cp.fontWeight = br.ReadUInt32();                          cp.faceName = Get_String(br' 32' true);                          cp.cursorSize = br.ReadUInt32();                          cp.fullScreen = br.ReadUInt32();                          cp.quickEdit = br.ReadUInt32();                          cp.insertMode = br.ReadUInt32();                          cp.autoPosition = br.ReadUInt32();                          cp.historyBufferSize = br.ReadUInt32();                          cp.numberOfHistoryBuffer = br.ReadUInt32();                          cp.historyNoDup = br.ReadUInt32();                          cp.colorTable = new uint[0x10];                          for (int i = 0; i < 0x10; i++)                              cp.colorTable[i] = br.ReadUInt32();                          extra.console = cp;                          break;                        case 0xA0000003:                          extra.tracker.blockSize = size;                          extra.tracker.blockSignature = sign;                          extra.tracker.length = br.ReadUInt32();                          extra.tracker.version = br.ReadUInt32();                          extra.tracker.machineID = Get_String(br' 0x10' false);                          extra.tracker.droid = br.ReadBytes(0x20);                          extra.tracker.droidBirth = br.ReadBytes(0x20);                          break;                        case 0xA0000004:                          extra.consoleFe.blockSize = size;                          extra.consoleFe.blockSignature = sign;                          extra.consoleFe.codePage = br.ReadUInt32();                          break;                        case 0xA0000005:                          extra.specialFolder.blockSize = size;                          extra.specialFolder.blockSignature = sign;                          extra.specialFolder.specialFolderID = br.ReadUInt32();                          extra.specialFolder.offset = br.ReadUInt32();                          break;                        case 0xA0000006:                          extra.darwin.blockSize = size;                          extra.darwin.blockSignature = sign;                          extra.darwin.darwinDataAnsi = Get_String(br' 260' false);                          extra.darwin.darwinDataUnicode = Get_String(br' 260' true);                          break;                        case 0xA0000007:                          extra.iconEnvironment.blockSize = size;                          extra.iconEnvironment.blockSignature = sign;                          extra.iconEnvironment.targetAnsi = Get_String(br' 260' false);                          extra.iconEnvironment.targetUnicode = Get_String(br' 260' true);                          break;                        case 0xA0000008:                          extra.shim.blockSize = size;                          extra.shim.blockSignature = sign;                          extra.shim.layerName = Get_String(br' (int)extra.shim.blockSize - 8'  true);                          break;                        case 0xA0000009:                          extra.propertyStore.blockSize = size;                          extra.propertyStore.blockSignature = sign;                          extra.propertyStore.propertyStore = null;                          break;                        case 0xA000000B:                          extra.knownFolder.blockSize = size;                          extra.knownFolder.blockSignature = sign;                          extra.knownFolder.knownFolderID = br.ReadBytes(0x10);                          extra.knownFolder.offset = br.ReadUInt32();                          break;                        case 0xA000000C:                          extra.vistaIDList.blockSize = size;                          extra.vistaIDList.blockSignature = sign;                          extra.vistaIDList.idlist = Read_IDList(br);                          break;                  }              }
Magic Number,Ekona.Helper,LNK,C:\repos\pleonex_tinke\Ekona\Helper\LNK.cs,Read_Extra,The following statement contains a magic number: for (; ; )              {                  uint size = br.ReadUInt32();                  if (size < 0x04)                  {                      extra.terminal.terminal = size;                      return extra;                  }                    uint sign = br.ReadUInt32();                  switch (sign)                  {                      case 0xA0000001:                          extra.environment.blockSize = size;                          extra.environment.blockSignature = sign;                          extra.environment.targetAnsi = Get_String(br' 260' false);                          extra.environment.targetUnicode = Get_String(br' 260' true);                          break;                        case 0xA0000002:                          CONSOLE_PROPS cp = new CONSOLE_PROPS();                          cp.blockSize = size;                          cp.blockSignature = sign;                          cp.fillAttributes = (FILL_ATTRIBUTES)br.ReadUInt16();                          cp.popupFillAttributes = br.ReadUInt16();                          cp.screenBufferSizeX = br.ReadUInt16();                          cp.screenBufferSizeY = br.ReadUInt16();                          cp.windowSizeX = br.ReadUInt16();                          cp.windowSizeY = br.ReadUInt16();                          cp.windowOriginX = br.ReadUInt16();                          cp.windowOriginY = br.ReadUInt16();                          cp.unused1 = br.ReadUInt32();                          cp.unused2 = br.ReadUInt32();                          cp.fontSize = br.ReadUInt32();                          cp.fontFamily = (FONT_FAMILY)br.ReadUInt32();                          cp.fontWeight = br.ReadUInt32();                          cp.faceName = Get_String(br' 32' true);                          cp.cursorSize = br.ReadUInt32();                          cp.fullScreen = br.ReadUInt32();                          cp.quickEdit = br.ReadUInt32();                          cp.insertMode = br.ReadUInt32();                          cp.autoPosition = br.ReadUInt32();                          cp.historyBufferSize = br.ReadUInt32();                          cp.numberOfHistoryBuffer = br.ReadUInt32();                          cp.historyNoDup = br.ReadUInt32();                          cp.colorTable = new uint[0x10];                          for (int i = 0; i < 0x10; i++)                              cp.colorTable[i] = br.ReadUInt32();                          extra.console = cp;                          break;                        case 0xA0000003:                          extra.tracker.blockSize = size;                          extra.tracker.blockSignature = sign;                          extra.tracker.length = br.ReadUInt32();                          extra.tracker.version = br.ReadUInt32();                          extra.tracker.machineID = Get_String(br' 0x10' false);                          extra.tracker.droid = br.ReadBytes(0x20);                          extra.tracker.droidBirth = br.ReadBytes(0x20);                          break;                        case 0xA0000004:                          extra.consoleFe.blockSize = size;                          extra.consoleFe.blockSignature = sign;                          extra.consoleFe.codePage = br.ReadUInt32();                          break;                        case 0xA0000005:                          extra.specialFolder.blockSize = size;                          extra.specialFolder.blockSignature = sign;                          extra.specialFolder.specialFolderID = br.ReadUInt32();                          extra.specialFolder.offset = br.ReadUInt32();                          break;                        case 0xA0000006:                          extra.darwin.blockSize = size;                          extra.darwin.blockSignature = sign;                          extra.darwin.darwinDataAnsi = Get_String(br' 260' false);                          extra.darwin.darwinDataUnicode = Get_String(br' 260' true);                          break;                        case 0xA0000007:                          extra.iconEnvironment.blockSize = size;                          extra.iconEnvironment.blockSignature = sign;                          extra.iconEnvironment.targetAnsi = Get_String(br' 260' false);                          extra.iconEnvironment.targetUnicode = Get_String(br' 260' true);                          break;                        case 0xA0000008:                          extra.shim.blockSize = size;                          extra.shim.blockSignature = sign;                          extra.shim.layerName = Get_String(br' (int)extra.shim.blockSize - 8'  true);                          break;                        case 0xA0000009:                          extra.propertyStore.blockSize = size;                          extra.propertyStore.blockSignature = sign;                          extra.propertyStore.propertyStore = null;                          break;                        case 0xA000000B:                          extra.knownFolder.blockSize = size;                          extra.knownFolder.blockSignature = sign;                          extra.knownFolder.knownFolderID = br.ReadBytes(0x10);                          extra.knownFolder.offset = br.ReadUInt32();                          break;                        case 0xA000000C:                          extra.vistaIDList.blockSize = size;                          extra.vistaIDList.blockSignature = sign;                          extra.vistaIDList.idlist = Read_IDList(br);                          break;                  }              }
Magic Number,Ekona.Helper,LNK,C:\repos\pleonex_tinke\Ekona\Helper\LNK.cs,Read_Extra,The following statement contains a magic number: for (; ; )              {                  uint size = br.ReadUInt32();                  if (size < 0x04)                  {                      extra.terminal.terminal = size;                      return extra;                  }                    uint sign = br.ReadUInt32();                  switch (sign)                  {                      case 0xA0000001:                          extra.environment.blockSize = size;                          extra.environment.blockSignature = sign;                          extra.environment.targetAnsi = Get_String(br' 260' false);                          extra.environment.targetUnicode = Get_String(br' 260' true);                          break;                        case 0xA0000002:                          CONSOLE_PROPS cp = new CONSOLE_PROPS();                          cp.blockSize = size;                          cp.blockSignature = sign;                          cp.fillAttributes = (FILL_ATTRIBUTES)br.ReadUInt16();                          cp.popupFillAttributes = br.ReadUInt16();                          cp.screenBufferSizeX = br.ReadUInt16();                          cp.screenBufferSizeY = br.ReadUInt16();                          cp.windowSizeX = br.ReadUInt16();                          cp.windowSizeY = br.ReadUInt16();                          cp.windowOriginX = br.ReadUInt16();                          cp.windowOriginY = br.ReadUInt16();                          cp.unused1 = br.ReadUInt32();                          cp.unused2 = br.ReadUInt32();                          cp.fontSize = br.ReadUInt32();                          cp.fontFamily = (FONT_FAMILY)br.ReadUInt32();                          cp.fontWeight = br.ReadUInt32();                          cp.faceName = Get_String(br' 32' true);                          cp.cursorSize = br.ReadUInt32();                          cp.fullScreen = br.ReadUInt32();                          cp.quickEdit = br.ReadUInt32();                          cp.insertMode = br.ReadUInt32();                          cp.autoPosition = br.ReadUInt32();                          cp.historyBufferSize = br.ReadUInt32();                          cp.numberOfHistoryBuffer = br.ReadUInt32();                          cp.historyNoDup = br.ReadUInt32();                          cp.colorTable = new uint[0x10];                          for (int i = 0; i < 0x10; i++)                              cp.colorTable[i] = br.ReadUInt32();                          extra.console = cp;                          break;                        case 0xA0000003:                          extra.tracker.blockSize = size;                          extra.tracker.blockSignature = sign;                          extra.tracker.length = br.ReadUInt32();                          extra.tracker.version = br.ReadUInt32();                          extra.tracker.machineID = Get_String(br' 0x10' false);                          extra.tracker.droid = br.ReadBytes(0x20);                          extra.tracker.droidBirth = br.ReadBytes(0x20);                          break;                        case 0xA0000004:                          extra.consoleFe.blockSize = size;                          extra.consoleFe.blockSignature = sign;                          extra.consoleFe.codePage = br.ReadUInt32();                          break;                        case 0xA0000005:                          extra.specialFolder.blockSize = size;                          extra.specialFolder.blockSignature = sign;                          extra.specialFolder.specialFolderID = br.ReadUInt32();                          extra.specialFolder.offset = br.ReadUInt32();                          break;                        case 0xA0000006:                          extra.darwin.blockSize = size;                          extra.darwin.blockSignature = sign;                          extra.darwin.darwinDataAnsi = Get_String(br' 260' false);                          extra.darwin.darwinDataUnicode = Get_String(br' 260' true);                          break;                        case 0xA0000007:                          extra.iconEnvironment.blockSize = size;                          extra.iconEnvironment.blockSignature = sign;                          extra.iconEnvironment.targetAnsi = Get_String(br' 260' false);                          extra.iconEnvironment.targetUnicode = Get_String(br' 260' true);                          break;                        case 0xA0000008:                          extra.shim.blockSize = size;                          extra.shim.blockSignature = sign;                          extra.shim.layerName = Get_String(br' (int)extra.shim.blockSize - 8'  true);                          break;                        case 0xA0000009:                          extra.propertyStore.blockSize = size;                          extra.propertyStore.blockSignature = sign;                          extra.propertyStore.propertyStore = null;                          break;                        case 0xA000000B:                          extra.knownFolder.blockSize = size;                          extra.knownFolder.blockSignature = sign;                          extra.knownFolder.knownFolderID = br.ReadBytes(0x10);                          extra.knownFolder.offset = br.ReadUInt32();                          break;                        case 0xA000000C:                          extra.vistaIDList.blockSize = size;                          extra.vistaIDList.blockSignature = sign;                          extra.vistaIDList.idlist = Read_IDList(br);                          break;                  }              }
Magic Number,Ekona.Helper,LNK,C:\repos\pleonex_tinke\Ekona\Helper\LNK.cs,Read_Extra,The following statement contains a magic number: for (; ; )              {                  uint size = br.ReadUInt32();                  if (size < 0x04)                  {                      extra.terminal.terminal = size;                      return extra;                  }                    uint sign = br.ReadUInt32();                  switch (sign)                  {                      case 0xA0000001:                          extra.environment.blockSize = size;                          extra.environment.blockSignature = sign;                          extra.environment.targetAnsi = Get_String(br' 260' false);                          extra.environment.targetUnicode = Get_String(br' 260' true);                          break;                        case 0xA0000002:                          CONSOLE_PROPS cp = new CONSOLE_PROPS();                          cp.blockSize = size;                          cp.blockSignature = sign;                          cp.fillAttributes = (FILL_ATTRIBUTES)br.ReadUInt16();                          cp.popupFillAttributes = br.ReadUInt16();                          cp.screenBufferSizeX = br.ReadUInt16();                          cp.screenBufferSizeY = br.ReadUInt16();                          cp.windowSizeX = br.ReadUInt16();                          cp.windowSizeY = br.ReadUInt16();                          cp.windowOriginX = br.ReadUInt16();                          cp.windowOriginY = br.ReadUInt16();                          cp.unused1 = br.ReadUInt32();                          cp.unused2 = br.ReadUInt32();                          cp.fontSize = br.ReadUInt32();                          cp.fontFamily = (FONT_FAMILY)br.ReadUInt32();                          cp.fontWeight = br.ReadUInt32();                          cp.faceName = Get_String(br' 32' true);                          cp.cursorSize = br.ReadUInt32();                          cp.fullScreen = br.ReadUInt32();                          cp.quickEdit = br.ReadUInt32();                          cp.insertMode = br.ReadUInt32();                          cp.autoPosition = br.ReadUInt32();                          cp.historyBufferSize = br.ReadUInt32();                          cp.numberOfHistoryBuffer = br.ReadUInt32();                          cp.historyNoDup = br.ReadUInt32();                          cp.colorTable = new uint[0x10];                          for (int i = 0; i < 0x10; i++)                              cp.colorTable[i] = br.ReadUInt32();                          extra.console = cp;                          break;                        case 0xA0000003:                          extra.tracker.blockSize = size;                          extra.tracker.blockSignature = sign;                          extra.tracker.length = br.ReadUInt32();                          extra.tracker.version = br.ReadUInt32();                          extra.tracker.machineID = Get_String(br' 0x10' false);                          extra.tracker.droid = br.ReadBytes(0x20);                          extra.tracker.droidBirth = br.ReadBytes(0x20);                          break;                        case 0xA0000004:                          extra.consoleFe.blockSize = size;                          extra.consoleFe.blockSignature = sign;                          extra.consoleFe.codePage = br.ReadUInt32();                          break;                        case 0xA0000005:                          extra.specialFolder.blockSize = size;                          extra.specialFolder.blockSignature = sign;                          extra.specialFolder.specialFolderID = br.ReadUInt32();                          extra.specialFolder.offset = br.ReadUInt32();                          break;                        case 0xA0000006:                          extra.darwin.blockSize = size;                          extra.darwin.blockSignature = sign;                          extra.darwin.darwinDataAnsi = Get_String(br' 260' false);                          extra.darwin.darwinDataUnicode = Get_String(br' 260' true);                          break;                        case 0xA0000007:                          extra.iconEnvironment.blockSize = size;                          extra.iconEnvironment.blockSignature = sign;                          extra.iconEnvironment.targetAnsi = Get_String(br' 260' false);                          extra.iconEnvironment.targetUnicode = Get_String(br' 260' true);                          break;                        case 0xA0000008:                          extra.shim.blockSize = size;                          extra.shim.blockSignature = sign;                          extra.shim.layerName = Get_String(br' (int)extra.shim.blockSize - 8'  true);                          break;                        case 0xA0000009:                          extra.propertyStore.blockSize = size;                          extra.propertyStore.blockSignature = sign;                          extra.propertyStore.propertyStore = null;                          break;                        case 0xA000000B:                          extra.knownFolder.blockSize = size;                          extra.knownFolder.blockSignature = sign;                          extra.knownFolder.knownFolderID = br.ReadBytes(0x10);                          extra.knownFolder.offset = br.ReadUInt32();                          break;                        case 0xA000000C:                          extra.vistaIDList.blockSize = size;                          extra.vistaIDList.blockSignature = sign;                          extra.vistaIDList.idlist = Read_IDList(br);                          break;                  }              }
Magic Number,Ekona.Helper,LNK,C:\repos\pleonex_tinke\Ekona\Helper\LNK.cs,Get_String,The following statement contains a magic number: for ( ; ; )              {                  if (unicode)                      c = Encoding.Unicode.GetChars(br.ReadBytes(2))[0];                  else                      c = br.ReadChar();                    if (c == '\0')                      break;                    t += c;              }
Magic Number,Ekona.Helper,LNK,C:\repos\pleonex_tinke\Ekona\Helper\LNK.cs,Get_String,The following statement contains a magic number: if (!unicode)                  return new string(Encoding.Default.GetChars(br.ReadBytes(size)));              else                  return new string(Encoding.Unicode.GetChars(br.ReadBytes(size * 2)));
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,BGR555ToColor,The following statement contains a magic number: Color[] colors = new Color[bytes.Length / 2];
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,BGR555ToColor,The following statement contains a magic number: for (int i = 0; i < bytes.Length / 2; i++)                  colors[i] = BGR555ToColor(bytes[i * 2]' bytes[i * 2 + 1]);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,BGR555ToColor,The following statement contains a magic number: for (int i = 0; i < bytes.Length / 2; i++)                  colors[i] = BGR555ToColor(bytes[i * 2]' bytes[i * 2 + 1]);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,BGR555ToColor,The following statement contains a magic number: for (int i = 0; i < bytes.Length / 2; i++)                  colors[i] = BGR555ToColor(bytes[i * 2]' bytes[i * 2 + 1]);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,BGR555ToColor,The following statement contains a magic number: g = ((bgr & 0x03E0) >> 5) * 0x08;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,BGR555ToColor,The following statement contains a magic number: b = ((bgr & 0x7C00) >> 10) * 0x08;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,ColorToBGR555,The following statement contains a magic number: byte[] data = new byte[colors.Length * 2];
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,ColorToBGR555,The following statement contains a magic number: for (int i = 0; i < colors.Length; i++)              {                  byte[] bgr = ColorToBGR555(colors[i]);                  data[i * 2] = bgr[0];                  data[i * 2 + 1] = bgr[1];              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,ColorToBGR555,The following statement contains a magic number: for (int i = 0; i < colors.Length; i++)              {                  byte[] bgr = ColorToBGR555(colors[i]);                  data[i * 2] = bgr[0];                  data[i * 2 + 1] = bgr[1];              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,ColorToBGRA555,The following statement contains a magic number: byte[] d = new byte[2];
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,ColorToBGRA555,The following statement contains a magic number: int r = color.R / 8;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,ColorToBGRA555,The following statement contains a magic number: int g = (color.G / 8) << 5;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,ColorToBGRA555,The following statement contains a magic number: int g = (color.G / 8) << 5;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,ColorToBGRA555,The following statement contains a magic number: int b = (color.B / 8) << 10;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,ColorToBGRA555,The following statement contains a magic number: int b = (color.B / 8) << 10;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,ColorToBGRA555,The following statement contains a magic number: int a = (color.A / 255) << 15;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,ColorToBGRA555,The following statement contains a magic number: int a = (color.A / 255) << 15;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,ColorToBGRA555,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(bgra)' d' 2);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,ColorToBGR555,The following statement contains a magic number: byte[] d = new byte[2];
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,ColorToBGR555,The following statement contains a magic number: int r = color.R / 8;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,ColorToBGR555,The following statement contains a magic number: int g = (color.G / 8) << 5;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,ColorToBGR555,The following statement contains a magic number: int g = (color.G / 8) << 5;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,ColorToBGR555,The following statement contains a magic number: int b = (color.B / 8) << 10;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,ColorToBGR555,The following statement contains a magic number: int b = (color.B / 8) << 10;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,ColorToBGR555,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(bgr)' d' 2);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: Bitmap palette = new Bitmap(160' height * 10);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: Bitmap palette = new Bitmap(160' height * 10);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: for (int i = 0; i < 16 & !end; i++)              {                  for (int j = 0; j < 16; j++)                  {                      if (colors.Length <= j + 16 * i)                      {                          end = true;                          break;                      }                        for (int k = 0; k < 10; k++)                          for (int q = 0; q < 10; q++)                              palette.SetPixel((j * 10 + q)' (i * 10 + k)' colors[j + 16 * i]);                  }              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: for (int i = 0; i < 16 & !end; i++)              {                  for (int j = 0; j < 16; j++)                  {                      if (colors.Length <= j + 16 * i)                      {                          end = true;                          break;                      }                        for (int k = 0; k < 10; k++)                          for (int q = 0; q < 10; q++)                              palette.SetPixel((j * 10 + q)' (i * 10 + k)' colors[j + 16 * i]);                  }              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: for (int i = 0; i < 16 & !end; i++)              {                  for (int j = 0; j < 16; j++)                  {                      if (colors.Length <= j + 16 * i)                      {                          end = true;                          break;                      }                        for (int k = 0; k < 10; k++)                          for (int q = 0; q < 10; q++)                              palette.SetPixel((j * 10 + q)' (i * 10 + k)' colors[j + 16 * i]);                  }              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: for (int i = 0; i < 16 & !end; i++)              {                  for (int j = 0; j < 16; j++)                  {                      if (colors.Length <= j + 16 * i)                      {                          end = true;                          break;                      }                        for (int k = 0; k < 10; k++)                          for (int q = 0; q < 10; q++)                              palette.SetPixel((j * 10 + q)' (i * 10 + k)' colors[j + 16 * i]);                  }              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: for (int i = 0; i < 16 & !end; i++)              {                  for (int j = 0; j < 16; j++)                  {                      if (colors.Length <= j + 16 * i)                      {                          end = true;                          break;                      }                        for (int k = 0; k < 10; k++)                          for (int q = 0; q < 10; q++)                              palette.SetPixel((j * 10 + q)' (i * 10 + k)' colors[j + 16 * i]);                  }              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: for (int i = 0; i < 16 & !end; i++)              {                  for (int j = 0; j < 16; j++)                  {                      if (colors.Length <= j + 16 * i)                      {                          end = true;                          break;                      }                        for (int k = 0; k < 10; k++)                          for (int q = 0; q < 10; q++)                              palette.SetPixel((j * 10 + q)' (i * 10 + k)' colors[j + 16 * i]);                  }              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: for (int i = 0; i < 16 & !end; i++)              {                  for (int j = 0; j < 16; j++)                  {                      if (colors.Length <= j + 16 * i)                      {                          end = true;                          break;                      }                        for (int k = 0; k < 10; k++)                          for (int q = 0; q < 10; q++)                              palette.SetPixel((j * 10 + q)' (i * 10 + k)' colors[j + 16 * i]);                  }              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: for (int i = 0; i < 16 & !end; i++)              {                  for (int j = 0; j < 16; j++)                  {                      if (colors.Length <= j + 16 * i)                      {                          end = true;                          break;                      }                        for (int k = 0; k < 10; k++)                          for (int q = 0; q < 10; q++)                              palette.SetPixel((j * 10 + q)' (i * 10 + k)' colors[j + 16 * i]);                  }              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,AlphaIndexTo32ARGB,The following statement contains a magic number: Byte[] direct = new byte[data.Length * 4];
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,AlphaIndexTo32ARGB,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  Color color = Color.Transparent;                  if (format == ColorFormat.A3I5)                  {                      int colorIndex = data[i] & 0x1F;                      int alpha = (data[i] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      color = Color.FromArgb(alpha'                          palette[colorIndex].R'                          palette[colorIndex].G'                          palette[colorIndex].B);                  }                  else if (format == ColorFormat.A5I3)                  {                      int colorIndex = data[i] & 0x7;                      int alpha = (data[i] >> 3);                      alpha *= 8;                      color = Color.FromArgb(alpha'                          palette[colorIndex].R'                          palette[colorIndex].G'                          palette[colorIndex].B);                  }                    Byte[] argb32 = BitConverter.GetBytes(color.ToArgb());                  Array.Copy(argb32' 0' direct' i * 4' 4);              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,AlphaIndexTo32ARGB,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  Color color = Color.Transparent;                  if (format == ColorFormat.A3I5)                  {                      int colorIndex = data[i] & 0x1F;                      int alpha = (data[i] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      color = Color.FromArgb(alpha'                          palette[colorIndex].R'                          palette[colorIndex].G'                          palette[colorIndex].B);                  }                  else if (format == ColorFormat.A5I3)                  {                      int colorIndex = data[i] & 0x7;                      int alpha = (data[i] >> 3);                      alpha *= 8;                      color = Color.FromArgb(alpha'                          palette[colorIndex].R'                          palette[colorIndex].G'                          palette[colorIndex].B);                  }                    Byte[] argb32 = BitConverter.GetBytes(color.ToArgb());                  Array.Copy(argb32' 0' direct' i * 4' 4);              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,AlphaIndexTo32ARGB,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  Color color = Color.Transparent;                  if (format == ColorFormat.A3I5)                  {                      int colorIndex = data[i] & 0x1F;                      int alpha = (data[i] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      color = Color.FromArgb(alpha'                          palette[colorIndex].R'                          palette[colorIndex].G'                          palette[colorIndex].B);                  }                  else if (format == ColorFormat.A5I3)                  {                      int colorIndex = data[i] & 0x7;                      int alpha = (data[i] >> 3);                      alpha *= 8;                      color = Color.FromArgb(alpha'                          palette[colorIndex].R'                          palette[colorIndex].G'                          palette[colorIndex].B);                  }                    Byte[] argb32 = BitConverter.GetBytes(color.ToArgb());                  Array.Copy(argb32' 0' direct' i * 4' 4);              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,AlphaIndexTo32ARGB,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  Color color = Color.Transparent;                  if (format == ColorFormat.A3I5)                  {                      int colorIndex = data[i] & 0x1F;                      int alpha = (data[i] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      color = Color.FromArgb(alpha'                          palette[colorIndex].R'                          palette[colorIndex].G'                          palette[colorIndex].B);                  }                  else if (format == ColorFormat.A5I3)                  {                      int colorIndex = data[i] & 0x7;                      int alpha = (data[i] >> 3);                      alpha *= 8;                      color = Color.FromArgb(alpha'                          palette[colorIndex].R'                          palette[colorIndex].G'                          palette[colorIndex].B);                  }                    Byte[] argb32 = BitConverter.GetBytes(color.ToArgb());                  Array.Copy(argb32' 0' direct' i * 4' 4);              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,AlphaIndexTo32ARGB,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  Color color = Color.Transparent;                  if (format == ColorFormat.A3I5)                  {                      int colorIndex = data[i] & 0x1F;                      int alpha = (data[i] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      color = Color.FromArgb(alpha'                          palette[colorIndex].R'                          palette[colorIndex].G'                          palette[colorIndex].B);                  }                  else if (format == ColorFormat.A5I3)                  {                      int colorIndex = data[i] & 0x7;                      int alpha = (data[i] >> 3);                      alpha *= 8;                      color = Color.FromArgb(alpha'                          palette[colorIndex].R'                          palette[colorIndex].G'                          palette[colorIndex].B);                  }                    Byte[] argb32 = BitConverter.GetBytes(color.ToArgb());                  Array.Copy(argb32' 0' direct' i * 4' 4);              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,AlphaIndexTo32ARGB,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  Color color = Color.Transparent;                  if (format == ColorFormat.A3I5)                  {                      int colorIndex = data[i] & 0x1F;                      int alpha = (data[i] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      color = Color.FromArgb(alpha'                          palette[colorIndex].R'                          palette[colorIndex].G'                          palette[colorIndex].B);                  }                  else if (format == ColorFormat.A5I3)                  {                      int colorIndex = data[i] & 0x7;                      int alpha = (data[i] >> 3);                      alpha *= 8;                      color = Color.FromArgb(alpha'                          palette[colorIndex].R'                          palette[colorIndex].G'                          palette[colorIndex].B);                  }                    Byte[] argb32 = BitConverter.GetBytes(color.ToArgb());                  Array.Copy(argb32' 0' direct' i * 4' 4);              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,AlphaIndexTo32ARGB,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  Color color = Color.Transparent;                  if (format == ColorFormat.A3I5)                  {                      int colorIndex = data[i] & 0x1F;                      int alpha = (data[i] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      color = Color.FromArgb(alpha'                          palette[colorIndex].R'                          palette[colorIndex].G'                          palette[colorIndex].B);                  }                  else if (format == ColorFormat.A5I3)                  {                      int colorIndex = data[i] & 0x7;                      int alpha = (data[i] >> 3);                      alpha *= 8;                      color = Color.FromArgb(alpha'                          palette[colorIndex].R'                          palette[colorIndex].G'                          palette[colorIndex].B);                  }                    Byte[] argb32 = BitConverter.GetBytes(color.ToArgb());                  Array.Copy(argb32' 0' direct' i * 4' 4);              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,AlphaIndexTo32ARGB,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  Color color = Color.Transparent;                  if (format == ColorFormat.A3I5)                  {                      int colorIndex = data[i] & 0x1F;                      int alpha = (data[i] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      color = Color.FromArgb(alpha'                          palette[colorIndex].R'                          palette[colorIndex].G'                          palette[colorIndex].B);                  }                  else if (format == ColorFormat.A5I3)                  {                      int colorIndex = data[i] & 0x7;                      int alpha = (data[i] >> 3);                      alpha *= 8;                      color = Color.FromArgb(alpha'                          palette[colorIndex].R'                          palette[colorIndex].G'                          palette[colorIndex].B);                  }                    Byte[] argb32 = BitConverter.GetBytes(color.ToArgb());                  Array.Copy(argb32' 0' direct' i * 4' 4);              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Bpp2ToBpp4,The following statement contains a magic number: Byte[] bpp4 = new byte[data.Length * 2];
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Bpp2ToBpp4,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  byte b1 = (byte)(data[i] & 0x3);                  b1 += (byte)(((data[i] >> 2) & 0x3) << 4);                    byte b2 = (byte)((data[i] >> 4) & 0x3);                  b2 += (byte)(((data[i] >> 6) & 0x3) << 4);                    bpp4[i * 2] = b1;                  bpp4[i * 2 + 1] = b2;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Bpp2ToBpp4,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  byte b1 = (byte)(data[i] & 0x3);                  b1 += (byte)(((data[i] >> 2) & 0x3) << 4);                    byte b2 = (byte)((data[i] >> 4) & 0x3);                  b2 += (byte)(((data[i] >> 6) & 0x3) << 4);                    bpp4[i * 2] = b1;                  bpp4[i * 2 + 1] = b2;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Bpp2ToBpp4,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  byte b1 = (byte)(data[i] & 0x3);                  b1 += (byte)(((data[i] >> 2) & 0x3) << 4);                    byte b2 = (byte)((data[i] >> 4) & 0x3);                  b2 += (byte)(((data[i] >> 6) & 0x3) << 4);                    bpp4[i * 2] = b1;                  bpp4[i * 2 + 1] = b2;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Bpp2ToBpp4,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  byte b1 = (byte)(data[i] & 0x3);                  b1 += (byte)(((data[i] >> 2) & 0x3) << 4);                    byte b2 = (byte)((data[i] >> 4) & 0x3);                  b2 += (byte)(((data[i] >> 6) & 0x3) << 4);                    bpp4[i * 2] = b1;                  bpp4[i * 2 + 1] = b2;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Bpp2ToBpp4,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  byte b1 = (byte)(data[i] & 0x3);                  b1 += (byte)(((data[i] >> 2) & 0x3) << 4);                    byte b2 = (byte)((data[i] >> 4) & 0x3);                  b2 += (byte)(((data[i] >> 6) & 0x3) << 4);                    bpp4[i * 2] = b1;                  bpp4[i * 2 + 1] = b2;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Bpp2ToBpp4,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  byte b1 = (byte)(data[i] & 0x3);                  b1 += (byte)(((data[i] >> 2) & 0x3) << 4);                    byte b2 = (byte)((data[i] >> 4) & 0x3);                  b2 += (byte)(((data[i] >> 6) & 0x3) << 4);                    bpp4[i * 2] = b1;                  bpp4[i * 2 + 1] = b2;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Bpp2ToBpp4,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  byte b1 = (byte)(data[i] & 0x3);                  b1 += (byte)(((data[i] >> 2) & 0x3) << 4);                    byte b2 = (byte)((data[i] >> 4) & 0x3);                  b2 += (byte)(((data[i] >> 6) & 0x3) << 4);                    bpp4[i * 2] = b1;                  bpp4[i * 2 + 1] = b2;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Color,The following statement contains a magic number: switch (format)              {                  case ColorFormat.A3I5:                      if (data.Length <= pos) break;                      index = data[pos] & 0x1F;                      alpha = (data[pos] >> 5);                      alpha = ((alpha * 4) + (alpha / 2)) * 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A4I4:                      if (data.Length <= pos) break;                      index = data[pos] & 0xF;                      alpha = (data[pos] >> 4);                      alpha *= 16;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                  case ColorFormat.A5I3:                      if (data.Length <= pos) break;                      index = data[pos] & 0x7;                      alpha = (data[pos] >> 3);                      alpha *= 8;                      if (palette.Length > index)                          color = Color.FromArgb(alpha'                              palette[index].R'                              palette[index].G'                              palette[index].B);                        pos++;                      break;                    case ColorFormat.colors2:                      if (data.Length <= (pos / 8)) break;                      byte bit1 = data[pos / 8];                      index = Helper.BitsConverter.ByteToBits(bit1)[pos % 8];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors4:                      if (data.Length <= (pos / 4)) break;                      byte bit2 = data[pos / 4];                      index = Helper.BitsConverter.ByteToBit2(bit2)[pos % 4];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors16:                      if (data.Length <= (pos / 2)) break;                      byte bit4 = data[pos / 2];                      index = Helper.BitsConverter.ByteToBit4(bit4)[pos % 2];                      if (palette.Length > index)                          color = palette[index];                      pos++;                      break;                  case ColorFormat.colors256:                      if (data.Length > pos && palette.Length > data[pos])                          color = palette[data[pos]];                      pos++;                      break;                    case ColorFormat.direct:    // RGB555                      if (pos + 2 >= data.Length)                          break;                        ushort byteColor = BitConverter.ToUInt16(data' pos);                      color = Color.FromArgb(                          ((byteColor >> 15) == 1 ? 255 : 0)'                          (byteColor & 0x1F) * 8'                          ((byteColor >> 5) & 0x1F) * 8'                          ((byteColor >> 10) & 0x1F) * 8);                      pos += 2;                      break;                    case ColorFormat.BGRA32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+3]' data[pos+0]' data[pos+1]' data[pos+2]);                      pos += 4;                      break;                    case ColorFormat.ABGR32:                      if (pos + 4 >= data.Length)                          break;                        color = Color.FromArgb(data[pos+0]' data[pos+1]' data[pos+2]' data[pos+3]);                      pos += 4;                      break;                    case ColorFormat.texel4x4:                      throw new NotSupportedException("Compressed texel 4x4 not supported yet");                  default:                      throw new FormatException("Unknown color format");              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,HorizontalToLineal,The following statement contains a magic number: int tile_width = tile_size * bpp / 8;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,LinealToHorizontal,The following statement contains a magic number: int tile_width = tile_size * bpp / 8;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Remove_DuplicatedColors,The following statement contains a magic number: for (int i = 0; i < palette.Length; i++)              {                  if (!colors.Contains(palette[i]))                      colors.Add(palette[i]);                  else        // The color is duplicated                  {                      int newIndex = colors.IndexOf(palette[i]);                      Replace_Color(ref tiles' i' newIndex);                      colors.Add(Color.FromArgb(248' 0' 248));                        if (first_duplicated_color == -1)                          first_duplicated_color = i;                  }              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Remove_DuplicatedColors,The following statement contains a magic number: for (int i = 0; i < palette.Length; i++)              {                  if (!colors.Contains(palette[i]))                      colors.Add(palette[i]);                  else        // The color is duplicated                  {                      int newIndex = colors.IndexOf(palette[i]);                      Replace_Color(ref tiles' i' newIndex);                      colors.Add(Color.FromArgb(248' 0' 248));                        if (first_duplicated_color == -1)                          first_duplicated_color = i;                  }              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Size,The following statement contains a magic number: int num_pix = fileSize * 8 / bpp;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Size,The following statement contains a magic number: if (Math.Pow((int)(Math.Sqrt(num_pix))' 2) == num_pix)                  width = height = (int)Math.Sqrt(num_pix);              else              {                  width = (num_pix < 0x100 ? num_pix : 0x0100);                  height = num_pix / width;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Indexed_Image,The following statement contains a magic number: int['] data = new int[width * height' 2];
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Indexed_Image,The following statement contains a magic number: switch (cf)              {                  case ColorFormat.A3I5: max_colors = 32; bpc = 8; break;                  case ColorFormat.colors4: max_colors = 4; bpc = 2; break;                  case ColorFormat.colors16: max_colors = 16; bpc = 4; break;                  case ColorFormat.colors256: max_colors = 256; bpc = 8; break;                  case ColorFormat.texel4x4: throw new NotSupportedException("Texel 4x4 not supported yet.");                  case ColorFormat.A5I3: max_colors = 8; bpc = 8; break;                  case ColorFormat.direct: max_colors = 0; bpc = 16; break;                  case ColorFormat.colors2: max_colors = 2; bpc = 1; break;                  case ColorFormat.A4I4: max_colors = 16; bpc = 8; break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Indexed_Image,The following statement contains a magic number: switch (cf)              {                  case ColorFormat.A3I5: max_colors = 32; bpc = 8; break;                  case ColorFormat.colors4: max_colors = 4; bpc = 2; break;                  case ColorFormat.colors16: max_colors = 16; bpc = 4; break;                  case ColorFormat.colors256: max_colors = 256; bpc = 8; break;                  case ColorFormat.texel4x4: throw new NotSupportedException("Texel 4x4 not supported yet.");                  case ColorFormat.A5I3: max_colors = 8; bpc = 8; break;                  case ColorFormat.direct: max_colors = 0; bpc = 16; break;                  case ColorFormat.colors2: max_colors = 2; bpc = 1; break;                  case ColorFormat.A4I4: max_colors = 16; bpc = 8; break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Indexed_Image,The following statement contains a magic number: switch (cf)              {                  case ColorFormat.A3I5: max_colors = 32; bpc = 8; break;                  case ColorFormat.colors4: max_colors = 4; bpc = 2; break;                  case ColorFormat.colors16: max_colors = 16; bpc = 4; break;                  case ColorFormat.colors256: max_colors = 256; bpc = 8; break;                  case ColorFormat.texel4x4: throw new NotSupportedException("Texel 4x4 not supported yet.");                  case ColorFormat.A5I3: max_colors = 8; bpc = 8; break;                  case ColorFormat.direct: max_colors = 0; bpc = 16; break;                  case ColorFormat.colors2: max_colors = 2; bpc = 1; break;                  case ColorFormat.A4I4: max_colors = 16; bpc = 8; break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Indexed_Image,The following statement contains a magic number: switch (cf)              {                  case ColorFormat.A3I5: max_colors = 32; bpc = 8; break;                  case ColorFormat.colors4: max_colors = 4; bpc = 2; break;                  case ColorFormat.colors16: max_colors = 16; bpc = 4; break;                  case ColorFormat.colors256: max_colors = 256; bpc = 8; break;                  case ColorFormat.texel4x4: throw new NotSupportedException("Texel 4x4 not supported yet.");                  case ColorFormat.A5I3: max_colors = 8; bpc = 8; break;                  case ColorFormat.direct: max_colors = 0; bpc = 16; break;                  case ColorFormat.colors2: max_colors = 2; bpc = 1; break;                  case ColorFormat.A4I4: max_colors = 16; bpc = 8; break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Indexed_Image,The following statement contains a magic number: switch (cf)              {                  case ColorFormat.A3I5: max_colors = 32; bpc = 8; break;                  case ColorFormat.colors4: max_colors = 4; bpc = 2; break;                  case ColorFormat.colors16: max_colors = 16; bpc = 4; break;                  case ColorFormat.colors256: max_colors = 256; bpc = 8; break;                  case ColorFormat.texel4x4: throw new NotSupportedException("Texel 4x4 not supported yet.");                  case ColorFormat.A5I3: max_colors = 8; bpc = 8; break;                  case ColorFormat.direct: max_colors = 0; bpc = 16; break;                  case ColorFormat.colors2: max_colors = 2; bpc = 1; break;                  case ColorFormat.A4I4: max_colors = 16; bpc = 8; break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Indexed_Image,The following statement contains a magic number: switch (cf)              {                  case ColorFormat.A3I5: max_colors = 32; bpc = 8; break;                  case ColorFormat.colors4: max_colors = 4; bpc = 2; break;                  case ColorFormat.colors16: max_colors = 16; bpc = 4; break;                  case ColorFormat.colors256: max_colors = 256; bpc = 8; break;                  case ColorFormat.texel4x4: throw new NotSupportedException("Texel 4x4 not supported yet.");                  case ColorFormat.A5I3: max_colors = 8; bpc = 8; break;                  case ColorFormat.direct: max_colors = 0; bpc = 16; break;                  case ColorFormat.colors2: max_colors = 2; bpc = 1; break;                  case ColorFormat.A4I4: max_colors = 16; bpc = 8; break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Indexed_Image,The following statement contains a magic number: switch (cf)              {                  case ColorFormat.A3I5: max_colors = 32; bpc = 8; break;                  case ColorFormat.colors4: max_colors = 4; bpc = 2; break;                  case ColorFormat.colors16: max_colors = 16; bpc = 4; break;                  case ColorFormat.colors256: max_colors = 256; bpc = 8; break;                  case ColorFormat.texel4x4: throw new NotSupportedException("Texel 4x4 not supported yet.");                  case ColorFormat.A5I3: max_colors = 8; bpc = 8; break;                  case ColorFormat.direct: max_colors = 0; bpc = 16; break;                  case ColorFormat.colors2: max_colors = 2; bpc = 1; break;                  case ColorFormat.A4I4: max_colors = 16; bpc = 8; break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Indexed_Image,The following statement contains a magic number: switch (cf)              {                  case ColorFormat.A3I5: max_colors = 32; bpc = 8; break;                  case ColorFormat.colors4: max_colors = 4; bpc = 2; break;                  case ColorFormat.colors16: max_colors = 16; bpc = 4; break;                  case ColorFormat.colors256: max_colors = 256; bpc = 8; break;                  case ColorFormat.texel4x4: throw new NotSupportedException("Texel 4x4 not supported yet.");                  case ColorFormat.A5I3: max_colors = 8; bpc = 8; break;                  case ColorFormat.direct: max_colors = 0; bpc = 16; break;                  case ColorFormat.colors2: max_colors = 2; bpc = 1; break;                  case ColorFormat.A4I4: max_colors = 16; bpc = 8; break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Indexed_Image,The following statement contains a magic number: switch (cf)              {                  case ColorFormat.A3I5: max_colors = 32; bpc = 8; break;                  case ColorFormat.colors4: max_colors = 4; bpc = 2; break;                  case ColorFormat.colors16: max_colors = 16; bpc = 4; break;                  case ColorFormat.colors256: max_colors = 256; bpc = 8; break;                  case ColorFormat.texel4x4: throw new NotSupportedException("Texel 4x4 not supported yet.");                  case ColorFormat.A5I3: max_colors = 8; bpc = 8; break;                  case ColorFormat.direct: max_colors = 0; bpc = 16; break;                  case ColorFormat.colors2: max_colors = 2; bpc = 1; break;                  case ColorFormat.A4I4: max_colors = 16; bpc = 8; break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Indexed_Image,The following statement contains a magic number: switch (cf)              {                  case ColorFormat.A3I5: max_colors = 32; bpc = 8; break;                  case ColorFormat.colors4: max_colors = 4; bpc = 2; break;                  case ColorFormat.colors16: max_colors = 16; bpc = 4; break;                  case ColorFormat.colors256: max_colors = 256; bpc = 8; break;                  case ColorFormat.texel4x4: throw new NotSupportedException("Texel 4x4 not supported yet.");                  case ColorFormat.A5I3: max_colors = 8; bpc = 8; break;                  case ColorFormat.direct: max_colors = 0; bpc = 16; break;                  case ColorFormat.colors2: max_colors = 2; bpc = 1; break;                  case ColorFormat.A4I4: max_colors = 16; bpc = 8; break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Indexed_Image,The following statement contains a magic number: switch (cf)              {                  case ColorFormat.A3I5: max_colors = 32; bpc = 8; break;                  case ColorFormat.colors4: max_colors = 4; bpc = 2; break;                  case ColorFormat.colors16: max_colors = 16; bpc = 4; break;                  case ColorFormat.colors256: max_colors = 256; bpc = 8; break;                  case ColorFormat.texel4x4: throw new NotSupportedException("Texel 4x4 not supported yet.");                  case ColorFormat.A5I3: max_colors = 8; bpc = 8; break;                  case ColorFormat.direct: max_colors = 0; bpc = 16; break;                  case ColorFormat.colors2: max_colors = 2; bpc = 1; break;                  case ColorFormat.A4I4: max_colors = 16; bpc = 8; break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Indexed_Image,The following statement contains a magic number: switch (cf)              {                  case ColorFormat.A3I5: max_colors = 32; bpc = 8; break;                  case ColorFormat.colors4: max_colors = 4; bpc = 2; break;                  case ColorFormat.colors16: max_colors = 16; bpc = 4; break;                  case ColorFormat.colors256: max_colors = 256; bpc = 8; break;                  case ColorFormat.texel4x4: throw new NotSupportedException("Texel 4x4 not supported yet.");                  case ColorFormat.A5I3: max_colors = 8; bpc = 8; break;                  case ColorFormat.direct: max_colors = 0; bpc = 16; break;                  case ColorFormat.colors2: max_colors = 2; bpc = 1; break;                  case ColorFormat.A4I4: max_colors = 16; bpc = 8; break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Indexed_Image,The following statement contains a magic number: switch (cf)              {                  case ColorFormat.A3I5: max_colors = 32; bpc = 8; break;                  case ColorFormat.colors4: max_colors = 4; bpc = 2; break;                  case ColorFormat.colors16: max_colors = 16; bpc = 4; break;                  case ColorFormat.colors256: max_colors = 256; bpc = 8; break;                  case ColorFormat.texel4x4: throw new NotSupportedException("Texel 4x4 not supported yet.");                  case ColorFormat.A5I3: max_colors = 8; bpc = 8; break;                  case ColorFormat.direct: max_colors = 0; bpc = 16; break;                  case ColorFormat.colors2: max_colors = 2; bpc = 1; break;                  case ColorFormat.A4I4: max_colors = 16; bpc = 8; break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Indexed_Image,The following statement contains a magic number: switch (cf)              {                  case ColorFormat.A3I5: max_colors = 32; bpc = 8; break;                  case ColorFormat.colors4: max_colors = 4; bpc = 2; break;                  case ColorFormat.colors16: max_colors = 16; bpc = 4; break;                  case ColorFormat.colors256: max_colors = 256; bpc = 8; break;                  case ColorFormat.texel4x4: throw new NotSupportedException("Texel 4x4 not supported yet.");                  case ColorFormat.A5I3: max_colors = 8; bpc = 8; break;                  case ColorFormat.direct: max_colors = 0; bpc = 16; break;                  case ColorFormat.colors2: max_colors = 2; bpc = 1; break;                  case ColorFormat.A4I4: max_colors = 16; bpc = 8; break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Indexed_Image,The following statement contains a magic number: tiles = new byte[width * height * bpc / 8];
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Indexed_Image,The following statement contains a magic number: for (int i = 0' j = 0; i < tiles.Length; )              {                  switch (cf)                  {                      case ColorFormat.colors2:                      case ColorFormat.colors4:                      case ColorFormat.colors16:                      case ColorFormat.colors256:                          for (int b = 0; b < 8; b += bpc)                              if (j < data.Length)                                  tiles[i] |= (byte)(data[j++' 0] << b);                            i++;                          break;                        case ColorFormat.A3I5:                          byte alpha1 = (byte)(data[j' 1] * 8 / 256);                          byte va1 = (byte)data[j++' 0];                          va1 |= (byte)(alpha1 << 5);                          tiles[i++] = va1;                          break;                      case ColorFormat.A4I4:                          byte alpha3 = (byte)(data[j' 1] * 16 / 256);                          byte va3 = (byte)data[j++' 0];                          va3 |= (byte)(alpha3 << 4);                          tiles[i++] = va3;                          break;                      case ColorFormat.A5I3:                          byte alpha2 = (byte)(data[j' 1] * 32 / 256);                          byte va2 = (byte)data[j++' 0];                          va2 |= (byte)(alpha2 << 3);                          tiles[i++] = va2;                          break;                        case ColorFormat.direct:                          byte[] v = ColorToBGRA555(Color.FromArgb(data[j' 1]' coldif[data[j++' 0]]));                          tiles[i++] = v[0];                          tiles[i++] = v[1];                          break;                        case ColorFormat.texel4x4:                          // Not supported                          break;                  }              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Indexed_Image,The following statement contains a magic number: for (int i = 0' j = 0; i < tiles.Length; )              {                  switch (cf)                  {                      case ColorFormat.colors2:                      case ColorFormat.colors4:                      case ColorFormat.colors16:                      case ColorFormat.colors256:                          for (int b = 0; b < 8; b += bpc)                              if (j < data.Length)                                  tiles[i] |= (byte)(data[j++' 0] << b);                            i++;                          break;                        case ColorFormat.A3I5:                          byte alpha1 = (byte)(data[j' 1] * 8 / 256);                          byte va1 = (byte)data[j++' 0];                          va1 |= (byte)(alpha1 << 5);                          tiles[i++] = va1;                          break;                      case ColorFormat.A4I4:                          byte alpha3 = (byte)(data[j' 1] * 16 / 256);                          byte va3 = (byte)data[j++' 0];                          va3 |= (byte)(alpha3 << 4);                          tiles[i++] = va3;                          break;                      case ColorFormat.A5I3:                          byte alpha2 = (byte)(data[j' 1] * 32 / 256);                          byte va2 = (byte)data[j++' 0];                          va2 |= (byte)(alpha2 << 3);                          tiles[i++] = va2;                          break;                        case ColorFormat.direct:                          byte[] v = ColorToBGRA555(Color.FromArgb(data[j' 1]' coldif[data[j++' 0]]));                          tiles[i++] = v[0];                          tiles[i++] = v[1];                          break;                        case ColorFormat.texel4x4:                          // Not supported                          break;                  }              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Indexed_Image,The following statement contains a magic number: for (int i = 0' j = 0; i < tiles.Length; )              {                  switch (cf)                  {                      case ColorFormat.colors2:                      case ColorFormat.colors4:                      case ColorFormat.colors16:                      case ColorFormat.colors256:                          for (int b = 0; b < 8; b += bpc)                              if (j < data.Length)                                  tiles[i] |= (byte)(data[j++' 0] << b);                            i++;                          break;                        case ColorFormat.A3I5:                          byte alpha1 = (byte)(data[j' 1] * 8 / 256);                          byte va1 = (byte)data[j++' 0];                          va1 |= (byte)(alpha1 << 5);                          tiles[i++] = va1;                          break;                      case ColorFormat.A4I4:                          byte alpha3 = (byte)(data[j' 1] * 16 / 256);                          byte va3 = (byte)data[j++' 0];                          va3 |= (byte)(alpha3 << 4);                          tiles[i++] = va3;                          break;                      case ColorFormat.A5I3:                          byte alpha2 = (byte)(data[j' 1] * 32 / 256);                          byte va2 = (byte)data[j++' 0];                          va2 |= (byte)(alpha2 << 3);                          tiles[i++] = va2;                          break;                        case ColorFormat.direct:                          byte[] v = ColorToBGRA555(Color.FromArgb(data[j' 1]' coldif[data[j++' 0]]));                          tiles[i++] = v[0];                          tiles[i++] = v[1];                          break;                        case ColorFormat.texel4x4:                          // Not supported                          break;                  }              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Indexed_Image,The following statement contains a magic number: for (int i = 0' j = 0; i < tiles.Length; )              {                  switch (cf)                  {                      case ColorFormat.colors2:                      case ColorFormat.colors4:                      case ColorFormat.colors16:                      case ColorFormat.colors256:                          for (int b = 0; b < 8; b += bpc)                              if (j < data.Length)                                  tiles[i] |= (byte)(data[j++' 0] << b);                            i++;                          break;                        case ColorFormat.A3I5:                          byte alpha1 = (byte)(data[j' 1] * 8 / 256);                          byte va1 = (byte)data[j++' 0];                          va1 |= (byte)(alpha1 << 5);                          tiles[i++] = va1;                          break;                      case ColorFormat.A4I4:                          byte alpha3 = (byte)(data[j' 1] * 16 / 256);                          byte va3 = (byte)data[j++' 0];                          va3 |= (byte)(alpha3 << 4);                          tiles[i++] = va3;                          break;                      case ColorFormat.A5I3:                          byte alpha2 = (byte)(data[j' 1] * 32 / 256);                          byte va2 = (byte)data[j++' 0];                          va2 |= (byte)(alpha2 << 3);                          tiles[i++] = va2;                          break;                        case ColorFormat.direct:                          byte[] v = ColorToBGRA555(Color.FromArgb(data[j' 1]' coldif[data[j++' 0]]));                          tiles[i++] = v[0];                          tiles[i++] = v[1];                          break;                        case ColorFormat.texel4x4:                          // Not supported                          break;                  }              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Indexed_Image,The following statement contains a magic number: for (int i = 0' j = 0; i < tiles.Length; )              {                  switch (cf)                  {                      case ColorFormat.colors2:                      case ColorFormat.colors4:                      case ColorFormat.colors16:                      case ColorFormat.colors256:                          for (int b = 0; b < 8; b += bpc)                              if (j < data.Length)                                  tiles[i] |= (byte)(data[j++' 0] << b);                            i++;                          break;                        case ColorFormat.A3I5:                          byte alpha1 = (byte)(data[j' 1] * 8 / 256);                          byte va1 = (byte)data[j++' 0];                          va1 |= (byte)(alpha1 << 5);                          tiles[i++] = va1;                          break;                      case ColorFormat.A4I4:                          byte alpha3 = (byte)(data[j' 1] * 16 / 256);                          byte va3 = (byte)data[j++' 0];                          va3 |= (byte)(alpha3 << 4);                          tiles[i++] = va3;                          break;                      case ColorFormat.A5I3:                          byte alpha2 = (byte)(data[j' 1] * 32 / 256);                          byte va2 = (byte)data[j++' 0];                          va2 |= (byte)(alpha2 << 3);                          tiles[i++] = va2;                          break;                        case ColorFormat.direct:                          byte[] v = ColorToBGRA555(Color.FromArgb(data[j' 1]' coldif[data[j++' 0]]));                          tiles[i++] = v[0];                          tiles[i++] = v[1];                          break;                        case ColorFormat.texel4x4:                          // Not supported                          break;                  }              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Indexed_Image,The following statement contains a magic number: for (int i = 0' j = 0; i < tiles.Length; )              {                  switch (cf)                  {                      case ColorFormat.colors2:                      case ColorFormat.colors4:                      case ColorFormat.colors16:                      case ColorFormat.colors256:                          for (int b = 0; b < 8; b += bpc)                              if (j < data.Length)                                  tiles[i] |= (byte)(data[j++' 0] << b);                            i++;                          break;                        case ColorFormat.A3I5:                          byte alpha1 = (byte)(data[j' 1] * 8 / 256);                          byte va1 = (byte)data[j++' 0];                          va1 |= (byte)(alpha1 << 5);                          tiles[i++] = va1;                          break;                      case ColorFormat.A4I4:                          byte alpha3 = (byte)(data[j' 1] * 16 / 256);                          byte va3 = (byte)data[j++' 0];                          va3 |= (byte)(alpha3 << 4);                          tiles[i++] = va3;                          break;                      case ColorFormat.A5I3:                          byte alpha2 = (byte)(data[j' 1] * 32 / 256);                          byte va2 = (byte)data[j++' 0];                          va2 |= (byte)(alpha2 << 3);                          tiles[i++] = va2;                          break;                        case ColorFormat.direct:                          byte[] v = ColorToBGRA555(Color.FromArgb(data[j' 1]' coldif[data[j++' 0]]));                          tiles[i++] = v[0];                          tiles[i++] = v[1];                          break;                        case ColorFormat.texel4x4:                          // Not supported                          break;                  }              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Indexed_Image,The following statement contains a magic number: for (int i = 0' j = 0; i < tiles.Length; )              {                  switch (cf)                  {                      case ColorFormat.colors2:                      case ColorFormat.colors4:                      case ColorFormat.colors16:                      case ColorFormat.colors256:                          for (int b = 0; b < 8; b += bpc)                              if (j < data.Length)                                  tiles[i] |= (byte)(data[j++' 0] << b);                            i++;                          break;                        case ColorFormat.A3I5:                          byte alpha1 = (byte)(data[j' 1] * 8 / 256);                          byte va1 = (byte)data[j++' 0];                          va1 |= (byte)(alpha1 << 5);                          tiles[i++] = va1;                          break;                      case ColorFormat.A4I4:                          byte alpha3 = (byte)(data[j' 1] * 16 / 256);                          byte va3 = (byte)data[j++' 0];                          va3 |= (byte)(alpha3 << 4);                          tiles[i++] = va3;                          break;                      case ColorFormat.A5I3:                          byte alpha2 = (byte)(data[j' 1] * 32 / 256);                          byte va2 = (byte)data[j++' 0];                          va2 |= (byte)(alpha2 << 3);                          tiles[i++] = va2;                          break;                        case ColorFormat.direct:                          byte[] v = ColorToBGRA555(Color.FromArgb(data[j' 1]' coldif[data[j++' 0]]));                          tiles[i++] = v[0];                          tiles[i++] = v[1];                          break;                        case ColorFormat.texel4x4:                          // Not supported                          break;                  }              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Indexed_Image,The following statement contains a magic number: for (int i = 0' j = 0; i < tiles.Length; )              {                  switch (cf)                  {                      case ColorFormat.colors2:                      case ColorFormat.colors4:                      case ColorFormat.colors16:                      case ColorFormat.colors256:                          for (int b = 0; b < 8; b += bpc)                              if (j < data.Length)                                  tiles[i] |= (byte)(data[j++' 0] << b);                            i++;                          break;                        case ColorFormat.A3I5:                          byte alpha1 = (byte)(data[j' 1] * 8 / 256);                          byte va1 = (byte)data[j++' 0];                          va1 |= (byte)(alpha1 << 5);                          tiles[i++] = va1;                          break;                      case ColorFormat.A4I4:                          byte alpha3 = (byte)(data[j' 1] * 16 / 256);                          byte va3 = (byte)data[j++' 0];                          va3 |= (byte)(alpha3 << 4);                          tiles[i++] = va3;                          break;                      case ColorFormat.A5I3:                          byte alpha2 = (byte)(data[j' 1] * 32 / 256);                          byte va2 = (byte)data[j++' 0];                          va2 |= (byte)(alpha2 << 3);                          tiles[i++] = va2;                          break;                        case ColorFormat.direct:                          byte[] v = ColorToBGRA555(Color.FromArgb(data[j' 1]' coldif[data[j++' 0]]));                          tiles[i++] = v[0];                          tiles[i++] = v[1];                          break;                        case ColorFormat.texel4x4:                          // Not supported                          break;                  }              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Indexed_Image,The following statement contains a magic number: for (int i = 0' j = 0; i < tiles.Length; )              {                  switch (cf)                  {                      case ColorFormat.colors2:                      case ColorFormat.colors4:                      case ColorFormat.colors16:                      case ColorFormat.colors256:                          for (int b = 0; b < 8; b += bpc)                              if (j < data.Length)                                  tiles[i] |= (byte)(data[j++' 0] << b);                            i++;                          break;                        case ColorFormat.A3I5:                          byte alpha1 = (byte)(data[j' 1] * 8 / 256);                          byte va1 = (byte)data[j++' 0];                          va1 |= (byte)(alpha1 << 5);                          tiles[i++] = va1;                          break;                      case ColorFormat.A4I4:                          byte alpha3 = (byte)(data[j' 1] * 16 / 256);                          byte va3 = (byte)data[j++' 0];                          va3 |= (byte)(alpha3 << 4);                          tiles[i++] = va3;                          break;                      case ColorFormat.A5I3:                          byte alpha2 = (byte)(data[j' 1] * 32 / 256);                          byte va2 = (byte)data[j++' 0];                          va2 |= (byte)(alpha2 << 3);                          tiles[i++] = va2;                          break;                        case ColorFormat.direct:                          byte[] v = ColorToBGRA555(Color.FromArgb(data[j' 1]' coldif[data[j++' 0]]));                          tiles[i++] = v[0];                          tiles[i++] = v[1];                          break;                        case ColorFormat.texel4x4:                          // Not supported                          break;                  }              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Indexed_Image,The following statement contains a magic number: for (int i = 0' j = 0; i < tiles.Length; )              {                  switch (cf)                  {                      case ColorFormat.colors2:                      case ColorFormat.colors4:                      case ColorFormat.colors16:                      case ColorFormat.colors256:                          for (int b = 0; b < 8; b += bpc)                              if (j < data.Length)                                  tiles[i] |= (byte)(data[j++' 0] << b);                            i++;                          break;                        case ColorFormat.A3I5:                          byte alpha1 = (byte)(data[j' 1] * 8 / 256);                          byte va1 = (byte)data[j++' 0];                          va1 |= (byte)(alpha1 << 5);                          tiles[i++] = va1;                          break;                      case ColorFormat.A4I4:                          byte alpha3 = (byte)(data[j' 1] * 16 / 256);                          byte va3 = (byte)data[j++' 0];                          va3 |= (byte)(alpha3 << 4);                          tiles[i++] = va3;                          break;                      case ColorFormat.A5I3:                          byte alpha2 = (byte)(data[j' 1] * 32 / 256);                          byte va2 = (byte)data[j++' 0];                          va2 |= (byte)(alpha2 << 3);                          tiles[i++] = va2;                          break;                        case ColorFormat.direct:                          byte[] v = ColorToBGRA555(Color.FromArgb(data[j' 1]' coldif[data[j++' 0]]));                          tiles[i++] = v[0];                          tiles[i++] = v[1];                          break;                        case ColorFormat.texel4x4:                          // Not supported                          break;                  }              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Apply_Map,The following statement contains a magic number: int tile_length = tile_size * tile_size * bpp / 8;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,XFlip,The following statement contains a magic number: int tile_width = tile_size * bpp / 8;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,XFlip,The following statement contains a magic number: for (int h = 0; h < tile_size; h++)              {                  for (int w = 0; w < tile_width / 2; w++)                  {                      byte b = tile[((tile_width - 1) - w) + h * tile_width];                      newTile[w + h * tile_width] = Reverse_Bits(b' bpp);                        b = tile[w + h * tile_width];                      newTile[((tile_width - 1) - w) + h * tile_width] = Reverse_Bits(b' bpp);                  }              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Reverse_Bits,The following statement contains a magic number: if (length == 4)                  rb = (byte)((b << 4) + (b >> 4));              else if (length == 8)                  return b;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Reverse_Bits,The following statement contains a magic number: if (length == 4)                  rb = (byte)((b << 4) + (b >> 4));              else if (length == 8)                  return b;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Reverse_Bits,The following statement contains a magic number: if (length == 4)                  rb = (byte)((b << 4) + (b >> 4));              else if (length == 8)                  return b;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Reverse_Bits,The following statement contains a magic number: if (length == 4)                  rb = (byte)((b << 4) + (b >> 4));              else if (length == 8)                  return b;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,YFlip,The following statement contains a magic number: int tile_width = tile_size * bpp / 8;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,YFlip,The following statement contains a magic number: for (int h = 0; h < tile_size / 2; h++)              {                  for (int w = 0; w < tile_width; w++)                  {                      newTile[w + h * tile_width] = tile[w + (tile_size - 1 - h) * tile_width];                      newTile[w + (tile_size - 1 - h) * tile_width] = tile[w + h * tile_width];                  }              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Create_Map,The following statement contains a magic number: int tile_length = ppt * bpp / 8;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,MapInfo,The following statement contains a magic number: mapInfo.xFlip = (byte)((value >> 10) & 1);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,MapInfo,The following statement contains a magic number: mapInfo.yFlip = (byte)((value >> 11) & 1);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,MapInfo,The following statement contains a magic number: mapInfo.nPalette = (byte)((value >> 12) & 0xF);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,MapInfo,The following statement contains a magic number: int npalette = map.nPalette << 12;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,MapInfo,The following statement contains a magic number: int yFlip = map.yFlip << 11;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,MapInfo,The following statement contains a magic number: int xFlip = map.xFlip << 10;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMSize,The following statement contains a magic number: switch (shape)              {                  case 0x00:  // Square                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 8);                              break;                          case 0x01:                              imageSize = new Size(16' 16);                              break;                          case 0x02:                              imageSize = new Size(32' 32);                              break;                          case 0x03:                              imageSize = new Size(64' 64);                              break;                      }                      break;                  case 0x01:  // Horizontal                      switch (size)                      {                          case 0x00:                              imageSize = new Size(16' 8);                              break;                          case 0x01:                              imageSize = new Size(32' 8);                              break;                          case 0x02:                              imageSize = new Size(32' 16);                              break;                          case 0x03:                              imageSize = new Size(64' 32);                              break;                      }                      break;                  case 0x02:  // Vertical                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 16);                              break;                          case 0x01:                              imageSize = new Size(8' 32);                              break;                          case 0x02:                              imageSize = new Size(16' 32);                              break;                          case 0x03:                              imageSize = new Size(32' 64);                              break;                      }                      break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMSize,The following statement contains a magic number: switch (shape)              {                  case 0x00:  // Square                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 8);                              break;                          case 0x01:                              imageSize = new Size(16' 16);                              break;                          case 0x02:                              imageSize = new Size(32' 32);                              break;                          case 0x03:                              imageSize = new Size(64' 64);                              break;                      }                      break;                  case 0x01:  // Horizontal                      switch (size)                      {                          case 0x00:                              imageSize = new Size(16' 8);                              break;                          case 0x01:                              imageSize = new Size(32' 8);                              break;                          case 0x02:                              imageSize = new Size(32' 16);                              break;                          case 0x03:                              imageSize = new Size(64' 32);                              break;                      }                      break;                  case 0x02:  // Vertical                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 16);                              break;                          case 0x01:                              imageSize = new Size(8' 32);                              break;                          case 0x02:                              imageSize = new Size(16' 32);                              break;                          case 0x03:                              imageSize = new Size(32' 64);                              break;                      }                      break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMSize,The following statement contains a magic number: switch (shape)              {                  case 0x00:  // Square                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 8);                              break;                          case 0x01:                              imageSize = new Size(16' 16);                              break;                          case 0x02:                              imageSize = new Size(32' 32);                              break;                          case 0x03:                              imageSize = new Size(64' 64);                              break;                      }                      break;                  case 0x01:  // Horizontal                      switch (size)                      {                          case 0x00:                              imageSize = new Size(16' 8);                              break;                          case 0x01:                              imageSize = new Size(32' 8);                              break;                          case 0x02:                              imageSize = new Size(32' 16);                              break;                          case 0x03:                              imageSize = new Size(64' 32);                              break;                      }                      break;                  case 0x02:  // Vertical                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 16);                              break;                          case 0x01:                              imageSize = new Size(8' 32);                              break;                          case 0x02:                              imageSize = new Size(16' 32);                              break;                          case 0x03:                              imageSize = new Size(32' 64);                              break;                      }                      break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMSize,The following statement contains a magic number: switch (shape)              {                  case 0x00:  // Square                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 8);                              break;                          case 0x01:                              imageSize = new Size(16' 16);                              break;                          case 0x02:                              imageSize = new Size(32' 32);                              break;                          case 0x03:                              imageSize = new Size(64' 64);                              break;                      }                      break;                  case 0x01:  // Horizontal                      switch (size)                      {                          case 0x00:                              imageSize = new Size(16' 8);                              break;                          case 0x01:                              imageSize = new Size(32' 8);                              break;                          case 0x02:                              imageSize = new Size(32' 16);                              break;                          case 0x03:                              imageSize = new Size(64' 32);                              break;                      }                      break;                  case 0x02:  // Vertical                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 16);                              break;                          case 0x01:                              imageSize = new Size(8' 32);                              break;                          case 0x02:                              imageSize = new Size(16' 32);                              break;                          case 0x03:                              imageSize = new Size(32' 64);                              break;                      }                      break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMSize,The following statement contains a magic number: switch (shape)              {                  case 0x00:  // Square                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 8);                              break;                          case 0x01:                              imageSize = new Size(16' 16);                              break;                          case 0x02:                              imageSize = new Size(32' 32);                              break;                          case 0x03:                              imageSize = new Size(64' 64);                              break;                      }                      break;                  case 0x01:  // Horizontal                      switch (size)                      {                          case 0x00:                              imageSize = new Size(16' 8);                              break;                          case 0x01:                              imageSize = new Size(32' 8);                              break;                          case 0x02:                              imageSize = new Size(32' 16);                              break;                          case 0x03:                              imageSize = new Size(64' 32);                              break;                      }                      break;                  case 0x02:  // Vertical                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 16);                              break;                          case 0x01:                              imageSize = new Size(8' 32);                              break;                          case 0x02:                              imageSize = new Size(16' 32);                              break;                          case 0x03:                              imageSize = new Size(32' 64);                              break;                      }                      break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMSize,The following statement contains a magic number: switch (shape)              {                  case 0x00:  // Square                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 8);                              break;                          case 0x01:                              imageSize = new Size(16' 16);                              break;                          case 0x02:                              imageSize = new Size(32' 32);                              break;                          case 0x03:                              imageSize = new Size(64' 64);                              break;                      }                      break;                  case 0x01:  // Horizontal                      switch (size)                      {                          case 0x00:                              imageSize = new Size(16' 8);                              break;                          case 0x01:                              imageSize = new Size(32' 8);                              break;                          case 0x02:                              imageSize = new Size(32' 16);                              break;                          case 0x03:                              imageSize = new Size(64' 32);                              break;                      }                      break;                  case 0x02:  // Vertical                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 16);                              break;                          case 0x01:                              imageSize = new Size(8' 32);                              break;                          case 0x02:                              imageSize = new Size(16' 32);                              break;                          case 0x03:                              imageSize = new Size(32' 64);                              break;                      }                      break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMSize,The following statement contains a magic number: switch (shape)              {                  case 0x00:  // Square                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 8);                              break;                          case 0x01:                              imageSize = new Size(16' 16);                              break;                          case 0x02:                              imageSize = new Size(32' 32);                              break;                          case 0x03:                              imageSize = new Size(64' 64);                              break;                      }                      break;                  case 0x01:  // Horizontal                      switch (size)                      {                          case 0x00:                              imageSize = new Size(16' 8);                              break;                          case 0x01:                              imageSize = new Size(32' 8);                              break;                          case 0x02:                              imageSize = new Size(32' 16);                              break;                          case 0x03:                              imageSize = new Size(64' 32);                              break;                      }                      break;                  case 0x02:  // Vertical                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 16);                              break;                          case 0x01:                              imageSize = new Size(8' 32);                              break;                          case 0x02:                              imageSize = new Size(16' 32);                              break;                          case 0x03:                              imageSize = new Size(32' 64);                              break;                      }                      break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMSize,The following statement contains a magic number: switch (shape)              {                  case 0x00:  // Square                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 8);                              break;                          case 0x01:                              imageSize = new Size(16' 16);                              break;                          case 0x02:                              imageSize = new Size(32' 32);                              break;                          case 0x03:                              imageSize = new Size(64' 64);                              break;                      }                      break;                  case 0x01:  // Horizontal                      switch (size)                      {                          case 0x00:                              imageSize = new Size(16' 8);                              break;                          case 0x01:                              imageSize = new Size(32' 8);                              break;                          case 0x02:                              imageSize = new Size(32' 16);                              break;                          case 0x03:                              imageSize = new Size(64' 32);                              break;                      }                      break;                  case 0x02:  // Vertical                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 16);                              break;                          case 0x01:                              imageSize = new Size(8' 32);                              break;                          case 0x02:                              imageSize = new Size(16' 32);                              break;                          case 0x03:                              imageSize = new Size(32' 64);                              break;                      }                      break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMSize,The following statement contains a magic number: switch (shape)              {                  case 0x00:  // Square                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 8);                              break;                          case 0x01:                              imageSize = new Size(16' 16);                              break;                          case 0x02:                              imageSize = new Size(32' 32);                              break;                          case 0x03:                              imageSize = new Size(64' 64);                              break;                      }                      break;                  case 0x01:  // Horizontal                      switch (size)                      {                          case 0x00:                              imageSize = new Size(16' 8);                              break;                          case 0x01:                              imageSize = new Size(32' 8);                              break;                          case 0x02:                              imageSize = new Size(32' 16);                              break;                          case 0x03:                              imageSize = new Size(64' 32);                              break;                      }                      break;                  case 0x02:  // Vertical                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 16);                              break;                          case 0x01:                              imageSize = new Size(8' 32);                              break;                          case 0x02:                              imageSize = new Size(16' 32);                              break;                          case 0x03:                              imageSize = new Size(32' 64);                              break;                      }                      break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMSize,The following statement contains a magic number: switch (shape)              {                  case 0x00:  // Square                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 8);                              break;                          case 0x01:                              imageSize = new Size(16' 16);                              break;                          case 0x02:                              imageSize = new Size(32' 32);                              break;                          case 0x03:                              imageSize = new Size(64' 64);                              break;                      }                      break;                  case 0x01:  // Horizontal                      switch (size)                      {                          case 0x00:                              imageSize = new Size(16' 8);                              break;                          case 0x01:                              imageSize = new Size(32' 8);                              break;                          case 0x02:                              imageSize = new Size(32' 16);                              break;                          case 0x03:                              imageSize = new Size(64' 32);                              break;                      }                      break;                  case 0x02:  // Vertical                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 16);                              break;                          case 0x01:                              imageSize = new Size(8' 32);                              break;                          case 0x02:                              imageSize = new Size(16' 32);                              break;                          case 0x03:                              imageSize = new Size(32' 64);                              break;                      }                      break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMSize,The following statement contains a magic number: switch (shape)              {                  case 0x00:  // Square                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 8);                              break;                          case 0x01:                              imageSize = new Size(16' 16);                              break;                          case 0x02:                              imageSize = new Size(32' 32);                              break;                          case 0x03:                              imageSize = new Size(64' 64);                              break;                      }                      break;                  case 0x01:  // Horizontal                      switch (size)                      {                          case 0x00:                              imageSize = new Size(16' 8);                              break;                          case 0x01:                              imageSize = new Size(32' 8);                              break;                          case 0x02:                              imageSize = new Size(32' 16);                              break;                          case 0x03:                              imageSize = new Size(64' 32);                              break;                      }                      break;                  case 0x02:  // Vertical                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 16);                              break;                          case 0x01:                              imageSize = new Size(8' 32);                              break;                          case 0x02:                              imageSize = new Size(16' 32);                              break;                          case 0x03:                              imageSize = new Size(32' 64);                              break;                      }                      break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMSize,The following statement contains a magic number: switch (shape)              {                  case 0x00:  // Square                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 8);                              break;                          case 0x01:                              imageSize = new Size(16' 16);                              break;                          case 0x02:                              imageSize = new Size(32' 32);                              break;                          case 0x03:                              imageSize = new Size(64' 64);                              break;                      }                      break;                  case 0x01:  // Horizontal                      switch (size)                      {                          case 0x00:                              imageSize = new Size(16' 8);                              break;                          case 0x01:                              imageSize = new Size(32' 8);                              break;                          case 0x02:                              imageSize = new Size(32' 16);                              break;                          case 0x03:                              imageSize = new Size(64' 32);                              break;                      }                      break;                  case 0x02:  // Vertical                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 16);                              break;                          case 0x01:                              imageSize = new Size(8' 32);                              break;                          case 0x02:                              imageSize = new Size(16' 32);                              break;                          case 0x03:                              imageSize = new Size(32' 64);                              break;                      }                      break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMSize,The following statement contains a magic number: switch (shape)              {                  case 0x00:  // Square                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 8);                              break;                          case 0x01:                              imageSize = new Size(16' 16);                              break;                          case 0x02:                              imageSize = new Size(32' 32);                              break;                          case 0x03:                              imageSize = new Size(64' 64);                              break;                      }                      break;                  case 0x01:  // Horizontal                      switch (size)                      {                          case 0x00:                              imageSize = new Size(16' 8);                              break;                          case 0x01:                              imageSize = new Size(32' 8);                              break;                          case 0x02:                              imageSize = new Size(32' 16);                              break;                          case 0x03:                              imageSize = new Size(64' 32);                              break;                      }                      break;                  case 0x02:  // Vertical                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 16);                              break;                          case 0x01:                              imageSize = new Size(8' 32);                              break;                          case 0x02:                              imageSize = new Size(16' 32);                              break;                          case 0x03:                              imageSize = new Size(32' 64);                              break;                      }                      break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMSize,The following statement contains a magic number: switch (shape)              {                  case 0x00:  // Square                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 8);                              break;                          case 0x01:                              imageSize = new Size(16' 16);                              break;                          case 0x02:                              imageSize = new Size(32' 32);                              break;                          case 0x03:                              imageSize = new Size(64' 64);                              break;                      }                      break;                  case 0x01:  // Horizontal                      switch (size)                      {                          case 0x00:                              imageSize = new Size(16' 8);                              break;                          case 0x01:                              imageSize = new Size(32' 8);                              break;                          case 0x02:                              imageSize = new Size(32' 16);                              break;                          case 0x03:                              imageSize = new Size(64' 32);                              break;                      }                      break;                  case 0x02:  // Vertical                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 16);                              break;                          case 0x01:                              imageSize = new Size(8' 32);                              break;                          case 0x02:                              imageSize = new Size(16' 32);                              break;                          case 0x03:                              imageSize = new Size(32' 64);                              break;                      }                      break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMSize,The following statement contains a magic number: switch (shape)              {                  case 0x00:  // Square                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 8);                              break;                          case 0x01:                              imageSize = new Size(16' 16);                              break;                          case 0x02:                              imageSize = new Size(32' 32);                              break;                          case 0x03:                              imageSize = new Size(64' 64);                              break;                      }                      break;                  case 0x01:  // Horizontal                      switch (size)                      {                          case 0x00:                              imageSize = new Size(16' 8);                              break;                          case 0x01:                              imageSize = new Size(32' 8);                              break;                          case 0x02:                              imageSize = new Size(32' 16);                              break;                          case 0x03:                              imageSize = new Size(64' 32);                              break;                      }                      break;                  case 0x02:  // Vertical                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 16);                              break;                          case 0x01:                              imageSize = new Size(8' 32);                              break;                          case 0x02:                              imageSize = new Size(16' 32);                              break;                          case 0x03:                              imageSize = new Size(32' 64);                              break;                      }                      break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMSize,The following statement contains a magic number: switch (shape)              {                  case 0x00:  // Square                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 8);                              break;                          case 0x01:                              imageSize = new Size(16' 16);                              break;                          case 0x02:                              imageSize = new Size(32' 32);                              break;                          case 0x03:                              imageSize = new Size(64' 64);                              break;                      }                      break;                  case 0x01:  // Horizontal                      switch (size)                      {                          case 0x00:                              imageSize = new Size(16' 8);                              break;                          case 0x01:                              imageSize = new Size(32' 8);                              break;                          case 0x02:                              imageSize = new Size(32' 16);                              break;                          case 0x03:                              imageSize = new Size(64' 32);                              break;                      }                      break;                  case 0x02:  // Vertical                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 16);                              break;                          case 0x01:                              imageSize = new Size(8' 32);                              break;                          case 0x02:                              imageSize = new Size(16' 32);                              break;                          case 0x03:                              imageSize = new Size(32' 64);                              break;                      }                      break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMSize,The following statement contains a magic number: switch (shape)              {                  case 0x00:  // Square                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 8);                              break;                          case 0x01:                              imageSize = new Size(16' 16);                              break;                          case 0x02:                              imageSize = new Size(32' 32);                              break;                          case 0x03:                              imageSize = new Size(64' 64);                              break;                      }                      break;                  case 0x01:  // Horizontal                      switch (size)                      {                          case 0x00:                              imageSize = new Size(16' 8);                              break;                          case 0x01:                              imageSize = new Size(32' 8);                              break;                          case 0x02:                              imageSize = new Size(32' 16);                              break;                          case 0x03:                              imageSize = new Size(64' 32);                              break;                      }                      break;                  case 0x02:  // Vertical                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 16);                              break;                          case 0x01:                              imageSize = new Size(8' 32);                              break;                          case 0x02:                              imageSize = new Size(16' 32);                              break;                          case 0x03:                              imageSize = new Size(32' 64);                              break;                      }                      break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMSize,The following statement contains a magic number: switch (shape)              {                  case 0x00:  // Square                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 8);                              break;                          case 0x01:                              imageSize = new Size(16' 16);                              break;                          case 0x02:                              imageSize = new Size(32' 32);                              break;                          case 0x03:                              imageSize = new Size(64' 64);                              break;                      }                      break;                  case 0x01:  // Horizontal                      switch (size)                      {                          case 0x00:                              imageSize = new Size(16' 8);                              break;                          case 0x01:                              imageSize = new Size(32' 8);                              break;                          case 0x02:                              imageSize = new Size(32' 16);                              break;                          case 0x03:                              imageSize = new Size(64' 32);                              break;                      }                      break;                  case 0x02:  // Vertical                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 16);                              break;                          case 0x01:                              imageSize = new Size(8' 32);                              break;                          case 0x02:                              imageSize = new Size(16' 32);                              break;                          case 0x03:                              imageSize = new Size(32' 64);                              break;                      }                      break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMSize,The following statement contains a magic number: switch (shape)              {                  case 0x00:  // Square                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 8);                              break;                          case 0x01:                              imageSize = new Size(16' 16);                              break;                          case 0x02:                              imageSize = new Size(32' 32);                              break;                          case 0x03:                              imageSize = new Size(64' 64);                              break;                      }                      break;                  case 0x01:  // Horizontal                      switch (size)                      {                          case 0x00:                              imageSize = new Size(16' 8);                              break;                          case 0x01:                              imageSize = new Size(32' 8);                              break;                          case 0x02:                              imageSize = new Size(32' 16);                              break;                          case 0x03:                              imageSize = new Size(64' 32);                              break;                      }                      break;                  case 0x02:  // Vertical                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 16);                              break;                          case 0x01:                              imageSize = new Size(8' 32);                              break;                          case 0x02:                              imageSize = new Size(16' 32);                              break;                          case 0x03:                              imageSize = new Size(32' 64);                              break;                      }                      break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMSize,The following statement contains a magic number: switch (shape)              {                  case 0x00:  // Square                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 8);                              break;                          case 0x01:                              imageSize = new Size(16' 16);                              break;                          case 0x02:                              imageSize = new Size(32' 32);                              break;                          case 0x03:                              imageSize = new Size(64' 64);                              break;                      }                      break;                  case 0x01:  // Horizontal                      switch (size)                      {                          case 0x00:                              imageSize = new Size(16' 8);                              break;                          case 0x01:                              imageSize = new Size(32' 8);                              break;                          case 0x02:                              imageSize = new Size(32' 16);                              break;                          case 0x03:                              imageSize = new Size(64' 32);                              break;                      }                      break;                  case 0x02:  // Vertical                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 16);                              break;                          case 0x01:                              imageSize = new Size(8' 32);                              break;                          case 0x02:                              imageSize = new Size(16' 32);                              break;                          case 0x03:                              imageSize = new Size(32' 64);                              break;                      }                      break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMSize,The following statement contains a magic number: switch (shape)              {                  case 0x00:  // Square                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 8);                              break;                          case 0x01:                              imageSize = new Size(16' 16);                              break;                          case 0x02:                              imageSize = new Size(32' 32);                              break;                          case 0x03:                              imageSize = new Size(64' 64);                              break;                      }                      break;                  case 0x01:  // Horizontal                      switch (size)                      {                          case 0x00:                              imageSize = new Size(16' 8);                              break;                          case 0x01:                              imageSize = new Size(32' 8);                              break;                          case 0x02:                              imageSize = new Size(32' 16);                              break;                          case 0x03:                              imageSize = new Size(64' 32);                              break;                      }                      break;                  case 0x02:  // Vertical                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 16);                              break;                          case 0x01:                              imageSize = new Size(8' 32);                              break;                          case 0x02:                              imageSize = new Size(16' 32);                              break;                          case 0x03:                              imageSize = new Size(32' 64);                              break;                      }                      break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMSize,The following statement contains a magic number: switch (shape)              {                  case 0x00:  // Square                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 8);                              break;                          case 0x01:                              imageSize = new Size(16' 16);                              break;                          case 0x02:                              imageSize = new Size(32' 32);                              break;                          case 0x03:                              imageSize = new Size(64' 64);                              break;                      }                      break;                  case 0x01:  // Horizontal                      switch (size)                      {                          case 0x00:                              imageSize = new Size(16' 8);                              break;                          case 0x01:                              imageSize = new Size(32' 8);                              break;                          case 0x02:                              imageSize = new Size(32' 16);                              break;                          case 0x03:                              imageSize = new Size(64' 32);                              break;                      }                      break;                  case 0x02:  // Vertical                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 16);                              break;                          case 0x01:                              imageSize = new Size(8' 32);                              break;                          case 0x02:                              imageSize = new Size(16' 32);                              break;                          case 0x03:                              imageSize = new Size(32' 64);                              break;                      }                      break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMSize,The following statement contains a magic number: switch (shape)              {                  case 0x00:  // Square                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 8);                              break;                          case 0x01:                              imageSize = new Size(16' 16);                              break;                          case 0x02:                              imageSize = new Size(32' 32);                              break;                          case 0x03:                              imageSize = new Size(64' 64);                              break;                      }                      break;                  case 0x01:  // Horizontal                      switch (size)                      {                          case 0x00:                              imageSize = new Size(16' 8);                              break;                          case 0x01:                              imageSize = new Size(32' 8);                              break;                          case 0x02:                              imageSize = new Size(32' 16);                              break;                          case 0x03:                              imageSize = new Size(64' 32);                              break;                      }                      break;                  case 0x02:  // Vertical                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 16);                              break;                          case 0x01:                              imageSize = new Size(8' 32);                              break;                          case 0x02:                              imageSize = new Size(16' 32);                              break;                          case 0x03:                              imageSize = new Size(32' 64);                              break;                      }                      break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMSize,The following statement contains a magic number: switch (shape)              {                  case 0x00:  // Square                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 8);                              break;                          case 0x01:                              imageSize = new Size(16' 16);                              break;                          case 0x02:                              imageSize = new Size(32' 32);                              break;                          case 0x03:                              imageSize = new Size(64' 64);                              break;                      }                      break;                  case 0x01:  // Horizontal                      switch (size)                      {                          case 0x00:                              imageSize = new Size(16' 8);                              break;                          case 0x01:                              imageSize = new Size(32' 8);                              break;                          case 0x02:                              imageSize = new Size(32' 16);                              break;                          case 0x03:                              imageSize = new Size(64' 32);                              break;                      }                      break;                  case 0x02:  // Vertical                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 16);                              break;                          case 0x01:                              imageSize = new Size(8' 32);                              break;                          case 0x02:                              imageSize = new Size(16' 32);                              break;                          case 0x03:                              imageSize = new Size(32' 64);                              break;                      }                      break;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: if (bank.oams.Length == 0)              {                  graphic.DrawString("No OAM"' SystemFonts.CaptionFont' Brushes.Black' new PointF(max_width / 2' max_height / 2));                  return bank_img;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: if (bank.oams.Length == 0)              {                  graphic.DrawString("No OAM"' SystemFonts.CaptionFont' Brushes.Black' new PointF(max_width / 2' max_height / 2));                  return bank_img;              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: if (draw_grid)              {                  for (int i = (0 - size.Width); i < size.Width; i += 8)                  {                      graphic.DrawLine(Pens.LightBlue' (i + size.Width / 2) * zoom' 0' (i + size.Width / 2) * zoom' size.Height * zoom);                      graphic.DrawLine(Pens.LightBlue' 0' (i + size.Height / 2) * zoom' size.Width * zoom' (i + size.Height / 2) * zoom);                  }                  graphic.DrawLine(Pens.Blue' (max_width / 2) * zoom' 0' (max_width / 2) * zoom' max_height * zoom);                  graphic.DrawLine(Pens.Blue' 0' (max_height / 2) * zoom' max_width * zoom' (max_height / 2) * zoom);              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: if (draw_grid)              {                  for (int i = (0 - size.Width); i < size.Width; i += 8)                  {                      graphic.DrawLine(Pens.LightBlue' (i + size.Width / 2) * zoom' 0' (i + size.Width / 2) * zoom' size.Height * zoom);                      graphic.DrawLine(Pens.LightBlue' 0' (i + size.Height / 2) * zoom' size.Width * zoom' (i + size.Height / 2) * zoom);                  }                  graphic.DrawLine(Pens.Blue' (max_width / 2) * zoom' 0' (max_width / 2) * zoom' max_height * zoom);                  graphic.DrawLine(Pens.Blue' 0' (max_height / 2) * zoom' max_width * zoom' (max_height / 2) * zoom);              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: if (draw_grid)              {                  for (int i = (0 - size.Width); i < size.Width; i += 8)                  {                      graphic.DrawLine(Pens.LightBlue' (i + size.Width / 2) * zoom' 0' (i + size.Width / 2) * zoom' size.Height * zoom);                      graphic.DrawLine(Pens.LightBlue' 0' (i + size.Height / 2) * zoom' size.Width * zoom' (i + size.Height / 2) * zoom);                  }                  graphic.DrawLine(Pens.Blue' (max_width / 2) * zoom' 0' (max_width / 2) * zoom' max_height * zoom);                  graphic.DrawLine(Pens.Blue' 0' (max_height / 2) * zoom' max_width * zoom' (max_height / 2) * zoom);              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: if (draw_grid)              {                  for (int i = (0 - size.Width); i < size.Width; i += 8)                  {                      graphic.DrawLine(Pens.LightBlue' (i + size.Width / 2) * zoom' 0' (i + size.Width / 2) * zoom' size.Height * zoom);                      graphic.DrawLine(Pens.LightBlue' 0' (i + size.Height / 2) * zoom' size.Width * zoom' (i + size.Height / 2) * zoom);                  }                  graphic.DrawLine(Pens.Blue' (max_width / 2) * zoom' 0' (max_width / 2) * zoom' max_height * zoom);                  graphic.DrawLine(Pens.Blue' 0' (max_height / 2) * zoom' max_width * zoom' (max_height / 2) * zoom);              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: if (draw_grid)              {                  for (int i = (0 - size.Width); i < size.Width; i += 8)                  {                      graphic.DrawLine(Pens.LightBlue' (i + size.Width / 2) * zoom' 0' (i + size.Width / 2) * zoom' size.Height * zoom);                      graphic.DrawLine(Pens.LightBlue' 0' (i + size.Height / 2) * zoom' size.Width * zoom' (i + size.Height / 2) * zoom);                  }                  graphic.DrawLine(Pens.Blue' (max_width / 2) * zoom' 0' (max_width / 2) * zoom' max_height * zoom);                  graphic.DrawLine(Pens.Blue' 0' (max_height / 2) * zoom' max_width * zoom' (max_height / 2) * zoom);              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: if (draw_grid)              {                  for (int i = (0 - size.Width); i < size.Width; i += 8)                  {                      graphic.DrawLine(Pens.LightBlue' (i + size.Width / 2) * zoom' 0' (i + size.Width / 2) * zoom' size.Height * zoom);                      graphic.DrawLine(Pens.LightBlue' 0' (i + size.Height / 2) * zoom' size.Width * zoom' (i + size.Height / 2) * zoom);                  }                  graphic.DrawLine(Pens.Blue' (max_width / 2) * zoom' 0' (max_width / 2) * zoom' max_height * zoom);                  graphic.DrawLine(Pens.Blue' 0' (max_height / 2) * zoom' max_width * zoom' (max_height / 2) * zoom);              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: if (draw_grid)              {                  for (int i = (0 - size.Width); i < size.Width; i += 8)                  {                      graphic.DrawLine(Pens.LightBlue' (i + size.Width / 2) * zoom' 0' (i + size.Width / 2) * zoom' size.Height * zoom);                      graphic.DrawLine(Pens.LightBlue' 0' (i + size.Height / 2) * zoom' size.Width * zoom' (i + size.Height / 2) * zoom);                  }                  graphic.DrawLine(Pens.Blue' (max_width / 2) * zoom' 0' (max_width / 2) * zoom' max_height * zoom);                  graphic.DrawLine(Pens.Blue' 0' (max_height / 2) * zoom' max_width * zoom' (max_height / 2) * zoom);              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: if (draw_grid)              {                  for (int i = (0 - size.Width); i < size.Width; i += 8)                  {                      graphic.DrawLine(Pens.LightBlue' (i + size.Width / 2) * zoom' 0' (i + size.Width / 2) * zoom' size.Height * zoom);                      graphic.DrawLine(Pens.LightBlue' 0' (i + size.Height / 2) * zoom' size.Width * zoom' (i + size.Height / 2) * zoom);                  }                  graphic.DrawLine(Pens.Blue' (max_width / 2) * zoom' 0' (max_width / 2) * zoom' max_height * zoom);                  graphic.DrawLine(Pens.Blue' 0' (max_height / 2) * zoom' max_width * zoom' (max_height / 2) * zoom);              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: if (draw_grid)              {                  for (int i = (0 - size.Width); i < size.Width; i += 8)                  {                      graphic.DrawLine(Pens.LightBlue' (i + size.Width / 2) * zoom' 0' (i + size.Width / 2) * zoom' size.Height * zoom);                      graphic.DrawLine(Pens.LightBlue' 0' (i + size.Height / 2) * zoom' size.Width * zoom' (i + size.Height / 2) * zoom);                  }                  graphic.DrawLine(Pens.Blue' (max_width / 2) * zoom' 0' (max_width / 2) * zoom' max_height * zoom);                  graphic.DrawLine(Pens.Blue' 0' (max_height / 2) * zoom' max_width * zoom' (max_height / 2) * zoom);              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: for (int i = 0; i < bank.oams.Length; i++)              {                  bool draw = false;                  if (index == null)                      draw = true;                  else                      for (int k = 0; k < index.Length; k++)                          if (index[k] == i)                              draw = true;                  if (!draw)                      continue;                        if (bank.oams[i].width == 0x00 || bank.oams[i].height == 0x00)                      continue;                    uint tileOffset = bank.oams[i].obj2.tileOffset;                  tileOffset = (uint)(tileOffset << (byte)blockSize);                    if (image)                  {                      ImageBase cell_img = new TestImage();                      cell_img.Set_Tiles((byte[])img.Tiles.Clone()' bank.oams[i].width' bank.oams[i].height' img.FormatColor'                                         img.FormTile' false);                      cell_img.StartByte = (int)(tileOffset * 0x20 + bank.data_offset);                        byte num_pal = bank.oams[i].obj2.index_palette;                      if (num_pal >= pal.NumberOfPalettes)                          num_pal = 0;                      for (int j = 0; j < cell_img.TilesPalette.Length; j++)                          cell_img.TilesPalette[j] = num_pal;                        cell = cell_img.Get_Image(pal);                      //else                      //{                      //    tileOffset /= (blockSize / 2);                      //    int imageWidth = img.Width;                      //    int imageHeight = img.Height;                        //    int posX = (int)(tileOffset % imageWidth);                      //    int posY = (int)(tileOffset / imageWidth);                        //    if (img.ColorFormat == ColorFormat.colors16)                      //        posY *= (int)blockSize * 2;                      //    else                      //        posY *= (int)blockSize;                      //    if (posY >= imageHeight)                      //        posY = posY % imageHeight;                        //    cells[i] = ((Bitmap)img.Get_Image(pal)).Clone(new Rectangle(posX * zoom' posY * zoom' bank.oams[i].width * zoom' bank.oams[i].height * zoom)'                      //                                                System.Drawing.Imaging.PixelFormat.DontCare);                      //}                        #region Flip                      if (bank.oams[i].obj1.flipX == 1 && bank.oams[i].obj1.flipY == 1)                          cell.RotateFlip(RotateFlipType.RotateNoneFlipXY);                      else if (bank.oams[i].obj1.flipX == 1)                          cell.RotateFlip(RotateFlipType.RotateNoneFlipX);                      else if (bank.oams[i].obj1.flipY == 1)                          cell.RotateFlip(RotateFlipType.RotateNoneFlipY);                      #endregion                        if (trans)                          ((Bitmap)cell).MakeTransparent(pal.Palette[num_pal][0]);                        graphic.DrawImageUnscaled(cell' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom);                  }                    if (draw_cells)                      graphic.DrawRectangle(Pens.Black' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom'                          bank.oams[i].width * zoom' bank.oams[i].height * zoom);                  if (i == currOAM)                      graphic.DrawRectangle(new Pen(Color.Red' 3)' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom'                          bank.oams[i].width * zoom' bank.oams[i].height * zoom);                  if (draw_numbers)                      graphic.DrawString(bank.oams[i].num_cell.ToString()' SystemFonts.CaptionFont' Brushes.Black' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom'                          size.Height / 2 + bank.oams[i].obj0.yOffset * zoom);              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: for (int i = 0; i < bank.oams.Length; i++)              {                  bool draw = false;                  if (index == null)                      draw = true;                  else                      for (int k = 0; k < index.Length; k++)                          if (index[k] == i)                              draw = true;                  if (!draw)                      continue;                        if (bank.oams[i].width == 0x00 || bank.oams[i].height == 0x00)                      continue;                    uint tileOffset = bank.oams[i].obj2.tileOffset;                  tileOffset = (uint)(tileOffset << (byte)blockSize);                    if (image)                  {                      ImageBase cell_img = new TestImage();                      cell_img.Set_Tiles((byte[])img.Tiles.Clone()' bank.oams[i].width' bank.oams[i].height' img.FormatColor'                                         img.FormTile' false);                      cell_img.StartByte = (int)(tileOffset * 0x20 + bank.data_offset);                        byte num_pal = bank.oams[i].obj2.index_palette;                      if (num_pal >= pal.NumberOfPalettes)                          num_pal = 0;                      for (int j = 0; j < cell_img.TilesPalette.Length; j++)                          cell_img.TilesPalette[j] = num_pal;                        cell = cell_img.Get_Image(pal);                      //else                      //{                      //    tileOffset /= (blockSize / 2);                      //    int imageWidth = img.Width;                      //    int imageHeight = img.Height;                        //    int posX = (int)(tileOffset % imageWidth);                      //    int posY = (int)(tileOffset / imageWidth);                        //    if (img.ColorFormat == ColorFormat.colors16)                      //        posY *= (int)blockSize * 2;                      //    else                      //        posY *= (int)blockSize;                      //    if (posY >= imageHeight)                      //        posY = posY % imageHeight;                        //    cells[i] = ((Bitmap)img.Get_Image(pal)).Clone(new Rectangle(posX * zoom' posY * zoom' bank.oams[i].width * zoom' bank.oams[i].height * zoom)'                      //                                                System.Drawing.Imaging.PixelFormat.DontCare);                      //}                        #region Flip                      if (bank.oams[i].obj1.flipX == 1 && bank.oams[i].obj1.flipY == 1)                          cell.RotateFlip(RotateFlipType.RotateNoneFlipXY);                      else if (bank.oams[i].obj1.flipX == 1)                          cell.RotateFlip(RotateFlipType.RotateNoneFlipX);                      else if (bank.oams[i].obj1.flipY == 1)                          cell.RotateFlip(RotateFlipType.RotateNoneFlipY);                      #endregion                        if (trans)                          ((Bitmap)cell).MakeTransparent(pal.Palette[num_pal][0]);                        graphic.DrawImageUnscaled(cell' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom);                  }                    if (draw_cells)                      graphic.DrawRectangle(Pens.Black' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom'                          bank.oams[i].width * zoom' bank.oams[i].height * zoom);                  if (i == currOAM)                      graphic.DrawRectangle(new Pen(Color.Red' 3)' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom'                          bank.oams[i].width * zoom' bank.oams[i].height * zoom);                  if (draw_numbers)                      graphic.DrawString(bank.oams[i].num_cell.ToString()' SystemFonts.CaptionFont' Brushes.Black' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom'                          size.Height / 2 + bank.oams[i].obj0.yOffset * zoom);              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: for (int i = 0; i < bank.oams.Length; i++)              {                  bool draw = false;                  if (index == null)                      draw = true;                  else                      for (int k = 0; k < index.Length; k++)                          if (index[k] == i)                              draw = true;                  if (!draw)                      continue;                        if (bank.oams[i].width == 0x00 || bank.oams[i].height == 0x00)                      continue;                    uint tileOffset = bank.oams[i].obj2.tileOffset;                  tileOffset = (uint)(tileOffset << (byte)blockSize);                    if (image)                  {                      ImageBase cell_img = new TestImage();                      cell_img.Set_Tiles((byte[])img.Tiles.Clone()' bank.oams[i].width' bank.oams[i].height' img.FormatColor'                                         img.FormTile' false);                      cell_img.StartByte = (int)(tileOffset * 0x20 + bank.data_offset);                        byte num_pal = bank.oams[i].obj2.index_palette;                      if (num_pal >= pal.NumberOfPalettes)                          num_pal = 0;                      for (int j = 0; j < cell_img.TilesPalette.Length; j++)                          cell_img.TilesPalette[j] = num_pal;                        cell = cell_img.Get_Image(pal);                      //else                      //{                      //    tileOffset /= (blockSize / 2);                      //    int imageWidth = img.Width;                      //    int imageHeight = img.Height;                        //    int posX = (int)(tileOffset % imageWidth);                      //    int posY = (int)(tileOffset / imageWidth);                        //    if (img.ColorFormat == ColorFormat.colors16)                      //        posY *= (int)blockSize * 2;                      //    else                      //        posY *= (int)blockSize;                      //    if (posY >= imageHeight)                      //        posY = posY % imageHeight;                        //    cells[i] = ((Bitmap)img.Get_Image(pal)).Clone(new Rectangle(posX * zoom' posY * zoom' bank.oams[i].width * zoom' bank.oams[i].height * zoom)'                      //                                                System.Drawing.Imaging.PixelFormat.DontCare);                      //}                        #region Flip                      if (bank.oams[i].obj1.flipX == 1 && bank.oams[i].obj1.flipY == 1)                          cell.RotateFlip(RotateFlipType.RotateNoneFlipXY);                      else if (bank.oams[i].obj1.flipX == 1)                          cell.RotateFlip(RotateFlipType.RotateNoneFlipX);                      else if (bank.oams[i].obj1.flipY == 1)                          cell.RotateFlip(RotateFlipType.RotateNoneFlipY);                      #endregion                        if (trans)                          ((Bitmap)cell).MakeTransparent(pal.Palette[num_pal][0]);                        graphic.DrawImageUnscaled(cell' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom);                  }                    if (draw_cells)                      graphic.DrawRectangle(Pens.Black' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom'                          bank.oams[i].width * zoom' bank.oams[i].height * zoom);                  if (i == currOAM)                      graphic.DrawRectangle(new Pen(Color.Red' 3)' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom'                          bank.oams[i].width * zoom' bank.oams[i].height * zoom);                  if (draw_numbers)                      graphic.DrawString(bank.oams[i].num_cell.ToString()' SystemFonts.CaptionFont' Brushes.Black' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom'                          size.Height / 2 + bank.oams[i].obj0.yOffset * zoom);              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: for (int i = 0; i < bank.oams.Length; i++)              {                  bool draw = false;                  if (index == null)                      draw = true;                  else                      for (int k = 0; k < index.Length; k++)                          if (index[k] == i)                              draw = true;                  if (!draw)                      continue;                        if (bank.oams[i].width == 0x00 || bank.oams[i].height == 0x00)                      continue;                    uint tileOffset = bank.oams[i].obj2.tileOffset;                  tileOffset = (uint)(tileOffset << (byte)blockSize);                    if (image)                  {                      ImageBase cell_img = new TestImage();                      cell_img.Set_Tiles((byte[])img.Tiles.Clone()' bank.oams[i].width' bank.oams[i].height' img.FormatColor'                                         img.FormTile' false);                      cell_img.StartByte = (int)(tileOffset * 0x20 + bank.data_offset);                        byte num_pal = bank.oams[i].obj2.index_palette;                      if (num_pal >= pal.NumberOfPalettes)                          num_pal = 0;                      for (int j = 0; j < cell_img.TilesPalette.Length; j++)                          cell_img.TilesPalette[j] = num_pal;                        cell = cell_img.Get_Image(pal);                      //else                      //{                      //    tileOffset /= (blockSize / 2);                      //    int imageWidth = img.Width;                      //    int imageHeight = img.Height;                        //    int posX = (int)(tileOffset % imageWidth);                      //    int posY = (int)(tileOffset / imageWidth);                        //    if (img.ColorFormat == ColorFormat.colors16)                      //        posY *= (int)blockSize * 2;                      //    else                      //        posY *= (int)blockSize;                      //    if (posY >= imageHeight)                      //        posY = posY % imageHeight;                        //    cells[i] = ((Bitmap)img.Get_Image(pal)).Clone(new Rectangle(posX * zoom' posY * zoom' bank.oams[i].width * zoom' bank.oams[i].height * zoom)'                      //                                                System.Drawing.Imaging.PixelFormat.DontCare);                      //}                        #region Flip                      if (bank.oams[i].obj1.flipX == 1 && bank.oams[i].obj1.flipY == 1)                          cell.RotateFlip(RotateFlipType.RotateNoneFlipXY);                      else if (bank.oams[i].obj1.flipX == 1)                          cell.RotateFlip(RotateFlipType.RotateNoneFlipX);                      else if (bank.oams[i].obj1.flipY == 1)                          cell.RotateFlip(RotateFlipType.RotateNoneFlipY);                      #endregion                        if (trans)                          ((Bitmap)cell).MakeTransparent(pal.Palette[num_pal][0]);                        graphic.DrawImageUnscaled(cell' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom);                  }                    if (draw_cells)                      graphic.DrawRectangle(Pens.Black' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom'                          bank.oams[i].width * zoom' bank.oams[i].height * zoom);                  if (i == currOAM)                      graphic.DrawRectangle(new Pen(Color.Red' 3)' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom'                          bank.oams[i].width * zoom' bank.oams[i].height * zoom);                  if (draw_numbers)                      graphic.DrawString(bank.oams[i].num_cell.ToString()' SystemFonts.CaptionFont' Brushes.Black' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom'                          size.Height / 2 + bank.oams[i].obj0.yOffset * zoom);              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: for (int i = 0; i < bank.oams.Length; i++)              {                  bool draw = false;                  if (index == null)                      draw = true;                  else                      for (int k = 0; k < index.Length; k++)                          if (index[k] == i)                              draw = true;                  if (!draw)                      continue;                        if (bank.oams[i].width == 0x00 || bank.oams[i].height == 0x00)                      continue;                    uint tileOffset = bank.oams[i].obj2.tileOffset;                  tileOffset = (uint)(tileOffset << (byte)blockSize);                    if (image)                  {                      ImageBase cell_img = new TestImage();                      cell_img.Set_Tiles((byte[])img.Tiles.Clone()' bank.oams[i].width' bank.oams[i].height' img.FormatColor'                                         img.FormTile' false);                      cell_img.StartByte = (int)(tileOffset * 0x20 + bank.data_offset);                        byte num_pal = bank.oams[i].obj2.index_palette;                      if (num_pal >= pal.NumberOfPalettes)                          num_pal = 0;                      for (int j = 0; j < cell_img.TilesPalette.Length; j++)                          cell_img.TilesPalette[j] = num_pal;                        cell = cell_img.Get_Image(pal);                      //else                      //{                      //    tileOffset /= (blockSize / 2);                      //    int imageWidth = img.Width;                      //    int imageHeight = img.Height;                        //    int posX = (int)(tileOffset % imageWidth);                      //    int posY = (int)(tileOffset / imageWidth);                        //    if (img.ColorFormat == ColorFormat.colors16)                      //        posY *= (int)blockSize * 2;                      //    else                      //        posY *= (int)blockSize;                      //    if (posY >= imageHeight)                      //        posY = posY % imageHeight;                        //    cells[i] = ((Bitmap)img.Get_Image(pal)).Clone(new Rectangle(posX * zoom' posY * zoom' bank.oams[i].width * zoom' bank.oams[i].height * zoom)'                      //                                                System.Drawing.Imaging.PixelFormat.DontCare);                      //}                        #region Flip                      if (bank.oams[i].obj1.flipX == 1 && bank.oams[i].obj1.flipY == 1)                          cell.RotateFlip(RotateFlipType.RotateNoneFlipXY);                      else if (bank.oams[i].obj1.flipX == 1)                          cell.RotateFlip(RotateFlipType.RotateNoneFlipX);                      else if (bank.oams[i].obj1.flipY == 1)                          cell.RotateFlip(RotateFlipType.RotateNoneFlipY);                      #endregion                        if (trans)                          ((Bitmap)cell).MakeTransparent(pal.Palette[num_pal][0]);                        graphic.DrawImageUnscaled(cell' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom);                  }                    if (draw_cells)                      graphic.DrawRectangle(Pens.Black' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom'                          bank.oams[i].width * zoom' bank.oams[i].height * zoom);                  if (i == currOAM)                      graphic.DrawRectangle(new Pen(Color.Red' 3)' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom'                          bank.oams[i].width * zoom' bank.oams[i].height * zoom);                  if (draw_numbers)                      graphic.DrawString(bank.oams[i].num_cell.ToString()' SystemFonts.CaptionFont' Brushes.Black' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom'                          size.Height / 2 + bank.oams[i].obj0.yOffset * zoom);              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: for (int i = 0; i < bank.oams.Length; i++)              {                  bool draw = false;                  if (index == null)                      draw = true;                  else                      for (int k = 0; k < index.Length; k++)                          if (index[k] == i)                              draw = true;                  if (!draw)                      continue;                        if (bank.oams[i].width == 0x00 || bank.oams[i].height == 0x00)                      continue;                    uint tileOffset = bank.oams[i].obj2.tileOffset;                  tileOffset = (uint)(tileOffset << (byte)blockSize);                    if (image)                  {                      ImageBase cell_img = new TestImage();                      cell_img.Set_Tiles((byte[])img.Tiles.Clone()' bank.oams[i].width' bank.oams[i].height' img.FormatColor'                                         img.FormTile' false);                      cell_img.StartByte = (int)(tileOffset * 0x20 + bank.data_offset);                        byte num_pal = bank.oams[i].obj2.index_palette;                      if (num_pal >= pal.NumberOfPalettes)                          num_pal = 0;                      for (int j = 0; j < cell_img.TilesPalette.Length; j++)                          cell_img.TilesPalette[j] = num_pal;                        cell = cell_img.Get_Image(pal);                      //else                      //{                      //    tileOffset /= (blockSize / 2);                      //    int imageWidth = img.Width;                      //    int imageHeight = img.Height;                        //    int posX = (int)(tileOffset % imageWidth);                      //    int posY = (int)(tileOffset / imageWidth);                        //    if (img.ColorFormat == ColorFormat.colors16)                      //        posY *= (int)blockSize * 2;                      //    else                      //        posY *= (int)blockSize;                      //    if (posY >= imageHeight)                      //        posY = posY % imageHeight;                        //    cells[i] = ((Bitmap)img.Get_Image(pal)).Clone(new Rectangle(posX * zoom' posY * zoom' bank.oams[i].width * zoom' bank.oams[i].height * zoom)'                      //                                                System.Drawing.Imaging.PixelFormat.DontCare);                      //}                        #region Flip                      if (bank.oams[i].obj1.flipX == 1 && bank.oams[i].obj1.flipY == 1)                          cell.RotateFlip(RotateFlipType.RotateNoneFlipXY);                      else if (bank.oams[i].obj1.flipX == 1)                          cell.RotateFlip(RotateFlipType.RotateNoneFlipX);                      else if (bank.oams[i].obj1.flipY == 1)                          cell.RotateFlip(RotateFlipType.RotateNoneFlipY);                      #endregion                        if (trans)                          ((Bitmap)cell).MakeTransparent(pal.Palette[num_pal][0]);                        graphic.DrawImageUnscaled(cell' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom);                  }                    if (draw_cells)                      graphic.DrawRectangle(Pens.Black' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom'                          bank.oams[i].width * zoom' bank.oams[i].height * zoom);                  if (i == currOAM)                      graphic.DrawRectangle(new Pen(Color.Red' 3)' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom'                          bank.oams[i].width * zoom' bank.oams[i].height * zoom);                  if (draw_numbers)                      graphic.DrawString(bank.oams[i].num_cell.ToString()' SystemFonts.CaptionFont' Brushes.Black' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom'                          size.Height / 2 + bank.oams[i].obj0.yOffset * zoom);              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: for (int i = 0; i < bank.oams.Length; i++)              {                  bool draw = false;                  if (index == null)                      draw = true;                  else                      for (int k = 0; k < index.Length; k++)                          if (index[k] == i)                              draw = true;                  if (!draw)                      continue;                        if (bank.oams[i].width == 0x00 || bank.oams[i].height == 0x00)                      continue;                    uint tileOffset = bank.oams[i].obj2.tileOffset;                  tileOffset = (uint)(tileOffset << (byte)blockSize);                    if (image)                  {                      ImageBase cell_img = new TestImage();                      cell_img.Set_Tiles((byte[])img.Tiles.Clone()' bank.oams[i].width' bank.oams[i].height' img.FormatColor'                                         img.FormTile' false);                      cell_img.StartByte = (int)(tileOffset * 0x20 + bank.data_offset);                        byte num_pal = bank.oams[i].obj2.index_palette;                      if (num_pal >= pal.NumberOfPalettes)                          num_pal = 0;                      for (int j = 0; j < cell_img.TilesPalette.Length; j++)                          cell_img.TilesPalette[j] = num_pal;                        cell = cell_img.Get_Image(pal);                      //else                      //{                      //    tileOffset /= (blockSize / 2);                      //    int imageWidth = img.Width;                      //    int imageHeight = img.Height;                        //    int posX = (int)(tileOffset % imageWidth);                      //    int posY = (int)(tileOffset / imageWidth);                        //    if (img.ColorFormat == ColorFormat.colors16)                      //        posY *= (int)blockSize * 2;                      //    else                      //        posY *= (int)blockSize;                      //    if (posY >= imageHeight)                      //        posY = posY % imageHeight;                        //    cells[i] = ((Bitmap)img.Get_Image(pal)).Clone(new Rectangle(posX * zoom' posY * zoom' bank.oams[i].width * zoom' bank.oams[i].height * zoom)'                      //                                                System.Drawing.Imaging.PixelFormat.DontCare);                      //}                        #region Flip                      if (bank.oams[i].obj1.flipX == 1 && bank.oams[i].obj1.flipY == 1)                          cell.RotateFlip(RotateFlipType.RotateNoneFlipXY);                      else if (bank.oams[i].obj1.flipX == 1)                          cell.RotateFlip(RotateFlipType.RotateNoneFlipX);                      else if (bank.oams[i].obj1.flipY == 1)                          cell.RotateFlip(RotateFlipType.RotateNoneFlipY);                      #endregion                        if (trans)                          ((Bitmap)cell).MakeTransparent(pal.Palette[num_pal][0]);                        graphic.DrawImageUnscaled(cell' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom);                  }                    if (draw_cells)                      graphic.DrawRectangle(Pens.Black' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom'                          bank.oams[i].width * zoom' bank.oams[i].height * zoom);                  if (i == currOAM)                      graphic.DrawRectangle(new Pen(Color.Red' 3)' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom'                          bank.oams[i].width * zoom' bank.oams[i].height * zoom);                  if (draw_numbers)                      graphic.DrawString(bank.oams[i].num_cell.ToString()' SystemFonts.CaptionFont' Brushes.Black' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom'                          size.Height / 2 + bank.oams[i].obj0.yOffset * zoom);              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: for (int i = 0; i < bank.oams.Length; i++)              {                  bool draw = false;                  if (index == null)                      draw = true;                  else                      for (int k = 0; k < index.Length; k++)                          if (index[k] == i)                              draw = true;                  if (!draw)                      continue;                        if (bank.oams[i].width == 0x00 || bank.oams[i].height == 0x00)                      continue;                    uint tileOffset = bank.oams[i].obj2.tileOffset;                  tileOffset = (uint)(tileOffset << (byte)blockSize);                    if (image)                  {                      ImageBase cell_img = new TestImage();                      cell_img.Set_Tiles((byte[])img.Tiles.Clone()' bank.oams[i].width' bank.oams[i].height' img.FormatColor'                                         img.FormTile' false);                      cell_img.StartByte = (int)(tileOffset * 0x20 + bank.data_offset);                        byte num_pal = bank.oams[i].obj2.index_palette;                      if (num_pal >= pal.NumberOfPalettes)                          num_pal = 0;                      for (int j = 0; j < cell_img.TilesPalette.Length; j++)                          cell_img.TilesPalette[j] = num_pal;                        cell = cell_img.Get_Image(pal);                      //else                      //{                      //    tileOffset /= (blockSize / 2);                      //    int imageWidth = img.Width;                      //    int imageHeight = img.Height;                        //    int posX = (int)(tileOffset % imageWidth);                      //    int posY = (int)(tileOffset / imageWidth);                        //    if (img.ColorFormat == ColorFormat.colors16)                      //        posY *= (int)blockSize * 2;                      //    else                      //        posY *= (int)blockSize;                      //    if (posY >= imageHeight)                      //        posY = posY % imageHeight;                        //    cells[i] = ((Bitmap)img.Get_Image(pal)).Clone(new Rectangle(posX * zoom' posY * zoom' bank.oams[i].width * zoom' bank.oams[i].height * zoom)'                      //                                                System.Drawing.Imaging.PixelFormat.DontCare);                      //}                        #region Flip                      if (bank.oams[i].obj1.flipX == 1 && bank.oams[i].obj1.flipY == 1)                          cell.RotateFlip(RotateFlipType.RotateNoneFlipXY);                      else if (bank.oams[i].obj1.flipX == 1)                          cell.RotateFlip(RotateFlipType.RotateNoneFlipX);                      else if (bank.oams[i].obj1.flipY == 1)                          cell.RotateFlip(RotateFlipType.RotateNoneFlipY);                      #endregion                        if (trans)                          ((Bitmap)cell).MakeTransparent(pal.Palette[num_pal][0]);                        graphic.DrawImageUnscaled(cell' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom);                  }                    if (draw_cells)                      graphic.DrawRectangle(Pens.Black' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom'                          bank.oams[i].width * zoom' bank.oams[i].height * zoom);                  if (i == currOAM)                      graphic.DrawRectangle(new Pen(Color.Red' 3)' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom'                          bank.oams[i].width * zoom' bank.oams[i].height * zoom);                  if (draw_numbers)                      graphic.DrawString(bank.oams[i].num_cell.ToString()' SystemFonts.CaptionFont' Brushes.Black' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom'                          size.Height / 2 + bank.oams[i].obj0.yOffset * zoom);              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_Image,The following statement contains a magic number: for (int i = 0; i < bank.oams.Length; i++)              {                  bool draw = false;                  if (index == null)                      draw = true;                  else                      for (int k = 0; k < index.Length; k++)                          if (index[k] == i)                              draw = true;                  if (!draw)                      continue;                        if (bank.oams[i].width == 0x00 || bank.oams[i].height == 0x00)                      continue;                    uint tileOffset = bank.oams[i].obj2.tileOffset;                  tileOffset = (uint)(tileOffset << (byte)blockSize);                    if (image)                  {                      ImageBase cell_img = new TestImage();                      cell_img.Set_Tiles((byte[])img.Tiles.Clone()' bank.oams[i].width' bank.oams[i].height' img.FormatColor'                                         img.FormTile' false);                      cell_img.StartByte = (int)(tileOffset * 0x20 + bank.data_offset);                        byte num_pal = bank.oams[i].obj2.index_palette;                      if (num_pal >= pal.NumberOfPalettes)                          num_pal = 0;                      for (int j = 0; j < cell_img.TilesPalette.Length; j++)                          cell_img.TilesPalette[j] = num_pal;                        cell = cell_img.Get_Image(pal);                      //else                      //{                      //    tileOffset /= (blockSize / 2);                      //    int imageWidth = img.Width;                      //    int imageHeight = img.Height;                        //    int posX = (int)(tileOffset % imageWidth);                      //    int posY = (int)(tileOffset / imageWidth);                        //    if (img.ColorFormat == ColorFormat.colors16)                      //        posY *= (int)blockSize * 2;                      //    else                      //        posY *= (int)blockSize;                      //    if (posY >= imageHeight)                      //        posY = posY % imageHeight;                        //    cells[i] = ((Bitmap)img.Get_Image(pal)).Clone(new Rectangle(posX * zoom' posY * zoom' bank.oams[i].width * zoom' bank.oams[i].height * zoom)'                      //                                                System.Drawing.Imaging.PixelFormat.DontCare);                      //}                        #region Flip                      if (bank.oams[i].obj1.flipX == 1 && bank.oams[i].obj1.flipY == 1)                          cell.RotateFlip(RotateFlipType.RotateNoneFlipXY);                      else if (bank.oams[i].obj1.flipX == 1)                          cell.RotateFlip(RotateFlipType.RotateNoneFlipX);                      else if (bank.oams[i].obj1.flipY == 1)                          cell.RotateFlip(RotateFlipType.RotateNoneFlipY);                      #endregion                        if (trans)                          ((Bitmap)cell).MakeTransparent(pal.Palette[num_pal][0]);                        graphic.DrawImageUnscaled(cell' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom);                  }                    if (draw_cells)                      graphic.DrawRectangle(Pens.Black' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom'                          bank.oams[i].width * zoom' bank.oams[i].height * zoom);                  if (i == currOAM)                      graphic.DrawRectangle(new Pen(Color.Red' 3)' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom' size.Height / 2 + bank.oams[i].obj0.yOffset * zoom'                          bank.oams[i].width * zoom' bank.oams[i].height * zoom);                  if (draw_numbers)                      graphic.DrawString(bank.oams[i].num_cell.ToString()' SystemFonts.CaptionFont' Brushes.Black' size.Width / 2 + bank.oams[i].obj1.xOffset * zoom'                          size.Height / 2 + bank.oams[i].obj0.yOffset * zoom);              }
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMdata,The following statement contains a magic number: int y1 = 128 + oam.obj0.yOffset;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMdata,The following statement contains a magic number: int x1 = 256 + oam.obj1.xOffset;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMdata,The following statement contains a magic number: for (int ht = 0; ht < 256; ht++)                  for (int wt = 0; wt < 512; wt++)                      if (ht >= y1 && ht < y2)                          if (wt >= x1 && wt < x2)                              data.Add(image[wt + ht * 512]);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMdata,The following statement contains a magic number: for (int ht = 0; ht < 256; ht++)                  for (int wt = 0; wt < 512; wt++)                      if (ht >= y1 && ht < y2)                          if (wt >= x1 && wt < x2)                              data.Add(image[wt + ht * 512]);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMdata,The following statement contains a magic number: for (int ht = 0; ht < 256; ht++)                  for (int wt = 0; wt < 512; wt++)                      if (ht >= y1 && ht < y2)                          if (wt >= x1 && wt < x2)                              data.Add(image[wt + ht * 512]);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: ushort[] obj = new ushort[3];
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: obj[0] += (ushort)((oam.obj0.rs_flag & 1) << 8);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: if (oam.obj0.rs_flag == 0x00)                  obj[0] += (ushort)((oam.obj0.objDisable & 1) << 9);              else                  obj[0] += (ushort)((oam.obj0.doubleSize & 1) << 9);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: if (oam.obj0.rs_flag == 0x00)                  obj[0] += (ushort)((oam.obj0.objDisable & 1) << 9);              else                  obj[0] += (ushort)((oam.obj0.doubleSize & 1) << 9);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: obj[0] += (ushort)((oam.obj0.objMode & 3) << 10);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: obj[0] += (ushort)((oam.obj0.objMode & 3) << 10);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: obj[0] += (ushort)((oam.obj0.mosaic_flag & 1) << 12);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: obj[0] += (ushort)((oam.obj0.depth & 1) << 13);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: obj[0] += (ushort)((oam.obj0.shape & 3) << 14);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: obj[0] += (ushort)((oam.obj0.shape & 3) << 14);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: if (oam.obj0.rs_flag == 0)              {                  obj[1] += (ushort)((oam.obj1.unused & 0x7) << 9);                  obj[1] += (ushort)((oam.obj1.flipX & 1) << 12);                  obj[1] += (ushort)((oam.obj1.flipY & 1) << 13);              }              else                  obj[1] += (ushort)((oam.obj1.select_param & 0x1F) << 9);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: if (oam.obj0.rs_flag == 0)              {                  obj[1] += (ushort)((oam.obj1.unused & 0x7) << 9);                  obj[1] += (ushort)((oam.obj1.flipX & 1) << 12);                  obj[1] += (ushort)((oam.obj1.flipY & 1) << 13);              }              else                  obj[1] += (ushort)((oam.obj1.select_param & 0x1F) << 9);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: if (oam.obj0.rs_flag == 0)              {                  obj[1] += (ushort)((oam.obj1.unused & 0x7) << 9);                  obj[1] += (ushort)((oam.obj1.flipX & 1) << 12);                  obj[1] += (ushort)((oam.obj1.flipY & 1) << 13);              }              else                  obj[1] += (ushort)((oam.obj1.select_param & 0x1F) << 9);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: if (oam.obj0.rs_flag == 0)              {                  obj[1] += (ushort)((oam.obj1.unused & 0x7) << 9);                  obj[1] += (ushort)((oam.obj1.flipX & 1) << 12);                  obj[1] += (ushort)((oam.obj1.flipY & 1) << 13);              }              else                  obj[1] += (ushort)((oam.obj1.select_param & 0x1F) << 9);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: obj[1] += (ushort)((oam.obj1.size & 3) << 14);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: obj[1] += (ushort)((oam.obj1.size & 3) << 14);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: obj[2] = 0;
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: obj[2] += (ushort)(oam.obj2.tileOffset & 0x3FF);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: obj[2] += (ushort)((oam.obj2.priority & 3) << 10);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: obj[2] += (ushort)((oam.obj2.priority & 3) << 10);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: obj[2] += (ushort)((oam.obj2.priority & 3) << 10);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: obj[2] += (ushort)((oam.obj2.index_palette & 0xF) << 12);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: obj[2] += (ushort)((oam.obj2.index_palette & 0xF) << 12);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: oam.obj0.rs_flag = (byte)((obj[0] >> 8) & 1);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: if (oam.obj0.rs_flag == 0)                  oam.obj0.objDisable = (byte)((obj[0] >> 9) & 1);              else                  oam.obj0.doubleSize = (byte)((obj[0] >> 9) & 1);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: if (oam.obj0.rs_flag == 0)                  oam.obj0.objDisable = (byte)((obj[0] >> 9) & 1);              else                  oam.obj0.doubleSize = (byte)((obj[0] >> 9) & 1);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: oam.obj0.objMode = (byte)((obj[0] >> 10) & 3);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: oam.obj0.objMode = (byte)((obj[0] >> 10) & 3);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: oam.obj0.mosaic_flag = (byte)((obj[0] >> 12) & 1);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: oam.obj0.depth = (byte)((obj[0] >> 13) & 1);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: oam.obj0.shape = (byte)((obj[0] >> 14) & 3);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: oam.obj0.shape = (byte)((obj[0] >> 14) & 3);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: if (oam.obj0.rs_flag == 0)              {                  oam.obj1.unused = (byte)((obj[1] >> 9) & 7);                  oam.obj1.flipX = (byte)((obj[1] >> 12) & 1);                  oam.obj1.flipY = (byte)((obj[1] >> 13) & 1);              }              else                  oam.obj1.select_param = (byte)((obj[1] >> 9) & 0x1F);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: if (oam.obj0.rs_flag == 0)              {                  oam.obj1.unused = (byte)((obj[1] >> 9) & 7);                  oam.obj1.flipX = (byte)((obj[1] >> 12) & 1);                  oam.obj1.flipY = (byte)((obj[1] >> 13) & 1);              }              else                  oam.obj1.select_param = (byte)((obj[1] >> 9) & 0x1F);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: if (oam.obj0.rs_flag == 0)              {                  oam.obj1.unused = (byte)((obj[1] >> 9) & 7);                  oam.obj1.flipX = (byte)((obj[1] >> 12) & 1);                  oam.obj1.flipY = (byte)((obj[1] >> 13) & 1);              }              else                  oam.obj1.select_param = (byte)((obj[1] >> 9) & 0x1F);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: if (oam.obj0.rs_flag == 0)              {                  oam.obj1.unused = (byte)((obj[1] >> 9) & 7);                  oam.obj1.flipX = (byte)((obj[1] >> 12) & 1);                  oam.obj1.flipY = (byte)((obj[1] >> 13) & 1);              }              else                  oam.obj1.select_param = (byte)((obj[1] >> 9) & 0x1F);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: if (oam.obj0.rs_flag == 0)              {                  oam.obj1.unused = (byte)((obj[1] >> 9) & 7);                  oam.obj1.flipX = (byte)((obj[1] >> 12) & 1);                  oam.obj1.flipY = (byte)((obj[1] >> 13) & 1);              }              else                  oam.obj1.select_param = (byte)((obj[1] >> 9) & 0x1F);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: oam.obj1.size = (byte)((obj[1] >> 14) & 3);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: oam.obj1.size = (byte)((obj[1] >> 14) & 3);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: oam.obj2.tileOffset = (uint)(obj[2] & 0x03FF);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: oam.obj2.priority = (byte)((obj[2] >> 10) & 3);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: oam.obj2.priority = (byte)((obj[2] >> 10) & 3);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: oam.obj2.priority = (byte)((obj[2] >> 10) & 3);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: oam.obj2.index_palette = (byte)((obj[2] >> 12) & 0xF);
Magic Number,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,OAMInfo,The following statement contains a magic number: oam.obj2.index_palette = (byte)((obj[2] >> 12) & 0xF);
Magic Number,Ekona.Images,ImageBase,C:\repos\pleonex_tinke\Ekona\Images\ImageBase.cs,Get_Image,The following statement contains a magic number: if (tileForm == Images.TileForm.Horizontal)              {                  if (height < tile_size) height = tile_size;                  img_tiles = Actions.LinealToHorizontal(tiles' width' height' bpp' tile_size);                  tilePal = Actions.LinealToHorizontal(tilePal' width' height' 8' tile_size);              }              else                  img_tiles = tiles;
Magic Number,Ekona.Images,ImageBase,C:\repos\pleonex_tinke\Ekona\Images\ImageBase.cs,Set_Tiles,The following statement contains a magic number: bpp = 8;
Magic Number,Ekona.Images,ImageBase,C:\repos\pleonex_tinke\Ekona\Images\ImageBase.cs,Set_Tiles,The following statement contains a magic number: if (format == Images.ColorFormat.colors16)                  bpp = 4;              else if (format == Images.ColorFormat.colors2)                  bpp = 1;              else if (format == Images.ColorFormat.colors4)                  bpp = 2;              else if (format == Images.ColorFormat.direct)                  bpp = 16;              else if (format == Images.ColorFormat.BGRA32 || format == Images.ColorFormat.ABGR32)                  bpp = 32;
Magic Number,Ekona.Images,ImageBase,C:\repos\pleonex_tinke\Ekona\Images\ImageBase.cs,Set_Tiles,The following statement contains a magic number: if (format == Images.ColorFormat.colors16)                  bpp = 4;              else if (format == Images.ColorFormat.colors2)                  bpp = 1;              else if (format == Images.ColorFormat.colors4)                  bpp = 2;              else if (format == Images.ColorFormat.direct)                  bpp = 16;              else if (format == Images.ColorFormat.BGRA32 || format == Images.ColorFormat.ABGR32)                  bpp = 32;
Magic Number,Ekona.Images,ImageBase,C:\repos\pleonex_tinke\Ekona\Images\ImageBase.cs,Set_Tiles,The following statement contains a magic number: if (format == Images.ColorFormat.colors16)                  bpp = 4;              else if (format == Images.ColorFormat.colors2)                  bpp = 1;              else if (format == Images.ColorFormat.colors4)                  bpp = 2;              else if (format == Images.ColorFormat.direct)                  bpp = 16;              else if (format == Images.ColorFormat.BGRA32 || format == Images.ColorFormat.ABGR32)                  bpp = 32;
Magic Number,Ekona.Images,ImageBase,C:\repos\pleonex_tinke\Ekona\Images\ImageBase.cs,Set_Tiles,The following statement contains a magic number: if (format == Images.ColorFormat.colors16)                  bpp = 4;              else if (format == Images.ColorFormat.colors2)                  bpp = 1;              else if (format == Images.ColorFormat.colors4)                  bpp = 2;              else if (format == Images.ColorFormat.direct)                  bpp = 16;              else if (format == Images.ColorFormat.BGRA32 || format == Images.ColorFormat.ABGR32)                  bpp = 32;
Magic Number,Ekona.Images,ImageBase,C:\repos\pleonex_tinke\Ekona\Images\ImageBase.cs,Set_Tiles,The following statement contains a magic number: bpp = 8;
Magic Number,Ekona.Images,ImageBase,C:\repos\pleonex_tinke\Ekona\Images\ImageBase.cs,Set_Tiles,The following statement contains a magic number: if (format == Images.ColorFormat.colors16)                  bpp = 4;              else if (format == Images.ColorFormat.colors2)                  bpp = 1;              else if (format == Images.ColorFormat.colors4)                  bpp = 2;              else if (format == Images.ColorFormat.direct)                  bpp = 16;              else if (format == Images.ColorFormat.BGRA32 || format == Images.ColorFormat.ABGR32)                  bpp = 32;
Magic Number,Ekona.Images,ImageBase,C:\repos\pleonex_tinke\Ekona\Images\ImageBase.cs,Set_Tiles,The following statement contains a magic number: if (format == Images.ColorFormat.colors16)                  bpp = 4;              else if (format == Images.ColorFormat.colors2)                  bpp = 1;              else if (format == Images.ColorFormat.colors4)                  bpp = 2;              else if (format == Images.ColorFormat.direct)                  bpp = 16;              else if (format == Images.ColorFormat.BGRA32 || format == Images.ColorFormat.ABGR32)                  bpp = 32;
Magic Number,Ekona.Images,ImageBase,C:\repos\pleonex_tinke\Ekona\Images\ImageBase.cs,Set_Tiles,The following statement contains a magic number: if (format == Images.ColorFormat.colors16)                  bpp = 4;              else if (format == Images.ColorFormat.colors2)                  bpp = 1;              else if (format == Images.ColorFormat.colors4)                  bpp = 2;              else if (format == Images.ColorFormat.direct)                  bpp = 16;              else if (format == Images.ColorFormat.BGRA32 || format == Images.ColorFormat.ABGR32)                  bpp = 32;
Magic Number,Ekona.Images,ImageBase,C:\repos\pleonex_tinke\Ekona\Images\ImageBase.cs,Set_Tiles,The following statement contains a magic number: if (format == Images.ColorFormat.colors16)                  bpp = 4;              else if (format == Images.ColorFormat.colors2)                  bpp = 1;              else if (format == Images.ColorFormat.colors4)                  bpp = 2;              else if (format == Images.ColorFormat.direct)                  bpp = 16;              else if (format == Images.ColorFormat.BGRA32 || format == Images.ColorFormat.ABGR32)                  bpp = 32;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,Update_Info,The following statement contains a magic number: switch (image.FormatColor)              {                  case ColorFormat.A3I5: comboDepth.SelectedIndex = 4; break;                  case ColorFormat.A5I3: comboDepth.SelectedIndex = 5; break;                  case ColorFormat.colors4: comboDepth.SelectedIndex = 6; break;                  case ColorFormat.colors16: comboDepth.SelectedIndex = 0; break;                  case ColorFormat.colors256: comboDepth.SelectedIndex = 1; break;                  case ColorFormat.direct: comboDepth.SelectedIndex = 3; break;                  case ColorFormat.colors2: comboDepth.SelectedIndex = 2; break;              }
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,Update_Info,The following statement contains a magic number: switch (image.FormatColor)              {                  case ColorFormat.A3I5: comboDepth.SelectedIndex = 4; break;                  case ColorFormat.A5I3: comboDepth.SelectedIndex = 5; break;                  case ColorFormat.colors4: comboDepth.SelectedIndex = 6; break;                  case ColorFormat.colors16: comboDepth.SelectedIndex = 0; break;                  case ColorFormat.colors256: comboDepth.SelectedIndex = 1; break;                  case ColorFormat.direct: comboDepth.SelectedIndex = 3; break;                  case ColorFormat.colors2: comboDepth.SelectedIndex = 2; break;              }
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,Update_Info,The following statement contains a magic number: switch (image.FormatColor)              {                  case ColorFormat.A3I5: comboDepth.SelectedIndex = 4; break;                  case ColorFormat.A5I3: comboDepth.SelectedIndex = 5; break;                  case ColorFormat.colors4: comboDepth.SelectedIndex = 6; break;                  case ColorFormat.colors16: comboDepth.SelectedIndex = 0; break;                  case ColorFormat.colors256: comboDepth.SelectedIndex = 1; break;                  case ColorFormat.direct: comboDepth.SelectedIndex = 3; break;                  case ColorFormat.colors2: comboDepth.SelectedIndex = 2; break;              }
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,Update_Info,The following statement contains a magic number: switch (image.FormatColor)              {                  case ColorFormat.A3I5: comboDepth.SelectedIndex = 4; break;                  case ColorFormat.A5I3: comboDepth.SelectedIndex = 5; break;                  case ColorFormat.colors4: comboDepth.SelectedIndex = 6; break;                  case ColorFormat.colors16: comboDepth.SelectedIndex = 0; break;                  case ColorFormat.colors256: comboDepth.SelectedIndex = 1; break;                  case ColorFormat.direct: comboDepth.SelectedIndex = 3; break;                  case ColorFormat.colors2: comboDepth.SelectedIndex = 2; break;              }
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,Update_Info,The following statement contains a magic number: switch (image.FormatColor)              {                  case ColorFormat.A3I5: comboDepth.SelectedIndex = 4; break;                  case ColorFormat.A5I3: comboDepth.SelectedIndex = 5; break;                  case ColorFormat.colors4: comboDepth.SelectedIndex = 6; break;                  case ColorFormat.colors16: comboDepth.SelectedIndex = 0; break;                  case ColorFormat.colors256: comboDepth.SelectedIndex = 1; break;                  case ColorFormat.direct: comboDepth.SelectedIndex = 3; break;                  case ColorFormat.colors2: comboDepth.SelectedIndex = 2; break;              }
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,Update_Image,The following statement contains a magic number: if (bitmap.Width == 512)                  pic.BorderStyle = System.Windows.Forms.BorderStyle.None;              else                  pic.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,comboDepth_SelectedIndexChanged,The following statement contains a magic number: switch (comboDepth.SelectedIndex)              {                  case 0: image.FormatColor = ColorFormat.colors16; break;                  case 1: image.FormatColor = ColorFormat.colors256; break;                  case 2: image.FormatColor = ColorFormat.colors2; break;                  case 3: image.FormatColor = ColorFormat.direct; break;                  case 4: image.FormatColor = ColorFormat.A3I5; break;                  case 5: image.FormatColor = ColorFormat.A5I3; break;                  case 6: image.FormatColor = ColorFormat.colors4; break;                  case 7: image.FormatColor = ColorFormat.A4I4; break;                  case 8: image.FormatColor = ColorFormat.BGRA32; break;                  case 9: image.FormatColor = ColorFormat.ABGR32; break;              }
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,comboDepth_SelectedIndexChanged,The following statement contains a magic number: switch (comboDepth.SelectedIndex)              {                  case 0: image.FormatColor = ColorFormat.colors16; break;                  case 1: image.FormatColor = ColorFormat.colors256; break;                  case 2: image.FormatColor = ColorFormat.colors2; break;                  case 3: image.FormatColor = ColorFormat.direct; break;                  case 4: image.FormatColor = ColorFormat.A3I5; break;                  case 5: image.FormatColor = ColorFormat.A5I3; break;                  case 6: image.FormatColor = ColorFormat.colors4; break;                  case 7: image.FormatColor = ColorFormat.A4I4; break;                  case 8: image.FormatColor = ColorFormat.BGRA32; break;                  case 9: image.FormatColor = ColorFormat.ABGR32; break;              }
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,comboDepth_SelectedIndexChanged,The following statement contains a magic number: switch (comboDepth.SelectedIndex)              {                  case 0: image.FormatColor = ColorFormat.colors16; break;                  case 1: image.FormatColor = ColorFormat.colors256; break;                  case 2: image.FormatColor = ColorFormat.colors2; break;                  case 3: image.FormatColor = ColorFormat.direct; break;                  case 4: image.FormatColor = ColorFormat.A3I5; break;                  case 5: image.FormatColor = ColorFormat.A5I3; break;                  case 6: image.FormatColor = ColorFormat.colors4; break;                  case 7: image.FormatColor = ColorFormat.A4I4; break;                  case 8: image.FormatColor = ColorFormat.BGRA32; break;                  case 9: image.FormatColor = ColorFormat.ABGR32; break;              }
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,comboDepth_SelectedIndexChanged,The following statement contains a magic number: switch (comboDepth.SelectedIndex)              {                  case 0: image.FormatColor = ColorFormat.colors16; break;                  case 1: image.FormatColor = ColorFormat.colors256; break;                  case 2: image.FormatColor = ColorFormat.colors2; break;                  case 3: image.FormatColor = ColorFormat.direct; break;                  case 4: image.FormatColor = ColorFormat.A3I5; break;                  case 5: image.FormatColor = ColorFormat.A5I3; break;                  case 6: image.FormatColor = ColorFormat.colors4; break;                  case 7: image.FormatColor = ColorFormat.A4I4; break;                  case 8: image.FormatColor = ColorFormat.BGRA32; break;                  case 9: image.FormatColor = ColorFormat.ABGR32; break;              }
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,comboDepth_SelectedIndexChanged,The following statement contains a magic number: switch (comboDepth.SelectedIndex)              {                  case 0: image.FormatColor = ColorFormat.colors16; break;                  case 1: image.FormatColor = ColorFormat.colors256; break;                  case 2: image.FormatColor = ColorFormat.colors2; break;                  case 3: image.FormatColor = ColorFormat.direct; break;                  case 4: image.FormatColor = ColorFormat.A3I5; break;                  case 5: image.FormatColor = ColorFormat.A5I3; break;                  case 6: image.FormatColor = ColorFormat.colors4; break;                  case 7: image.FormatColor = ColorFormat.A4I4; break;                  case 8: image.FormatColor = ColorFormat.BGRA32; break;                  case 9: image.FormatColor = ColorFormat.ABGR32; break;              }
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,comboDepth_SelectedIndexChanged,The following statement contains a magic number: switch (comboDepth.SelectedIndex)              {                  case 0: image.FormatColor = ColorFormat.colors16; break;                  case 1: image.FormatColor = ColorFormat.colors256; break;                  case 2: image.FormatColor = ColorFormat.colors2; break;                  case 3: image.FormatColor = ColorFormat.direct; break;                  case 4: image.FormatColor = ColorFormat.A3I5; break;                  case 5: image.FormatColor = ColorFormat.A5I3; break;                  case 6: image.FormatColor = ColorFormat.colors4; break;                  case 7: image.FormatColor = ColorFormat.A4I4; break;                  case 8: image.FormatColor = ColorFormat.BGRA32; break;                  case 9: image.FormatColor = ColorFormat.ABGR32; break;              }
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,comboDepth_SelectedIndexChanged,The following statement contains a magic number: switch (comboDepth.SelectedIndex)              {                  case 0: image.FormatColor = ColorFormat.colors16; break;                  case 1: image.FormatColor = ColorFormat.colors256; break;                  case 2: image.FormatColor = ColorFormat.colors2; break;                  case 3: image.FormatColor = ColorFormat.direct; break;                  case 4: image.FormatColor = ColorFormat.A3I5; break;                  case 5: image.FormatColor = ColorFormat.A5I3; break;                  case 6: image.FormatColor = ColorFormat.colors4; break;                  case 7: image.FormatColor = ColorFormat.A4I4; break;                  case 8: image.FormatColor = ColorFormat.BGRA32; break;                  case 9: image.FormatColor = ColorFormat.ABGR32; break;              }
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,comboDepth_SelectedIndexChanged,The following statement contains a magic number: switch (comboDepth.SelectedIndex)              {                  case 0: image.FormatColor = ColorFormat.colors16; break;                  case 1: image.FormatColor = ColorFormat.colors256; break;                  case 2: image.FormatColor = ColorFormat.colors2; break;                  case 3: image.FormatColor = ColorFormat.direct; break;                  case 4: image.FormatColor = ColorFormat.A3I5; break;                  case 5: image.FormatColor = ColorFormat.A5I3; break;                  case 6: image.FormatColor = ColorFormat.colors4; break;                  case 7: image.FormatColor = ColorFormat.A4I4; break;                  case 8: image.FormatColor = ColorFormat.BGRA32; break;                  case 9: image.FormatColor = ColorFormat.ABGR32; break;              }
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,btnSetTrans_Click,The following statement contains a magic number: if ((palette.Depth == ColorFormat.colors256 && palette.NumberOfColors == 256) ||                  (palette.Depth == ColorFormat.colors16 && palette.NumberOfColors == 16))              {                  index = Actions.Remove_DuplicatedColors(ref pal' ref tiles);                  if (index == -1)                  {                      index = Actions.Remove_NotUsedColors(ref pal' ref tiles);                    }              }              else              {                  index = palette.NumberOfColors; // First empty place                  Color[] newPal = new Color[pal.Length + 1];                  Array.Copy(pal' newPal' pal.Length);                  pal = newPal;              }
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,btnSetTrans_Click,The following statement contains a magic number: if ((palette.Depth == ColorFormat.colors256 && palette.NumberOfColors == 256) ||                  (palette.Depth == ColorFormat.colors16 && palette.NumberOfColors == 16))              {                  index = Actions.Remove_DuplicatedColors(ref pal' ref tiles);                  if (index == -1)                  {                      index = Actions.Remove_NotUsedColors(ref pal' ref tiles);                    }              }              else              {                  index = palette.NumberOfColors; // First empty place                  Color[] newPal = new Color[pal.Length + 1];                  Array.Copy(pal' newPal' pal.Length);                  pal = newPal;              }
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,btnSetTrans_Click,The following statement contains a magic number: pal[index] = Color.FromArgb(248' 0' 248);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,btnSetTrans_Click,The following statement contains a magic number: pal[index] = Color.FromArgb(248' 0' 248);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,btnExport_Click,The following statement contains a magic number: if (o.ShowDialog() == DialogResult.OK)              {                  if (o.FilterIndex == 2)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Bmp);                  else if (o.FilterIndex == 1)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Png);                  else if (o.FilterIndex == 3)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Jpeg);                  else if (o.FilterIndex == 4)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Tiff);                  else if (o.FilterIndex == 5)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Gif);                  else if (o.FilterIndex == 6)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Icon);              }
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,btnExport_Click,The following statement contains a magic number: if (o.ShowDialog() == DialogResult.OK)              {                  if (o.FilterIndex == 2)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Bmp);                  else if (o.FilterIndex == 1)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Png);                  else if (o.FilterIndex == 3)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Jpeg);                  else if (o.FilterIndex == 4)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Tiff);                  else if (o.FilterIndex == 5)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Gif);                  else if (o.FilterIndex == 6)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Icon);              }
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,btnExport_Click,The following statement contains a magic number: if (o.ShowDialog() == DialogResult.OK)              {                  if (o.FilterIndex == 2)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Bmp);                  else if (o.FilterIndex == 1)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Png);                  else if (o.FilterIndex == 3)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Jpeg);                  else if (o.FilterIndex == 4)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Tiff);                  else if (o.FilterIndex == 5)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Gif);                  else if (o.FilterIndex == 6)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Icon);              }
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,btnExport_Click,The following statement contains a magic number: if (o.ShowDialog() == DialogResult.OK)              {                  if (o.FilterIndex == 2)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Bmp);                  else if (o.FilterIndex == 1)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Png);                  else if (o.FilterIndex == 3)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Jpeg);                  else if (o.FilterIndex == 4)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Tiff);                  else if (o.FilterIndex == 5)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Gif);                  else if (o.FilterIndex == 6)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Icon);              }
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,btnExport_Click,The following statement contains a magic number: if (o.ShowDialog() == DialogResult.OK)              {                  if (o.FilterIndex == 2)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Bmp);                  else if (o.FilterIndex == 1)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Png);                  else if (o.FilterIndex == 3)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Jpeg);                  else if (o.FilterIndex == 4)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Tiff);                  else if (o.FilterIndex == 5)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Gif);                  else if (o.FilterIndex == 6)                      pic.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Icon);              }
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,btnImport_Click,The following statement contains a magic number: if (image.FormTile == TileForm.Horizontal || isMap)              {                  tiles = Actions.HorizontalToLineal(tiles' bitmap.Width' bitmap.Height' image.BPP' 8);                  image.FormTile = TileForm.Horizontal;              }
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,btnImport_Click,The following statement contains a magic number: if (isMap && checkMapCmp.Checked)                  map.Set_Map(Actions.Create_Map(ref tiles' image.BPP' image.TileSize' (byte)numPal.Value)' map.CanEdit' bitmap.Width' bitmap.Height);              else if (isMap)              {                  int num_tiles = (tiles.Length * 8 / image.BPP) / (image.TileSize * image.TileSize);                  map.Set_Map(Actions.Create_BasicMap(num_tiles' 0' (byte)numPal.Value)' map.CanEdit);              }
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,btnImport_Click,The following statement contains a magic number: image.Set_Tiles(tiles' bitmap.Width' bitmap.Height' image.FormatColor' image.FormTile' image.CanEdit' 8);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,pic_DoubleClick,The following statement contains a magic number: ven.MaximumSize = new Size(1024' 700);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,pic_DoubleClick,The following statement contains a magic number: ven.MaximumSize = new Size(1024' 700);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numericWidth.Location = new System.Drawing.Point(48' 76);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numericWidth.Location = new System.Drawing.Point(48' 76);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numericWidth.Maximum = new decimal(new int[] {              65536'              0'              0'              0});
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numericWidth.Size = new System.Drawing.Size(71' 20);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numericWidth.Size = new System.Drawing.Size(71' 20);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(6' 78);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(6' 78);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label1.TabIndex = 2;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(128' 78);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(128' 78);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 3;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numericHeight.Location = new System.Drawing.Point(165' 76);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numericHeight.Location = new System.Drawing.Point(165' 76);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numericHeight.Maximum = new decimal(new int[] {              65536'              0'              0'              0});
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numericHeight.Size = new System.Drawing.Size(71' 20);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numericHeight.Size = new System.Drawing.Size(71' 20);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numericHeight.TabIndex = 4;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.groupProp.Location = new System.Drawing.Point(0' 306);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.groupProp.Size = new System.Drawing.Size(252' 206);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.groupProp.Size = new System.Drawing.Size(252' 206);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.groupProp.TabIndex = 5;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label10.Location = new System.Drawing.Point(128' 143);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label10.Location = new System.Drawing.Point(128' 143);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label10.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label10.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label10.TabIndex = 30;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numTileSize.Location = new System.Drawing.Point(199' 141);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numTileSize.Location = new System.Drawing.Point(199' 141);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numTileSize.Maximum = new decimal(new int[] {              1024'              0'              0'              0});
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numTileSize.Size = new System.Drawing.Size(37' 20);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numTileSize.Size = new System.Drawing.Size(37' 20);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numTileSize.TabIndex = 29;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numTileSize.Value = new decimal(new int[] {              8'              0'              0'              0});
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label9.Location = new System.Drawing.Point(128' 174);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label9.Location = new System.Drawing.Point(128' 174);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label9.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label9.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label9.TabIndex = 26;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numPal.Location = new System.Drawing.Point(199' 172);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numPal.Location = new System.Drawing.Point(199' 172);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numPal.Size = new System.Drawing.Size(37' 20);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numPal.Size = new System.Drawing.Size(37' 20);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numPal.TabIndex = 25;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.checkHex.Location = new System.Drawing.Point(32' 46);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.checkHex.Location = new System.Drawing.Point(32' 46);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.checkHex.Size = new System.Drawing.Size(45' 17);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.checkHex.Size = new System.Drawing.Size(45' 17);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.checkHex.TabIndex = 24;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.checkTransparency.Location = new System.Drawing.Point(9' 175);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.checkTransparency.Location = new System.Drawing.Point(9' 175);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.checkTransparency.Size = new System.Drawing.Size(46' 17);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.checkTransparency.Size = new System.Drawing.Size(46' 17);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.checkTransparency.TabIndex = 19;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label6.Location = new System.Drawing.Point(6' 117);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label6.Location = new System.Drawing.Point(6' 117);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label6.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label6.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label6.TabIndex = 11;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.comboBox1.Location = new System.Drawing.Point(116' 114);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.comboBox1.Location = new System.Drawing.Point(116' 114);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.comboBox1.Size = new System.Drawing.Size(119' 21);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.comboBox1.Size = new System.Drawing.Size(119' 21);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.comboBox1.TabIndex = 10;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(128' 22);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(128' 22);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(31' 13);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(31' 13);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label4.TabIndex = 9;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.comboDepth.Location = new System.Drawing.Point(165' 19);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.comboDepth.Location = new System.Drawing.Point(165' 19);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.comboDepth.Size = new System.Drawing.Size(83' 21);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.comboDepth.Size = new System.Drawing.Size(83' 21);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.comboDepth.TabIndex = 8;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(6' 22);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(6' 22);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 7;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numericStart.Location = new System.Drawing.Point(48' 20);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numericStart.Location = new System.Drawing.Point(48' 20);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numericStart.Maximum = new decimal(new int[] {              65535'              0'              0'              0});
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numericStart.Size = new System.Drawing.Size(71' 20);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numericStart.Size = new System.Drawing.Size(71' 20);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numericStart.TabIndex = 6;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.checkMapCmp.Location = new System.Drawing.Point(258' 444);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.checkMapCmp.Location = new System.Drawing.Point(258' 444);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.checkMapCmp.Size = new System.Drawing.Size(45' 17);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.checkMapCmp.Size = new System.Drawing.Size(45' 17);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.checkMapCmp.TabIndex = 48;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.groupBox2.Location = new System.Drawing.Point(258' 352);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.groupBox2.Location = new System.Drawing.Point(258' 352);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.groupBox2.Size = new System.Drawing.Size(254' 86);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.groupBox2.Size = new System.Drawing.Size(254' 86);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.groupBox2.TabIndex = 47;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.radioSwapPal.Location = new System.Drawing.Point(6' 19);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.radioSwapPal.Location = new System.Drawing.Point(6' 19);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.radioSwapPal.Size = new System.Drawing.Size(44' 17);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.radioSwapPal.Size = new System.Drawing.Size(44' 17);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.radioSwapPal.TabIndex = 41;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.radioOriginalPal.Location = new System.Drawing.Point(6' 42);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.radioOriginalPal.Location = new System.Drawing.Point(6' 42);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.radioOriginalPal.Size = new System.Drawing.Size(45' 17);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.radioOriginalPal.Size = new System.Drawing.Size(45' 17);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.radioOriginalPal.TabIndex = 39;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.radioReplacePal.Location = new System.Drawing.Point(6' 65);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.radioReplacePal.Location = new System.Drawing.Point(6' 65);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.radioReplacePal.Size = new System.Drawing.Size(44' 17);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.radioReplacePal.Size = new System.Drawing.Size(44' 17);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.radioReplacePal.TabIndex = 40;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label7.Location = new System.Drawing.Point(174' 13);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label7.Location = new System.Drawing.Point(174' 13);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label7.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label7.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label7.TabIndex = 43;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numThreshold.DecimalPlaces = 4;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numThreshold.Increment = new decimal(new int[] {              5'              0'              0'              65536});
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numThreshold.Increment = new decimal(new int[] {              5'              0'              0'              65536});
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numThreshold.Location = new System.Drawing.Point(177' 29);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numThreshold.Location = new System.Drawing.Point(177' 29);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numThreshold.Maximum = new decimal(new int[] {              442'              0'              0'              0});
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numThreshold.Size = new System.Drawing.Size(77' 20);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numThreshold.Size = new System.Drawing.Size(77' 20);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.numThreshold.TabIndex = 42;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.btnSetTrans.Location = new System.Drawing.Point(258' 306);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.btnSetTrans.Location = new System.Drawing.Point(258' 306);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.btnSetTrans.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.btnSetTrans.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.btnSetTrans.TabIndex = 28;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.btnImport.Location = new System.Drawing.Point(429' 469);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.btnImport.Location = new System.Drawing.Point(429' 469);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.btnImport.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.btnImport.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.btnImport.TabIndex = 23;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.btnBgdRem.Location = new System.Drawing.Point(430' 306);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.btnBgdRem.Location = new System.Drawing.Point(430' 306);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.btnBgdRem.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.btnBgdRem.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.btnBgdRem.TabIndex = 22;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.btnBgd.Location = new System.Drawing.Point(344' 306);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.btnBgd.Location = new System.Drawing.Point(344' 306);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.btnBgd.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.btnBgd.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.btnBgd.TabIndex = 20;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.btnExport.Location = new System.Drawing.Point(332' 469);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.btnExport.Location = new System.Drawing.Point(332' 469);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.btnExport.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.btnExport.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.btnExport.TabIndex = 6;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(6' 290);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(6' 290);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.label5.TabIndex = 6;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.pic.Size = new System.Drawing.Size(100' 100);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.pic.Size = new System.Drawing.Size(100' 100);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.panel1.Size = new System.Drawing.Size(512' 287);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.panel1.Size = new System.Drawing.Size(512' 287);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.panel1.TabIndex = 7;
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(512' 512);
Magic Number,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(512' 512);
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Clamp,The following statement contains a magic number: if (a > 255) a = 255;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Clamp,The following statement contains a magic number: if (a > 255) a = 255;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Error,The following statement contains a magic number: Vector3[] dxtFourPointsTemp = new Vector3[4];
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Error,The following statement contains a magic number: if (!hasAlpha)              {                  dxtFourPointsTemp[2] = (5 * dxtFourPointsTemp[0] + 3* dxtFourPointsTemp[1]) / 8;                  dxtFourPointsTemp[3] = (5 * dxtFourPointsTemp[1] + 3* dxtFourPointsTemp[0]) / 8;              }              else              {                  dxtFourPointsTemp[2] = (dxtFourPointsTemp[0] + dxtFourPointsTemp[1]) / 2;                  dxtFourPointsTemp[3] = new Vector3(double.MaxValue' double.MaxValue' double.MaxValue);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Error,The following statement contains a magic number: if (!hasAlpha)              {                  dxtFourPointsTemp[2] = (5 * dxtFourPointsTemp[0] + 3* dxtFourPointsTemp[1]) / 8;                  dxtFourPointsTemp[3] = (5 * dxtFourPointsTemp[1] + 3* dxtFourPointsTemp[0]) / 8;              }              else              {                  dxtFourPointsTemp[2] = (dxtFourPointsTemp[0] + dxtFourPointsTemp[1]) / 2;                  dxtFourPointsTemp[3] = new Vector3(double.MaxValue' double.MaxValue' double.MaxValue);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Error,The following statement contains a magic number: if (!hasAlpha)              {                  dxtFourPointsTemp[2] = (5 * dxtFourPointsTemp[0] + 3* dxtFourPointsTemp[1]) / 8;                  dxtFourPointsTemp[3] = (5 * dxtFourPointsTemp[1] + 3* dxtFourPointsTemp[0]) / 8;              }              else              {                  dxtFourPointsTemp[2] = (dxtFourPointsTemp[0] + dxtFourPointsTemp[1]) / 2;                  dxtFourPointsTemp[3] = new Vector3(double.MaxValue' double.MaxValue' double.MaxValue);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Error,The following statement contains a magic number: if (!hasAlpha)              {                  dxtFourPointsTemp[2] = (5 * dxtFourPointsTemp[0] + 3* dxtFourPointsTemp[1]) / 8;                  dxtFourPointsTemp[3] = (5 * dxtFourPointsTemp[1] + 3* dxtFourPointsTemp[0]) / 8;              }              else              {                  dxtFourPointsTemp[2] = (dxtFourPointsTemp[0] + dxtFourPointsTemp[1]) / 2;                  dxtFourPointsTemp[3] = new Vector3(double.MaxValue' double.MaxValue' double.MaxValue);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Error,The following statement contains a magic number: if (!hasAlpha)              {                  dxtFourPointsTemp[2] = (5 * dxtFourPointsTemp[0] + 3* dxtFourPointsTemp[1]) / 8;                  dxtFourPointsTemp[3] = (5 * dxtFourPointsTemp[1] + 3* dxtFourPointsTemp[0]) / 8;              }              else              {                  dxtFourPointsTemp[2] = (dxtFourPointsTemp[0] + dxtFourPointsTemp[1]) / 2;                  dxtFourPointsTemp[3] = new Vector3(double.MaxValue' double.MaxValue' double.MaxValue);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Error,The following statement contains a magic number: if (!hasAlpha)              {                  dxtFourPointsTemp[2] = (5 * dxtFourPointsTemp[0] + 3* dxtFourPointsTemp[1]) / 8;                  dxtFourPointsTemp[3] = (5 * dxtFourPointsTemp[1] + 3* dxtFourPointsTemp[0]) / 8;              }              else              {                  dxtFourPointsTemp[2] = (dxtFourPointsTemp[0] + dxtFourPointsTemp[1]) / 2;                  dxtFourPointsTemp[3] = new Vector3(double.MaxValue' double.MaxValue' double.MaxValue);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Error,The following statement contains a magic number: if (!hasAlpha)              {                  dxtFourPointsTemp[2] = (5 * dxtFourPointsTemp[0] + 3* dxtFourPointsTemp[1]) / 8;                  dxtFourPointsTemp[3] = (5 * dxtFourPointsTemp[1] + 3* dxtFourPointsTemp[0]) / 8;              }              else              {                  dxtFourPointsTemp[2] = (dxtFourPointsTemp[0] + dxtFourPointsTemp[1]) / 2;                  dxtFourPointsTemp[3] = new Vector3(double.MaxValue' double.MaxValue' double.MaxValue);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Error,The following statement contains a magic number: if (!hasAlpha)              {                  dxtFourPointsTemp[2] = (5 * dxtFourPointsTemp[0] + 3* dxtFourPointsTemp[1]) / 8;                  dxtFourPointsTemp[3] = (5 * dxtFourPointsTemp[1] + 3* dxtFourPointsTemp[0]) / 8;              }              else              {                  dxtFourPointsTemp[2] = (dxtFourPointsTemp[0] + dxtFourPointsTemp[1]) / 2;                  dxtFourPointsTemp[3] = new Vector3(double.MaxValue' double.MaxValue' double.MaxValue);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Error,The following statement contains a magic number: if (!hasAlpha)              {                  dxtFourPointsTemp[2] = (5 * dxtFourPointsTemp[0] + 3* dxtFourPointsTemp[1]) / 8;                  dxtFourPointsTemp[3] = (5 * dxtFourPointsTemp[1] + 3* dxtFourPointsTemp[0]) / 8;              }              else              {                  dxtFourPointsTemp[2] = (dxtFourPointsTemp[0] + dxtFourPointsTemp[1]) / 2;                  dxtFourPointsTemp[3] = new Vector3(double.MaxValue' double.MaxValue' double.MaxValue);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Error,The following statement contains a magic number: if (!hasAlpha)              {                  dxtFourPointsTemp[2] = (5 * dxtFourPointsTemp[0] + 3* dxtFourPointsTemp[1]) / 8;                  dxtFourPointsTemp[3] = (5 * dxtFourPointsTemp[1] + 3* dxtFourPointsTemp[0]) / 8;              }              else              {                  dxtFourPointsTemp[2] = (dxtFourPointsTemp[0] + dxtFourPointsTemp[1]) / 2;                  dxtFourPointsTemp[3] = new Vector3(double.MaxValue' double.MaxValue' double.MaxValue);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Error,The following statement contains a magic number: if (!hasAlpha)              {                  dxtFourPointsTemp[2] = (5 * dxtFourPointsTemp[0] + 3* dxtFourPointsTemp[1]) / 8;                  dxtFourPointsTemp[3] = (5 * dxtFourPointsTemp[1] + 3* dxtFourPointsTemp[0]) / 8;              }              else              {                  dxtFourPointsTemp[2] = (dxtFourPointsTemp[0] + dxtFourPointsTemp[1]) / 2;                  dxtFourPointsTemp[3] = new Vector3(double.MaxValue' double.MaxValue' double.MaxValue);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Error,The following statement contains a magic number: for (int i = 0; i < inputPoints.Length; i++)              {                  if (mask[i] > 0)                  {                      double dist0 = ColorLengthSquared(inputPoints[i] - dxtFourPointsTemp[0]);                      double dist1 = ColorLengthSquared(inputPoints[i] - dxtFourPointsTemp[1]);                      double dist2 = ColorLengthSquared(inputPoints[i] - dxtFourPointsTemp[2]);                      double dist3 = ColorLengthSquared(inputPoints[i] - dxtFourPointsTemp[3]);                      if (dist0 < dist2 && dist0 < dist3)                      {                          error += dist0;                      }                      else if (dist1 < dist2 && dist1 < dist3)                      {                          error += dist1;                      }                      else error += Math.Min(dist2' dist3);                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Error,The following statement contains a magic number: for (int i = 0; i < inputPoints.Length; i++)              {                  if (mask[i] > 0)                  {                      double dist0 = ColorLengthSquared(inputPoints[i] - dxtFourPointsTemp[0]);                      double dist1 = ColorLengthSquared(inputPoints[i] - dxtFourPointsTemp[1]);                      double dist2 = ColorLengthSquared(inputPoints[i] - dxtFourPointsTemp[2]);                      double dist3 = ColorLengthSquared(inputPoints[i] - dxtFourPointsTemp[3]);                      if (dist0 < dist2 && dist0 < dist3)                      {                          error += dist0;                      }                      else if (dist1 < dist2 && dist1 < dist3)                      {                          error += dist1;                      }                      else error += Math.Min(dist2' dist3);                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,VectorToColor,The following statement contains a magic number: return Color.FromArgb(255'                           (byte)Clamp(v.X /* 255 / 31*/)'                           (byte)Clamp(v.Y /* 255 / 63*/)'                           (byte)Clamp(v.Z /* 255 / 31*/));
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CalcSecondBoundColor,The following statement contains a magic number: int r = 2 * c.R - boundColor.R;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CalcSecondBoundColor,The following statement contains a magic number: int g = 2 * c.G - boundColor.G;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CalcSecondBoundColor,The following statement contains a magic number: int b = 2 * c.B - boundColor.B;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CalcSecondBoundColor,The following statement contains a magic number: if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255) return c;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CalcSecondBoundColor,The following statement contains a magic number: if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255) return c;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CalcSecondBoundColor,The following statement contains a magic number: if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255) return c;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CalcSecondBoundColor,The following statement contains a magic number: return Color.FromArgb(255' r' g' b);
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count > 0)              {                  uniqueColors[0] = colors[aIndex];                  uniqueColors[count - 1] = colors[bIndex];                  for (int i = 0' j = 1; i < colors.Length && j < count - 1; i++)                      if (uniqueFlags[i] && i != aIndex && i != bIndex) uniqueColors[j++] = colors[i];                  for (int i = 0; i < count; i++)                      inputPoints[i] = new Vector3(uniqueColors[i].R / 8' uniqueColors[i].G / 8' uniqueColors[i].B / 8);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count > 0)              {                  uniqueColors[0] = colors[aIndex];                  uniqueColors[count - 1] = colors[bIndex];                  for (int i = 0' j = 1; i < colors.Length && j < count - 1; i++)                      if (uniqueFlags[i] && i != aIndex && i != bIndex) uniqueColors[j++] = colors[i];                  for (int i = 0; i < count; i++)                      inputPoints[i] = new Vector3(uniqueColors[i].R / 8' uniqueColors[i].G / 8' uniqueColors[i].B / 8);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count > 0)              {                  uniqueColors[0] = colors[aIndex];                  uniqueColors[count - 1] = colors[bIndex];                  for (int i = 0' j = 1; i < colors.Length && j < count - 1; i++)                      if (uniqueFlags[i] && i != aIndex && i != bIndex) uniqueColors[j++] = colors[i];                  for (int i = 0; i < count; i++)                      inputPoints[i] = new Vector3(uniqueColors[i].R / 8' uniqueColors[i].G / 8' uniqueColors[i].B / 8);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: dxtBoundColors = new Color[2];
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,IsCompressedBlock,The following statement contains a magic number: if (count == 0)              {                  #region Transparent block                  dxtBoundColors[0] = Color.Black;                  dxtBoundColors[1] = dxtBoundColors[0];                  hasAlpha = true;                  #endregion              }              else if (count == 1)              {                  #region Single color                  int r = (byte)(inputPoints[0].X * 255 / 31);                  int g = (byte)(inputPoints[0].Y * 255 / 31);                  int b = (byte)(inputPoints[0].Z * 255 / 31);                  if (uniqueColors[0].R == r && uniqueColors[0].G == g && uniqueColors[0].B == b)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = dxtBoundColors[0];                      hasAlpha = true;                  }                  else                  {                      Vector3[] dxtPoints = new Vector3[2];                      dxtPoints[0] = Vector3.Zero;                      dxtPoints[1] = 2 * new Vector3(uniqueColors[0].R' uniqueColors[0].G' uniqueColors[0].B);                      if (dxtPoints[1].X > 255)                      {                          dxtPoints[0].X = dxtPoints[1].X - 255;                          dxtPoints[1].X -= dxtPoints[0].X;                      }                      if (dxtPoints[1].Y > 255)                      {                          dxtPoints[0].Y = dxtPoints[1].Y - 255;                          dxtPoints[1].Y -= dxtPoints[0].Y;                      }                      if (dxtPoints[1].Z > 255)                      {                          dxtPoints[0].Z = dxtPoints[1].Z - 255;                          dxtPoints[1].Z -= dxtPoints[0].Z;                      }                        dxtBoundColors[0] = Color.FromArgb(255' (byte)dxtPoints[0].X' (byte)dxtPoints[0].Y' (byte)dxtPoints[0].Z);                      dxtBoundColors[1] = Color.FromArgb(255' (byte)dxtPoints[1].X' (byte)dxtPoints[1].Y' (byte)dxtPoints[1].Z);                      hasAlpha = true;                  }                  #endregion              }              else if (count == 2)              {                  #region Two colors block                  byte r0 = (byte)(inputPoints[0].X * 255 / 31);                  byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                  byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                  byte r1 = (byte)(inputPoints[1].X * 255 / 31);                  byte g1 = (byte)(inputPoints[1].Y * 255 / 31);                  byte b1 = (byte)(inputPoints[1].Z * 255 / 31);                  bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                  bool color1 = uniqueColors[1].R == r1 && uniqueColors[1].G == g1 && uniqueColors[1].B == b1;                  if (color0 && color1)                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[1];                      hasAlpha = true;                  }                  else                  {                      if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          hasAlpha = true;                      }                      else if (color1 || hasAlpha)                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[1];                          hasAlpha = true;                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[1]' uniqueColors[0]);                          if (dxtBoundColors[0] == uniqueColors[0] || dxtBoundColors[1] == uniqueColors[1])                              hasAlpha = true;                      }                  }                  #endregion              }              else if (count == 3)              {                  #region Three colors block                    Color middle = SumColors(uniqueColors[0]' uniqueColors[2]' 1' 1);                  if (middle.R == uniqueColors[1].R && middle.G == uniqueColors[1].G && middle.B == uniqueColors[1].B)                  {                      byte r0 = (byte)(inputPoints[0].X * 255 / 31);                      byte g0 = (byte)(inputPoints[0].Y * 255 / 31);                      byte b0 = (byte)(inputPoints[0].Z * 255 / 31);                      byte r2 = (byte)(inputPoints[2].X * 255 / 31);                      byte g2 = (byte)(inputPoints[2].Y * 255 / 31);                      byte b2 = (byte)(inputPoints[2].Z * 255 / 31);                      bool color0 = uniqueColors[0].R == r0 && uniqueColors[0].G == g0 && uniqueColors[0].B == b0;                      bool color2 = uniqueColors[2].R == r2 && uniqueColors[2].G == g2 && uniqueColors[2].B == b2;                      if ((color0 && color2) || hasAlpha)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = true;                      }                      else if (color0)                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = CalcSecondBoundColor(uniqueColors[2]' uniqueColors[1]);                          hasAlpha = (dxtBoundColors[1] == uniqueColors[2]);                      }                      else                      {                          dxtBoundColors[0] = CalcSecondBoundColor(uniqueColors[0]' uniqueColors[1]);                          dxtBoundColors[1] = uniqueColors[2];                          hasAlpha = (dxtBoundColors[0] == uniqueColors[0]);                      }                  }                  else if (!hasAlpha)                  {                      Color m1 = SumColors(uniqueColors[0]' uniqueColors[2]' 5' 3);                      Color m2 = SumColors(uniqueColors[0]' uniqueColors[2]' 3' 5);                      if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B)                          || (uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                      {                          dxtBoundColors[0] = uniqueColors[0];                          dxtBoundColors[1] = uniqueColors[2];                      }                      else return false;                    }                  else return false;                    #endregion              }              else if (count == 4 && !hasAlpha)              {                  #region Four colors block                    Color m1 = SumColors(uniqueColors[0]' uniqueColors[3]' 5' 3);                  Color m2 = SumColors(uniqueColors[0]' uniqueColors[3]' 3' 5);                  if ((uniqueColors[1].R == m1.R && uniqueColors[1].G == m1.G && uniqueColors[1].B == m1.B                       && uniqueColors[2].R == m2.R && uniqueColors[2].G == m2.G && uniqueColors[2].B == m2.B)                      || (uniqueColors[2].R == m1.R && uniqueColors[2].G == m1.G && uniqueColors[2].B == m1.B                          && uniqueColors[1].R == m2.R && uniqueColors[1].G == m2.G && uniqueColors[1].B == m2.B))                  {                      dxtBoundColors[0] = uniqueColors[0];                      dxtBoundColors[1] = uniqueColors[3];                  }                  else return false;                    #endregion              }              else return false;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,OptimizeEndPoints3,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  uint bits = indices >> (2 * i);                    float beta = (float)(bits & 1);                  if ((bits & 2) > 0) beta = 0.5f;                  float alpha = 1.0f - beta;                    alpha2_sum += alpha * alpha;                  beta2_sum += beta * beta;                  alphabeta_sum += alpha * beta;                  alphax_sum += alpha * block[i];                  betax_sum += beta * block[i];              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,OptimizeEndPoints3,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  uint bits = indices >> (2 * i);                    float beta = (float)(bits & 1);                  if ((bits & 2) > 0) beta = 0.5f;                  float alpha = 1.0f - beta;                    alpha2_sum += alpha * alpha;                  beta2_sum += beta * beta;                  alphabeta_sum += alpha * beta;                  alphax_sum += alpha * block[i];                  betax_sum += beta * block[i];              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,OptimizeEndPoints3,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  uint bits = indices >> (2 * i);                    float beta = (float)(bits & 1);                  if ((bits & 2) > 0) beta = 0.5f;                  float alpha = 1.0f - beta;                    alpha2_sum += alpha * alpha;                  beta2_sum += beta * beta;                  alphabeta_sum += alpha * beta;                  alphax_sum += alpha * block[i];                  betax_sum += beta * block[i];              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,OptimizeEndPoints3,The following statement contains a magic number: a = Vector3.Clamp(a' 0' 255);
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,OptimizeEndPoints3,The following statement contains a magic number: b = Vector3.Clamp(b' 0' 255);
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,OptimizeEndPoints4,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  uint bits = indices >> (2 * i);                    float beta = (float)(bits & 1);                  if ((bits & 2) > 0) beta = (1 + beta) / 3.0f;                  float alpha = 1.0f - beta;                    alpha2_sum += alpha * alpha;                  beta2_sum += beta * beta;                  alphabeta_sum += alpha * beta;                  alphax_sum += alpha * block[i];                  betax_sum += beta * block[i];              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,OptimizeEndPoints4,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  uint bits = indices >> (2 * i);                    float beta = (float)(bits & 1);                  if ((bits & 2) > 0) beta = (1 + beta) / 3.0f;                  float alpha = 1.0f - beta;                    alpha2_sum += alpha * alpha;                  beta2_sum += beta * beta;                  alphabeta_sum += alpha * beta;                  alphax_sum += alpha * block[i];                  betax_sum += beta * block[i];              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,OptimizeEndPoints4,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  uint bits = indices >> (2 * i);                    float beta = (float)(bits & 1);                  if ((bits & 2) > 0) beta = (1 + beta) / 3.0f;                  float alpha = 1.0f - beta;                    alpha2_sum += alpha * alpha;                  beta2_sum += beta * beta;                  alphabeta_sum += alpha * beta;                  alphax_sum += alpha * block[i];                  betax_sum += beta * block[i];              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,OptimizeEndPoints4,The following statement contains a magic number: a = Vector3.Clamp(a' 0' 255);
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,OptimizeEndPoints4,The following statement contains a magic number: b = Vector3.Clamp(b' 0' 255);
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,ComputeIndices3,The following statement contains a magic number: Vector3[] palette = new Vector3[4];
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,ComputeIndices3,The following statement contains a magic number: palette[2] = (palette[0] + palette[1]) * 0.5f;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,ComputeIndices3,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  double d0 = ColorDistance(palette[0]' block[i]);                  double d1 = ColorDistance(palette[1]' block[i]);                  double d2 = ColorDistance(palette[2]' block[i]);                    uint index;                  if (d0 < d1 && d0 < d2) index = 0;                  else if (d1 < d2) index = 1;                  else index = 2;                    indices |= index << (2 * i);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,ComputeIndices3,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  double d0 = ColorDistance(palette[0]' block[i]);                  double d1 = ColorDistance(palette[1]' block[i]);                  double d2 = ColorDistance(palette[2]' block[i]);                    uint index;                  if (d0 < d1 && d0 < d2) index = 0;                  else if (d1 < d2) index = 1;                  else index = 2;                    indices |= index << (2 * i);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,ComputeIndices3,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  double d0 = ColorDistance(palette[0]' block[i]);                  double d1 = ColorDistance(palette[1]' block[i]);                  double d2 = ColorDistance(palette[2]' block[i]);                    uint index;                  if (d0 < d1 && d0 < d2) index = 0;                  else if (d1 < d2) index = 1;                  else index = 2;                    indices |= index << (2 * i);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,ComputeIndices3,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  double d0 = ColorDistance(palette[0]' block[i]);                  double d1 = ColorDistance(palette[1]' block[i]);                  double d2 = ColorDistance(palette[2]' block[i]);                    uint index;                  if (d0 < d1 && d0 < d2) index = 0;                  else if (d1 < d2) index = 1;                  else index = 2;                    indices |= index << (2 * i);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,ComputeIndices4,The following statement contains a magic number: Vector3[] palette = new Vector3[4];
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,ComputeIndices4,The following statement contains a magic number: palette[2] = Vector3.Lerp(palette[0]' palette[1]' 3.0f / 8.0f);
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,ComputeIndices4,The following statement contains a magic number: palette[3] = Vector3.Lerp(palette[0]' palette[1]' 5.0f / 8.0f);
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,ComputeIndices4,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  double d0 = ColorDistance(palette[0]' block[i]);                  double d1 = ColorDistance(palette[1]' block[i]);                  double d2 = ColorDistance(palette[2]' block[i]);                  double d3 = ColorDistance(palette[3]' block[i]);                    uint b0 = d0 > d3 ? (uint)1 : 0;                  uint b1 = d1 > d2 ? (uint)1 : 0;                  uint b2 = d0 > d2 ? (uint)1 : 0;                  uint b3 = d1 > d3 ? (uint)1 : 0;                  uint b4 = d2 > d3 ? (uint)1 : 0;                    uint x0 = b1 & b2;                  uint x1 = b0 & b3;                  uint x2 = b0 & b4;                    indices |= (x2 | ((x0 | x1) << 1)) << (2 * i);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,ComputeIndices4,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  double d0 = ColorDistance(palette[0]' block[i]);                  double d1 = ColorDistance(palette[1]' block[i]);                  double d2 = ColorDistance(palette[2]' block[i]);                  double d3 = ColorDistance(palette[3]' block[i]);                    uint b0 = d0 > d3 ? (uint)1 : 0;                  uint b1 = d1 > d2 ? (uint)1 : 0;                  uint b2 = d0 > d2 ? (uint)1 : 0;                  uint b3 = d1 > d3 ? (uint)1 : 0;                  uint b4 = d2 > d3 ? (uint)1 : 0;                    uint x0 = b1 & b2;                  uint x1 = b0 & b3;                  uint x2 = b0 & b4;                    indices |= (x2 | ((x0 | x1) << 1)) << (2 * i);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,ComputeIndices4,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  double d0 = ColorDistance(palette[0]' block[i]);                  double d1 = ColorDistance(palette[1]' block[i]);                  double d2 = ColorDistance(palette[2]' block[i]);                  double d3 = ColorDistance(palette[3]' block[i]);                    uint b0 = d0 > d3 ? (uint)1 : 0;                  uint b1 = d1 > d2 ? (uint)1 : 0;                  uint b2 = d0 > d2 ? (uint)1 : 0;                  uint b3 = d1 > d3 ? (uint)1 : 0;                  uint b4 = d2 > d3 ? (uint)1 : 0;                    uint x0 = b1 & b2;                  uint x1 = b0 & b3;                  uint x2 = b0 & b4;                    indices |= (x2 | ((x0 | x1) << 1)) << (2 * i);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,ComputeIndices4,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  double d0 = ColorDistance(palette[0]' block[i]);                  double d1 = ColorDistance(palette[1]' block[i]);                  double d2 = ColorDistance(palette[2]' block[i]);                  double d3 = ColorDistance(palette[3]' block[i]);                    uint b0 = d0 > d3 ? (uint)1 : 0;                  uint b1 = d1 > d2 ? (uint)1 : 0;                  uint b2 = d0 > d2 ? (uint)1 : 0;                  uint b3 = d1 > d3 ? (uint)1 : 0;                  uint b4 = d2 > d3 ? (uint)1 : 0;                    uint x0 = b1 & b2;                  uint x1 = b0 & b3;                  uint x2 = b0 & b4;                    indices |= (x2 | ((x0 | x1) << 1)) << (2 * i);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,RoundAndExpand,The following statement contains a magic number: float r0 = (float)(((r + 0) << 3) | ((r + 0) >> 2));
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,RoundAndExpand,The following statement contains a magic number: float r0 = (float)(((r + 0) << 3) | ((r + 0) >> 2));
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,RoundAndExpand,The following statement contains a magic number: float r1 = (float)(((r + 1) << 3) | ((r + 1) >> 2));
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,RoundAndExpand,The following statement contains a magic number: float r1 = (float)(((r + 1) << 3) | ((r + 1) >> 2));
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,RoundAndExpand,The following statement contains a magic number: float g0 = (float)(((g + 0) << 3) | ((g + 0) >> 2));
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,RoundAndExpand,The following statement contains a magic number: float g0 = (float)(((g + 0) << 3) | ((g + 0) >> 2));
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,RoundAndExpand,The following statement contains a magic number: float g1 = (float)(((g + 1) << 3) | ((g + 1) >> 2));
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,RoundAndExpand,The following statement contains a magic number: float g1 = (float)(((g + 1) << 3) | ((g + 1) >> 2));
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,RoundAndExpand,The following statement contains a magic number: float b0 = (float)(((b + 0) << 3) | ((b + 0) >> 2));
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,RoundAndExpand,The following statement contains a magic number: float b0 = (float)(((b + 0) << 3) | ((b + 0) >> 2));
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,RoundAndExpand,The following statement contains a magic number: float b1 = (float)(((b + 1) << 3) | ((b + 1) >> 2));
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,RoundAndExpand,The following statement contains a magic number: float b1 = (float)(((b + 1) << 3) | ((b + 1) >> 2));
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,RoundAndExpand,The following statement contains a magic number: ushort w = (ushort)((b << 10) | (g << 5) | r);
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,RoundAndExpand,The following statement contains a magic number: ushort w = (ushort)((b << 10) | (g << 5) | r);
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,RoundAndExpand,The following statement contains a magic number: r = (r << 3) | (r >> 2);
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,RoundAndExpand,The following statement contains a magic number: r = (r << 3) | (r >> 2);
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,RoundAndExpand,The following statement contains a magic number: g = (g << 3) | (g >> 2);
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,RoundAndExpand,The following statement contains a magic number: g = (g << 3) | (g >> 2);
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,RoundAndExpand,The following statement contains a magic number: b = (b << 3) | (b >> 2);
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,RoundAndExpand,The following statement contains a magic number: b = (b << 3) | (b >> 2);
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < block.Length; i++)              {                  inputPoints[i] = ColorToVector(block[i]);                  if (block[i].A >= 8)                  {                      bool dubled = false;                      bool dubledWithMask = false;                      for (int j = i - 1; j >= 0 && (!dubled || !dubledWithMask); --j)                      {                          if (block[j].A >= 8)                          {                              double dist = (inputPoints[i] - inputPoints[j]).LengthSquared();                              if (uniqueFlags[j])                              {                                  dubled |= dist < 1e-6;                                  if (dist > maxDistance)                                  {                                      maxDistance = dist;                                      lowIds[0] = j;                                      highIds[0] = i;                                  }                              }                                if (mask[j] > 0 && mask[i] > 0)                              {                                  dubledWithMask |= dist < 1e-6;                                  if (dist > maxDistanceWithMask)                                  {                                      maxDistanceWithMask = dist;                                      lowIds[2] = j;                                      highIds[2] = i;                                  }                              }                          }                      }                        if (!dubled)                      {                          count++;                          uniqueFlags[i] = true;                          if (maxDistance < 0) lowIds[0] = i;                      }                        if (!dubledWithMask && mask[i] > 0)                      {                          countWithmask++;                          if (maxDistanceWithMask < 0) lowIds[2] = i;                      }                  }                  else hasAlpha = true;              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < block.Length; i++)              {                  inputPoints[i] = ColorToVector(block[i]);                  if (block[i].A >= 8)                  {                      bool dubled = false;                      bool dubledWithMask = false;                      for (int j = i - 1; j >= 0 && (!dubled || !dubledWithMask); --j)                      {                          if (block[j].A >= 8)                          {                              double dist = (inputPoints[i] - inputPoints[j]).LengthSquared();                              if (uniqueFlags[j])                              {                                  dubled |= dist < 1e-6;                                  if (dist > maxDistance)                                  {                                      maxDistance = dist;                                      lowIds[0] = j;                                      highIds[0] = i;                                  }                              }                                if (mask[j] > 0 && mask[i] > 0)                              {                                  dubledWithMask |= dist < 1e-6;                                  if (dist > maxDistanceWithMask)                                  {                                      maxDistanceWithMask = dist;                                      lowIds[2] = j;                                      highIds[2] = i;                                  }                              }                          }                      }                        if (!dubled)                      {                          count++;                          uniqueFlags[i] = true;                          if (maxDistance < 0) lowIds[0] = i;                      }                        if (!dubledWithMask && mask[i] > 0)                      {                          countWithmask++;                          if (maxDistanceWithMask < 0) lowIds[2] = i;                      }                  }                  else hasAlpha = true;              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < block.Length; i++)              {                  inputPoints[i] = ColorToVector(block[i]);                  if (block[i].A >= 8)                  {                      bool dubled = false;                      bool dubledWithMask = false;                      for (int j = i - 1; j >= 0 && (!dubled || !dubledWithMask); --j)                      {                          if (block[j].A >= 8)                          {                              double dist = (inputPoints[i] - inputPoints[j]).LengthSquared();                              if (uniqueFlags[j])                              {                                  dubled |= dist < 1e-6;                                  if (dist > maxDistance)                                  {                                      maxDistance = dist;                                      lowIds[0] = j;                                      highIds[0] = i;                                  }                              }                                if (mask[j] > 0 && mask[i] > 0)                              {                                  dubledWithMask |= dist < 1e-6;                                  if (dist > maxDistanceWithMask)                                  {                                      maxDistanceWithMask = dist;                                      lowIds[2] = j;                                      highIds[2] = i;                                  }                              }                          }                      }                        if (!dubled)                      {                          count++;                          uniqueFlags[i] = true;                          if (maxDistance < 0) lowIds[0] = i;                      }                        if (!dubledWithMask && mask[i] > 0)                      {                          countWithmask++;                          if (maxDistanceWithMask < 0) lowIds[2] = i;                      }                  }                  else hasAlpha = true;              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < block.Length; i++)              {                  inputPoints[i] = ColorToVector(block[i]);                  if (block[i].A >= 8)                  {                      bool dubled = false;                      bool dubledWithMask = false;                      for (int j = i - 1; j >= 0 && (!dubled || !dubledWithMask); --j)                      {                          if (block[j].A >= 8)                          {                              double dist = (inputPoints[i] - inputPoints[j]).LengthSquared();                              if (uniqueFlags[j])                              {                                  dubled |= dist < 1e-6;                                  if (dist > maxDistance)                                  {                                      maxDistance = dist;                                      lowIds[0] = j;                                      highIds[0] = i;                                  }                              }                                if (mask[j] > 0 && mask[i] > 0)                              {                                  dubledWithMask |= dist < 1e-6;                                  if (dist > maxDistanceWithMask)                                  {                                      maxDistanceWithMask = dist;                                      lowIds[2] = j;                                      highIds[2] = i;                                  }                              }                          }                      }                        if (!dubled)                      {                          count++;                          uniqueFlags[i] = true;                          if (maxDistance < 0) lowIds[0] = i;                      }                        if (!dubledWithMask && mask[i] > 0)                      {                          countWithmask++;                          if (maxDistanceWithMask < 0) lowIds[2] = i;                      }                  }                  else hasAlpha = true;              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < block.Length; i++)              {                  inputPoints[i] = ColorToVector(block[i]);                  if (block[i].A >= 8)                  {                      bool dubled = false;                      bool dubledWithMask = false;                      for (int j = i - 1; j >= 0 && (!dubled || !dubledWithMask); --j)                      {                          if (block[j].A >= 8)                          {                              double dist = (inputPoints[i] - inputPoints[j]).LengthSquared();                              if (uniqueFlags[j])                              {                                  dubled |= dist < 1e-6;                                  if (dist > maxDistance)                                  {                                      maxDistance = dist;                                      lowIds[0] = j;                                      highIds[0] = i;                                  }                              }                                if (mask[j] > 0 && mask[i] > 0)                              {                                  dubledWithMask |= dist < 1e-6;                                  if (dist > maxDistanceWithMask)                                  {                                      maxDistanceWithMask = dist;                                      lowIds[2] = j;                                      highIds[2] = i;                                  }                              }                          }                      }                        if (!dubled)                      {                          count++;                          uniqueFlags[i] = true;                          if (maxDistance < 0) lowIds[0] = i;                      }                        if (!dubledWithMask && mask[i] > 0)                      {                          countWithmask++;                          if (maxDistanceWithMask < 0) lowIds[2] = i;                      }                  }                  else hasAlpha = true;              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < block.Length; i++)              {                  inputPoints[i] = ColorToVector(block[i]);                  if (block[i].A >= 8)                  {                      bool dubled = false;                      bool dubledWithMask = false;                      for (int j = i - 1; j >= 0 && (!dubled || !dubledWithMask); --j)                      {                          if (block[j].A >= 8)                          {                              double dist = (inputPoints[i] - inputPoints[j]).LengthSquared();                              if (uniqueFlags[j])                              {                                  dubled |= dist < 1e-6;                                  if (dist > maxDistance)                                  {                                      maxDistance = dist;                                      lowIds[0] = j;                                      highIds[0] = i;                                  }                              }                                if (mask[j] > 0 && mask[i] > 0)                              {                                  dubledWithMask |= dist < 1e-6;                                  if (dist > maxDistanceWithMask)                                  {                                      maxDistanceWithMask = dist;                                      lowIds[2] = j;                                      highIds[2] = i;                                  }                              }                          }                      }                        if (!dubled)                      {                          count++;                          uniqueFlags[i] = true;                          if (maxDistance < 0) lowIds[0] = i;                      }                        if (!dubledWithMask && mask[i] > 0)                      {                          countWithmask++;                          if (maxDistanceWithMask < 0) lowIds[2] = i;                      }                  }                  else hasAlpha = true;              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < block.Length; i++)              {                  inputPoints[i] = ColorToVector(block[i]);                  if (block[i].A >= 8)                  {                      bool dubled = false;                      bool dubledWithMask = false;                      for (int j = i - 1; j >= 0 && (!dubled || !dubledWithMask); --j)                      {                          if (block[j].A >= 8)                          {                              double dist = (inputPoints[i] - inputPoints[j]).LengthSquared();                              if (uniqueFlags[j])                              {                                  dubled |= dist < 1e-6;                                  if (dist > maxDistance)                                  {                                      maxDistance = dist;                                      lowIds[0] = j;                                      highIds[0] = i;                                  }                              }                                if (mask[j] > 0 && mask[i] > 0)                              {                                  dubledWithMask |= dist < 1e-6;                                  if (dist > maxDistanceWithMask)                                  {                                      maxDistanceWithMask = dist;                                      lowIds[2] = j;                                      highIds[2] = i;                                  }                              }                          }                      }                        if (!dubled)                      {                          count++;                          uniqueFlags[i] = true;                          if (maxDistance < 0) lowIds[0] = i;                      }                        if (!dubledWithMask && mask[i] > 0)                      {                          countWithmask++;                          if (maxDistanceWithMask < 0) lowIds[2] = i;                      }                  }                  else hasAlpha = true;              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: if (count <= 4)                  compressed = IsCompressedBlock(block' uniqueFlags' count' lowIds[0]' highIds[0]' out dxtBoundColors' ref hasAlpha);
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: Vector3[] dxtBoundPoints = new Vector3[2];
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: if (!compressed)              {                  hasAlpha = hasAlpha0;                  if (countWithmask == 0)                  {                      bestError = 0;                      dxtBoundPoints[0] = inputPoints[lowIds[0]];                      dxtBoundPoints[1] = inputPoints[highIds[0]];                      hasAlpha = true;                  }                  else if (countWithmask == 1)                  {                      bestError = Math.Max(0' maxDistance);                      uint dist0 = ColorSquaredDistance(block[lowIds[2]]' block[lowIds[0]]);                      uint dist1 = ColorSquaredDistance(block[lowIds[2]]' block[highIds[0]]);                      if (dist0 > dist1)                          dxtBoundPoints[1] = inputPoints[lowIds[0]];                      else                          dxtBoundPoints[1] = inputPoints[highIds[0]];                      dxtBoundPoints[0] = inputPoints[lowIds[2]];                      hasAlpha = true;                  }                  else                  {                      Vector3 maxColor = inputPoints[lowIds[2]];                      Vector3 minColor = inputPoints[highIds[2]];                        UInt16 color0 = RoundAndExpand(ref maxColor);                      UInt16 color1 = RoundAndExpand(ref minColor);                      hasAlpha |= color0 == color1;                        if (color0 < color1)                      {                          NvMath.Swap(ref maxColor' ref minColor);                          NvMath.Swap(ref color0' ref color1);                      }                        dxtBoundPoints[0] = maxColor;                      dxtBoundPoints[1] = minColor;                      if (!hasAlpha)                      {                          uint indices = ComputeIndices4(inputPoints' maxColor' minColor);                          OptimizeEndPoints4(inputPoints' ref dxtBoundPoints' ref indices);                      }                      //else                      //{                      //    uint indices = computeIndices3(inputPoints' maxColor' minColor);                      //    optimizeEndPoints3(inputPoints' ref dxtBoundPoints' ref indices);                      //}                  }              }              else              {                  for (int i = 0; i < 2; i++) dxtBoundPoints[i] = ColorToVector(dxtBoundColors[i]);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: if (!compressed)              {                  hasAlpha = hasAlpha0;                  if (countWithmask == 0)                  {                      bestError = 0;                      dxtBoundPoints[0] = inputPoints[lowIds[0]];                      dxtBoundPoints[1] = inputPoints[highIds[0]];                      hasAlpha = true;                  }                  else if (countWithmask == 1)                  {                      bestError = Math.Max(0' maxDistance);                      uint dist0 = ColorSquaredDistance(block[lowIds[2]]' block[lowIds[0]]);                      uint dist1 = ColorSquaredDistance(block[lowIds[2]]' block[highIds[0]]);                      if (dist0 > dist1)                          dxtBoundPoints[1] = inputPoints[lowIds[0]];                      else                          dxtBoundPoints[1] = inputPoints[highIds[0]];                      dxtBoundPoints[0] = inputPoints[lowIds[2]];                      hasAlpha = true;                  }                  else                  {                      Vector3 maxColor = inputPoints[lowIds[2]];                      Vector3 minColor = inputPoints[highIds[2]];                        UInt16 color0 = RoundAndExpand(ref maxColor);                      UInt16 color1 = RoundAndExpand(ref minColor);                      hasAlpha |= color0 == color1;                        if (color0 < color1)                      {                          NvMath.Swap(ref maxColor' ref minColor);                          NvMath.Swap(ref color0' ref color1);                      }                        dxtBoundPoints[0] = maxColor;                      dxtBoundPoints[1] = minColor;                      if (!hasAlpha)                      {                          uint indices = ComputeIndices4(inputPoints' maxColor' minColor);                          OptimizeEndPoints4(inputPoints' ref dxtBoundPoints' ref indices);                      }                      //else                      //{                      //    uint indices = computeIndices3(inputPoints' maxColor' minColor);                      //    optimizeEndPoints3(inputPoints' ref dxtBoundPoints' ref indices);                      //}                  }              }              else              {                  for (int i = 0; i < 2; i++) dxtBoundPoints[i] = ColorToVector(dxtBoundColors[i]);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: if (!compressed)              {                  hasAlpha = hasAlpha0;                  if (countWithmask == 0)                  {                      bestError = 0;                      dxtBoundPoints[0] = inputPoints[lowIds[0]];                      dxtBoundPoints[1] = inputPoints[highIds[0]];                      hasAlpha = true;                  }                  else if (countWithmask == 1)                  {                      bestError = Math.Max(0' maxDistance);                      uint dist0 = ColorSquaredDistance(block[lowIds[2]]' block[lowIds[0]]);                      uint dist1 = ColorSquaredDistance(block[lowIds[2]]' block[highIds[0]]);                      if (dist0 > dist1)                          dxtBoundPoints[1] = inputPoints[lowIds[0]];                      else                          dxtBoundPoints[1] = inputPoints[highIds[0]];                      dxtBoundPoints[0] = inputPoints[lowIds[2]];                      hasAlpha = true;                  }                  else                  {                      Vector3 maxColor = inputPoints[lowIds[2]];                      Vector3 minColor = inputPoints[highIds[2]];                        UInt16 color0 = RoundAndExpand(ref maxColor);                      UInt16 color1 = RoundAndExpand(ref minColor);                      hasAlpha |= color0 == color1;                        if (color0 < color1)                      {                          NvMath.Swap(ref maxColor' ref minColor);                          NvMath.Swap(ref color0' ref color1);                      }                        dxtBoundPoints[0] = maxColor;                      dxtBoundPoints[1] = minColor;                      if (!hasAlpha)                      {                          uint indices = ComputeIndices4(inputPoints' maxColor' minColor);                          OptimizeEndPoints4(inputPoints' ref dxtBoundPoints' ref indices);                      }                      //else                      //{                      //    uint indices = computeIndices3(inputPoints' maxColor' minColor);                      //    optimizeEndPoints3(inputPoints' ref dxtBoundPoints' ref indices);                      //}                  }              }              else              {                  for (int i = 0; i < 2; i++) dxtBoundPoints[i] = ColorToVector(dxtBoundColors[i]);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: if (!compressed)              {                  hasAlpha = hasAlpha0;                  if (countWithmask == 0)                  {                      bestError = 0;                      dxtBoundPoints[0] = inputPoints[lowIds[0]];                      dxtBoundPoints[1] = inputPoints[highIds[0]];                      hasAlpha = true;                  }                  else if (countWithmask == 1)                  {                      bestError = Math.Max(0' maxDistance);                      uint dist0 = ColorSquaredDistance(block[lowIds[2]]' block[lowIds[0]]);                      uint dist1 = ColorSquaredDistance(block[lowIds[2]]' block[highIds[0]]);                      if (dist0 > dist1)                          dxtBoundPoints[1] = inputPoints[lowIds[0]];                      else                          dxtBoundPoints[1] = inputPoints[highIds[0]];                      dxtBoundPoints[0] = inputPoints[lowIds[2]];                      hasAlpha = true;                  }                  else                  {                      Vector3 maxColor = inputPoints[lowIds[2]];                      Vector3 minColor = inputPoints[highIds[2]];                        UInt16 color0 = RoundAndExpand(ref maxColor);                      UInt16 color1 = RoundAndExpand(ref minColor);                      hasAlpha |= color0 == color1;                        if (color0 < color1)                      {                          NvMath.Swap(ref maxColor' ref minColor);                          NvMath.Swap(ref color0' ref color1);                      }                        dxtBoundPoints[0] = maxColor;                      dxtBoundPoints[1] = minColor;                      if (!hasAlpha)                      {                          uint indices = ComputeIndices4(inputPoints' maxColor' minColor);                          OptimizeEndPoints4(inputPoints' ref dxtBoundPoints' ref indices);                      }                      //else                      //{                      //    uint indices = computeIndices3(inputPoints' maxColor' minColor);                      //    optimizeEndPoints3(inputPoints' ref dxtBoundPoints' ref indices);                      //}                  }              }              else              {                  for (int i = 0; i < 2; i++) dxtBoundPoints[i] = ColorToVector(dxtBoundColors[i]);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: if (!compressed)              {                  hasAlpha = hasAlpha0;                  if (countWithmask == 0)                  {                      bestError = 0;                      dxtBoundPoints[0] = inputPoints[lowIds[0]];                      dxtBoundPoints[1] = inputPoints[highIds[0]];                      hasAlpha = true;                  }                  else if (countWithmask == 1)                  {                      bestError = Math.Max(0' maxDistance);                      uint dist0 = ColorSquaredDistance(block[lowIds[2]]' block[lowIds[0]]);                      uint dist1 = ColorSquaredDistance(block[lowIds[2]]' block[highIds[0]]);                      if (dist0 > dist1)                          dxtBoundPoints[1] = inputPoints[lowIds[0]];                      else                          dxtBoundPoints[1] = inputPoints[highIds[0]];                      dxtBoundPoints[0] = inputPoints[lowIds[2]];                      hasAlpha = true;                  }                  else                  {                      Vector3 maxColor = inputPoints[lowIds[2]];                      Vector3 minColor = inputPoints[highIds[2]];                        UInt16 color0 = RoundAndExpand(ref maxColor);                      UInt16 color1 = RoundAndExpand(ref minColor);                      hasAlpha |= color0 == color1;                        if (color0 < color1)                      {                          NvMath.Swap(ref maxColor' ref minColor);                          NvMath.Swap(ref color0' ref color1);                      }                        dxtBoundPoints[0] = maxColor;                      dxtBoundPoints[1] = minColor;                      if (!hasAlpha)                      {                          uint indices = ComputeIndices4(inputPoints' maxColor' minColor);                          OptimizeEndPoints4(inputPoints' ref dxtBoundPoints' ref indices);                      }                      //else                      //{                      //    uint indices = computeIndices3(inputPoints' maxColor' minColor);                      //    optimizeEndPoints3(inputPoints' ref dxtBoundPoints' ref indices);                      //}                  }              }              else              {                  for (int i = 0; i < 2; i++) dxtBoundPoints[i] = ColorToVector(dxtBoundColors[i]);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: if (!compressed)              {                  hasAlpha = hasAlpha0;                  if (countWithmask == 0)                  {                      bestError = 0;                      dxtBoundPoints[0] = inputPoints[lowIds[0]];                      dxtBoundPoints[1] = inputPoints[highIds[0]];                      hasAlpha = true;                  }                  else if (countWithmask == 1)                  {                      bestError = Math.Max(0' maxDistance);                      uint dist0 = ColorSquaredDistance(block[lowIds[2]]' block[lowIds[0]]);                      uint dist1 = ColorSquaredDistance(block[lowIds[2]]' block[highIds[0]]);                      if (dist0 > dist1)                          dxtBoundPoints[1] = inputPoints[lowIds[0]];                      else                          dxtBoundPoints[1] = inputPoints[highIds[0]];                      dxtBoundPoints[0] = inputPoints[lowIds[2]];                      hasAlpha = true;                  }                  else                  {                      Vector3 maxColor = inputPoints[lowIds[2]];                      Vector3 minColor = inputPoints[highIds[2]];                        UInt16 color0 = RoundAndExpand(ref maxColor);                      UInt16 color1 = RoundAndExpand(ref minColor);                      hasAlpha |= color0 == color1;                        if (color0 < color1)                      {                          NvMath.Swap(ref maxColor' ref minColor);                          NvMath.Swap(ref color0' ref color1);                      }                        dxtBoundPoints[0] = maxColor;                      dxtBoundPoints[1] = minColor;                      if (!hasAlpha)                      {                          uint indices = ComputeIndices4(inputPoints' maxColor' minColor);                          OptimizeEndPoints4(inputPoints' ref dxtBoundPoints' ref indices);                      }                      //else                      //{                      //    uint indices = computeIndices3(inputPoints' maxColor' minColor);                      //    optimizeEndPoints3(inputPoints' ref dxtBoundPoints' ref indices);                      //}                  }              }              else              {                  for (int i = 0; i < 2; i++) dxtBoundPoints[i] = ColorToVector(dxtBoundColors[i]);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: compressColors = new Color[4];
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < 2; i++) compressColors[i] = VectorToColor(dxtBoundPoints[i]);
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: if (hasAlpha)              {                  compressColors[2] = SumColors(compressColors[0]' compressColors[1]' 1' 1);                  compressColors[3] = Color.FromArgb(0' 0' 0' 0);              }              else              {                  compressColors[2] = SumColors(compressColors[0]' compressColors[1]' 5' 3);                  compressColors[3] = SumColors(compressColors[0]' compressColors[1]' 3' 5);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: if (hasAlpha)              {                  compressColors[2] = SumColors(compressColors[0]' compressColors[1]' 1' 1);                  compressColors[3] = Color.FromArgb(0' 0' 0' 0);              }              else              {                  compressColors[2] = SumColors(compressColors[0]' compressColors[1]' 5' 3);                  compressColors[3] = SumColors(compressColors[0]' compressColors[1]' 3' 5);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: if (hasAlpha)              {                  compressColors[2] = SumColors(compressColors[0]' compressColors[1]' 1' 1);                  compressColors[3] = Color.FromArgb(0' 0' 0' 0);              }              else              {                  compressColors[2] = SumColors(compressColors[0]' compressColors[1]' 5' 3);                  compressColors[3] = SumColors(compressColors[0]' compressColors[1]' 3' 5);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: if (hasAlpha)              {                  compressColors[2] = SumColors(compressColors[0]' compressColors[1]' 1' 1);                  compressColors[3] = Color.FromArgb(0' 0' 0' 0);              }              else              {                  compressColors[2] = SumColors(compressColors[0]' compressColors[1]' 5' 3);                  compressColors[3] = SumColors(compressColors[0]' compressColors[1]' 3' 5);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: if (hasAlpha)              {                  compressColors[2] = SumColors(compressColors[0]' compressColors[1]' 1' 1);                  compressColors[3] = Color.FromArgb(0' 0' 0' 0);              }              else              {                  compressColors[2] = SumColors(compressColors[0]' compressColors[1]' 5' 3);                  compressColors[3] = SumColors(compressColors[0]' compressColors[1]' 3' 5);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: if (hasAlpha)              {                  compressColors[2] = SumColors(compressColors[0]' compressColors[1]' 1' 1);                  compressColors[3] = Color.FromArgb(0' 0' 0' 0);              }              else              {                  compressColors[2] = SumColors(compressColors[0]' compressColors[1]' 5' 3);                  compressColors[3] = SumColors(compressColors[0]' compressColors[1]' 3' 5);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: if (hasAlpha)              {                  compressColors[2] = SumColors(compressColors[0]' compressColors[1]' 1' 1);                  compressColors[3] = Color.FromArgb(0' 0' 0' 0);              }              else              {                  compressColors[2] = SumColors(compressColors[0]' compressColors[1]' 5' 3);                  compressColors[3] = SumColors(compressColors[0]' compressColors[1]' 3' 5);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: if (hasAlpha)              {                  compressColors[2] = SumColors(compressColors[0]' compressColors[1]' 1' 1);                  compressColors[3] = Color.FromArgb(0' 0' 0' 0);              }              else              {                  compressColors[2] = SumColors(compressColors[0]' compressColors[1]' 5' 3);                  compressColors[3] = SumColors(compressColors[0]' compressColors[1]' 3' 5);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  byte ci;                  if (block[i].A >= 8)                  {                      double dist0 = ColorSquaredDistance(block[i]' compressColors[0]);                      double dist1 = ColorSquaredDistance(block[i]' compressColors[1]);                      double dist2 = ColorSquaredDistance(block[i]' compressColors[2]);                      double dist3 = ColorSquaredDistance(block[i]' compressColors[3]);                        if (dist0 < dist2)                      {                          ci = 0;                          bestError += dist0;                      }                      else if (dist1 < dist2 && dist1 < dist3)                      {                          ci = 1;                          bestError += dist1;                      }                      else if (dist2 < dist3)                      {                          ci = 2;                          bestError += dist2;                      }                      else                      {                          ci = 3;                          bestError += dist3;                      }                  }                  else ci = 3;                    texels |= (uint)(ci << (2 * i));              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  byte ci;                  if (block[i].A >= 8)                  {                      double dist0 = ColorSquaredDistance(block[i]' compressColors[0]);                      double dist1 = ColorSquaredDistance(block[i]' compressColors[1]);                      double dist2 = ColorSquaredDistance(block[i]' compressColors[2]);                      double dist3 = ColorSquaredDistance(block[i]' compressColors[3]);                        if (dist0 < dist2)                      {                          ci = 0;                          bestError += dist0;                      }                      else if (dist1 < dist2 && dist1 < dist3)                      {                          ci = 1;                          bestError += dist1;                      }                      else if (dist2 < dist3)                      {                          ci = 2;                          bestError += dist2;                      }                      else                      {                          ci = 3;                          bestError += dist3;                      }                  }                  else ci = 3;                    texels |= (uint)(ci << (2 * i));              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  byte ci;                  if (block[i].A >= 8)                  {                      double dist0 = ColorSquaredDistance(block[i]' compressColors[0]);                      double dist1 = ColorSquaredDistance(block[i]' compressColors[1]);                      double dist2 = ColorSquaredDistance(block[i]' compressColors[2]);                      double dist3 = ColorSquaredDistance(block[i]' compressColors[3]);                        if (dist0 < dist2)                      {                          ci = 0;                          bestError += dist0;                      }                      else if (dist1 < dist2 && dist1 < dist3)                      {                          ci = 1;                          bestError += dist1;                      }                      else if (dist2 < dist3)                      {                          ci = 2;                          bestError += dist2;                      }                      else                      {                          ci = 3;                          bestError += dist3;                      }                  }                  else ci = 3;                    texels |= (uint)(ci << (2 * i));              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  byte ci;                  if (block[i].A >= 8)                  {                      double dist0 = ColorSquaredDistance(block[i]' compressColors[0]);                      double dist1 = ColorSquaredDistance(block[i]' compressColors[1]);                      double dist2 = ColorSquaredDistance(block[i]' compressColors[2]);                      double dist3 = ColorSquaredDistance(block[i]' compressColors[3]);                        if (dist0 < dist2)                      {                          ci = 0;                          bestError += dist0;                      }                      else if (dist1 < dist2 && dist1 < dist3)                      {                          ci = 1;                          bestError += dist1;                      }                      else if (dist2 < dist3)                      {                          ci = 2;                          bestError += dist2;                      }                      else                      {                          ci = 3;                          bestError += dist3;                      }                  }                  else ci = 3;                    texels |= (uint)(ci << (2 * i));              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  byte ci;                  if (block[i].A >= 8)                  {                      double dist0 = ColorSquaredDistance(block[i]' compressColors[0]);                      double dist1 = ColorSquaredDistance(block[i]' compressColors[1]);                      double dist2 = ColorSquaredDistance(block[i]' compressColors[2]);                      double dist3 = ColorSquaredDistance(block[i]' compressColors[3]);                        if (dist0 < dist2)                      {                          ci = 0;                          bestError += dist0;                      }                      else if (dist1 < dist2 && dist1 < dist3)                      {                          ci = 1;                          bestError += dist1;                      }                      else if (dist2 < dist3)                      {                          ci = 2;                          bestError += dist2;                      }                      else                      {                          ci = 3;                          bestError += dist3;                      }                  }                  else ci = 3;                    texels |= (uint)(ci << (2 * i));              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  byte ci;                  if (block[i].A >= 8)                  {                      double dist0 = ColorSquaredDistance(block[i]' compressColors[0]);                      double dist1 = ColorSquaredDistance(block[i]' compressColors[1]);                      double dist2 = ColorSquaredDistance(block[i]' compressColors[2]);                      double dist3 = ColorSquaredDistance(block[i]' compressColors[3]);                        if (dist0 < dist2)                      {                          ci = 0;                          bestError += dist0;                      }                      else if (dist1 < dist2 && dist1 < dist3)                      {                          ci = 1;                          bestError += dist1;                      }                      else if (dist2 < dist3)                      {                          ci = 2;                          bestError += dist2;                      }                      else                      {                          ci = 3;                          bestError += dist3;                      }                  }                  else ci = 3;                    texels |= (uint)(ci << (2 * i));              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  byte ci;                  if (block[i].A >= 8)                  {                      double dist0 = ColorSquaredDistance(block[i]' compressColors[0]);                      double dist1 = ColorSquaredDistance(block[i]' compressColors[1]);                      double dist2 = ColorSquaredDistance(block[i]' compressColors[2]);                      double dist3 = ColorSquaredDistance(block[i]' compressColors[3]);                        if (dist0 < dist2)                      {                          ci = 0;                          bestError += dist0;                      }                      else if (dist1 < dist2 && dist1 < dist3)                      {                          ci = 1;                          bestError += dist1;                      }                      else if (dist2 < dist3)                      {                          ci = 2;                          bestError += dist2;                      }                      else                      {                          ci = 3;                          bestError += dist3;                      }                  }                  else ci = 3;                    texels |= (uint)(ci << (2 * i));              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  byte ci;                  if (block[i].A >= 8)                  {                      double dist0 = ColorSquaredDistance(block[i]' compressColors[0]);                      double dist1 = ColorSquaredDistance(block[i]' compressColors[1]);                      double dist2 = ColorSquaredDistance(block[i]' compressColors[2]);                      double dist3 = ColorSquaredDistance(block[i]' compressColors[3]);                        if (dist0 < dist2)                      {                          ci = 0;                          bestError += dist0;                      }                      else if (dist1 < dist2 && dist1 < dist3)                      {                          ci = 1;                          bestError += dist1;                      }                      else if (dist2 < dist3)                      {                          ci = 2;                          bestError += dist2;                      }                      else                      {                          ci = 3;                          bestError += dist3;                      }                  }                  else ci = 3;                    texels |= (uint)(ci << (2 * i));              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,CompressBlock,The following statement contains a magic number: return Math.Sqrt(bestError / 16);
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: uint wt = width / 4;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: uint texelsCount = width * height / 16;
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: byte[] result = new byte[texelsCount * 6];
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint y = 0; y < height; y += 4)              {                  for (uint x = 0; x < width; x += 4)                  {                      Color[] block = new Color[16];                      for (int j = 0; j < 4; j++)                      {                          for (int i = 0; i < 4; i++)                          {                              uint pixelIndex = (uint)((y + i) * width + (x + j));                              int pixelBlockIndex = i * 4 + j;                              block[pixelBlockIndex] = Color.FromArgb(                                  bgra[4 * pixelIndex + 3]'                                   bgra[4 * pixelIndex + 2]'                                   bgra[4 * pixelIndex + 1]'                                   bgra[4 * pixelIndex + 0]);                          }                      }                        int[] mask;                      if (boundaryApprox)                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 0' 0' 1'                              1' 0' 0' 1'                              1' 1' 1' 1                          };                      }                      else                      {                          mask = new[] {                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1'                              1' 1' 1' 1                          };                      }                        // try                      {                          Color[] compressColors;                          uint texels = 0;                          ushort c0' c1;                          double err = CompressBlock(block' mask' out compressColors' out c0' out c1' out texels);                            uint texelIndex = y / 4 * wt + x / 4;                          uint resIndex = texelIndex * 4;                          result[resIndex + 0] = (byte)((texels >> 0) & 0xFF);                          result[resIndex + 1] = (byte)((texels >> 8) & 0xFF);                          result[resIndex + 2] = (byte)((texels >> 16) & 0xFF);                          result[resIndex + 3] = (byte)((texels >> 24) & 0xFF);                            palTypes[texelIndex] = (c0 <= c1) ? (byte)1 : (byte)3;                          colorPairsOrQuarts[texelIndex] = (c0 <= c1) ? (uint)((c1 << 16) | c0) : (uint)((c0 << 16) | c1);                            int colorIndex = -1;                          if (!onlyInterpolatedPalettes && err >= 16)                          {                              Vector3[] cV = { Vector3.Zero' Vector3.Zero' Vector3.Zero' Vector3.Zero };                              int[] cN = { 0' 0' 0' 0};                              for (int i = 0; i < 16; i++)                              {                                  uint ci = (texels >> (2 * i)) & 0x3;                                  cV[ci] += ColorToVector(block[i]);                                  cN[ci]++;                              }                                if (cN[2] != 0 || cN[3] != 0)                              {                                  palTypes[texelIndex] -= 1;                                    ushort[] c = new ushort[4];                                  for (int ci = 0; ci < 4; ci++)                                  {                                      if (cN[ci] > 0) cV[ci] /= cN[ci];                                      c[ci] = RoundAndExpand(ref cV[ci]);                                  }                                    colorPairsOrQuarts[texelIndex] = ((ulong)((c[3] << 16) | c[2]) << 32) | (ulong)((c[1] << 16) | c[0]);                                  colorIndex = 2 * colorQuarts.IndexOf(colorPairsOrQuarts[texelIndex]);                                  if (colorIndex < 0)                                  {                                      colorIndex = 2 * colorQuarts.Count;                                      colorQuarts.Add(colorPairsOrQuarts[texelIndex]);                                  }                              }                          }                            colorPairIndexes[texelIndex] = colorIndex;                      }                      // catch (Exception e)                      // {                      //    throw e;                      // }                  }              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (int i = 0; i < colorQuarts.Count; i++)              {                  UInt32 pair1 = (uint)(colorQuarts[i] & 0xFFFFFFFF);                  UInt32 pair2 = (uint)((colorQuarts[i] >> 32) & 0xFFFFFFFF);                  colorPairs.Add(pair1);                  colorPairs.Add(pair2);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint i = 0; i < texelsCount; i++)              {                  int colorIndex = colorPairIndexes[i];                  if (palTypes[i] % 2 != 0)                  {                      UInt32 colorPair = (uint)colorPairsOrQuarts[i];                      colorIndex = colorPairs.IndexOf(colorPair);                      if (colorIndex < 0)                      {                          colorIndex = colorPairs.Count;                          colorPairs.Add(colorPair);                      }                  }                    if (colorIndex > 0x3FFF) colorIndex = 0;                  ushort palInfo = (ushort)((colorIndex & 0x3FFF) | (palTypes[i] << 14));                  uint resIndex = texelsCount * 4 + i * 2;                  result[resIndex + 0] = (byte)((palInfo >> 0) & 0xFF);                  result[resIndex + 1] = (byte)((palInfo >> 8) & 0xFF);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint i = 0; i < texelsCount; i++)              {                  int colorIndex = colorPairIndexes[i];                  if (palTypes[i] % 2 != 0)                  {                      UInt32 colorPair = (uint)colorPairsOrQuarts[i];                      colorIndex = colorPairs.IndexOf(colorPair);                      if (colorIndex < 0)                      {                          colorIndex = colorPairs.Count;                          colorPairs.Add(colorPair);                      }                  }                    if (colorIndex > 0x3FFF) colorIndex = 0;                  ushort palInfo = (ushort)((colorIndex & 0x3FFF) | (palTypes[i] << 14));                  uint resIndex = texelsCount * 4 + i * 2;                  result[resIndex + 0] = (byte)((palInfo >> 0) & 0xFF);                  result[resIndex + 1] = (byte)((palInfo >> 8) & 0xFF);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint i = 0; i < texelsCount; i++)              {                  int colorIndex = colorPairIndexes[i];                  if (palTypes[i] % 2 != 0)                  {                      UInt32 colorPair = (uint)colorPairsOrQuarts[i];                      colorIndex = colorPairs.IndexOf(colorPair);                      if (colorIndex < 0)                      {                          colorIndex = colorPairs.Count;                          colorPairs.Add(colorPair);                      }                  }                    if (colorIndex > 0x3FFF) colorIndex = 0;                  ushort palInfo = (ushort)((colorIndex & 0x3FFF) | (palTypes[i] << 14));                  uint resIndex = texelsCount * 4 + i * 2;                  result[resIndex + 0] = (byte)((palInfo >> 0) & 0xFF);                  result[resIndex + 1] = (byte)((palInfo >> 8) & 0xFF);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint i = 0; i < texelsCount; i++)              {                  int colorIndex = colorPairIndexes[i];                  if (palTypes[i] % 2 != 0)                  {                      UInt32 colorPair = (uint)colorPairsOrQuarts[i];                      colorIndex = colorPairs.IndexOf(colorPair);                      if (colorIndex < 0)                      {                          colorIndex = colorPairs.Count;                          colorPairs.Add(colorPair);                      }                  }                    if (colorIndex > 0x3FFF) colorIndex = 0;                  ushort palInfo = (ushort)((colorIndex & 0x3FFF) | (palTypes[i] << 14));                  uint resIndex = texelsCount * 4 + i * 2;                  result[resIndex + 0] = (byte)((palInfo >> 0) & 0xFF);                  result[resIndex + 1] = (byte)((palInfo >> 8) & 0xFF);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (uint i = 0; i < texelsCount; i++)              {                  int colorIndex = colorPairIndexes[i];                  if (palTypes[i] % 2 != 0)                  {                      UInt32 colorPair = (uint)colorPairsOrQuarts[i];                      colorIndex = colorPairs.IndexOf(colorPair);                      if (colorIndex < 0)                      {                          colorIndex = colorPairs.Count;                          colorPairs.Add(colorPair);                      }                  }                    if (colorIndex > 0x3FFF) colorIndex = 0;                  ushort palInfo = (ushort)((colorIndex & 0x3FFF) | (palTypes[i] << 14));                  uint resIndex = texelsCount * 4 + i * 2;                  result[resIndex + 0] = (byte)((palInfo >> 0) & 0xFF);                  result[resIndex + 1] = (byte)((palInfo >> 8) & 0xFF);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: palette = new byte[colorPairs.Count * 4];
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (int i = 0; i < colorPairs.Count; i++)              {                  byte[] colorsData = BitConverter.GetBytes(colorPairs[i]);                  Array.Copy(colorsData' 0' palette' 4 * i' 4);              }
Magic Number,Ekona.Images,NitroTextureCompressor,C:\repos\pleonex_tinke\Ekona\Images\NitroTextureCompressor.cs,Compress,The following statement contains a magic number: for (int i = 0; i < colorPairs.Count; i++)              {                  byte[] colorsData = BitConverter.GetBytes(colorPairs[i]);                  Array.Copy(colorsData' 0' palette' 4 * i' 4);              }
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,Update_Image,The following statement contains a magic number: imgBox.Image = sprite.Get_Image(image' palette' comboBank.SelectedIndex' 512' 256'                  checkGrid.Checked' checkCellBorder.Checked' checkNumber.Checked' checkTransparency.Checked'                  checkImage.Checked' (checkSelectOAM.Checked ? checkListOAM.SelectedIndex : -1)'                   index);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,Update_Image,The following statement contains a magic number: imgBox.Image = sprite.Get_Image(image' palette' comboBank.SelectedIndex' 512' 256'                  checkGrid.Checked' checkCellBorder.Checked' checkNumber.Checked' checkTransparency.Checked'                  checkImage.Checked' (checkSelectOAM.Checked ? checkListOAM.SelectedIndex : -1)'                   index);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,btnShowAll_Click,The following statement contains a magic number: int xMax = 516 * 2;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,btnShowAll_Click,The following statement contains a magic number: int xMax = 516 * 2;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,btnShowAll_Click,The following statement contains a magic number: int y = 15;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,btnShowAll_Click,The following statement contains a magic number: for (int i = 0; i < sprite.NumBanks; i++)              {                  PictureBox pic = new PictureBox();                  pic.Size = new Size(512' 256);                  pic.Location = new Point(x' y);                  pic.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;                  pic.Image = sprite.Get_Image(image' palette' i' 512' 256'                      checkGrid.Checked' checkCellBorder.Checked' checkNumber.Checked'                      checkTransparency.Checked' checkImage.Checked);                    Label lbl = new Label();                  lbl.Text = sprite.Banks[i].name;                  lbl.Location = new Point(x' y - 15);                    win.Controls.Add(pic);                  win.Controls.Add(lbl);                    x += 516;                  if (x >= xMax)                  {                      x = 0;                      y += 275;                  }              }
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,btnShowAll_Click,The following statement contains a magic number: for (int i = 0; i < sprite.NumBanks; i++)              {                  PictureBox pic = new PictureBox();                  pic.Size = new Size(512' 256);                  pic.Location = new Point(x' y);                  pic.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;                  pic.Image = sprite.Get_Image(image' palette' i' 512' 256'                      checkGrid.Checked' checkCellBorder.Checked' checkNumber.Checked'                      checkTransparency.Checked' checkImage.Checked);                    Label lbl = new Label();                  lbl.Text = sprite.Banks[i].name;                  lbl.Location = new Point(x' y - 15);                    win.Controls.Add(pic);                  win.Controls.Add(lbl);                    x += 516;                  if (x >= xMax)                  {                      x = 0;                      y += 275;                  }              }
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,btnShowAll_Click,The following statement contains a magic number: for (int i = 0; i < sprite.NumBanks; i++)              {                  PictureBox pic = new PictureBox();                  pic.Size = new Size(512' 256);                  pic.Location = new Point(x' y);                  pic.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;                  pic.Image = sprite.Get_Image(image' palette' i' 512' 256'                      checkGrid.Checked' checkCellBorder.Checked' checkNumber.Checked'                      checkTransparency.Checked' checkImage.Checked);                    Label lbl = new Label();                  lbl.Text = sprite.Banks[i].name;                  lbl.Location = new Point(x' y - 15);                    win.Controls.Add(pic);                  win.Controls.Add(lbl);                    x += 516;                  if (x >= xMax)                  {                      x = 0;                      y += 275;                  }              }
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,btnShowAll_Click,The following statement contains a magic number: for (int i = 0; i < sprite.NumBanks; i++)              {                  PictureBox pic = new PictureBox();                  pic.Size = new Size(512' 256);                  pic.Location = new Point(x' y);                  pic.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;                  pic.Image = sprite.Get_Image(image' palette' i' 512' 256'                      checkGrid.Checked' checkCellBorder.Checked' checkNumber.Checked'                      checkTransparency.Checked' checkImage.Checked);                    Label lbl = new Label();                  lbl.Text = sprite.Banks[i].name;                  lbl.Location = new Point(x' y - 15);                    win.Controls.Add(pic);                  win.Controls.Add(lbl);                    x += 516;                  if (x >= xMax)                  {                      x = 0;                      y += 275;                  }              }
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,btnShowAll_Click,The following statement contains a magic number: for (int i = 0; i < sprite.NumBanks; i++)              {                  PictureBox pic = new PictureBox();                  pic.Size = new Size(512' 256);                  pic.Location = new Point(x' y);                  pic.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;                  pic.Image = sprite.Get_Image(image' palette' i' 512' 256'                      checkGrid.Checked' checkCellBorder.Checked' checkNumber.Checked'                      checkTransparency.Checked' checkImage.Checked);                    Label lbl = new Label();                  lbl.Text = sprite.Banks[i].name;                  lbl.Location = new Point(x' y - 15);                    win.Controls.Add(pic);                  win.Controls.Add(lbl);                    x += 516;                  if (x >= xMax)                  {                      x = 0;                      y += 275;                  }              }
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,btnShowAll_Click,The following statement contains a magic number: for (int i = 0; i < sprite.NumBanks; i++)              {                  PictureBox pic = new PictureBox();                  pic.Size = new Size(512' 256);                  pic.Location = new Point(x' y);                  pic.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;                  pic.Image = sprite.Get_Image(image' palette' i' 512' 256'                      checkGrid.Checked' checkCellBorder.Checked' checkNumber.Checked'                      checkTransparency.Checked' checkImage.Checked);                    Label lbl = new Label();                  lbl.Text = sprite.Banks[i].name;                  lbl.Location = new Point(x' y - 15);                    win.Controls.Add(pic);                  win.Controls.Add(lbl);                    x += 516;                  if (x >= xMax)                  {                      x = 0;                      y += 275;                  }              }
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,btnShowAll_Click,The following statement contains a magic number: for (int i = 0; i < sprite.NumBanks; i++)              {                  PictureBox pic = new PictureBox();                  pic.Size = new Size(512' 256);                  pic.Location = new Point(x' y);                  pic.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;                  pic.Image = sprite.Get_Image(image' palette' i' 512' 256'                      checkGrid.Checked' checkCellBorder.Checked' checkNumber.Checked'                      checkTransparency.Checked' checkImage.Checked);                    Label lbl = new Label();                  lbl.Text = sprite.Banks[i].name;                  lbl.Location = new Point(x' y - 15);                    win.Controls.Add(pic);                  win.Controls.Add(lbl);                    x += 516;                  if (x >= xMax)                  {                      x = 0;                      y += 275;                  }              }
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,btnShowAll_Click,The following statement contains a magic number: win.MaximumSize = new System.Drawing.Size(1050' 700);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,btnShowAll_Click,The following statement contains a magic number: win.MaximumSize = new System.Drawing.Size(1050' 700);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,Export_Single,The following statement contains a magic number: if (o.ShowDialog() == DialogResult.OK)              {                  if (o.FilterIndex == 1)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Png);                  else if (o.FilterIndex == 2)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Bmp);                  else if (o.FilterIndex == 3)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Jpeg);                  else if (o.FilterIndex == 4)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Tiff);                  else if (o.FilterIndex == 5)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Gif);                  else if (o.FilterIndex == 6)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Icon);              }
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,Export_Single,The following statement contains a magic number: if (o.ShowDialog() == DialogResult.OK)              {                  if (o.FilterIndex == 1)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Png);                  else if (o.FilterIndex == 2)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Bmp);                  else if (o.FilterIndex == 3)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Jpeg);                  else if (o.FilterIndex == 4)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Tiff);                  else if (o.FilterIndex == 5)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Gif);                  else if (o.FilterIndex == 6)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Icon);              }
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,Export_Single,The following statement contains a magic number: if (o.ShowDialog() == DialogResult.OK)              {                  if (o.FilterIndex == 1)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Png);                  else if (o.FilterIndex == 2)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Bmp);                  else if (o.FilterIndex == 3)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Jpeg);                  else if (o.FilterIndex == 4)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Tiff);                  else if (o.FilterIndex == 5)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Gif);                  else if (o.FilterIndex == 6)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Icon);              }
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,Export_Single,The following statement contains a magic number: if (o.ShowDialog() == DialogResult.OK)              {                  if (o.FilterIndex == 1)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Png);                  else if (o.FilterIndex == 2)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Bmp);                  else if (o.FilterIndex == 3)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Jpeg);                  else if (o.FilterIndex == 4)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Tiff);                  else if (o.FilterIndex == 5)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Gif);                  else if (o.FilterIndex == 6)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Icon);              }
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,Export_Single,The following statement contains a magic number: if (o.ShowDialog() == DialogResult.OK)              {                  if (o.FilterIndex == 1)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Png);                  else if (o.FilterIndex == 2)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Bmp);                  else if (o.FilterIndex == 3)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Jpeg);                  else if (o.FilterIndex == 4)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Tiff);                  else if (o.FilterIndex == 5)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Gif);                  else if (o.FilterIndex == 6)                      imgBox.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Icon);              }
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,Export_All,The following statement contains a magic number: for (int i = 0; i < sprite.NumBanks; i++)              {                  Image img = sprite.Get_Image(image' palette' i' 512' 256' checkGrid.Checked' checkCellBorder.Checked'                      checkNumber.Checked' checkTransparency.Checked' checkImage.Checked);                    string path = o.SelectedPath + Path.DirectorySeparatorChar;                  path += txtBatch.Text.Replace("%s"' i.ToString()) + ".png";                  img.Save(path' System.Drawing.Imaging.ImageFormat.Png);              }
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,Export_All,The following statement contains a magic number: for (int i = 0; i < sprite.NumBanks; i++)              {                  Image img = sprite.Get_Image(image' palette' i' 512' 256' checkGrid.Checked' checkCellBorder.Checked'                      checkNumber.Checked' checkTransparency.Checked' checkImage.Checked);                    string path = o.SelectedPath + Path.DirectorySeparatorChar;                  path += txtBatch.Text.Replace("%s"' i.ToString()) + ".png";                  img.Save(path' System.Drawing.Imaging.ImageFormat.Png);              }
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,Import_File,The following statement contains a magic number: for (int i = 0; i < oams.Length; i++)              {                  if (!checkListOAM.GetItemChecked(i))                      continue;                    Console.WriteLine("Processing cell {0}"' oams[i].num_cell.ToString());                  byte[] cellImg;                  if (!radioOriginalPal.Checked)                  {                      Bitmap subImg = (Bitmap)bitmap.Clone(new Rectangle(                          oams[i].obj1.xOffset + 256' oams[i].obj0.yOffset + 128'                          oams[i].width' oams[i].height)'                          System.Drawing.Imaging.PixelFormat.DontCare);                      Actions.Indexed_Image(subImg' image.FormatColor' out cellImg' out pal);                  }                  else                      cellImg = Actions.Get_OAMdata(oams[i]' tiles' image.FormatColor);                    // Swap palettes if "Swap palette" is checked. Try to change the colors to the old palette                  if (radioSwapPal.Checked)                  {                      try { Actions.Swap_Palette(ref cellImg' palette.Palette[oams[i].obj2.index_palette]' pal' image.FormatColor' numThreshold.Value); }                      catch (Exception ex) { MessageBox.Show(ex.Message); Console.WriteLine(ex.Message); return; }                  }                  else if (radioReplacePal.Checked) // Set the palette                      pals[oams[i].obj2.index_palette] = pal;                    if (image.FormTile == TileForm.Horizontal)                      cellImg = Actions.HorizontalToLineal(cellImg' oams[i].width' oams[i].height' image.BPP' 8);                    // If Add image is checked add the new image to the end of the original file and change the tileOffset                  if (radioImgAdd.Checked)                  {                      uint added = 0;                      uint size = (sprite.Banks[banki].data_size > 0) ? sprite.Banks[banki].data_size + addedSize : (uint)imgData.Length;                      uint offset = Actions.Add_Image(ref imgData' cellImg' sprite.Banks[banki].data_offset' size' (uint)(0x20 << (int)sprite.BlockSize)' out added) - sprite.Banks[banki].data_offset;                      addedSize += added;                        offset = (offset / 0x20) >> (int)this.sprite.BlockSize;                      if (offset >= 0x400)                      {                          MessageBox.Show(                              "The characters data size has exceeded the boundaries of what is permitted!\r\nSome characters will not be displayed.");                          break;                      }                        oams[i].obj2.tileOffset = offset;                      oams[i].obj1.flipX = 0;                      oams[i].obj1.flipY = 0;                  }                  else   // Replace the old image                  {                      uint tileOffset = oams[i].obj2.tileOffset;                      tileOffset = (uint)(tileOffset << (byte)sprite.BlockSize) * 0x20 + sprite.Banks[banki].data_offset;                      Array.Copy(cellImg' 0' imgData' tileOffset' cellImg.Length);                  }              }
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,Import_File,The following statement contains a magic number: for (int i = 0; i < oams.Length; i++)              {                  if (!checkListOAM.GetItemChecked(i))                      continue;                    Console.WriteLine("Processing cell {0}"' oams[i].num_cell.ToString());                  byte[] cellImg;                  if (!radioOriginalPal.Checked)                  {                      Bitmap subImg = (Bitmap)bitmap.Clone(new Rectangle(                          oams[i].obj1.xOffset + 256' oams[i].obj0.yOffset + 128'                          oams[i].width' oams[i].height)'                          System.Drawing.Imaging.PixelFormat.DontCare);                      Actions.Indexed_Image(subImg' image.FormatColor' out cellImg' out pal);                  }                  else                      cellImg = Actions.Get_OAMdata(oams[i]' tiles' image.FormatColor);                    // Swap palettes if "Swap palette" is checked. Try to change the colors to the old palette                  if (radioSwapPal.Checked)                  {                      try { Actions.Swap_Palette(ref cellImg' palette.Palette[oams[i].obj2.index_palette]' pal' image.FormatColor' numThreshold.Value); }                      catch (Exception ex) { MessageBox.Show(ex.Message); Console.WriteLine(ex.Message); return; }                  }                  else if (radioReplacePal.Checked) // Set the palette                      pals[oams[i].obj2.index_palette] = pal;                    if (image.FormTile == TileForm.Horizontal)                      cellImg = Actions.HorizontalToLineal(cellImg' oams[i].width' oams[i].height' image.BPP' 8);                    // If Add image is checked add the new image to the end of the original file and change the tileOffset                  if (radioImgAdd.Checked)                  {                      uint added = 0;                      uint size = (sprite.Banks[banki].data_size > 0) ? sprite.Banks[banki].data_size + addedSize : (uint)imgData.Length;                      uint offset = Actions.Add_Image(ref imgData' cellImg' sprite.Banks[banki].data_offset' size' (uint)(0x20 << (int)sprite.BlockSize)' out added) - sprite.Banks[banki].data_offset;                      addedSize += added;                        offset = (offset / 0x20) >> (int)this.sprite.BlockSize;                      if (offset >= 0x400)                      {                          MessageBox.Show(                              "The characters data size has exceeded the boundaries of what is permitted!\r\nSome characters will not be displayed.");                          break;                      }                        oams[i].obj2.tileOffset = offset;                      oams[i].obj1.flipX = 0;                      oams[i].obj1.flipY = 0;                  }                  else   // Replace the old image                  {                      uint tileOffset = oams[i].obj2.tileOffset;                      tileOffset = (uint)(tileOffset << (byte)sprite.BlockSize) * 0x20 + sprite.Banks[banki].data_offset;                      Array.Copy(cellImg' 0' imgData' tileOffset' cellImg.Length);                  }              }
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,Import_File,The following statement contains a magic number: for (int i = 0; i < oams.Length; i++)              {                  if (!checkListOAM.GetItemChecked(i))                      continue;                    Console.WriteLine("Processing cell {0}"' oams[i].num_cell.ToString());                  byte[] cellImg;                  if (!radioOriginalPal.Checked)                  {                      Bitmap subImg = (Bitmap)bitmap.Clone(new Rectangle(                          oams[i].obj1.xOffset + 256' oams[i].obj0.yOffset + 128'                          oams[i].width' oams[i].height)'                          System.Drawing.Imaging.PixelFormat.DontCare);                      Actions.Indexed_Image(subImg' image.FormatColor' out cellImg' out pal);                  }                  else                      cellImg = Actions.Get_OAMdata(oams[i]' tiles' image.FormatColor);                    // Swap palettes if "Swap palette" is checked. Try to change the colors to the old palette                  if (radioSwapPal.Checked)                  {                      try { Actions.Swap_Palette(ref cellImg' palette.Palette[oams[i].obj2.index_palette]' pal' image.FormatColor' numThreshold.Value); }                      catch (Exception ex) { MessageBox.Show(ex.Message); Console.WriteLine(ex.Message); return; }                  }                  else if (radioReplacePal.Checked) // Set the palette                      pals[oams[i].obj2.index_palette] = pal;                    if (image.FormTile == TileForm.Horizontal)                      cellImg = Actions.HorizontalToLineal(cellImg' oams[i].width' oams[i].height' image.BPP' 8);                    // If Add image is checked add the new image to the end of the original file and change the tileOffset                  if (radioImgAdd.Checked)                  {                      uint added = 0;                      uint size = (sprite.Banks[banki].data_size > 0) ? sprite.Banks[banki].data_size + addedSize : (uint)imgData.Length;                      uint offset = Actions.Add_Image(ref imgData' cellImg' sprite.Banks[banki].data_offset' size' (uint)(0x20 << (int)sprite.BlockSize)' out added) - sprite.Banks[banki].data_offset;                      addedSize += added;                        offset = (offset / 0x20) >> (int)this.sprite.BlockSize;                      if (offset >= 0x400)                      {                          MessageBox.Show(                              "The characters data size has exceeded the boundaries of what is permitted!\r\nSome characters will not be displayed.");                          break;                      }                        oams[i].obj2.tileOffset = offset;                      oams[i].obj1.flipX = 0;                      oams[i].obj1.flipY = 0;                  }                  else   // Replace the old image                  {                      uint tileOffset = oams[i].obj2.tileOffset;                      tileOffset = (uint)(tileOffset << (byte)sprite.BlockSize) * 0x20 + sprite.Banks[banki].data_offset;                      Array.Copy(cellImg' 0' imgData' tileOffset' cellImg.Length);                  }              }
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,Import_File,The following statement contains a magic number: int height = (imgData.Length * 8 / image.BPP) / image.Width;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.imgBox.Size = new System.Drawing.Size(512' 256);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.imgBox.Size = new System.Drawing.Size(512' 256);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(2' 266);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(2' 266);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.label1.TabIndex = 2;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.comboBank.Location = new System.Drawing.Point(72' 263);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.comboBank.Location = new System.Drawing.Point(72' 263);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.comboBank.Size = new System.Drawing.Size(183' 21);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.comboBank.Size = new System.Drawing.Size(183' 21);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.comboBank.TabIndex = 3;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnShowAll.Location = new System.Drawing.Point(3' 290);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnShowAll.Location = new System.Drawing.Point(3' 290);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnShowAll.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnShowAll.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnShowAll.TabIndex = 4;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnExport.Location = new System.Drawing.Point(261' 471);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnExport.Location = new System.Drawing.Point(261' 471);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnExport.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnExport.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnExport.TabIndex = 5;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkGrid.Location = new System.Drawing.Point(6' 17);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkGrid.Location = new System.Drawing.Point(6' 17);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkGrid.Size = new System.Drawing.Size(46' 17);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkGrid.Size = new System.Drawing.Size(46' 17);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkGrid.TabIndex = 6;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkNumber.Location = new System.Drawing.Point(147' 40);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkNumber.Location = new System.Drawing.Point(147' 40);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkNumber.Size = new System.Drawing.Size(45' 17);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkNumber.Size = new System.Drawing.Size(45' 17);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkNumber.TabIndex = 7;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkCellBorder.Location = new System.Drawing.Point(6' 40);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkCellBorder.Location = new System.Drawing.Point(6' 40);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkCellBorder.Size = new System.Drawing.Size(47' 17);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkCellBorder.Size = new System.Drawing.Size(47' 17);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkCellBorder.TabIndex = 8;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkTransparency.Location = new System.Drawing.Point(147' 17);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkTransparency.Location = new System.Drawing.Point(147' 17);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkTransparency.Size = new System.Drawing.Size(45' 17);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkTransparency.Size = new System.Drawing.Size(45' 17);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkTransparency.TabIndex = 9;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkImage.Location = new System.Drawing.Point(6' 63);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkImage.Location = new System.Drawing.Point(6' 63);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkImage.Size = new System.Drawing.Size(46' 17);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkImage.Size = new System.Drawing.Size(46' 17);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkImage.TabIndex = 10;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnBgdTrans.Location = new System.Drawing.Point(175' 290);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnBgdTrans.Location = new System.Drawing.Point(175' 290);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnBgdTrans.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnBgdTrans.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnBgdTrans.TabIndex = 29;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnBgd.Location = new System.Drawing.Point(261' 290);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnBgd.Location = new System.Drawing.Point(261' 290);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnBgd.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnBgd.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnBgd.TabIndex = 27;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnImport.Location = new System.Drawing.Point(347' 471);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnImport.Location = new System.Drawing.Point(347' 471);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnImport.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnImport.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnImport.TabIndex = 30;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnSetTrans.Location = new System.Drawing.Point(89' 290);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnSetTrans.Location = new System.Drawing.Point(89' 290);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnSetTrans.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnSetTrans.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnSetTrans.TabIndex = 31;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Location = new System.Drawing.Point(6' 426);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Location = new System.Drawing.Point(6' 426);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Size = new System.Drawing.Size(250' 83);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Size = new System.Drawing.Size(250' 83);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.TabIndex = 33;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkSelectOAM.Location = new System.Drawing.Point(147' 63);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkSelectOAM.Location = new System.Drawing.Point(147' 63);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkSelectOAM.Size = new System.Drawing.Size(83' 17);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkSelectOAM.Size = new System.Drawing.Size(83' 17);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkSelectOAM.TabIndex = 11;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnOAMeditor.Location = new System.Drawing.Point(261' 425);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnOAMeditor.Location = new System.Drawing.Point(261' 425);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnOAMeditor.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnOAMeditor.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnOAMeditor.TabIndex = 35;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkBatch.Location = new System.Drawing.Point(347' 315);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkBatch.Location = new System.Drawing.Point(347' 315);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkBatch.Size = new System.Drawing.Size(45' 17);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkBatch.Size = new System.Drawing.Size(45' 17);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkBatch.TabIndex = 36;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(344' 259);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(344' 259);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 37;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.txtBatch.Location = new System.Drawing.Point(347' 291);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.txtBatch.Location = new System.Drawing.Point(347' 291);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.txtBatch.Size = new System.Drawing.Size(159' 20);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.txtBatch.Size = new System.Drawing.Size(159' 20);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.txtBatch.TabIndex = 38;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.radioOriginalPal.Location = new System.Drawing.Point(6' 39);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.radioOriginalPal.Location = new System.Drawing.Point(6' 39);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.radioOriginalPal.Size = new System.Drawing.Size(44' 17);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.radioOriginalPal.Size = new System.Drawing.Size(44' 17);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.radioOriginalPal.TabIndex = 39;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.radioReplacePal.Location = new System.Drawing.Point(6' 62);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.radioReplacePal.Location = new System.Drawing.Point(6' 62);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.radioReplacePal.Size = new System.Drawing.Size(44' 17);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.radioReplacePal.Size = new System.Drawing.Size(44' 17);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.radioReplacePal.TabIndex = 40;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.radioSwapPal.Location = new System.Drawing.Point(6' 16);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.radioSwapPal.Location = new System.Drawing.Point(6' 16);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.radioSwapPal.Size = new System.Drawing.Size(44' 17);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.radioSwapPal.Size = new System.Drawing.Size(44' 17);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.radioSwapPal.TabIndex = 41;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.numThreshold.DecimalPlaces = 4;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.numThreshold.Increment = new decimal(new int[] {              5'              0'              0'              65536});
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.numThreshold.Increment = new decimal(new int[] {              5'              0'              0'              65536});
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.numThreshold.Location = new System.Drawing.Point(224' 16);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.numThreshold.Location = new System.Drawing.Point(224' 16);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.numThreshold.Maximum = new decimal(new int[] {              442'              0'              0'              0});
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.numThreshold.Size = new System.Drawing.Size(77' 20);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.numThreshold.Size = new System.Drawing.Size(77' 20);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.numThreshold.TabIndex = 42;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(159' 18);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(159' 18);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 43;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.radioImgAdd.Location = new System.Drawing.Point(6' 16);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.radioImgAdd.Location = new System.Drawing.Point(6' 16);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.radioImgAdd.Size = new System.Drawing.Size(44' 17);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.radioImgAdd.Size = new System.Drawing.Size(44' 17);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.radioImgAdd.TabIndex = 44;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.radioImgReplace.Location = new System.Drawing.Point(6' 38);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.radioImgReplace.Location = new System.Drawing.Point(6' 38);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.radioImgReplace.Size = new System.Drawing.Size(44' 17);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.radioImgReplace.Size = new System.Drawing.Size(44' 17);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.radioImgReplace.TabIndex = 45;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.groupBox2.Location = new System.Drawing.Point(3' 334);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.groupBox2.Location = new System.Drawing.Point(3' 334);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.groupBox2.Size = new System.Drawing.Size(334' 85);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.groupBox2.Size = new System.Drawing.Size(334' 85);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.groupBox2.TabIndex = 46;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.groupBox3.Location = new System.Drawing.Point(347' 338);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.groupBox3.Location = new System.Drawing.Point(347' 338);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.groupBox3.Size = new System.Drawing.Size(163' 59);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.groupBox3.Size = new System.Drawing.Size(163' 59);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.groupBox3.TabIndex = 47;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(261' 266);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(261' 266);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(19' 13);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(19' 13);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.label4.TabIndex = 48;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkListOAM.Location = new System.Drawing.Point(432' 402);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkListOAM.Location = new System.Drawing.Point(432' 402);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkListOAM.Size = new System.Drawing.Size(78' 109);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkListOAM.Size = new System.Drawing.Size(78' 109);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkListOAM.TabIndex = 49;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(344' 402);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(344' 402);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(88' 26);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(88' 26);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.label5.TabIndex = 50;
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(514' 514);
Magic Number,Ekona.Images,SpriteControl,C:\repos\pleonex_tinke\Ekona\Images\SpriteControl.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(514' 514);
Magic Number,Ekona.Images,MapBase,C:\repos\pleonex_tinke\Ekona\Images\MapBase.cs,Change_StartByte,The following statement contains a magic number: map = new NTFS[newData.Length / 2];
Magic Number,Ekona.Images,MapBase,C:\repos\pleonex_tinke\Ekona\Images\MapBase.cs,Change_StartByte,The following statement contains a magic number: for (int i = 0; i < map.Length; i ++)              {                  map[i] = Actions.MapInfo(BitConverter.ToUInt16(newData' i * 2));              }
Magic Number,Ekona.Images,PaletteBase,C:\repos\pleonex_tinke\Ekona\Images\PaletteBase.cs,Set_Palette,The following statement contains a magic number: if (palette[0].Length > 16)                  depth = ColorFormat.colors256;              else                  depth = ColorFormat.colors16;
Magic Number,Ekona.Images,PaletteBase,C:\repos\pleonex_tinke\Ekona\Images\PaletteBase.cs,Set_Palette,The following statement contains a magic number: if (palette[0].Length > 16)                  depth = ColorFormat.colors256;              else                  depth = ColorFormat.colors16;
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,Update_Info,The following statement contains a magic number: if (palette.Depth == ColorFormat.colors16)                  numFillColors.Value = 16;              else                  numFillColors.Value = 256;
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,Update_Info,The following statement contains a magic number: if (palette.Depth == ColorFormat.colors16)                  numFillColors.Value = 16;              else                  numFillColors.Value = 256;
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,ReadLanguage,The following statement contains a magic number: try              {                  XElement xml = XElement.Load(pluginHost.Get_LangXML());                  xml = xml.Element("Ekona");                  xml = xml.Element("PaletteControl");                    label1.Text = xml.Element("S01").Value;                  btnShow.Text = xml.Element("S02").Value;                  btnExport.Text = xml.Element("S03").Value;                  btnImport.Text = xml.Element("S04").Value;                  label2.Text = xml.Element("S05").Value;                  label4.Text = xml.Element("S06").Value;                  btnUseThis.Text = xml.Element("S0A").Value;                  checkHex.Text = xml.Element("S0B").Value;                  label5.Text = xml.Element("S0C").Value;                  btnFillColors.Text = xml.Element("S0D").Value;                    translation = new string[3];                  translation[0] = xml.Element("S07").Value;                  translation[1] = xml.Element("S09").Value;                  translation[2] = xml.Element("S08").Value;              }              catch { throw new Exception("There was an error reading the XML file of language."); }
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,ReadLanguage,The following statement contains a magic number: try              {                  XElement xml = XElement.Load(pluginHost.Get_LangXML());                  xml = xml.Element("Ekona");                  xml = xml.Element("PaletteControl");                    label1.Text = xml.Element("S01").Value;                  btnShow.Text = xml.Element("S02").Value;                  btnExport.Text = xml.Element("S03").Value;                  btnImport.Text = xml.Element("S04").Value;                  label2.Text = xml.Element("S05").Value;                  label4.Text = xml.Element("S06").Value;                  btnUseThis.Text = xml.Element("S0A").Value;                  checkHex.Text = xml.Element("S0B").Value;                  label5.Text = xml.Element("S0C").Value;                  btnFillColors.Text = xml.Element("S0D").Value;                    translation = new string[3];                  translation[0] = xml.Element("S07").Value;                  translation[1] = xml.Element("S09").Value;                  translation[2] = xml.Element("S08").Value;              }              catch { throw new Exception("There was an error reading the XML file of language."); }
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,comboDepth_SelectedIndexChanged,The following statement contains a magic number: if (palette.Depth == ColorFormat.colors16)                  numFillColors.Value = 16;              else                  numFillColors.Value = 256;
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,comboDepth_SelectedIndexChanged,The following statement contains a magic number: if (palette.Depth == ColorFormat.colors16)                  numFillColors.Value = 16;              else                  numFillColors.Value = 256;
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,btnShow_Click,The following statement contains a magic number: int xMax = 6 * 170;
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,btnShow_Click,The following statement contains a magic number: int xMax = 6 * 170;
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,btnShow_Click,The following statement contains a magic number: int y = 15;
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,btnShow_Click,The following statement contains a magic number: for (int i = 0; i < palette.NumberOfPalettes; i++)              {                  PictureBox pic = new PictureBox();                  pic.Size = new Size(160' 160);                  pic.Location = new Point(x' y);                  pic.BorderStyle = BorderStyle.FixedSingle;                  pic.Image = palette.Get_Image(i);                  Label lbl = new Label();                  lbl.Text = translation[2] + (i + 1).ToString();                  lbl.Location = new Point(x' y - 15);                    win.Controls.Add(pic);                  win.Controls.Add(lbl);                    x += 170;                  if (x >= xMax)                  {                      x = 0;                      y += 185;                  }              }
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,btnShow_Click,The following statement contains a magic number: for (int i = 0; i < palette.NumberOfPalettes; i++)              {                  PictureBox pic = new PictureBox();                  pic.Size = new Size(160' 160);                  pic.Location = new Point(x' y);                  pic.BorderStyle = BorderStyle.FixedSingle;                  pic.Image = palette.Get_Image(i);                  Label lbl = new Label();                  lbl.Text = translation[2] + (i + 1).ToString();                  lbl.Location = new Point(x' y - 15);                    win.Controls.Add(pic);                  win.Controls.Add(lbl);                    x += 170;                  if (x >= xMax)                  {                      x = 0;                      y += 185;                  }              }
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,btnShow_Click,The following statement contains a magic number: for (int i = 0; i < palette.NumberOfPalettes; i++)              {                  PictureBox pic = new PictureBox();                  pic.Size = new Size(160' 160);                  pic.Location = new Point(x' y);                  pic.BorderStyle = BorderStyle.FixedSingle;                  pic.Image = palette.Get_Image(i);                  Label lbl = new Label();                  lbl.Text = translation[2] + (i + 1).ToString();                  lbl.Location = new Point(x' y - 15);                    win.Controls.Add(pic);                  win.Controls.Add(lbl);                    x += 170;                  if (x >= xMax)                  {                      x = 0;                      y += 185;                  }              }
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,btnShow_Click,The following statement contains a magic number: for (int i = 0; i < palette.NumberOfPalettes; i++)              {                  PictureBox pic = new PictureBox();                  pic.Size = new Size(160' 160);                  pic.Location = new Point(x' y);                  pic.BorderStyle = BorderStyle.FixedSingle;                  pic.Image = palette.Get_Image(i);                  Label lbl = new Label();                  lbl.Text = translation[2] + (i + 1).ToString();                  lbl.Location = new Point(x' y - 15);                    win.Controls.Add(pic);                  win.Controls.Add(lbl);                    x += 170;                  if (x >= xMax)                  {                      x = 0;                      y += 185;                  }              }
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,btnShow_Click,The following statement contains a magic number: for (int i = 0; i < palette.NumberOfPalettes; i++)              {                  PictureBox pic = new PictureBox();                  pic.Size = new Size(160' 160);                  pic.Location = new Point(x' y);                  pic.BorderStyle = BorderStyle.FixedSingle;                  pic.Image = palette.Get_Image(i);                  Label lbl = new Label();                  lbl.Text = translation[2] + (i + 1).ToString();                  lbl.Location = new Point(x' y - 15);                    win.Controls.Add(pic);                  win.Controls.Add(lbl);                    x += 170;                  if (x >= xMax)                  {                      x = 0;                      y += 185;                  }              }
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,btnShow_Click,The following statement contains a magic number: for (int i = 0; i < palette.NumberOfPalettes; i++)              {                  PictureBox pic = new PictureBox();                  pic.Size = new Size(160' 160);                  pic.Location = new Point(x' y);                  pic.BorderStyle = BorderStyle.FixedSingle;                  pic.Image = palette.Get_Image(i);                  Label lbl = new Label();                  lbl.Text = translation[2] + (i + 1).ToString();                  lbl.Location = new Point(x' y - 15);                    win.Controls.Add(pic);                  win.Controls.Add(lbl);                    x += 170;                  if (x >= xMax)                  {                      x = 0;                      y += 185;                  }              }
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,btnShow_Click,The following statement contains a magic number: win.MaximumSize = new Size(1024' 760);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,btnShow_Click,The following statement contains a magic number: win.MaximumSize = new Size(1024' 760);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,btnExport_Click,The following statement contains a magic number: if (o.FilterIndex == 3)                  picPalette.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Png);              else if (o.FilterIndex == 1 || o.FilterIndex == 2)              {                  Formats.PaletteWin palwin = new Formats.PaletteWin(palette.Palette[(int)numericPalette.Value]);                  if (o.FilterIndex == 1) palwin.Gimp_Error = true;                  palwin.Write(o.FileName);              }              else if (o.FilterIndex == 4)              {                  Formats.ACO palaco = new Formats.ACO(palette.Palette[(int)numericPalette.Value]);                  palaco.Write(o.FileName);              }
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,btnExport_Click,The following statement contains a magic number: if (o.FilterIndex == 3)                  picPalette.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Png);              else if (o.FilterIndex == 1 || o.FilterIndex == 2)              {                  Formats.PaletteWin palwin = new Formats.PaletteWin(palette.Palette[(int)numericPalette.Value]);                  if (o.FilterIndex == 1) palwin.Gimp_Error = true;                  palwin.Write(o.FileName);              }              else if (o.FilterIndex == 4)              {                  Formats.ACO palaco = new Formats.ACO(palette.Palette[(int)numericPalette.Value]);                  palaco.Write(o.FileName);              }
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,btnExport_Click,The following statement contains a magic number: if (o.FilterIndex == 3)                  picPalette.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Png);              else if (o.FilterIndex == 1 || o.FilterIndex == 2)              {                  Formats.PaletteWin palwin = new Formats.PaletteWin(palette.Palette[(int)numericPalette.Value]);                  if (o.FilterIndex == 1) palwin.Gimp_Error = true;                  palwin.Write(o.FileName);              }              else if (o.FilterIndex == 4)              {                  Formats.ACO palaco = new Formats.ACO(palette.Palette[(int)numericPalette.Value]);                  palaco.Write(o.FileName);              }
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.picPalette.Size = new System.Drawing.Size(160' 160);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.picPalette.Size = new System.Drawing.Size(160' 160);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.numericPalette.Location = new System.Drawing.Point(101' 182);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.numericPalette.Location = new System.Drawing.Point(101' 182);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.numericPalette.Size = new System.Drawing.Size(37' 20);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.numericPalette.Size = new System.Drawing.Size(37' 20);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.numericPalette.TabIndex = 2;
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(3' 184);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(3' 184);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.label1.TabIndex = 3;
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnShow.Location = new System.Drawing.Point(6' 208);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnShow.Location = new System.Drawing.Point(6' 208);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnShow.Size = new System.Drawing.Size(160' 30);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnShow.Size = new System.Drawing.Size(160' 30);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnShow.TabIndex = 4;
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnExport.Location = new System.Drawing.Point(343' 3);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnExport.Location = new System.Drawing.Point(343' 3);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnExport.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnExport.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnExport.TabIndex = 6;
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.lblRGB.Location = new System.Drawing.Point(3' 163);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.lblRGB.Location = new System.Drawing.Point(3' 163);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.lblRGB.Size = new System.Drawing.Size(33' 13);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.lblRGB.Size = new System.Drawing.Size(33' 13);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.lblRGB.TabIndex = 7;
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnImport.Location = new System.Drawing.Point(429' 3);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnImport.Location = new System.Drawing.Point(429' 3);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnImport.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnImport.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnImport.TabIndex = 3;
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(313' 97);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(313' 97);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.numericStartByte.Location = new System.Drawing.Point(400' 95);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.numericStartByte.Location = new System.Drawing.Point(400' 95);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.numericStartByte.Size = new System.Drawing.Size(106' 20);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.numericStartByte.Size = new System.Drawing.Size(106' 20);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(142' 184);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(142' 184);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 9;
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.comboDepth.Location = new System.Drawing.Point(400' 121);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.comboDepth.Location = new System.Drawing.Point(400' 121);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.comboDepth.Size = new System.Drawing.Size(106' 21);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.comboDepth.Size = new System.Drawing.Size(106' 21);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.comboDepth.TabIndex = 10;
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(313' 124);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(313' 124);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(26' 13);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.label4.TabIndex = 11;
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkHex.Location = new System.Drawing.Point(400' 72);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkHex.Location = new System.Drawing.Point(400' 72);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkHex.Size = new System.Drawing.Size(46' 17);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkHex.Size = new System.Drawing.Size(46' 17);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkHex.TabIndex = 12;
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnUseThis.Location = new System.Drawing.Point(166' 3);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnUseThis.Location = new System.Drawing.Point(166' 3);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnUseThis.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnUseThis.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnUseThis.TabIndex = 13;
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(259' 208);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(259' 208);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(27' 13);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(27' 13);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.label5.TabIndex = 14;
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.numFillColors.Location = new System.Drawing.Point(345' 206);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.numFillColors.Location = new System.Drawing.Point(345' 206);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.numFillColors.Maximum = new decimal(new int[] {              65535'              0'              0'              0});
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.numFillColors.Size = new System.Drawing.Size(78' 20);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.numFillColors.Size = new System.Drawing.Size(78' 20);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.numFillColors.TabIndex = 15;
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnFillColors.Location = new System.Drawing.Point(429' 194);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnFillColors.Location = new System.Drawing.Point(429' 194);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnFillColors.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnFillColors.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.btnFillColors.TabIndex = 16;
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkDuplicated.Location = new System.Drawing.Point(166' 72);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkDuplicated.Location = new System.Drawing.Point(166' 72);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkDuplicated.Size = new System.Drawing.Size(128' 17);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkDuplicated.Size = new System.Drawing.Size(128' 17);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.checkDuplicated.TabIndex = 17;
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(512' 512);
Magic Number,Ekona.Images,PaletteControl,C:\repos\pleonex_tinke\Ekona\Images\PaletteControl.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(512' 512);
Magic Number,Ekona.Images,RawMap,C:\repos\pleonex_tinke\Ekona\Images\RawData.cs,Read,The following statement contains a magic number: NTFS[] map = new NTFS[file_size / 2];
Magic Number,Ekona.Images,RawMap,C:\repos\pleonex_tinke\Ekona\Images\RawData.cs,Read,The following statement contains a magic number: int width = (map.Length * 8 >= 0x100 ? 0x100 : map.Length * 8);
Magic Number,Ekona.Images,RawMap,C:\repos\pleonex_tinke\Ekona\Images\RawData.cs,Read,The following statement contains a magic number: int width = (map.Length * 8 >= 0x100 ? 0x100 : map.Length * 8);
Magic Number,Ekona.Images,RawMap,C:\repos\pleonex_tinke\Ekona\Images\RawData.cs,Read,The following statement contains a magic number: int height = (map.Length / (width / 8)) * 8;
Magic Number,Ekona.Images,RawMap,C:\repos\pleonex_tinke\Ekona\Images\RawData.cs,Read,The following statement contains a magic number: int height = (map.Length / (width / 8)) * 8;
Magic Number,Ekona.Images.Formats,APNG,C:\repos\pleonex_tinke\Ekona\Images\Formats\APNG.cs,Create,The following statement contains a magic number: byte[] pngSignature = new byte[] { 137' 80' 78' 71' 13' 10' 26' 10 };
Magic Number,Ekona.Images.Formats,APNG,C:\repos\pleonex_tinke\Ekona\Images\Formats\APNG.cs,Create,The following statement contains a magic number: byte[] pngSignature = new byte[] { 137' 80' 78' 71' 13' 10' 26' 10 };
Magic Number,Ekona.Images.Formats,APNG,C:\repos\pleonex_tinke\Ekona\Images\Formats\APNG.cs,Create,The following statement contains a magic number: byte[] pngSignature = new byte[] { 137' 80' 78' 71' 13' 10' 26' 10 };
Magic Number,Ekona.Images.Formats,APNG,C:\repos\pleonex_tinke\Ekona\Images\Formats\APNG.cs,Create,The following statement contains a magic number: byte[] pngSignature = new byte[] { 137' 80' 78' 71' 13' 10' 26' 10 };
Magic Number,Ekona.Images.Formats,APNG,C:\repos\pleonex_tinke\Ekona\Images\Formats\APNG.cs,Create,The following statement contains a magic number: byte[] pngSignature = new byte[] { 137' 80' 78' 71' 13' 10' 26' 10 };
Magic Number,Ekona.Images.Formats,APNG,C:\repos\pleonex_tinke\Ekona\Images\Formats\APNG.cs,Create,The following statement contains a magic number: byte[] pngSignature = new byte[] { 137' 80' 78' 71' 13' 10' 26' 10 };
Magic Number,Ekona.Images.Formats,APNG,C:\repos\pleonex_tinke\Ekona\Images\Formats\APNG.cs,Create,The following statement contains a magic number: byte[] pngSignature = new byte[] { 137' 80' 78' 71' 13' 10' 26' 10 };
Magic Number,Ekona.Images.Formats,APNG,C:\repos\pleonex_tinke\Ekona\Images\Formats\APNG.cs,Create,The following statement contains a magic number: byte[] pngSignature = new byte[] { 137' 80' 78' 71' 13' 10' 26' 10 };
Magic Number,Ekona.Images.Formats,APNG,C:\repos\pleonex_tinke\Ekona\Images\Formats\APNG.cs,Create,The following statement contains a magic number: actl.length = BitConverter.GetBytes(8).Reverse().ToArray();
Magic Number,Ekona.Images.Formats,APNG,C:\repos\pleonex_tinke\Ekona\Images\Formats\APNG.cs,Read_IHDR,The following statement contains a magic number: ihdr.length = br.ReadBytes(4);
Magic Number,Ekona.Images.Formats,APNG,C:\repos\pleonex_tinke\Ekona\Images\Formats\APNG.cs,Read_IHDR,The following statement contains a magic number: ihdr.id = br.ReadBytes(4);
Magic Number,Ekona.Images.Formats,APNG,C:\repos\pleonex_tinke\Ekona\Images\Formats\APNG.cs,Read_IHDR,The following statement contains a magic number: ihdr.crc = br.ReadBytes(4);
Magic Number,Ekona.Images.Formats,APNG,C:\repos\pleonex_tinke\Ekona\Images\Formats\APNG.cs,Read_fcTL,The following statement contains a magic number: fctl.length = BitConverter.GetBytes(26).Reverse().ToArray();
Magic Number,Ekona.Images.Formats,APNG,C:\repos\pleonex_tinke\Ekona\Images\Formats\APNG.cs,Read_fcTL,The following statement contains a magic number: fctl.width = br.ReadBytes(4);
Magic Number,Ekona.Images.Formats,APNG,C:\repos\pleonex_tinke\Ekona\Images\Formats\APNG.cs,Read_fcTL,The following statement contains a magic number: fctl.height = br.ReadBytes(4);
Magic Number,Ekona.Images.Formats,APNG,C:\repos\pleonex_tinke\Ekona\Images\Formats\APNG.cs,Read_fcTL,The following statement contains a magic number: fctl.delay_den = BitConverter.GetBytes((ushort)1000).Reverse().ToArray();
Magic Number,Ekona.Images.Formats,APNG,C:\repos\pleonex_tinke\Ekona\Images\Formats\APNG.cs,Read_IDAT,The following statement contains a magic number: br.BaseStream.Position -= 8;
Magic Number,Ekona.Images.Formats,APNG,C:\repos\pleonex_tinke\Ekona\Images\Formats\APNG.cs,Read_IDAT,The following statement contains a magic number: int length = BitConverter.ToInt32(br.ReadBytes(4).Reverse().ToArray()' 0);
Magic Number,Ekona.Images.Formats,APNG,C:\repos\pleonex_tinke\Ekona\Images\Formats\APNG.cs,Read_IDAT,The following statement contains a magic number: br.BaseStream.Position -= 4;
Magic Number,Ekona.Images.Formats,APNG,C:\repos\pleonex_tinke\Ekona\Images\Formats\APNG.cs,Read_IDAT,The following statement contains a magic number: buffer = br.ReadBytes(length + 12);
Magic Number,Ekona.Images.Formats,APNG,C:\repos\pleonex_tinke\Ekona\Images\Formats\APNG.cs,Read_fdAT,The following statement contains a magic number: br.BaseStream.Position -= 8;
Magic Number,Ekona.Images.Formats,APNG,C:\repos\pleonex_tinke\Ekona\Images\Formats\APNG.cs,Read_fdAT,The following statement contains a magic number: int length = BitConverter.ToInt32(br.ReadBytes(4).Reverse().ToArray()' 0);
Magic Number,Ekona.Images.Formats,APNG,C:\repos\pleonex_tinke\Ekona\Images\Formats\APNG.cs,Read_fdAT,The following statement contains a magic number: fdat.length = BitConverter.GetBytes(length + 4).Reverse().ToArray();
Magic Number,Ekona.Images.Formats,APNG,C:\repos\pleonex_tinke\Ekona\Images\Formats\APNG.cs,Read_fdAT,The following statement contains a magic number: br.BaseStream.Position += 4;
Magic Number,Ekona.Images.Formats,BMP,C:\repos\pleonex_tinke\Ekona\Images\Formats\Bitmap.cs,Read,The following statement contains a magic number: if (new String(br.ReadChars(2)) != "BM")                  throw new NotSupportedException();
Magic Number,Ekona.Images.Formats,BMP,C:\repos\pleonex_tinke\Ekona\Images\Formats\Bitmap.cs,Read,The following statement contains a magic number: for (int i = 0; i < num_colors; i++)              {                  Byte[] color = br.ReadBytes(4);                  colors[0][i] = Color.FromArgb(color[2]' color[1]' color[0]);              }
Magic Number,Ekona.Images.Formats,BMP,C:\repos\pleonex_tinke\Ekona\Images\Formats\Bitmap.cs,Read,The following statement contains a magic number: for (int i = 0; i < num_colors; i++)              {                  Byte[] color = br.ReadBytes(4);                  colors[0][i] = Color.FromArgb(color[2]' color[1]' color[0]);              }
Magic Number,Ekona.Images.Formats,BMP,C:\repos\pleonex_tinke\Ekona\Images\Formats\Bitmap.cs,Read,The following statement contains a magic number: switch (bpp)              {                  case 4:                      int divisor = (int)width / 2;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width / 2' 4' out res);                          divisor = (int)width / 2 + (4 - res);                      }                        tiles = new byte[tiles.Length * 2];                      for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w += 2)                          {                              byte b = br.ReadByte();                              tiles[w + h * width] = (byte)(b >> 4);                                if (w + 1 != width)                                  tiles[w + 1 + h * width] = (byte)(b & 0xF);                          }                          br.ReadBytes((int)(divisor - ((float)width / 2)));                      }                      tiles = Helper.BitsConverter.Bits4ToByte(tiles);                      break;                  case 8:                      divisor = (int)width;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width' 4' out res);                          divisor = (int)width + (4 - res);                      }                        for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w++)                          {                              tiles[w + h * width] = br.ReadByte();                          }                          br.ReadBytes(divisor - (int)width);                      }                      break;              }
Magic Number,Ekona.Images.Formats,BMP,C:\repos\pleonex_tinke\Ekona\Images\Formats\Bitmap.cs,Read,The following statement contains a magic number: switch (bpp)              {                  case 4:                      int divisor = (int)width / 2;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width / 2' 4' out res);                          divisor = (int)width / 2 + (4 - res);                      }                        tiles = new byte[tiles.Length * 2];                      for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w += 2)                          {                              byte b = br.ReadByte();                              tiles[w + h * width] = (byte)(b >> 4);                                if (w + 1 != width)                                  tiles[w + 1 + h * width] = (byte)(b & 0xF);                          }                          br.ReadBytes((int)(divisor - ((float)width / 2)));                      }                      tiles = Helper.BitsConverter.Bits4ToByte(tiles);                      break;                  case 8:                      divisor = (int)width;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width' 4' out res);                          divisor = (int)width + (4 - res);                      }                        for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w++)                          {                              tiles[w + h * width] = br.ReadByte();                          }                          br.ReadBytes(divisor - (int)width);                      }                      break;              }
Magic Number,Ekona.Images.Formats,BMP,C:\repos\pleonex_tinke\Ekona\Images\Formats\Bitmap.cs,Read,The following statement contains a magic number: switch (bpp)              {                  case 4:                      int divisor = (int)width / 2;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width / 2' 4' out res);                          divisor = (int)width / 2 + (4 - res);                      }                        tiles = new byte[tiles.Length * 2];                      for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w += 2)                          {                              byte b = br.ReadByte();                              tiles[w + h * width] = (byte)(b >> 4);                                if (w + 1 != width)                                  tiles[w + 1 + h * width] = (byte)(b & 0xF);                          }                          br.ReadBytes((int)(divisor - ((float)width / 2)));                      }                      tiles = Helper.BitsConverter.Bits4ToByte(tiles);                      break;                  case 8:                      divisor = (int)width;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width' 4' out res);                          divisor = (int)width + (4 - res);                      }                        for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w++)                          {                              tiles[w + h * width] = br.ReadByte();                          }                          br.ReadBytes(divisor - (int)width);                      }                      break;              }
Magic Number,Ekona.Images.Formats,BMP,C:\repos\pleonex_tinke\Ekona\Images\Formats\Bitmap.cs,Read,The following statement contains a magic number: switch (bpp)              {                  case 4:                      int divisor = (int)width / 2;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width / 2' 4' out res);                          divisor = (int)width / 2 + (4 - res);                      }                        tiles = new byte[tiles.Length * 2];                      for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w += 2)                          {                              byte b = br.ReadByte();                              tiles[w + h * width] = (byte)(b >> 4);                                if (w + 1 != width)                                  tiles[w + 1 + h * width] = (byte)(b & 0xF);                          }                          br.ReadBytes((int)(divisor - ((float)width / 2)));                      }                      tiles = Helper.BitsConverter.Bits4ToByte(tiles);                      break;                  case 8:                      divisor = (int)width;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width' 4' out res);                          divisor = (int)width + (4 - res);                      }                        for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w++)                          {                              tiles[w + h * width] = br.ReadByte();                          }                          br.ReadBytes(divisor - (int)width);                      }                      break;              }
Magic Number,Ekona.Images.Formats,BMP,C:\repos\pleonex_tinke\Ekona\Images\Formats\Bitmap.cs,Read,The following statement contains a magic number: switch (bpp)              {                  case 4:                      int divisor = (int)width / 2;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width / 2' 4' out res);                          divisor = (int)width / 2 + (4 - res);                      }                        tiles = new byte[tiles.Length * 2];                      for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w += 2)                          {                              byte b = br.ReadByte();                              tiles[w + h * width] = (byte)(b >> 4);                                if (w + 1 != width)                                  tiles[w + 1 + h * width] = (byte)(b & 0xF);                          }                          br.ReadBytes((int)(divisor - ((float)width / 2)));                      }                      tiles = Helper.BitsConverter.Bits4ToByte(tiles);                      break;                  case 8:                      divisor = (int)width;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width' 4' out res);                          divisor = (int)width + (4 - res);                      }                        for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w++)                          {                              tiles[w + h * width] = br.ReadByte();                          }                          br.ReadBytes(divisor - (int)width);                      }                      break;              }
Magic Number,Ekona.Images.Formats,BMP,C:\repos\pleonex_tinke\Ekona\Images\Formats\Bitmap.cs,Read,The following statement contains a magic number: switch (bpp)              {                  case 4:                      int divisor = (int)width / 2;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width / 2' 4' out res);                          divisor = (int)width / 2 + (4 - res);                      }                        tiles = new byte[tiles.Length * 2];                      for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w += 2)                          {                              byte b = br.ReadByte();                              tiles[w + h * width] = (byte)(b >> 4);                                if (w + 1 != width)                                  tiles[w + 1 + h * width] = (byte)(b & 0xF);                          }                          br.ReadBytes((int)(divisor - ((float)width / 2)));                      }                      tiles = Helper.BitsConverter.Bits4ToByte(tiles);                      break;                  case 8:                      divisor = (int)width;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width' 4' out res);                          divisor = (int)width + (4 - res);                      }                        for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w++)                          {                              tiles[w + h * width] = br.ReadByte();                          }                          br.ReadBytes(divisor - (int)width);                      }                      break;              }
Magic Number,Ekona.Images.Formats,BMP,C:\repos\pleonex_tinke\Ekona\Images\Formats\Bitmap.cs,Read,The following statement contains a magic number: switch (bpp)              {                  case 4:                      int divisor = (int)width / 2;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width / 2' 4' out res);                          divisor = (int)width / 2 + (4 - res);                      }                        tiles = new byte[tiles.Length * 2];                      for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w += 2)                          {                              byte b = br.ReadByte();                              tiles[w + h * width] = (byte)(b >> 4);                                if (w + 1 != width)                                  tiles[w + 1 + h * width] = (byte)(b & 0xF);                          }                          br.ReadBytes((int)(divisor - ((float)width / 2)));                      }                      tiles = Helper.BitsConverter.Bits4ToByte(tiles);                      break;                  case 8:                      divisor = (int)width;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width' 4' out res);                          divisor = (int)width + (4 - res);                      }                        for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w++)                          {                              tiles[w + h * width] = br.ReadByte();                          }                          br.ReadBytes(divisor - (int)width);                      }                      break;              }
Magic Number,Ekona.Images.Formats,BMP,C:\repos\pleonex_tinke\Ekona\Images\Formats\Bitmap.cs,Read,The following statement contains a magic number: switch (bpp)              {                  case 4:                      int divisor = (int)width / 2;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width / 2' 4' out res);                          divisor = (int)width / 2 + (4 - res);                      }                        tiles = new byte[tiles.Length * 2];                      for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w += 2)                          {                              byte b = br.ReadByte();                              tiles[w + h * width] = (byte)(b >> 4);                                if (w + 1 != width)                                  tiles[w + 1 + h * width] = (byte)(b & 0xF);                          }                          br.ReadBytes((int)(divisor - ((float)width / 2)));                      }                      tiles = Helper.BitsConverter.Bits4ToByte(tiles);                      break;                  case 8:                      divisor = (int)width;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width' 4' out res);                          divisor = (int)width + (4 - res);                      }                        for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w++)                          {                              tiles[w + h * width] = br.ReadByte();                          }                          br.ReadBytes(divisor - (int)width);                      }                      break;              }
Magic Number,Ekona.Images.Formats,BMP,C:\repos\pleonex_tinke\Ekona\Images\Formats\Bitmap.cs,Read,The following statement contains a magic number: switch (bpp)              {                  case 4:                      int divisor = (int)width / 2;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width / 2' 4' out res);                          divisor = (int)width / 2 + (4 - res);                      }                        tiles = new byte[tiles.Length * 2];                      for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w += 2)                          {                              byte b = br.ReadByte();                              tiles[w + h * width] = (byte)(b >> 4);                                if (w + 1 != width)                                  tiles[w + 1 + h * width] = (byte)(b & 0xF);                          }                          br.ReadBytes((int)(divisor - ((float)width / 2)));                      }                      tiles = Helper.BitsConverter.Bits4ToByte(tiles);                      break;                  case 8:                      divisor = (int)width;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width' 4' out res);                          divisor = (int)width + (4 - res);                      }                        for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w++)                          {                              tiles[w + h * width] = br.ReadByte();                          }                          br.ReadBytes(divisor - (int)width);                      }                      break;              }
Magic Number,Ekona.Images.Formats,BMP,C:\repos\pleonex_tinke\Ekona\Images\Formats\Bitmap.cs,Read,The following statement contains a magic number: switch (bpp)              {                  case 4:                      int divisor = (int)width / 2;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width / 2' 4' out res);                          divisor = (int)width / 2 + (4 - res);                      }                        tiles = new byte[tiles.Length * 2];                      for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w += 2)                          {                              byte b = br.ReadByte();                              tiles[w + h * width] = (byte)(b >> 4);                                if (w + 1 != width)                                  tiles[w + 1 + h * width] = (byte)(b & 0xF);                          }                          br.ReadBytes((int)(divisor - ((float)width / 2)));                      }                      tiles = Helper.BitsConverter.Bits4ToByte(tiles);                      break;                  case 8:                      divisor = (int)width;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width' 4' out res);                          divisor = (int)width + (4 - res);                      }                        for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w++)                          {                              tiles[w + h * width] = br.ReadByte();                          }                          br.ReadBytes(divisor - (int)width);                      }                      break;              }
Magic Number,Ekona.Images.Formats,BMP,C:\repos\pleonex_tinke\Ekona\Images\Formats\Bitmap.cs,Read,The following statement contains a magic number: switch (bpp)              {                  case 4:                      int divisor = (int)width / 2;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width / 2' 4' out res);                          divisor = (int)width / 2 + (4 - res);                      }                        tiles = new byte[tiles.Length * 2];                      for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w += 2)                          {                              byte b = br.ReadByte();                              tiles[w + h * width] = (byte)(b >> 4);                                if (w + 1 != width)                                  tiles[w + 1 + h * width] = (byte)(b & 0xF);                          }                          br.ReadBytes((int)(divisor - ((float)width / 2)));                      }                      tiles = Helper.BitsConverter.Bits4ToByte(tiles);                      break;                  case 8:                      divisor = (int)width;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width' 4' out res);                          divisor = (int)width + (4 - res);                      }                        for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w++)                          {                              tiles[w + h * width] = br.ReadByte();                          }                          br.ReadBytes(divisor - (int)width);                      }                      break;              }
Magic Number,Ekona.Images.Formats,BMP,C:\repos\pleonex_tinke\Ekona\Images\Formats\Bitmap.cs,Read,The following statement contains a magic number: switch (bpp)              {                  case 4:                      int divisor = (int)width / 2;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width / 2' 4' out res);                          divisor = (int)width / 2 + (4 - res);                      }                        tiles = new byte[tiles.Length * 2];                      for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w += 2)                          {                              byte b = br.ReadByte();                              tiles[w + h * width] = (byte)(b >> 4);                                if (w + 1 != width)                                  tiles[w + 1 + h * width] = (byte)(b & 0xF);                          }                          br.ReadBytes((int)(divisor - ((float)width / 2)));                      }                      tiles = Helper.BitsConverter.Bits4ToByte(tiles);                      break;                  case 8:                      divisor = (int)width;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width' 4' out res);                          divisor = (int)width + (4 - res);                      }                        for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w++)                          {                              tiles[w + h * width] = br.ReadByte();                          }                          br.ReadBytes(divisor - (int)width);                      }                      break;              }
Magic Number,Ekona.Images.Formats,BMP,C:\repos\pleonex_tinke\Ekona\Images\Formats\Bitmap.cs,Read,The following statement contains a magic number: switch (bpp)              {                  case 4:                      int divisor = (int)width / 2;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width / 2' 4' out res);                          divisor = (int)width / 2 + (4 - res);                      }                        tiles = new byte[tiles.Length * 2];                      for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w += 2)                          {                              byte b = br.ReadByte();                              tiles[w + h * width] = (byte)(b >> 4);                                if (w + 1 != width)                                  tiles[w + 1 + h * width] = (byte)(b & 0xF);                          }                          br.ReadBytes((int)(divisor - ((float)width / 2)));                      }                      tiles = Helper.BitsConverter.Bits4ToByte(tiles);                      break;                  case 8:                      divisor = (int)width;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width' 4' out res);                          divisor = (int)width + (4 - res);                      }                        for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w++)                          {                              tiles[w + h * width] = br.ReadByte();                          }                          br.ReadBytes(divisor - (int)width);                      }                      break;              }
Magic Number,Ekona.Images.Formats,BMP,C:\repos\pleonex_tinke\Ekona\Images\Formats\Bitmap.cs,Read,The following statement contains a magic number: switch (bpp)              {                  case 4:                      int divisor = (int)width / 2;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width / 2' 4' out res);                          divisor = (int)width / 2 + (4 - res);                      }                        tiles = new byte[tiles.Length * 2];                      for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w += 2)                          {                              byte b = br.ReadByte();                              tiles[w + h * width] = (byte)(b >> 4);                                if (w + 1 != width)                                  tiles[w + 1 + h * width] = (byte)(b & 0xF);                          }                          br.ReadBytes((int)(divisor - ((float)width / 2)));                      }                      tiles = Helper.BitsConverter.Bits4ToByte(tiles);                      break;                  case 8:                      divisor = (int)width;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width' 4' out res);                          divisor = (int)width + (4 - res);                      }                        for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w++)                          {                              tiles[w + h * width] = br.ReadByte();                          }                          br.ReadBytes(divisor - (int)width);                      }                      break;              }
Magic Number,Ekona.Images.Formats,BMP,C:\repos\pleonex_tinke\Ekona\Images\Formats\Bitmap.cs,Read,The following statement contains a magic number: switch (bpp)              {                  case 4:                      int divisor = (int)width / 2;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width / 2' 4' out res);                          divisor = (int)width / 2 + (4 - res);                      }                        tiles = new byte[tiles.Length * 2];                      for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w += 2)                          {                              byte b = br.ReadByte();                              tiles[w + h * width] = (byte)(b >> 4);                                if (w + 1 != width)                                  tiles[w + 1 + h * width] = (byte)(b & 0xF);                          }                          br.ReadBytes((int)(divisor - ((float)width / 2)));                      }                      tiles = Helper.BitsConverter.Bits4ToByte(tiles);                      break;                  case 8:                      divisor = (int)width;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width' 4' out res);                          divisor = (int)width + (4 - res);                      }                        for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w++)                          {                              tiles[w + h * width] = br.ReadByte();                          }                          br.ReadBytes(divisor - (int)width);                      }                      break;              }
Magic Number,Ekona.Images.Formats,PaletteWin,C:\repos\pleonex_tinke\Ekona\Images\Formats\PaletteWin.cs,Read,The following statement contains a magic number: br.ReadChars(4);
Magic Number,Ekona.Images.Formats,PaletteWin,C:\repos\pleonex_tinke\Ekona\Images\Formats\PaletteWin.cs,Read,The following statement contains a magic number: br.ReadChars(4);
Magic Number,Ekona.Images.Formats,PaletteWin,C:\repos\pleonex_tinke\Ekona\Images\Formats\PaletteWin.cs,Read,The following statement contains a magic number: br.ReadChars(4);
Magic Number,Ekona.Images.Formats,PaletteWin,C:\repos\pleonex_tinke\Ekona\Images\Formats\PaletteWin.cs,Write,The following statement contains a magic number: bw.Write((uint)(0x10 + palette[0].Length * 4));
Magic Number,Ekona.Images.Formats,PaletteWin,C:\repos\pleonex_tinke\Ekona\Images\Formats\PaletteWin.cs,Write,The following statement contains a magic number: bw.Write((uint)palette[0].Length * 4 + 4);
Magic Number,Ekona.Images.Formats,PaletteWin,C:\repos\pleonex_tinke\Ekona\Images\Formats\PaletteWin.cs,Write,The following statement contains a magic number: bw.Write((uint)palette[0].Length * 4 + 4);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,Read_Language,The following statement contains a magic number: try              {                  this.Text = xml.Element("S01").Value;                  label11.Text = xml.Element("S02").Value;                  label12.Text = xml.Element("S03").Value + ' ' + numOAM.Maximum.ToString();                  groupObj0.Text = xml.Element("S04").Value;                  label1.Text = xml.Element("S05").Value;                  checkRSflag.Text = xml.Element("S06").Value;                  checkObjdisable.Text = xml.Element("S07").Value;                  checkDoubleSize.Text = xml.Element("S08").Value;                  label3.Text = xml.Element("S09").Value;                  comboObjMode.Items[0] = xml.Element("S0A").Value;                  comboObjMode.Items[1] = xml.Element("S0B").Value;                  comboObjMode.Items[2] = xml.Element("S0C").Value;                  comboObjMode.Items[3] = xml.Element("S0D").Value;                  checkMosaic.Text = xml.Element("S0E").Value;                  label5.Text = xml.Element("S0F").Value;                  comboDepth.Items[0] = xml.Element("S10").Value;                  comboDepth.Items[1] = xml.Element("S11").Value;                  label4.Text = xml.Element("S12").Value;                  comboShape.Items[0] = xml.Element("S13").Value;                  comboShape.Items[1] = xml.Element("S14").Value;                  comboShape.Items[2] = xml.Element("S15").Value;                  comboShape.Items[3] = xml.Element("S0D").Value;                  label15.Text = xml.Element("S16").Value;                  label13.Text = xml.Element("S17").Value;                  btnAddOAM.Text = xml.Element("S18").Value;                  btnRemOAM.Text = xml.Element("S19").Value;                  groupObj1.Text = xml.Element("S1A").Value;                  label2.Text = xml.Element("S1B").Value;                  label6.Text = xml.Element("S1C").Value;                  checkFlipX.Text = xml.Element("S1D").Value;                  checkFlipY.Text = xml.Element("S1E").Value;                  label7.Text = xml.Element("S1F").Value;                  groupObj2.Text = xml.Element("S20").Value;                  label8.Text = xml.Element("S21").Value;                  label9.Text = xml.Element("S22").Value;                  label10.Text = xml.Element("S23").Value;                  btnSave.Text = xml.Element("S24").Value;                  label14.Text = xml.Element("S25").Value;                  groupPreview.Text = xml.Element("S26").Value;                  checkTrans.Text = xml.Element("S27").Value;                  checkOAM.Text = xml.Element("S28").Value;                  checkImage.Text = xml.Element("S29").Value;                  checkNumbers.Text = xml.Element("S2A").Value;                  checkGrid.Text = xml.Element("S2B").Value;                  checkCurrOAM.Text = xml.Element("S2C").Value;              }              catch { throw new Exception("There was an error reading the XML file of language."); }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,Read_Language,The following statement contains a magic number: try              {                  this.Text = xml.Element("S01").Value;                  label11.Text = xml.Element("S02").Value;                  label12.Text = xml.Element("S03").Value + ' ' + numOAM.Maximum.ToString();                  groupObj0.Text = xml.Element("S04").Value;                  label1.Text = xml.Element("S05").Value;                  checkRSflag.Text = xml.Element("S06").Value;                  checkObjdisable.Text = xml.Element("S07").Value;                  checkDoubleSize.Text = xml.Element("S08").Value;                  label3.Text = xml.Element("S09").Value;                  comboObjMode.Items[0] = xml.Element("S0A").Value;                  comboObjMode.Items[1] = xml.Element("S0B").Value;                  comboObjMode.Items[2] = xml.Element("S0C").Value;                  comboObjMode.Items[3] = xml.Element("S0D").Value;                  checkMosaic.Text = xml.Element("S0E").Value;                  label5.Text = xml.Element("S0F").Value;                  comboDepth.Items[0] = xml.Element("S10").Value;                  comboDepth.Items[1] = xml.Element("S11").Value;                  label4.Text = xml.Element("S12").Value;                  comboShape.Items[0] = xml.Element("S13").Value;                  comboShape.Items[1] = xml.Element("S14").Value;                  comboShape.Items[2] = xml.Element("S15").Value;                  comboShape.Items[3] = xml.Element("S0D").Value;                  label15.Text = xml.Element("S16").Value;                  label13.Text = xml.Element("S17").Value;                  btnAddOAM.Text = xml.Element("S18").Value;                  btnRemOAM.Text = xml.Element("S19").Value;                  groupObj1.Text = xml.Element("S1A").Value;                  label2.Text = xml.Element("S1B").Value;                  label6.Text = xml.Element("S1C").Value;                  checkFlipX.Text = xml.Element("S1D").Value;                  checkFlipY.Text = xml.Element("S1E").Value;                  label7.Text = xml.Element("S1F").Value;                  groupObj2.Text = xml.Element("S20").Value;                  label8.Text = xml.Element("S21").Value;                  label9.Text = xml.Element("S22").Value;                  label10.Text = xml.Element("S23").Value;                  btnSave.Text = xml.Element("S24").Value;                  label14.Text = xml.Element("S25").Value;                  groupPreview.Text = xml.Element("S26").Value;                  checkTrans.Text = xml.Element("S27").Value;                  checkOAM.Text = xml.Element("S28").Value;                  checkImage.Text = xml.Element("S29").Value;                  checkNumbers.Text = xml.Element("S2A").Value;                  checkGrid.Text = xml.Element("S2B").Value;                  checkCurrOAM.Text = xml.Element("S2C").Value;              }              catch { throw new Exception("There was an error reading the XML file of language."); }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,Read_Language,The following statement contains a magic number: try              {                  this.Text = xml.Element("S01").Value;                  label11.Text = xml.Element("S02").Value;                  label12.Text = xml.Element("S03").Value + ' ' + numOAM.Maximum.ToString();                  groupObj0.Text = xml.Element("S04").Value;                  label1.Text = xml.Element("S05").Value;                  checkRSflag.Text = xml.Element("S06").Value;                  checkObjdisable.Text = xml.Element("S07").Value;                  checkDoubleSize.Text = xml.Element("S08").Value;                  label3.Text = xml.Element("S09").Value;                  comboObjMode.Items[0] = xml.Element("S0A").Value;                  comboObjMode.Items[1] = xml.Element("S0B").Value;                  comboObjMode.Items[2] = xml.Element("S0C").Value;                  comboObjMode.Items[3] = xml.Element("S0D").Value;                  checkMosaic.Text = xml.Element("S0E").Value;                  label5.Text = xml.Element("S0F").Value;                  comboDepth.Items[0] = xml.Element("S10").Value;                  comboDepth.Items[1] = xml.Element("S11").Value;                  label4.Text = xml.Element("S12").Value;                  comboShape.Items[0] = xml.Element("S13").Value;                  comboShape.Items[1] = xml.Element("S14").Value;                  comboShape.Items[2] = xml.Element("S15").Value;                  comboShape.Items[3] = xml.Element("S0D").Value;                  label15.Text = xml.Element("S16").Value;                  label13.Text = xml.Element("S17").Value;                  btnAddOAM.Text = xml.Element("S18").Value;                  btnRemOAM.Text = xml.Element("S19").Value;                  groupObj1.Text = xml.Element("S1A").Value;                  label2.Text = xml.Element("S1B").Value;                  label6.Text = xml.Element("S1C").Value;                  checkFlipX.Text = xml.Element("S1D").Value;                  checkFlipY.Text = xml.Element("S1E").Value;                  label7.Text = xml.Element("S1F").Value;                  groupObj2.Text = xml.Element("S20").Value;                  label8.Text = xml.Element("S21").Value;                  label9.Text = xml.Element("S22").Value;                  label10.Text = xml.Element("S23").Value;                  btnSave.Text = xml.Element("S24").Value;                  label14.Text = xml.Element("S25").Value;                  groupPreview.Text = xml.Element("S26").Value;                  checkTrans.Text = xml.Element("S27").Value;                  checkOAM.Text = xml.Element("S28").Value;                  checkImage.Text = xml.Element("S29").Value;                  checkNumbers.Text = xml.Element("S2A").Value;                  checkGrid.Text = xml.Element("S2B").Value;                  checkCurrOAM.Text = xml.Element("S2C").Value;              }              catch { throw new Exception("There was an error reading the XML file of language."); }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,Read_Language,The following statement contains a magic number: try              {                  this.Text = xml.Element("S01").Value;                  label11.Text = xml.Element("S02").Value;                  label12.Text = xml.Element("S03").Value + ' ' + numOAM.Maximum.ToString();                  groupObj0.Text = xml.Element("S04").Value;                  label1.Text = xml.Element("S05").Value;                  checkRSflag.Text = xml.Element("S06").Value;                  checkObjdisable.Text = xml.Element("S07").Value;                  checkDoubleSize.Text = xml.Element("S08").Value;                  label3.Text = xml.Element("S09").Value;                  comboObjMode.Items[0] = xml.Element("S0A").Value;                  comboObjMode.Items[1] = xml.Element("S0B").Value;                  comboObjMode.Items[2] = xml.Element("S0C").Value;                  comboObjMode.Items[3] = xml.Element("S0D").Value;                  checkMosaic.Text = xml.Element("S0E").Value;                  label5.Text = xml.Element("S0F").Value;                  comboDepth.Items[0] = xml.Element("S10").Value;                  comboDepth.Items[1] = xml.Element("S11").Value;                  label4.Text = xml.Element("S12").Value;                  comboShape.Items[0] = xml.Element("S13").Value;                  comboShape.Items[1] = xml.Element("S14").Value;                  comboShape.Items[2] = xml.Element("S15").Value;                  comboShape.Items[3] = xml.Element("S0D").Value;                  label15.Text = xml.Element("S16").Value;                  label13.Text = xml.Element("S17").Value;                  btnAddOAM.Text = xml.Element("S18").Value;                  btnRemOAM.Text = xml.Element("S19").Value;                  groupObj1.Text = xml.Element("S1A").Value;                  label2.Text = xml.Element("S1B").Value;                  label6.Text = xml.Element("S1C").Value;                  checkFlipX.Text = xml.Element("S1D").Value;                  checkFlipY.Text = xml.Element("S1E").Value;                  label7.Text = xml.Element("S1F").Value;                  groupObj2.Text = xml.Element("S20").Value;                  label8.Text = xml.Element("S21").Value;                  label9.Text = xml.Element("S22").Value;                  label10.Text = xml.Element("S23").Value;                  btnSave.Text = xml.Element("S24").Value;                  label14.Text = xml.Element("S25").Value;                  groupPreview.Text = xml.Element("S26").Value;                  checkTrans.Text = xml.Element("S27").Value;                  checkOAM.Text = xml.Element("S28").Value;                  checkImage.Text = xml.Element("S29").Value;                  checkNumbers.Text = xml.Element("S2A").Value;                  checkGrid.Text = xml.Element("S2B").Value;                  checkCurrOAM.Text = xml.Element("S2C").Value;              }              catch { throw new Exception("There was an error reading the XML file of language."); }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,Read_Info,The following statement contains a magic number: switch (oam.obj0.shape)              {                  case 0:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 0;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 1;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 2;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 3;                      break;                  case 1:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 4;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 5;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 6;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 7;                      break;                  case 2:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 8;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 9;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 10;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 11;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,Read_Info,The following statement contains a magic number: switch (oam.obj0.shape)              {                  case 0:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 0;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 1;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 2;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 3;                      break;                  case 1:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 4;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 5;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 6;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 7;                      break;                  case 2:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 8;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 9;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 10;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 11;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,Read_Info,The following statement contains a magic number: switch (oam.obj0.shape)              {                  case 0:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 0;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 1;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 2;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 3;                      break;                  case 1:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 4;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 5;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 6;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 7;                      break;                  case 2:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 8;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 9;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 10;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 11;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,Read_Info,The following statement contains a magic number: switch (oam.obj0.shape)              {                  case 0:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 0;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 1;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 2;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 3;                      break;                  case 1:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 4;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 5;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 6;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 7;                      break;                  case 2:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 8;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 9;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 10;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 11;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,Read_Info,The following statement contains a magic number: switch (oam.obj0.shape)              {                  case 0:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 0;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 1;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 2;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 3;                      break;                  case 1:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 4;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 5;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 6;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 7;                      break;                  case 2:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 8;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 9;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 10;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 11;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,Read_Info,The following statement contains a magic number: switch (oam.obj0.shape)              {                  case 0:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 0;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 1;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 2;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 3;                      break;                  case 1:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 4;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 5;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 6;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 7;                      break;                  case 2:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 8;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 9;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 10;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 11;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,Read_Info,The following statement contains a magic number: switch (oam.obj0.shape)              {                  case 0:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 0;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 1;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 2;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 3;                      break;                  case 1:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 4;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 5;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 6;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 7;                      break;                  case 2:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 8;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 9;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 10;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 11;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,Read_Info,The following statement contains a magic number: switch (oam.obj0.shape)              {                  case 0:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 0;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 1;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 2;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 3;                      break;                  case 1:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 4;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 5;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 6;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 7;                      break;                  case 2:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 8;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 9;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 10;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 11;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,Read_Info,The following statement contains a magic number: switch (oam.obj0.shape)              {                  case 0:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 0;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 1;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 2;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 3;                      break;                  case 1:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 4;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 5;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 6;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 7;                      break;                  case 2:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 8;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 9;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 10;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 11;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,Read_Info,The following statement contains a magic number: switch (oam.obj0.shape)              {                  case 0:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 0;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 1;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 2;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 3;                      break;                  case 1:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 4;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 5;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 6;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 7;                      break;                  case 2:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 8;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 9;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 10;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 11;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,Read_Info,The following statement contains a magic number: switch (oam.obj0.shape)              {                  case 0:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 0;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 1;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 2;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 3;                      break;                  case 1:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 4;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 5;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 6;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 7;                      break;                  case 2:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 8;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 9;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 10;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 11;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,Read_Info,The following statement contains a magic number: switch (oam.obj0.shape)              {                  case 0:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 0;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 1;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 2;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 3;                      break;                  case 1:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 4;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 5;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 6;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 7;                      break;                  case 2:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 8;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 9;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 10;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 11;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,Read_Info,The following statement contains a magic number: switch (oam.obj0.shape)              {                  case 0:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 0;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 1;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 2;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 3;                      break;                  case 1:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 4;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 5;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 6;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 7;                      break;                  case 2:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 8;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 9;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 10;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 11;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,Read_Info,The following statement contains a magic number: switch (oam.obj0.shape)              {                  case 0:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 0;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 1;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 2;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 3;                      break;                  case 1:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 4;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 5;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 6;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 7;                      break;                  case 2:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 8;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 9;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 10;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 11;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,Read_Info,The following statement contains a magic number: switch (oam.obj0.shape)              {                  case 0:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 0;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 1;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 2;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 3;                      break;                  case 1:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 4;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 5;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 6;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 7;                      break;                  case 2:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 8;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 9;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 10;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 11;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,Read_Info,The following statement contains a magic number: switch (oam.obj0.shape)              {                  case 0:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 0;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 1;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 2;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 3;                      break;                  case 1:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 4;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 5;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 6;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 7;                      break;                  case 2:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 8;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 9;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 10;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 11;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,Read_Info,The following statement contains a magic number: switch (oam.obj0.shape)              {                  case 0:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 0;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 1;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 2;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 3;                      break;                  case 1:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 4;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 5;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 6;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 7;                      break;                  case 2:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 8;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 9;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 10;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 11;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,Update_Image,The following statement contains a magic number: numObj2.Value = objs[2];
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,Update_Image,The following statement contains a magic number: picBox.Image = sprite.Get_Image(image' palette' bank' 512' 256' checkGrid.Checked' checkOAM.Checked'                  checkNumbers.Checked' checkTrans.Checked' checkImage.Checked' (checkCurrOAM.Checked ? (int)numOAM.Value : -1));
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,Update_Image,The following statement contains a magic number: picBox.Image = sprite.Get_Image(image' palette' bank' 512' 256' checkGrid.Checked' checkOAM.Checked'                  checkNumbers.Checked' checkTrans.Checked' checkImage.Checked' (checkCurrOAM.Checked ? (int)numOAM.Value : -1));
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,comboSize_SelectedIndexChanged,The following statement contains a magic number: switch (comboSize.SelectedIndex)              {                  case 0:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 1:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 2:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 3:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 4:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 5:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 6:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 7:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 8:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 9:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 10:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 11:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,comboSize_SelectedIndexChanged,The following statement contains a magic number: switch (comboSize.SelectedIndex)              {                  case 0:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 1:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 2:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 3:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 4:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 5:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 6:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 7:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 8:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 9:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 10:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 11:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,comboSize_SelectedIndexChanged,The following statement contains a magic number: switch (comboSize.SelectedIndex)              {                  case 0:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 1:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 2:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 3:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 4:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 5:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 6:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 7:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 8:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 9:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 10:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 11:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,comboSize_SelectedIndexChanged,The following statement contains a magic number: switch (comboSize.SelectedIndex)              {                  case 0:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 1:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 2:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 3:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 4:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 5:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 6:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 7:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 8:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 9:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 10:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 11:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,comboSize_SelectedIndexChanged,The following statement contains a magic number: switch (comboSize.SelectedIndex)              {                  case 0:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 1:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 2:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 3:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 4:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 5:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 6:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 7:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 8:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 9:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 10:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 11:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,comboSize_SelectedIndexChanged,The following statement contains a magic number: switch (comboSize.SelectedIndex)              {                  case 0:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 1:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 2:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 3:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 4:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 5:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 6:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 7:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 8:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 9:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 10:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 11:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,comboSize_SelectedIndexChanged,The following statement contains a magic number: switch (comboSize.SelectedIndex)              {                  case 0:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 1:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 2:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 3:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 4:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 5:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 6:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 7:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 8:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 9:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 10:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 11:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,comboSize_SelectedIndexChanged,The following statement contains a magic number: switch (comboSize.SelectedIndex)              {                  case 0:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 1:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 2:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 3:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 4:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 5:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 6:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 7:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 8:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 9:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 10:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 11:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,comboSize_SelectedIndexChanged,The following statement contains a magic number: switch (comboSize.SelectedIndex)              {                  case 0:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 1:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 2:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 3:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 4:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 5:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 6:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 7:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 8:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 9:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 10:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 11:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,comboSize_SelectedIndexChanged,The following statement contains a magic number: switch (comboSize.SelectedIndex)              {                  case 0:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 1:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 2:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 3:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 4:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 5:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 6:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 7:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 8:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 9:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 10:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 11:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,comboSize_SelectedIndexChanged,The following statement contains a magic number: switch (comboSize.SelectedIndex)              {                  case 0:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 1:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 2:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 3:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 4:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 5:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 6:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 7:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 8:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 9:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 10:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 11:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,comboSize_SelectedIndexChanged,The following statement contains a magic number: switch (comboSize.SelectedIndex)              {                  case 0:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 1:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 2:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 3:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 4:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 5:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 6:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 7:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 8:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 9:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 10:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 11:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,comboSize_SelectedIndexChanged,The following statement contains a magic number: switch (comboSize.SelectedIndex)              {                  case 0:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 1:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 2:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 3:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 4:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 5:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 6:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 7:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 8:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 9:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 10:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 11:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,comboSize_SelectedIndexChanged,The following statement contains a magic number: switch (comboSize.SelectedIndex)              {                  case 0:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 1:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 2:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 3:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 4:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 5:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 6:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 7:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 8:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 9:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 10:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 11:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,comboSize_SelectedIndexChanged,The following statement contains a magic number: switch (comboSize.SelectedIndex)              {                  case 0:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 1:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 2:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 3:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 4:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 5:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 6:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 7:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 8:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 9:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 10:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 11:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,comboSize_SelectedIndexChanged,The following statement contains a magic number: switch (comboSize.SelectedIndex)              {                  case 0:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 1:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 2:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 3:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 4:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 5:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 6:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 7:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 8:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 9:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 10:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 11:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,comboSize_SelectedIndexChanged,The following statement contains a magic number: switch (comboSize.SelectedIndex)              {                  case 0:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 1:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 2:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 3:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 4:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 5:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 6:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 7:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 8:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 9:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 10:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 11:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,comboSize_SelectedIndexChanged,The following statement contains a magic number: switch (comboSize.SelectedIndex)              {                  case 0:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 1:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 2:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 3:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 4:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 5:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 6:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 7:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 8:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 9:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 10:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 11:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,comboSize_SelectedIndexChanged,The following statement contains a magic number: switch (comboSize.SelectedIndex)              {                  case 0:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 1:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 2:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 3:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 4:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 5:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 6:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 7:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 8:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 9:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 10:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 11:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,comboSize_SelectedIndexChanged,The following statement contains a magic number: switch (comboSize.SelectedIndex)              {                  case 0:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 1:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 2:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 3:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 4:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 5:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 6:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 7:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 8:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 9:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 10:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 11:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;              }
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,btnAddOAM_Click,The following statement contains a magic number: newOAM[length].obj0.yOffset = -128;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,btnAddOAM_Click,The following statement contains a magic number: newOAM[length].obj1.xOffset = -256;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.groupObj0.Location = new System.Drawing.Point(14' 33);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.groupObj0.Location = new System.Drawing.Point(14' 33);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.groupObj0.Size = new System.Drawing.Size(222' 197);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.groupObj0.Size = new System.Drawing.Size(222' 197);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.comboShape.Location = new System.Drawing.Point(98' 169);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.comboShape.Location = new System.Drawing.Point(98' 169);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.comboShape.Size = new System.Drawing.Size(110' 21);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.comboShape.Size = new System.Drawing.Size(110' 21);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.comboShape.TabIndex = 22;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(7' 143);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(7' 143);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(39' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(39' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label5.TabIndex = 21;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.comboDepth.Location = new System.Drawing.Point(98' 140);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.comboDepth.Location = new System.Drawing.Point(98' 140);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.comboDepth.Size = new System.Drawing.Size(110' 21);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.comboDepth.Size = new System.Drawing.Size(110' 21);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.comboDepth.TabIndex = 20;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.comboObjMode.Location = new System.Drawing.Point(98' 91);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.comboObjMode.Location = new System.Drawing.Point(98' 91);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.comboObjMode.Size = new System.Drawing.Size(110' 21);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.comboObjMode.Size = new System.Drawing.Size(110' 21);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.comboObjMode.TabIndex = 19;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkMosaic.Location = new System.Drawing.Point(9' 117);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkMosaic.Location = new System.Drawing.Point(9' 117);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkMosaic.Size = new System.Drawing.Size(60' 17);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkMosaic.Size = new System.Drawing.Size(60' 17);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkMosaic.TabIndex = 17;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkDoubleSize.Location = new System.Drawing.Point(135' 68);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkDoubleSize.Location = new System.Drawing.Point(135' 68);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkDoubleSize.Size = new System.Drawing.Size(81' 17);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkDoubleSize.Size = new System.Drawing.Size(81' 17);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkDoubleSize.TabIndex = 16;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkObjdisable.Location = new System.Drawing.Point(36' 68);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkObjdisable.Location = new System.Drawing.Point(36' 68);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkObjdisable.Size = new System.Drawing.Size(93' 17);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkObjdisable.Size = new System.Drawing.Size(93' 17);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkObjdisable.TabIndex = 15;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkRSflag.Location = new System.Drawing.Point(10' 45);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkRSflag.Location = new System.Drawing.Point(10' 45);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkRSflag.Size = new System.Drawing.Size(104' 17);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkRSflag.Size = new System.Drawing.Size(104' 17);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkRSflag.TabIndex = 14;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(6' 169);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(6' 169);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(41' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(41' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label4.TabIndex = 4;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(6' 94);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(6' 94);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(70' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(70' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 2;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numYoffset.Location = new System.Drawing.Point(98' 19);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numYoffset.Location = new System.Drawing.Point(98' 19);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numYoffset.Maximum = new decimal(new int[] {              127'              0'              0'              0});
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numYoffset.Minimum = new decimal(new int[] {              128'              0'              0'              -2147483648});
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numYoffset.Minimum = new decimal(new int[] {              128'              0'              0'              -2147483648});
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numYoffset.Size = new System.Drawing.Size(60' 20);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numYoffset.Size = new System.Drawing.Size(60' 20);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(6' 21);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(6' 21);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(56' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(56' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.groupObj1.Location = new System.Drawing.Point(242' 33);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.groupObj1.Location = new System.Drawing.Point(242' 33);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.groupObj1.Size = new System.Drawing.Size(169' 118);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.groupObj1.Size = new System.Drawing.Size(169' 118);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numSize.Location = new System.Drawing.Point(99' 92);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numSize.Location = new System.Drawing.Point(99' 92);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numSize.Maximum = new decimal(new int[] {              3'              0'              0'              0});
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numSize.Size = new System.Drawing.Size(60' 20);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numSize.Size = new System.Drawing.Size(60' 20);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numSize.TabIndex = 8;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label7.Location = new System.Drawing.Point(6' 94);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label7.Location = new System.Drawing.Point(6' 94);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label7.Size = new System.Drawing.Size(30' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label7.Size = new System.Drawing.Size(30' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label7.TabIndex = 7;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label6.Location = new System.Drawing.Point(6' 48);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label6.Location = new System.Drawing.Point(6' 48);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label6.Size = new System.Drawing.Size(72' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label6.Size = new System.Drawing.Size(72' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label6.TabIndex = 5;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkFlipY.Location = new System.Drawing.Point(99' 72);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkFlipY.Location = new System.Drawing.Point(99' 72);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkFlipY.Size = new System.Drawing.Size(52' 17);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkFlipY.Size = new System.Drawing.Size(52' 17);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkFlipY.TabIndex = 4;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkFlipX.Location = new System.Drawing.Point(9' 72);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkFlipX.Location = new System.Drawing.Point(9' 72);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkFlipX.Size = new System.Drawing.Size(52' 17);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkFlipX.Size = new System.Drawing.Size(52' 17);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkFlipX.TabIndex = 3;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numSelectPar.Location = new System.Drawing.Point(99' 46);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numSelectPar.Location = new System.Drawing.Point(99' 46);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numSelectPar.Maximum = new decimal(new int[] {              31'              0'              0'              0});
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numSelectPar.Size = new System.Drawing.Size(60' 20);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numSelectPar.Size = new System.Drawing.Size(60' 20);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numSelectPar.TabIndex = 2;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(6' 21);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(6' 21);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(56' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(56' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numXpos.Location = new System.Drawing.Point(99' 19);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numXpos.Location = new System.Drawing.Point(99' 19);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numXpos.Maximum = new decimal(new int[] {              255'              0'              0'              0});
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numXpos.Minimum = new decimal(new int[] {              256'              0'              0'              -2147483648});
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numXpos.Minimum = new decimal(new int[] {              256'              0'              0'              -2147483648});
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numXpos.Size = new System.Drawing.Size(60' 20);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numXpos.Size = new System.Drawing.Size(60' 20);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.groupObj2.Location = new System.Drawing.Point(242' 157);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.groupObj2.Location = new System.Drawing.Point(242' 157);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.groupObj2.Size = new System.Drawing.Size(169' 100);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.groupObj2.Size = new System.Drawing.Size(169' 100);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numPal.Location = new System.Drawing.Point(99' 71);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numPal.Location = new System.Drawing.Point(99' 71);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numPal.Maximum = new decimal(new int[] {              15'              0'              0'              0});
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numPal.Size = new System.Drawing.Size(60' 20);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numPal.Size = new System.Drawing.Size(60' 20);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numPal.TabIndex = 7;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label10.Location = new System.Drawing.Point(7' 73);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label10.Location = new System.Drawing.Point(7' 73);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label10.Size = new System.Drawing.Size(71' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label10.Size = new System.Drawing.Size(71' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label10.TabIndex = 6;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numPrio.Location = new System.Drawing.Point(99' 45);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numPrio.Location = new System.Drawing.Point(99' 45);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numPrio.Maximum = new decimal(new int[] {              3'              0'              0'              0});
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numPrio.Size = new System.Drawing.Size(60' 20);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numPrio.Size = new System.Drawing.Size(60' 20);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numPrio.TabIndex = 5;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label9.Location = new System.Drawing.Point(7' 47);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label9.Location = new System.Drawing.Point(7' 47);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label9.Size = new System.Drawing.Size(41' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label9.Size = new System.Drawing.Size(41' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label9.TabIndex = 4;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numOffset.Location = new System.Drawing.Point(99' 19);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numOffset.Location = new System.Drawing.Point(99' 19);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numOffset.Maximum = new decimal(new int[] {              1023'              0'              0'              0});
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numOffset.Size = new System.Drawing.Size(60' 20);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numOffset.Size = new System.Drawing.Size(60' 20);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numOffset.TabIndex = 3;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label8.Location = new System.Drawing.Point(7' 21);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label8.Location = new System.Drawing.Point(7' 21);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label8.Size = new System.Drawing.Size(56' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label8.Size = new System.Drawing.Size(56' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label8.TabIndex = 2;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numOAM.Location = new System.Drawing.Point(52' 7);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numOAM.Location = new System.Drawing.Point(52' 7);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numOAM.Size = new System.Drawing.Size(60' 20);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numOAM.Size = new System.Drawing.Size(60' 20);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numOAM.TabIndex = 2;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label11.Location = new System.Drawing.Point(12' 9);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label11.Location = new System.Drawing.Point(12' 9);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label11.Size = new System.Drawing.Size(34' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label11.Size = new System.Drawing.Size(34' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label11.TabIndex = 3;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label12.Location = new System.Drawing.Point(118' 9);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label12.Location = new System.Drawing.Point(118' 9);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label12.Size = new System.Drawing.Size(19' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label12.Size = new System.Drawing.Size(19' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label12.TabIndex = 4;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.picBox.Location = new System.Drawing.Point(14' 289);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.picBox.Location = new System.Drawing.Point(14' 289);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.picBox.Size = new System.Drawing.Size(512' 256);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.picBox.Size = new System.Drawing.Size(512' 256);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.picBox.TabIndex = 5;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label13.Location = new System.Drawing.Point(13' 270);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label13.Location = new System.Drawing.Point(13' 270);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label13.Size = new System.Drawing.Size(48' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label13.Size = new System.Drawing.Size(48' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label13.TabIndex = 6;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.btnSave.Location = new System.Drawing.Point(449' 4);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.btnSave.Location = new System.Drawing.Point(449' 4);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.btnSave.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.btnSave.Size = new System.Drawing.Size(80' 40);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.btnSave.TabIndex = 7;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label14.Location = new System.Drawing.Point(415' 57);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label14.Location = new System.Drawing.Point(415' 57);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label14.Size = new System.Drawing.Size(70' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label14.Size = new System.Drawing.Size(70' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label14.TabIndex = 8;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.comboSize.Location = new System.Drawing.Point(415' 73);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.comboSize.Location = new System.Drawing.Point(415' 73);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.comboSize.Size = new System.Drawing.Size(110' 21);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.comboSize.Size = new System.Drawing.Size(110' 21);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.comboSize.TabIndex = 9;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkGrid.Location = new System.Drawing.Point(3' 108);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkGrid.Location = new System.Drawing.Point(3' 108);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkGrid.Size = new System.Drawing.Size(69' 17);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkGrid.Size = new System.Drawing.Size(69' 17);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkGrid.TabIndex = 10;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkNumbers.Location = new System.Drawing.Point(3' 85);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkNumbers.Location = new System.Drawing.Point(3' 85);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkNumbers.Size = new System.Drawing.Size(92' 17);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkNumbers.Size = new System.Drawing.Size(92' 17);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkNumbers.TabIndex = 11;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkImage.Location = new System.Drawing.Point(3' 62);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkImage.Location = new System.Drawing.Point(3' 62);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkImage.Size = new System.Drawing.Size(80' 17);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkImage.Size = new System.Drawing.Size(80' 17);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkImage.TabIndex = 12;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkOAM.Location = new System.Drawing.Point(3' 42);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkOAM.Location = new System.Drawing.Point(3' 42);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkOAM.Size = new System.Drawing.Size(105' 17);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkOAM.Size = new System.Drawing.Size(105' 17);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkOAM.TabIndex = 13;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkTrans.Location = new System.Drawing.Point(3' 19);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkTrans.Location = new System.Drawing.Point(3' 19);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkTrans.Size = new System.Drawing.Size(91' 17);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkTrans.Size = new System.Drawing.Size(91' 17);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkTrans.TabIndex = 14;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.groupPreview.Location = new System.Drawing.Point(418' 105);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.groupPreview.Location = new System.Drawing.Point(418' 105);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.groupPreview.Size = new System.Drawing.Size(111' 152);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.groupPreview.Size = new System.Drawing.Size(111' 152);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.groupPreview.TabIndex = 15;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkCurrOAM.Location = new System.Drawing.Point(3' 129);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkCurrOAM.Location = new System.Drawing.Point(3' 129);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkCurrOAM.Size = new System.Drawing.Size(79' 17);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkCurrOAM.Size = new System.Drawing.Size(79' 17);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkCurrOAM.TabIndex = 15;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.btnAddOAM.Location = new System.Drawing.Point(225' 4);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.btnAddOAM.Location = new System.Drawing.Point(225' 4);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.btnAddOAM.Size = new System.Drawing.Size(90' 23);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.btnAddOAM.Size = new System.Drawing.Size(90' 23);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.btnAddOAM.TabIndex = 16;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.btnRemOAM.Location = new System.Drawing.Point(321' 4);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.btnRemOAM.Location = new System.Drawing.Point(321' 4);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.btnRemOAM.Size = new System.Drawing.Size(90' 23);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.btnRemOAM.Size = new System.Drawing.Size(90' 23);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.btnRemOAM.TabIndex = 17;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numNumOAM.Location = new System.Drawing.Point(176' 236);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numNumOAM.Location = new System.Drawing.Point(176' 236);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numNumOAM.Maximum = new decimal(new int[] {              65535'              0'              0'              0});
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numNumOAM.Size = new System.Drawing.Size(60' 20);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numNumOAM.Size = new System.Drawing.Size(60' 20);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numNumOAM.TabIndex = 18;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label15.Location = new System.Drawing.Point(125' 238);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label15.Location = new System.Drawing.Point(125' 238);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label15.Size = new System.Drawing.Size(45' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label15.Size = new System.Drawing.Size(45' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label15.TabIndex = 19;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numObj0.Location = new System.Drawing.Point(176' 263);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numObj0.Location = new System.Drawing.Point(176' 263);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numObj0.Maximum = new decimal(new int[] {              65535'              0'              0'              0});
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numObj0.Size = new System.Drawing.Size(60' 20);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numObj0.Size = new System.Drawing.Size(60' 20);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numObj0.TabIndex = 20;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numObj0.Value = new decimal(new int[] {              65535'              0'              0'              0});
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label16.Location = new System.Drawing.Point(126' 265);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label16.Location = new System.Drawing.Point(126' 265);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label16.Size = new System.Drawing.Size(32' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label16.Size = new System.Drawing.Size(32' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label16.TabIndex = 21;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label17.Location = new System.Drawing.Point(257' 265);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label17.Location = new System.Drawing.Point(257' 265);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label17.Size = new System.Drawing.Size(32' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label17.Size = new System.Drawing.Size(32' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label17.TabIndex = 23;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numObj1.Location = new System.Drawing.Point(307' 263);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numObj1.Location = new System.Drawing.Point(307' 263);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numObj1.Maximum = new decimal(new int[] {              65535'              0'              0'              0});
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numObj1.Size = new System.Drawing.Size(60' 20);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numObj1.Size = new System.Drawing.Size(60' 20);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numObj1.TabIndex = 22;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numObj1.Value = new decimal(new int[] {              65535'              0'              0'              0});
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label18.Location = new System.Drawing.Point(383' 265);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label18.Location = new System.Drawing.Point(383' 265);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label18.Size = new System.Drawing.Size(32' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label18.Size = new System.Drawing.Size(32' 13);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.label18.TabIndex = 25;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numObj2.Location = new System.Drawing.Point(433' 263);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numObj2.Location = new System.Drawing.Point(433' 263);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numObj2.Maximum = new decimal(new int[] {              65535'              0'              0'              0});
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numObj2.Size = new System.Drawing.Size(60' 20);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numObj2.Size = new System.Drawing.Size(60' 20);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numObj2.TabIndex = 24;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.numObj2.Value = new decimal(new int[] {              65535'              0'              0'              0});
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkAddFirst.Location = new System.Drawing.Point(14' 234);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkAddFirst.Location = new System.Drawing.Point(14' 234);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkAddFirst.Size = new System.Drawing.Size(78' 17);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkAddFirst.Size = new System.Drawing.Size(78' 17);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.checkAddFirst.TabIndex = 26;
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(533' 550);
Magic Number,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(533' 550);
Magic Number,Ekona.Mathematics,Vector3,C:\repos\pleonex_tinke\Ekona\Mathematics\Vector3.cs,Vector3,The following statement contains a magic number: this.z = coordinates[2];
Magic Number,Ekona.Mathematics,Vector3,C:\repos\pleonex_tinke\Ekona\Mathematics\Vector3.cs,CounterclockwiseAngleBetween,The following statement contains a magic number: betweenAngle = factor > 0 ? betweenAngle : 2.0 * Math.PI - betweenAngle;
Magic Number,Ekona.Mathematics,Vector3,C:\repos\pleonex_tinke\Ekona\Mathematics\Vector3.cs,CounterclockwiseAngleBetween,The following statement contains a magic number: if (det < 0) angle = 2 * Math.PI - angle;
Magic Number,Ekona.Mathematics,Vector3,C:\repos\pleonex_tinke\Ekona\Mathematics\Vector3.cs,Orthogonal,The following statement contains a magic number: for (int i = 1; i < 3; i++)                  if (Math.Abs(this[i]) > Math.Abs(this[maxCoordIndex]))                      maxCoordIndex = i;
Magic Number,Ekona.Mathematics,Vector3,C:\repos\pleonex_tinke\Ekona\Mathematics\Vector3.cs,Orthogonal,The following statement contains a magic number: result[(maxCoordIndex + 1) % 3] = 0;
Magic Number,Ekona.Mathematics,Vector3,C:\repos\pleonex_tinke\Ekona\Mathematics\Vector3.cs,Orthogonal,The following statement contains a magic number: result[(maxCoordIndex + 2) % 3] = -this[maxCoordIndex];
Magic Number,Ekona.Mathematics,Vector3,C:\repos\pleonex_tinke\Ekona\Mathematics\Vector3.cs,Orthogonal,The following statement contains a magic number: result[(maxCoordIndex + 2) % 3] = -this[maxCoordIndex];
Magic Number,Ekona.Mathematics,Vector3,C:\repos\pleonex_tinke\Ekona\Mathematics\Vector3.cs,Orthogonal,The following statement contains a magic number: result[maxCoordIndex] = this[(maxCoordIndex + 2) % 3];
Magic Number,Ekona.Mathematics,Vector3,C:\repos\pleonex_tinke\Ekona\Mathematics\Vector3.cs,Orthogonal,The following statement contains a magic number: result[maxCoordIndex] = this[(maxCoordIndex + 2) % 3];
Missing Default,Ekona.Helper,LNK,C:\repos\pleonex_tinke\Ekona\Helper\LNK.cs,Read_Extra,The following switch statement is missing a default case: switch (sign)                  {                      case 0xA0000001:                          extra.environment.blockSize = size;                          extra.environment.blockSignature = sign;                          extra.environment.targetAnsi = Get_String(br' 260' false);                          extra.environment.targetUnicode = Get_String(br' 260' true);                          break;                        case 0xA0000002:                          CONSOLE_PROPS cp = new CONSOLE_PROPS();                          cp.blockSize = size;                          cp.blockSignature = sign;                          cp.fillAttributes = (FILL_ATTRIBUTES)br.ReadUInt16();                          cp.popupFillAttributes = br.ReadUInt16();                          cp.screenBufferSizeX = br.ReadUInt16();                          cp.screenBufferSizeY = br.ReadUInt16();                          cp.windowSizeX = br.ReadUInt16();                          cp.windowSizeY = br.ReadUInt16();                          cp.windowOriginX = br.ReadUInt16();                          cp.windowOriginY = br.ReadUInt16();                          cp.unused1 = br.ReadUInt32();                          cp.unused2 = br.ReadUInt32();                          cp.fontSize = br.ReadUInt32();                          cp.fontFamily = (FONT_FAMILY)br.ReadUInt32();                          cp.fontWeight = br.ReadUInt32();                          cp.faceName = Get_String(br' 32' true);                          cp.cursorSize = br.ReadUInt32();                          cp.fullScreen = br.ReadUInt32();                          cp.quickEdit = br.ReadUInt32();                          cp.insertMode = br.ReadUInt32();                          cp.autoPosition = br.ReadUInt32();                          cp.historyBufferSize = br.ReadUInt32();                          cp.numberOfHistoryBuffer = br.ReadUInt32();                          cp.historyNoDup = br.ReadUInt32();                          cp.colorTable = new uint[0x10];                          for (int i = 0; i < 0x10; i++)                              cp.colorTable[i] = br.ReadUInt32();                          extra.console = cp;                          break;                        case 0xA0000003:                          extra.tracker.blockSize = size;                          extra.tracker.blockSignature = sign;                          extra.tracker.length = br.ReadUInt32();                          extra.tracker.version = br.ReadUInt32();                          extra.tracker.machineID = Get_String(br' 0x10' false);                          extra.tracker.droid = br.ReadBytes(0x20);                          extra.tracker.droidBirth = br.ReadBytes(0x20);                          break;                        case 0xA0000004:                          extra.consoleFe.blockSize = size;                          extra.consoleFe.blockSignature = sign;                          extra.consoleFe.codePage = br.ReadUInt32();                          break;                        case 0xA0000005:                          extra.specialFolder.blockSize = size;                          extra.specialFolder.blockSignature = sign;                          extra.specialFolder.specialFolderID = br.ReadUInt32();                          extra.specialFolder.offset = br.ReadUInt32();                          break;                        case 0xA0000006:                          extra.darwin.blockSize = size;                          extra.darwin.blockSignature = sign;                          extra.darwin.darwinDataAnsi = Get_String(br' 260' false);                          extra.darwin.darwinDataUnicode = Get_String(br' 260' true);                          break;                        case 0xA0000007:                          extra.iconEnvironment.blockSize = size;                          extra.iconEnvironment.blockSignature = sign;                          extra.iconEnvironment.targetAnsi = Get_String(br' 260' false);                          extra.iconEnvironment.targetUnicode = Get_String(br' 260' true);                          break;                        case 0xA0000008:                          extra.shim.blockSize = size;                          extra.shim.blockSignature = sign;                          extra.shim.layerName = Get_String(br' (int)extra.shim.blockSize - 8'  true);                          break;                        case 0xA0000009:                          extra.propertyStore.blockSize = size;                          extra.propertyStore.blockSignature = sign;                          extra.propertyStore.propertyStore = null;                          break;                        case 0xA000000B:                          extra.knownFolder.blockSize = size;                          extra.knownFolder.blockSignature = sign;                          extra.knownFolder.knownFolderID = br.ReadBytes(0x10);                          extra.knownFolder.offset = br.ReadUInt32();                          break;                        case 0xA000000C:                          extra.vistaIDList.blockSize = size;                          extra.vistaIDList.blockSignature = sign;                          extra.vistaIDList.idlist = Read_IDList(br);                          break;                  }
Missing Default,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Indexed_Image,The following switch statement is missing a default case: switch (cf)              {                  case ColorFormat.A3I5: max_colors = 32; bpc = 8; break;                  case ColorFormat.colors4: max_colors = 4; bpc = 2; break;                  case ColorFormat.colors16: max_colors = 16; bpc = 4; break;                  case ColorFormat.colors256: max_colors = 256; bpc = 8; break;                  case ColorFormat.texel4x4: throw new NotSupportedException("Texel 4x4 not supported yet.");                  case ColorFormat.A5I3: max_colors = 8; bpc = 8; break;                  case ColorFormat.direct: max_colors = 0; bpc = 16; break;                  case ColorFormat.colors2: max_colors = 2; bpc = 1; break;                  case ColorFormat.A4I4: max_colors = 16; bpc = 8; break;              }
Missing Default,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Indexed_Image,The following switch statement is missing a default case: switch (cf)                  {                      case ColorFormat.colors2:                      case ColorFormat.colors4:                      case ColorFormat.colors16:                      case ColorFormat.colors256:                          for (int b = 0; b < 8; b += bpc)                              if (j < data.Length)                                  tiles[i] |= (byte)(data[j++' 0] << b);                            i++;                          break;                        case ColorFormat.A3I5:                          byte alpha1 = (byte)(data[j' 1] * 8 / 256);                          byte va1 = (byte)data[j++' 0];                          va1 |= (byte)(alpha1 << 5);                          tiles[i++] = va1;                          break;                      case ColorFormat.A4I4:                          byte alpha3 = (byte)(data[j' 1] * 16 / 256);                          byte va3 = (byte)data[j++' 0];                          va3 |= (byte)(alpha3 << 4);                          tiles[i++] = va3;                          break;                      case ColorFormat.A5I3:                          byte alpha2 = (byte)(data[j' 1] * 32 / 256);                          byte va2 = (byte)data[j++' 0];                          va2 |= (byte)(alpha2 << 3);                          tiles[i++] = va2;                          break;                        case ColorFormat.direct:                          byte[] v = ColorToBGRA555(Color.FromArgb(data[j' 1]' coldif[data[j++' 0]]));                          tiles[i++] = v[0];                          tiles[i++] = v[1];                          break;                        case ColorFormat.texel4x4:                          // Not supported                          break;                  }
Missing Default,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMSize,The following switch statement is missing a default case: switch (shape)              {                  case 0x00:  // Square                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 8);                              break;                          case 0x01:                              imageSize = new Size(16' 16);                              break;                          case 0x02:                              imageSize = new Size(32' 32);                              break;                          case 0x03:                              imageSize = new Size(64' 64);                              break;                      }                      break;                  case 0x01:  // Horizontal                      switch (size)                      {                          case 0x00:                              imageSize = new Size(16' 8);                              break;                          case 0x01:                              imageSize = new Size(32' 8);                              break;                          case 0x02:                              imageSize = new Size(32' 16);                              break;                          case 0x03:                              imageSize = new Size(64' 32);                              break;                      }                      break;                  case 0x02:  // Vertical                      switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 16);                              break;                          case 0x01:                              imageSize = new Size(8' 32);                              break;                          case 0x02:                              imageSize = new Size(16' 32);                              break;                          case 0x03:                              imageSize = new Size(32' 64);                              break;                      }                      break;              }
Missing Default,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMSize,The following switch statement is missing a default case: switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 8);                              break;                          case 0x01:                              imageSize = new Size(16' 16);                              break;                          case 0x02:                              imageSize = new Size(32' 32);                              break;                          case 0x03:                              imageSize = new Size(64' 64);                              break;                      }
Missing Default,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMSize,The following switch statement is missing a default case: switch (size)                      {                          case 0x00:                              imageSize = new Size(16' 8);                              break;                          case 0x01:                              imageSize = new Size(32' 8);                              break;                          case 0x02:                              imageSize = new Size(32' 16);                              break;                          case 0x03:                              imageSize = new Size(64' 32);                              break;                      }
Missing Default,Ekona.Images,Actions,C:\repos\pleonex_tinke\Ekona\Images\Actions.cs,Get_OAMSize,The following switch statement is missing a default case: switch (size)                      {                          case 0x00:                              imageSize = new Size(8' 16);                              break;                          case 0x01:                              imageSize = new Size(8' 32);                              break;                          case 0x02:                              imageSize = new Size(16' 32);                              break;                          case 0x03:                              imageSize = new Size(32' 64);                              break;                      }
Missing Default,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,Update_Info,The following switch statement is missing a default case: switch (image.FormatColor)              {                  case ColorFormat.A3I5: comboDepth.SelectedIndex = 4; break;                  case ColorFormat.A5I3: comboDepth.SelectedIndex = 5; break;                  case ColorFormat.colors4: comboDepth.SelectedIndex = 6; break;                  case ColorFormat.colors16: comboDepth.SelectedIndex = 0; break;                  case ColorFormat.colors256: comboDepth.SelectedIndex = 1; break;                  case ColorFormat.direct: comboDepth.SelectedIndex = 3; break;                  case ColorFormat.colors2: comboDepth.SelectedIndex = 2; break;              }
Missing Default,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,Update_Info,The following switch statement is missing a default case: switch (image.FormTile)                  {                      case TileForm.Lineal:                          comboBox1.SelectedIndex = 0;                          numericHeight.Minimum = 1;                          numericWidth.Minimum = 1;                          numericWidth.Increment = 1;                          numericHeight.Increment = 1;                          break;                      case TileForm.Horizontal:                          comboBox1.SelectedIndex = 1;                          numericHeight.Minimum = image.TileSize;                          numericWidth.Minimum = image.TileSize;                          numericWidth.Increment = image.TileSize;                          numericHeight.Increment = image.TileSize;                          break;                  }
Missing Default,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,comboDepth_SelectedIndexChanged,The following switch statement is missing a default case: switch (comboDepth.SelectedIndex)              {                  case 0: image.FormatColor = ColorFormat.colors16; break;                  case 1: image.FormatColor = ColorFormat.colors256; break;                  case 2: image.FormatColor = ColorFormat.colors2; break;                  case 3: image.FormatColor = ColorFormat.direct; break;                  case 4: image.FormatColor = ColorFormat.A3I5; break;                  case 5: image.FormatColor = ColorFormat.A5I3; break;                  case 6: image.FormatColor = ColorFormat.colors4; break;                  case 7: image.FormatColor = ColorFormat.A4I4; break;                  case 8: image.FormatColor = ColorFormat.BGRA32; break;                  case 9: image.FormatColor = ColorFormat.ABGR32; break;              }
Missing Default,Ekona.Images,ImageControl,C:\repos\pleonex_tinke\Ekona\Images\ImageControl.cs,comboBox1_SelectedIndexChanged,The following switch statement is missing a default case: switch (comboBox1.SelectedIndex)              {                  case 0:                      image.FormTile = TileForm.Lineal;                      numericHeight.Minimum = 1;                      numericWidth.Minimum = 1;                      numericWidth.Increment = 1;                      numericHeight.Increment = 1;                      break;                  case 1:                      image.FormTile = TileForm.Horizontal;                      numericHeight.Minimum = image.TileSize;                      numericWidth.Minimum = image.TileSize;                      numericWidth.Increment = image.TileSize;                      numericHeight.Increment = image.TileSize;                      break;              }
Missing Default,Ekona.Images.Formats,BMP,C:\repos\pleonex_tinke\Ekona\Images\Formats\Bitmap.cs,Read,The following switch statement is missing a default case: switch (bpp)              {                  case 4:                      int divisor = (int)width / 2;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width / 2' 4' out res);                          divisor = (int)width / 2 + (4 - res);                      }                        tiles = new byte[tiles.Length * 2];                      for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w += 2)                          {                              byte b = br.ReadByte();                              tiles[w + h * width] = (byte)(b >> 4);                                if (w + 1 != width)                                  tiles[w + 1 + h * width] = (byte)(b & 0xF);                          }                          br.ReadBytes((int)(divisor - ((float)width / 2)));                      }                      tiles = Helper.BitsConverter.Bits4ToByte(tiles);                      break;                  case 8:                      divisor = (int)width;                      if (width % 4 != 0)                      {                          int res;                          Math.DivRem((int)width' 4' out res);                          divisor = (int)width + (4 - res);                      }                        for (int h = (int)height - 1; h >= 0; h--)                      {                          for (int w = 0; w < width; w++)                          {                              tiles[w + h * width] = br.ReadByte();                          }                          br.ReadBytes(divisor - (int)width);                      }                      break;              }
Missing Default,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,Read_Info,The following switch statement is missing a default case: switch (oam.obj0.shape)              {                  case 0:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 0;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 1;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 2;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 3;                      break;                  case 1:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 4;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 5;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 6;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 7;                      break;                  case 2:                      if (oam.obj1.size == 0) comboSize.SelectedIndex = 8;                      else if (oam.obj1.size == 1) comboSize.SelectedIndex = 9;                      else if (oam.obj1.size == 2) comboSize.SelectedIndex = 10;                      else if (oam.obj1.size == 3) comboSize.SelectedIndex = 11;                      break;              }
Missing Default,Ekona.Images.Dialogs,OAMEditor,C:\repos\pleonex_tinke\Ekona\Images\Dialogs\OAMEditor.cs,comboSize_SelectedIndexChanged,The following switch statement is missing a default case: switch (comboSize.SelectedIndex)              {                  case 0:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 1:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 2:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 3:                      bank.oams[(int)numOAM.Value].obj0.shape = 0;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 4:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 5:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 6:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 7:                      bank.oams[(int)numOAM.Value].obj0.shape = 1;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;                  case 8:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 0;                      break;                  case 9:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 1;                      break;                  case 10:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 2;                      break;                  case 11:                      bank.oams[(int)numOAM.Value].obj0.shape = 2;                      bank.oams[(int)numOAM.Value].obj1.size = 3;                      break;              }
