Implementation smell,Namespace,Class,File,Method,Description
Long Method,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The method has 539 lines of code.
Long Method,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Write_Info,The method has 128 lines of code.
Long Method,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The method has 142 lines of code.
Long Method,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read,The method has 150 lines of code.
Long Method,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read_Section,The method has 131 lines of code.
Long Method,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The method has 104 lines of code.
Long Method,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The method has 204 lines of code.
Complex Method,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,Cyclomatic complexity of the method is 45
Complex Method,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Write_Info,Cyclomatic complexity of the method is 16
Complex Method,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read,Cyclomatic complexity of the method is 14
Complex Method,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read_Section,Cyclomatic complexity of the method is 12
Complex Method,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,Cyclomatic complexity of the method is 8
Complex Method,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,Cyclomatic complexity of the method is 8
Long Parameter List,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_Texture,The method has 5 parameters. Parameters: pluginHost' btx0' data' info' palette
Long Parameter List,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The method has 5 parameters. Parameters: pluginHost' btx0' data' info' num_pal
Long Parameter List,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Find_IDs,The method has 5 parameters. Parameters: num_tex' num_pal' tex_name' pal_name' texture
Long Statement,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The length of the statement  "                    br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i]; " is 121.
Long Statement,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The length of the statement  "                            sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t]; " is 135.
Long Statement,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The length of the statement  "                            sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p]; " is 135.
Long Statement,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The length of the statement  "                    br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i]; " is 120.
Long Statement,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Write_Info,The length of the statement  "                System.Xml.Linq.XElement xml = System.Xml.Linq.XElement.Load(System.Windows.Forms.Application.StartupPath + Path.DirectorySeparatorChar + " is 137.
Long Statement,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Write_Info,The length of the statement  "                    Console.WriteLine("-------------------<h4>" + xml.Element("S04").Value + "</h4>"' m.ToString()' bmd.model.mdlInfo.names[m]); " is 124.
Long Statement,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Write_Info,The length of the statement  "                            bmd.model.mdlData[m].bones.commands[i].size' BitConverter.ToString(bmd.model.mdlData[m].bones.commands[i].parameters' 0)); " is 122.
Long Statement,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Write_Info,The length of the statement  "                        Console.WriteLine("|__" + xml.Element("S2B").Value' BitConverter.ToString(bmd.model.mdlData[m].material.material[i].definition' 0)); " is 132.
Long Statement,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Write_Info,The length of the statement  "                        sBMD0.Model.ModelData.Material.TexPalData texInfo = (sBMD0.Model.ModelData.Material.TexPalData)bmd.model.mdlData[m].material.texture.infoBlock.infoData[i]; " is 155.
Long Statement,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Write_Info,The length of the statement  "                        sBMD0.Model.ModelData.Material.TexPalData palInfo = (sBMD0.Model.ModelData.Material.TexPalData)bmd.model.mdlData[m].material.palette.infoBlock.infoData[i]; " is 155.
Long Statement,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Write_Info,The length of the statement  "                    Console.WriteLine(xml.Element("S17").Value' texInfo.unknown.ToString()' texInfo.unknown2.ToString()' texInfo.unknown3.ToString()); " is 130.
Long Statement,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Write_Info,The length of the statement  "                    Console.WriteLine(xml.Element("S17").Value' texInfo.unknown.ToString()' texInfo.unknown2.ToString()' texInfo.unknown3.ToString()); " is 130.
Long Statement,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,GetTexture,The length of the statement  "                br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.textCompressedData_offset + texInfo.tex_offset * 8; " is 120.
Long Statement,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The length of the statement  "            br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.textCompressedInfoData_offset + info.compressedDataStart; " is 126.
Long Statement,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,LoadAllTex,The length of the statement  "                sBMD0.Model.ModelData.Material.MatDef mat = (sBMD0.Model.ModelData.Material.MatDef)model.model.mdlData[0].material.material[i]; " is 127.
Long Statement,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,Render,The length of the statement  "                    sBMD0.Model.ModelData.Material.MatDef mat = (sBMD0.Model.ModelData.Material.MatDef)model.model.mdlData[0].material.material[poly.materialID]; " is 141.
Long Statement,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,Render,The length of the statement  "                sBMD0.Model.ModelData.Material.MatDef mat = (sBMD0.Model.ModelData.Material.MatDef)model.model.mdlData[0].material.material[poly.materialID]; " is 141.
Long Statement,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,LoadTextures,The length of the statement  "            System.Drawing.Imaging.BitmapData bmp_data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' ImageLockMode.ReadOnly' System.Drawing.Imaging.PixelFormat.Format32bppRgb); " is 177.
Long Statement,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,UpdateTexture,The length of the statement  "                br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.textCompressedData_offset + texInfo.tex_offset * 8; " is 120.
Long Statement,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The length of the statement  "            sBTX0.Texture.PalInfo palInfo = (sBTX0.Texture.PalInfo)btx0.texture.palInfo.infoBlock.infoData[listPalettes.SelectedIndex]; " is 123.
Long Statement,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The length of the statement  "            br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.textCompressedInfoData_offset + info.compressedDataStart; " is 126.
Long Statement,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Info,The length of the statement  "            listProp.Items[10].SubItems.Add(texInfo.coord_transf.ToString() + " (" + (TextureCoordTransf)texInfo.coord_transf + ')'); " is 121.
Long Statement,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The length of the statement  "            "S03"}' -1' System.Drawing.Color.Empty' System.Drawing.Color.Empty' new System.Drawing.Font("Microsoft Sans Serif"' 9F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0)))); " is 200.
Long Statement,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The length of the statement  "            "S0E"}' -1' System.Drawing.Color.Empty' System.Drawing.Color.Empty' new System.Drawing.Font("Microsoft Sans Serif"' 9F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0)))); " is 200.
Empty Catch Block,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_Texture,The method has an empty catch block.
Empty Catch Block,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_Texture,The method has an empty catch block.
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: bmd.header.type = br.ReadChars(4);
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: bmd.model.type = br.ReadChars(4);
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: for (int m = 0; m < bmd.model.mdlInfo.num_objs; m++)              {                  uint modelOffset = bmd.header.offset[0] + (uint)bmd.model.mdlInfo.infoBlock.infoData[m];                  br.BaseStream.Position = modelOffset;                    #region Read Model Data block                  sBMD0.Model.ModelData data = new sBMD0.Model.ModelData();                    #region Header                  data.header.blockSize = br.ReadUInt32();                  data.header.bonesOffset = br.ReadUInt32();                  data.header.materialOffset = br.ReadUInt32();                  data.header.polygonStartOffset = br.ReadUInt32();                  data.header.polygonEndOffset = br.ReadUInt32();                  data.header.unknown1 = br.ReadByte();                  data.header.unknown2 = br.ReadByte();                  data.header.unknown3 = br.ReadByte();                  data.header.numObjects = br.ReadByte();                  data.header.numMaterial = br.ReadByte();                  data.header.numPolygon = br.ReadByte();                  data.header.unknown4 = br.ReadByte();                  data.header.scaleMode = br.ReadByte();                  data.header.unknown5 = br.ReadUInt64();                  data.header.numVertices = br.ReadUInt16();                  data.header.numSurfaces = br.ReadUInt16();                  data.header.numTriangles = br.ReadUInt16();                  data.header.numQuads = br.ReadUInt16();                  data.header.boundingX = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingY = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingZ = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingWidth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingHeight = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.boundingDepth = Get_SignedFixedPoint(br.ReadUInt16());                  data.header.unused = br.ReadUInt64();                  #endregion                    // Objetcs section                  int objSecOffset = (int)br.BaseStream.Position;                  #region 3DInfo                  mdlInfo = new Info3D();                    // Header                  mdlInfo.dummy = br.ReadByte();                  mdlInfo.num_objs = br.ReadByte();                  mdlInfo.section_size = br.ReadUInt16();                    // Unknown                  mdlInfo.unknownBlock.header_size = br.ReadUInt16();                  mdlInfo.unknownBlock.section_size = br.ReadUInt16();                  mdlInfo.unknownBlock.constant = br.ReadUInt32();                    mdlInfo.unknownBlock.unknown1 = new ushort[mdlInfo.num_objs];                  mdlInfo.unknownBlock.unknown2 = new ushort[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.unknownBlock.unknown1[i] = br.ReadUInt16();                      mdlInfo.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  mdlInfo.infoBlock.header_size = br.ReadUInt16();                  mdlInfo.infoBlock.data_size = br.ReadUInt16();                  mdlInfo.infoBlock.infoData = new Object[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                  {                      mdlInfo.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  mdlInfo.names = new string[mdlInfo.num_objs];                  for (int i = 0; i < mdlInfo.num_objs; i++)                      mdlInfo.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.objects.header = mdlInfo;                  #endregion                  #region Object data                  data.objects.objData = new sBMD0.Model.ModelData.Objects.ObjData[data.objects.header.num_objs];                  for (int i = 0; i < data.objects.header.num_objs; i++)                  {                      sBMD0.Model.ModelData.Objects.ObjData objData = new sBMD0.Model.ModelData.Objects.ObjData();                      br.BaseStream.Position = objSecOffset + (uint)data.objects.header.infoBlock.infoData[i];                        objData.transFlag = br.ReadUInt16();                      objData.padding = br.ReadUInt16();                      objData.T = (byte)(objData.transFlag & 1);                      objData.R = (byte)((objData.transFlag >> 1) & 1);                      objData.S = (byte)((objData.transFlag >> 2) & 1);                      objData.P = (byte)((objData.transFlag >> 3) & 1);                      objData.N = (byte)((objData.transFlag >> 4) & 0xF);                        if (objData.T == 0)                      {                          objData.xValue = br.ReadUInt32();                          objData.yValue = br.ReadUInt32();                          objData.zValue = br.ReadUInt32();                      }                      if (objData.P == 1)                      {                          objData.value1 = br.ReadUInt16();                          objData.value2 = br.ReadUInt16();                      }                      if (objData.S == 0)                      {                          objData.xScale = br.ReadUInt32();                          objData.yScale = br.ReadUInt32();                          objData.zScale = br.ReadUInt32();                      }                      if (objData.P == 0 && objData.R == 0)                      {                          objData.rot1 = br.ReadUInt16();                          objData.rot2 = br.ReadUInt16();                          objData.rot3 = br.ReadUInt16();                          objData.rot4 = br.ReadUInt16();                          objData.rot5 = br.ReadUInt16();                          objData.rot6 = br.ReadUInt16();                          objData.rot7 = br.ReadUInt16();                          objData.rot8 = br.ReadUInt16();                      }                        data.objects.objData[i] = objData;                  }                  #endregion                    // Bones commands                  #region Commands                  br.BaseStream.Position = data.header.bonesOffset + modelOffset;                  byte cmd = 0;                  data.bones.commands = new List<sBMD0.Model.ModelData.Bones.Command>();                  while (cmd != 0x01)                  {                      cmd = br.ReadByte();                      sBMD0.Model.ModelData.Bones.Command command = new sBMD0.Model.ModelData.Bones.Command();                      command.command = cmd;                      command.parameters = new byte[0];                        switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }                        data.bones.commands.Add(command);                  }                  #endregion                    // Material section                  br.BaseStream.Position = modelOffset + data.header.materialOffset;                  data.material.texOffset = br.ReadUInt16();                  data.material.paletteOffset = br.ReadUInt16();                    #region 3DInfo                  Info3D info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.definition = info;                  #endregion                  #region Texture Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.texOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData texInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      texInfo.matching_data_offset = br.ReadUInt16();                      texInfo.num_associated_mat = br.ReadByte();                      texInfo.dummy0 = br.ReadByte();                        // Read the Matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + texInfo.matching_data_offset;                      texInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = texInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.texture = info;                  #endregion                  #region Palette Information                  br.BaseStream.Position = modelOffset + data.header.materialOffset + data.material.paletteOffset;                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.TexPalData palInfo = new sBMD0.Model.ModelData.Material.TexPalData();                      palInfo.matching_data_offset = br.ReadUInt16();                      palInfo.num_associated_mat = br.ReadByte();                      palInfo.dummy0 = br.ReadByte();                        // Read the matching data                      long currPos = br.BaseStream.Position;                      br.BaseStream.Position = modelOffset + data.header.materialOffset + palInfo.matching_data_offset;                      palInfo.ID = br.ReadByte();                      br.BaseStream.Position = currPos;                        info.infoBlock.infoData[i] = palInfo;                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.material.palette = info;                  #endregion                  #region Material definition                  data.material.material = new sBMD0.Model.ModelData.Material.MatDef[data.material.definition.num_objs];                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.materialOffset + (uint)data.material.definition.infoBlock.infoData[i];                      br.BaseStream.Position += 4 + 18;       // 0x04 for Texture and Palette offset' 18 unknown but it works :)                      data.material.material[i].definition = br.ReadBytes(0x2E);                        if (i < data.material.texture.names.Length)                      {                          int texID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[i]).ID;                          data.material.material[texID].texName = data.material.texture.names[i];                          data.material.material[texID].texID = (byte)i;                      }                      if (i < data.material.palette.names.Length)                      {                          int palID = ((sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[i]).ID;                          data.material.material[palID].palName = data.material.palette.names[i];                          data.material.material[palID].palID = (byte)i;                      }                  }                  for (int i = 0; i < data.material.definition.num_objs; i++)                  {                      sBMD0.Model.ModelData.Material.MatDef mat = data.material.material[i];                      if (mat.palName != null && mat.texName != null)                          continue;                        Console.WriteLine("Trying to fix...");                      if (mat.texName == null)                      {                          for (int t = 0; t < data.material.texture.infoBlock.infoData.Length; t++)                          {                              sBMD0.Model.ModelData.Material.TexPalData tex = (sBMD0.Model.ModelData.Material.TexPalData)data.material.texture.infoBlock.infoData[t];                              if (tex.num_associated_mat <= 1)                                  continue;                                mat.texName = data.material.texture.names[t];                              mat.texID = (byte)t;                              tex.num_associated_mat--;                              data.material.texture.infoBlock.infoData[t] = tex;                              break;                          }                      }                      if (mat.palName == null)                      {                          for (int p = 0; p < data.material.palette.infoBlock.infoData.Length; p++)                          {                              sBMD0.Model.ModelData.Material.TexPalData pal = (sBMD0.Model.ModelData.Material.TexPalData)data.material.palette.infoBlock.infoData[p];                              if (pal.num_associated_mat <= 1)                                  continue;                                mat.palName = data.material.palette.names[p];                              mat.palID = (byte)p;                              pal.num_associated_mat--;                              data.material.palette.infoBlock.infoData[p] = pal;                              break;                          }                      }                      data.material.material[i] = mat;                  }                  BTX0.Match_Textures(ref data.material.material' data.material.palette.names' data.material.texture.names);                  #endregion                    // Polygon section                  br.BaseStream.Position = modelOffset + data.header.polygonStartOffset;                  #region 3DInfo                  info = new Info3D();                    // Header                  info.dummy = br.ReadByte();                  info.num_objs = br.ReadByte();                  info.section_size = br.ReadUInt16();                    // Unknown                  info.unknownBlock.header_size = br.ReadUInt16();                  info.unknownBlock.section_size = br.ReadUInt16();                  info.unknownBlock.constant = br.ReadUInt32();                    info.unknownBlock.unknown1 = new ushort[info.num_objs];                  info.unknownBlock.unknown2 = new ushort[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.unknownBlock.unknown1[i] = br.ReadUInt16();                      info.unknownBlock.unknown2[i] = br.ReadUInt16();                  }                    // Data                  info.infoBlock.header_size = br.ReadUInt16();                  info.infoBlock.data_size = br.ReadUInt16();                  info.infoBlock.infoData = new Object[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                  {                      info.infoBlock.infoData[i] = br.ReadUInt32();                  }                    // Names                  info.names = new string[info.num_objs];                  for (int i = 0; i < info.num_objs; i++)                      info.names[i] = new String(br.ReadChars(0x10)).Replace("\0"' "");                    data.polygon.header = info;                  #endregion                  #region Polygon definition                  data.polygon.definition = new sBMD0.Model.ModelData.Polygon.Definition[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = modelOffset + data.header.polygonStartOffset + (uint)data.polygon.header.infoBlock.infoData[i];                      long currPos = br.BaseStream.Position;                        sBMD0.Model.ModelData.Polygon.Definition def = new sBMD0.Model.ModelData.Polygon.Definition();                      def.unknown1 = br.ReadUInt32();                      def.unknown2 = br.ReadUInt32();                      def.display_offset = br.ReadUInt32() + (uint)currPos;                      def.display_size = br.ReadUInt32();                      data.polygon.definition[i] = def;                  }                  #endregion                  #region Display list                  data.polygon.display = new sBMD0.Model.ModelData.Polygon.Display[data.polygon.header.num_objs];                  for (int i = 0; i < data.polygon.header.num_objs; i++)                  {                      br.BaseStream.Position = data.polygon.definition[i].display_offset;                      byte[] display_list = br.ReadBytes((int)data.polygon.definition[i].display_size);                        data.polygon.display[i].commands = new List<Command>();                      for (int l = 0; l + 4 < display_list.Length; )                      {                          byte[] cmdID = new byte[] { display_list[l]' display_list[l + 1]' display_list[l + 2]' display_list[l + 3] };                          l += 4;                            Command[] commands = new Command[4];                          for (int c = 0; c < 4; c++)                          {                              commands[c] = new Command();                              commands[c].cmd = cmdID[c];                                int cmd_size = Get_CommandSize(cmdID[c]);                              commands[c].param = new uint[cmd_size];                              for (int p = 0; p < cmd_size && l + 4 < display_list.Length; p++' l += 4)                                  commands[c].param[p] = BitConverter.ToUInt32(display_list' l);                          }                            data.polygon.display[i].commands.AddRange(commands);                      }                  }                  #endregion                    bmd.model.mdlData[m] = data;                  #endregion              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following statement contains a magic number: if (bmd.header.numSect == 2)    // There is a Tex0 section              {                  br.BaseStream.Position = bmd.header.offset[1];                  bmd.texture = BTX0.Read_Section(ref br' bmd.header.offset[1]' pluginHost.Get_Language());              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Get_SignedFixedPoint,The following statement contains a magic number: double point = ((value >> 12) & 7);
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Get_SignedFixedPoint,The following statement contains a magic number: double point = ((value >> 12) & 7);
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Get_SignedFixedPoint,The following statement contains a magic number: if ((value >> 15) == 1)                  point = -point;
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Get_Double,The following statement contains a magic number: if (signed)              {                  if ((value >> (integer + fractional)) == 1)                  {                      integerMask = (int)Math.Pow(2' integer + 1) - 1;                      int intPart = ((value >> fractional) & integerMask);                      point = intPart - (int)Math.Pow(2' integer + 1);                  }                  else                  {                      integerMask = (int)Math.Pow(2' integer) - 1;                      point = ((value >> fractional) & integerMask);                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Get_Double,The following statement contains a magic number: if (signed)              {                  if ((value >> (integer + fractional)) == 1)                  {                      integerMask = (int)Math.Pow(2' integer + 1) - 1;                      int intPart = ((value >> fractional) & integerMask);                      point = intPart - (int)Math.Pow(2' integer + 1);                  }                  else                  {                      integerMask = (int)Math.Pow(2' integer) - 1;                      point = ((value >> fractional) & integerMask);                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Get_Double,The following statement contains a magic number: if (signed)              {                  if ((value >> (integer + fractional)) == 1)                  {                      integerMask = (int)Math.Pow(2' integer + 1) - 1;                      int intPart = ((value >> fractional) & integerMask);                      point = intPart - (int)Math.Pow(2' integer + 1);                  }                  else                  {                      integerMask = (int)Math.Pow(2' integer) - 1;                      point = ((value >> fractional) & integerMask);                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Get_Double,The following statement contains a magic number: int fractionalMask = (int)Math.Pow(2' fractional) - 1;
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Get_CommandSize,The following statement contains a magic number: switch (cmd)              {                  case 0: return 0;                    case 0x10: return 1;                  case 0x11: return 0;                  case 0x12: return 1;                  case 0x13: return 1;                  case 0x14: return 1;                  case 0x15: return 0;                  case 0x16: return 16;                  case 0x17: return 12;                  case 0x18: return 16;                  case 0x19: return 12;                  case 0x1A: return 9;                  case 0x1B: return 3;                  case 0x1C: return 3;                    case 0x20: return 1;                  case 0x21: return 1;                  case 0x22: return 1;                  case 0x23: return 2;                  case 0x24: return 1;                  case 0x25: return 1;                  case 0x26: return 1;                  case 0x27: return 1;                  case 0x28: return 1;                    case 0x29: return 1;                  case 0x2A: return 1;                  case 0x2B: return 1;                    case 0x30: return 1;                  case 0x31: return 1;                  case 0x32: return 1;                  case 0x33: return 1;                  case 0x34: return 32;                    case 0x40: return 1;                  case 0x41: return 0;                    case 0x50: return 1;                    case 0x60: return 1;                    case 0x70: return 3;                  case 0x71: return 2;                  case 0x72: return 1;                    default:                      return 0;              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Get_CommandSize,The following statement contains a magic number: switch (cmd)              {                  case 0: return 0;                    case 0x10: return 1;                  case 0x11: return 0;                  case 0x12: return 1;                  case 0x13: return 1;                  case 0x14: return 1;                  case 0x15: return 0;                  case 0x16: return 16;                  case 0x17: return 12;                  case 0x18: return 16;                  case 0x19: return 12;                  case 0x1A: return 9;                  case 0x1B: return 3;                  case 0x1C: return 3;                    case 0x20: return 1;                  case 0x21: return 1;                  case 0x22: return 1;                  case 0x23: return 2;                  case 0x24: return 1;                  case 0x25: return 1;                  case 0x26: return 1;                  case 0x27: return 1;                  case 0x28: return 1;                    case 0x29: return 1;                  case 0x2A: return 1;                  case 0x2B: return 1;                    case 0x30: return 1;                  case 0x31: return 1;                  case 0x32: return 1;                  case 0x33: return 1;                  case 0x34: return 32;                    case 0x40: return 1;                  case 0x41: return 0;                    case 0x50: return 1;                    case 0x60: return 1;                    case 0x70: return 3;                  case 0x71: return 2;                  case 0x72: return 1;                    default:                      return 0;              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Get_CommandSize,The following statement contains a magic number: switch (cmd)              {                  case 0: return 0;                    case 0x10: return 1;                  case 0x11: return 0;                  case 0x12: return 1;                  case 0x13: return 1;                  case 0x14: return 1;                  case 0x15: return 0;                  case 0x16: return 16;                  case 0x17: return 12;                  case 0x18: return 16;                  case 0x19: return 12;                  case 0x1A: return 9;                  case 0x1B: return 3;                  case 0x1C: return 3;                    case 0x20: return 1;                  case 0x21: return 1;                  case 0x22: return 1;                  case 0x23: return 2;                  case 0x24: return 1;                  case 0x25: return 1;                  case 0x26: return 1;                  case 0x27: return 1;                  case 0x28: return 1;                    case 0x29: return 1;                  case 0x2A: return 1;                  case 0x2B: return 1;                    case 0x30: return 1;                  case 0x31: return 1;                  case 0x32: return 1;                  case 0x33: return 1;                  case 0x34: return 32;                    case 0x40: return 1;                  case 0x41: return 0;                    case 0x50: return 1;                    case 0x60: return 1;                    case 0x70: return 3;                  case 0x71: return 2;                  case 0x72: return 1;                    default:                      return 0;              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Get_CommandSize,The following statement contains a magic number: switch (cmd)              {                  case 0: return 0;                    case 0x10: return 1;                  case 0x11: return 0;                  case 0x12: return 1;                  case 0x13: return 1;                  case 0x14: return 1;                  case 0x15: return 0;                  case 0x16: return 16;                  case 0x17: return 12;                  case 0x18: return 16;                  case 0x19: return 12;                  case 0x1A: return 9;                  case 0x1B: return 3;                  case 0x1C: return 3;                    case 0x20: return 1;                  case 0x21: return 1;                  case 0x22: return 1;                  case 0x23: return 2;                  case 0x24: return 1;                  case 0x25: return 1;                  case 0x26: return 1;                  case 0x27: return 1;                  case 0x28: return 1;                    case 0x29: return 1;                  case 0x2A: return 1;                  case 0x2B: return 1;                    case 0x30: return 1;                  case 0x31: return 1;                  case 0x32: return 1;                  case 0x33: return 1;                  case 0x34: return 32;                    case 0x40: return 1;                  case 0x41: return 0;                    case 0x50: return 1;                    case 0x60: return 1;                    case 0x70: return 3;                  case 0x71: return 2;                  case 0x72: return 1;                    default:                      return 0;              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Get_CommandSize,The following statement contains a magic number: switch (cmd)              {                  case 0: return 0;                    case 0x10: return 1;                  case 0x11: return 0;                  case 0x12: return 1;                  case 0x13: return 1;                  case 0x14: return 1;                  case 0x15: return 0;                  case 0x16: return 16;                  case 0x17: return 12;                  case 0x18: return 16;                  case 0x19: return 12;                  case 0x1A: return 9;                  case 0x1B: return 3;                  case 0x1C: return 3;                    case 0x20: return 1;                  case 0x21: return 1;                  case 0x22: return 1;                  case 0x23: return 2;                  case 0x24: return 1;                  case 0x25: return 1;                  case 0x26: return 1;                  case 0x27: return 1;                  case 0x28: return 1;                    case 0x29: return 1;                  case 0x2A: return 1;                  case 0x2B: return 1;                    case 0x30: return 1;                  case 0x31: return 1;                  case 0x32: return 1;                  case 0x33: return 1;                  case 0x34: return 32;                    case 0x40: return 1;                  case 0x41: return 0;                    case 0x50: return 1;                    case 0x60: return 1;                    case 0x70: return 3;                  case 0x71: return 2;                  case 0x72: return 1;                    default:                      return 0;              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Get_CommandSize,The following statement contains a magic number: switch (cmd)              {                  case 0: return 0;                    case 0x10: return 1;                  case 0x11: return 0;                  case 0x12: return 1;                  case 0x13: return 1;                  case 0x14: return 1;                  case 0x15: return 0;                  case 0x16: return 16;                  case 0x17: return 12;                  case 0x18: return 16;                  case 0x19: return 12;                  case 0x1A: return 9;                  case 0x1B: return 3;                  case 0x1C: return 3;                    case 0x20: return 1;                  case 0x21: return 1;                  case 0x22: return 1;                  case 0x23: return 2;                  case 0x24: return 1;                  case 0x25: return 1;                  case 0x26: return 1;                  case 0x27: return 1;                  case 0x28: return 1;                    case 0x29: return 1;                  case 0x2A: return 1;                  case 0x2B: return 1;                    case 0x30: return 1;                  case 0x31: return 1;                  case 0x32: return 1;                  case 0x33: return 1;                  case 0x34: return 32;                    case 0x40: return 1;                  case 0x41: return 0;                    case 0x50: return 1;                    case 0x60: return 1;                    case 0x70: return 3;                  case 0x71: return 2;                  case 0x72: return 1;                    default:                      return 0;              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Get_CommandSize,The following statement contains a magic number: switch (cmd)              {                  case 0: return 0;                    case 0x10: return 1;                  case 0x11: return 0;                  case 0x12: return 1;                  case 0x13: return 1;                  case 0x14: return 1;                  case 0x15: return 0;                  case 0x16: return 16;                  case 0x17: return 12;                  case 0x18: return 16;                  case 0x19: return 12;                  case 0x1A: return 9;                  case 0x1B: return 3;                  case 0x1C: return 3;                    case 0x20: return 1;                  case 0x21: return 1;                  case 0x22: return 1;                  case 0x23: return 2;                  case 0x24: return 1;                  case 0x25: return 1;                  case 0x26: return 1;                  case 0x27: return 1;                  case 0x28: return 1;                    case 0x29: return 1;                  case 0x2A: return 1;                  case 0x2B: return 1;                    case 0x30: return 1;                  case 0x31: return 1;                  case 0x32: return 1;                  case 0x33: return 1;                  case 0x34: return 32;                    case 0x40: return 1;                  case 0x41: return 0;                    case 0x50: return 1;                    case 0x60: return 1;                    case 0x70: return 3;                  case 0x71: return 2;                  case 0x72: return 1;                    default:                      return 0;              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Get_CommandSize,The following statement contains a magic number: switch (cmd)              {                  case 0: return 0;                    case 0x10: return 1;                  case 0x11: return 0;                  case 0x12: return 1;                  case 0x13: return 1;                  case 0x14: return 1;                  case 0x15: return 0;                  case 0x16: return 16;                  case 0x17: return 12;                  case 0x18: return 16;                  case 0x19: return 12;                  case 0x1A: return 9;                  case 0x1B: return 3;                  case 0x1C: return 3;                    case 0x20: return 1;                  case 0x21: return 1;                  case 0x22: return 1;                  case 0x23: return 2;                  case 0x24: return 1;                  case 0x25: return 1;                  case 0x26: return 1;                  case 0x27: return 1;                  case 0x28: return 1;                    case 0x29: return 1;                  case 0x2A: return 1;                  case 0x2B: return 1;                    case 0x30: return 1;                  case 0x31: return 1;                  case 0x32: return 1;                  case 0x33: return 1;                  case 0x34: return 32;                    case 0x40: return 1;                  case 0x41: return 0;                    case 0x50: return 1;                    case 0x60: return 1;                    case 0x70: return 3;                  case 0x71: return 2;                  case 0x72: return 1;                    default:                      return 0;              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Get_CommandSize,The following statement contains a magic number: switch (cmd)              {                  case 0: return 0;                    case 0x10: return 1;                  case 0x11: return 0;                  case 0x12: return 1;                  case 0x13: return 1;                  case 0x14: return 1;                  case 0x15: return 0;                  case 0x16: return 16;                  case 0x17: return 12;                  case 0x18: return 16;                  case 0x19: return 12;                  case 0x1A: return 9;                  case 0x1B: return 3;                  case 0x1C: return 3;                    case 0x20: return 1;                  case 0x21: return 1;                  case 0x22: return 1;                  case 0x23: return 2;                  case 0x24: return 1;                  case 0x25: return 1;                  case 0x26: return 1;                  case 0x27: return 1;                  case 0x28: return 1;                    case 0x29: return 1;                  case 0x2A: return 1;                  case 0x2B: return 1;                    case 0x30: return 1;                  case 0x31: return 1;                  case 0x32: return 1;                  case 0x33: return 1;                  case 0x34: return 32;                    case 0x40: return 1;                  case 0x41: return 0;                    case 0x50: return 1;                    case 0x60: return 1;                    case 0x70: return 3;                  case 0x71: return 2;                  case 0x72: return 1;                    default:                      return 0;              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Get_CommandSize,The following statement contains a magic number: switch (cmd)              {                  case 0: return 0;                    case 0x10: return 1;                  case 0x11: return 0;                  case 0x12: return 1;                  case 0x13: return 1;                  case 0x14: return 1;                  case 0x15: return 0;                  case 0x16: return 16;                  case 0x17: return 12;                  case 0x18: return 16;                  case 0x19: return 12;                  case 0x1A: return 9;                  case 0x1B: return 3;                  case 0x1C: return 3;                    case 0x20: return 1;                  case 0x21: return 1;                  case 0x22: return 1;                  case 0x23: return 2;                  case 0x24: return 1;                  case 0x25: return 1;                  case 0x26: return 1;                  case 0x27: return 1;                  case 0x28: return 1;                    case 0x29: return 1;                  case 0x2A: return 1;                  case 0x2B: return 1;                    case 0x30: return 1;                  case 0x31: return 1;                  case 0x32: return 1;                  case 0x33: return 1;                  case 0x34: return 32;                    case 0x40: return 1;                  case 0x41: return 0;                    case 0x50: return 1;                    case 0x60: return 1;                    case 0x70: return 3;                  case 0x71: return 2;                  case 0x72: return 1;                    default:                      return 0;              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Get_CommandSize,The following statement contains a magic number: switch (cmd)              {                  case 0: return 0;                    case 0x10: return 1;                  case 0x11: return 0;                  case 0x12: return 1;                  case 0x13: return 1;                  case 0x14: return 1;                  case 0x15: return 0;                  case 0x16: return 16;                  case 0x17: return 12;                  case 0x18: return 16;                  case 0x19: return 12;                  case 0x1A: return 9;                  case 0x1B: return 3;                  case 0x1C: return 3;                    case 0x20: return 1;                  case 0x21: return 1;                  case 0x22: return 1;                  case 0x23: return 2;                  case 0x24: return 1;                  case 0x25: return 1;                  case 0x26: return 1;                  case 0x27: return 1;                  case 0x28: return 1;                    case 0x29: return 1;                  case 0x2A: return 1;                  case 0x2B: return 1;                    case 0x30: return 1;                  case 0x31: return 1;                  case 0x32: return 1;                  case 0x33: return 1;                  case 0x34: return 32;                    case 0x40: return 1;                  case 0x41: return 0;                    case 0x50: return 1;                    case 0x60: return 1;                    case 0x70: return 3;                  case 0x71: return 2;                  case 0x72: return 1;                    default:                      return 0;              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,GeometryCommands,The following statement contains a magic number: for (int i = 0; i < geoCmd.Count; i++)              {                  switch ((GeometryCmd)geoCmd[i].cmd)                  {                      case GeometryCmd.NOP:                          break;                      case GeometryCmd.MTX_MODE:                          break;                      case GeometryCmd.MTX_PUSH:                          break;                      case GeometryCmd.MTX_POP:                          break;                      case GeometryCmd.MTX_STORE:                          break;                      case GeometryCmd.MTX_RESTORE:                          break;                      case GeometryCmd.MTX_IDENTITY:                          break;                      case GeometryCmd.MTX_LOAD_4x4:                          break;                      case GeometryCmd.MTX_LOAD_4x3:                          break;                      case GeometryCmd.MTX_MULT_4x4:                          break;                      case GeometryCmd.MTX_MULT_4x3:                          break;                      case GeometryCmd.MTX_MULT_3x3:                          break;                      case GeometryCmd.MTX_SCALE:                          break;                      case GeometryCmd.MTX_TRANS:                          break;                        #region Vertex commands                      // Multiply by the clipmatrix                      case GeometryCmd.VTX_16:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[1] & 0xFFFF)' true' 3' 12);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_10:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 3' 6);                          vector.Y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FF)' true' 3' 6);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 3' 6);                            GL.Vertex3(vector);                          break;                        case GeometryCmd.VTX_XY:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Y = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_XZ:                          vector.X = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_YZ:                          vector.Y = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 3' 12);                          vector.Z = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 3' 12);                            GL.Vertex3(vector);                            break;                        case GeometryCmd.VTX_DIFF:                          float diffX' diffY' diffZ;                            diffX = Get_Double((int)(geoCmd[i].param[0] & 0x3FF)' true' 0' 9);                          diffY = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          diffZ = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            vector.X += (diffX / 8);                          vector.Y += (diffY / 8);                          vector.Z += (diffZ / 8);                            GL.Vertex3(vector);                          break;                      #endregion                        case GeometryCmd.COLOR:                          // Convert the param to RGB555 color                          int r = (int)(geoCmd[i].param[0] & 0x1F);                          int g = (int)((geoCmd[i].param[0] >> 5) & 0x1F);                          int b = (int)((geoCmd[i].param[0] >> 10) & 0x1F);                            GL.Color3((float)r / 31.0f' (float)g / 31.0f' (float)b / 31.0f);                          break;                      case GeometryCmd.POLYGON_ATTR:                          break;                        #region Texture attributes                      case GeometryCmd.TEXCOORD:                          double s' t;                          s = Get_Double((int)(geoCmd[i].param[0] & 0xFFFF)' true' 11' 4);                          t = Get_Double((int)(geoCmd[i].param[0] >> 16)' true' 11' 4);                          GL.TexCoord2(s' t);                          break;                        case GeometryCmd.TEXIMAGE_PARAM:                          break;                      case GeometryCmd.PLTT_BASE:                          break;                      #endregion                        case GeometryCmd.DIF_AMB:                          break;                      case GeometryCmd.SPE_EMI:                          break;                      case GeometryCmd.LIGHT_VECTOR:                          break;                      case GeometryCmd.LIGHT_COLOR:                          break;                      case GeometryCmd.SHININESS:                          break;                        case GeometryCmd.NORMAL:                          float x' y' z;                          x = Get_Double((int)(geoCmd[i].param[0] & 0x3FFF)' true' 0' 9);                          y = Get_Double((int)((geoCmd[i].param[0] >> 10) & 0x3FFF)' true' 0' 9);                          z = Get_Double((int)(geoCmd[i].param[0] >> 20)' true' 0' 9);                            // Multiplay by the directional matrix                          GL.Normal3(x' y' z);                          break;                        case GeometryCmd.BEGIN_VTXS:                          if (geoCmd[i].param[0] == 0)                              GL.Begin(BeginMode.Triangles);                          else if (geoCmd[i].param[0] == 1)                              GL.Begin(BeginMode.Quads);                          else if (geoCmd[i].param[0] == 2)                              GL.Begin(BeginMode.TriangleStrip);                          else if (geoCmd[i].param[0] == 3)                              GL.Begin(BeginMode.QuadStrip);                          break;                      case GeometryCmd.END_VTXS:                          GL.End();                          break;                        case GeometryCmd.SWAP_BUFFERS:                          break;                      case GeometryCmd.VIEWPORT:                          break;                      case GeometryCmd.BOX_TEST:                          break;                      case GeometryCmd.POS_TEST:                          break;                      case GeometryCmd.VEC_TEST:                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read,The following statement contains a magic number: btx.header.type = br.ReadChars(4);
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read,The following statement contains a magic number: tex.header.type = br.ReadChars(4);
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read,The following statement contains a magic number: tex.header.textCompressedData_size = (ushort)(br.ReadUInt16() << 3);
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read,The following statement contains a magic number: tex.header.paletteData_size = (uint)(br.ReadUInt32() << 3);
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read_Section,The following statement contains a magic number: tex.header.type = br.ReadChars(4);
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read_Section,The following statement contains a magic number: tex.header.textCompressedData_size = (ushort)(br.ReadUInt16() << 3);
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read_Section,The following statement contains a magic number: tex.header.paletteData_size = (uint)(br.ReadUInt32() << 3);
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read_Section,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read_Section,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read_Section,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read_Section,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read_Section,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read_Section,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read_Section,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read_Section,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read_Section,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read_Section,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read_Section,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read_Section,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read_Section,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read_Section,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read_Section,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read_Section,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Read_Section,The following statement contains a magic number: for (int i = 0; i < tex.texInfo.num_objs; i++)              {                  sBTX0.Texture.TextInfo texInfo = new sBTX0.Texture.TextInfo();                  texInfo.tex_offset = br.ReadUInt16();                  texInfo.parameters = br.ReadUInt16();                  texInfo.width2 = br.ReadByte();                  texInfo.unknown = br.ReadByte();                  texInfo.unknown2 = br.ReadByte();                  texInfo.unknown3 = br.ReadByte();                    texInfo.coord_transf = (byte)(texInfo.parameters & 14);                  texInfo.color0 = (byte)((texInfo.parameters >> 13) & 1);                  texInfo.format = (byte)((texInfo.parameters >> 10) & 7);                  texInfo.height = (byte)(8 << ((texInfo.parameters >> 7) & 7));                  texInfo.width = (byte)(8 << ((texInfo.parameters >> 4) & 7));                  texInfo.flip_Y = (byte)((texInfo.parameters >> 3) & 1);                  texInfo.flip_X = (byte)((texInfo.parameters >> 2) & 1);                  texInfo.repeat_Y = (byte)((texInfo.parameters >> 1) & 1);                  texInfo.repeat_X = (byte)(texInfo.parameters & 1);                    if (texInfo.width == 0x00)                      switch (texInfo.unknown & 0x3)                      {                          case 2:                              texInfo.width = 0x200;                              break;                          default:                              texInfo.width = 0x100;                              break;                      }                  if (texInfo.height == 0x00)                      switch ((texInfo.unknown >> 4) & 0x3)                      {                          case 2:                              texInfo.height = 0x200;                              break;                          default:                              texInfo.height = 0x100;                              break;                      }                    texInfo.depth = FormatDepth[texInfo.format];                  if (texInfo.format == 5)                  {                      texInfo.compressedDataStart = compressedStartOffset;                      compressedStartOffset += (uint)(texInfo.width * texInfo.height / 8);                  }                    tex.texInfo.infoBlock.infoData[i] = texInfo;              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,GetTexture,The following statement contains a magic number: if (texInfo.format != 5)                  br.BaseStream.Position = texInfo.tex_offset * 8 + btx0.header.offset[0] + btx0.texture.header.textData_offset;              else                  br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.textCompressedData_offset + texInfo.tex_offset * 8;
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,GetTexture,The following statement contains a magic number: if (texInfo.format != 5)                  br.BaseStream.Position = texInfo.tex_offset * 8 + btx0.header.offset[0] + btx0.texture.header.textData_offset;              else                  br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.textCompressedData_offset + texInfo.tex_offset * 8;
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,GetTexture,The following statement contains a magic number: if (texInfo.format != 5)                  br.BaseStream.Position = texInfo.tex_offset * 8 + btx0.header.offset[0] + btx0.texture.header.textData_offset;              else                  br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.textCompressedData_offset + texInfo.tex_offset * 8;
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,GetTexture,The following statement contains a magic number: Byte[] tile_data = br.ReadBytes((int)(texInfo.width * texInfo.height * texInfo.depth / 8));
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,GetTexture,The following statement contains a magic number: br.BaseStream.Position += palInfo.palette_offset * 8;
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,GetTexture,The following statement contains a magic number: if (texInfo.format != 5)                  tex = Draw_Texture(pluginHost' btx0' tile_data' texInfo' palette);              else                  tex = Draw_CompressedTexture(pluginHost' btx0' tile_data' texInfo' num_pal);
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_Texture,The following statement contains a magic number: if (info.format == 3) // 16-color 4 bits                  data = Ekona.Helper.BitsConverter.BytesToBit4(data);              else if (info.format == 2) // 4-color 2 bits                  data = Bit8ToBit2(data);
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_Texture,The following statement contains a magic number: if (info.format == 3) // 16-color 4 bits                  data = Ekona.Helper.BitsConverter.BytesToBit4(data);              else if (info.format == 2) // 4-color 2 bits                  data = Bit8ToBit2(data);
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Bit8ToBit2,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  bit2.Add((byte)(data[i] & 0x3));                  bit2.Add((byte)((data[i] >> 2) & 0x3));                  bit2.Add((byte)((data[i] >> 4) & 0x3));                  bit2.Add((byte)((data[i] >> 6) & 0x3));              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Bit8ToBit2,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  bit2.Add((byte)(data[i] & 0x3));                  bit2.Add((byte)((data[i] >> 2) & 0x3));                  bit2.Add((byte)((data[i] >> 4) & 0x3));                  bit2.Add((byte)((data[i] >> 6) & 0x3));              }
Magic Number,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Bit8ToBit2,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  bit2.Add((byte)(data[i] & 0x3));                  bit2.Add((byte)((data[i] >> 2) & 0x3));                  bit2.Add((byte)((data[i] >> 4) & 0x3));                  bit2.Add((byte)((data[i] >> 6) & 0x3));              }
Magic Number,_3DModels,Main,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\Main.cs,Read,The following statement contains a magic number: string ext = new String(br.ReadChars(4));
Magic Number,_3DModels,Main,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\Main.cs,Show_Info,The following statement contains a magic number: string ext = new String(br.ReadChars(4));
Magic Number,_3DModels,Main,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\Main.cs,Show_Info,The following statement contains a magic number: if (ext == "BTX0")              {                  btx = BTX0.Read(file.path' file.id' pluginHost);                  return new TextureControl(pluginHost' btx);              }              else if (ext == "BMD0")              {                  sBMD0 bmd = BMD0.Read(file.path' file.id' pluginHost);                    if (bmd.header.numSect == 2)                      return new ModelControl(pluginHost' bmd);                  else if (btx.texture.texInfo.num_objs != 0)                      return new ModelControl(pluginHost' bmd' btx);                  else                      System.Windows.Forms.MessageBox.Show("There aren't textures.");              }
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,ModelControl_Load,The following statement contains a magic number: GL.Viewport(new Size(512' 512));
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,ModelControl_Load,The following statement contains a magic number: GL.Viewport(new Size(512' 512));
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,ProcessBones,The following statement contains a magic number: for (int c = 0; c < model.model.mdlData[0].bones.commands.Count; c++)              {                  sBMD0.Model.ModelData.Bones.Command cmd = model.model.mdlData[0].bones.commands[c];                  switch (cmd.command)                  {                      case 0x44:                      case 0x24:                      case 0x04:                          int currTex = 0;                          if (texturesGL.ContainsKey(cmd.parameters[0]))                              currTex = cmd.parameters[0];                          else                              texturesGL.TryGetValue(1' out currTex);                            model.model.mdlData[0].polygon.display[cmd.parameters[2]].materialAssoc = texturesGL[currTex];                          model.model.mdlData[0].polygon.display[cmd.parameters[2]].materialID = cmd.parameters[0];                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,ProcessBones,The following statement contains a magic number: for (int c = 0; c < model.model.mdlData[0].bones.commands.Count; c++)              {                  sBMD0.Model.ModelData.Bones.Command cmd = model.model.mdlData[0].bones.commands[c];                  switch (cmd.command)                  {                      case 0x44:                      case 0x24:                      case 0x04:                          int currTex = 0;                          if (texturesGL.ContainsKey(cmd.parameters[0]))                              currTex = cmd.parameters[0];                          else                              texturesGL.TryGetValue(1' out currTex);                            model.model.mdlData[0].polygon.display[cmd.parameters[2]].materialAssoc = texturesGL[currTex];                          model.model.mdlData[0].polygon.display[cmd.parameters[2]].materialID = cmd.parameters[0];                          break;                      default:                          break;                  }              }
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,glControl1_MouseMove,The following statement contains a magic number: if (ev.Button == MouseButtons.Right)              {                  distance = (distanceS + (ev.Y - _mouseStartY)) / ZOOM_FACTOR;                  if (distance > 3)                      distance = 3;                  else if (distance <= 0)                      distance = 2 / ZOOM_FACTOR;              }
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,glControl1_MouseMove,The following statement contains a magic number: if (ev.Button == MouseButtons.Right)              {                  distance = (distanceS + (ev.Y - _mouseStartY)) / ZOOM_FACTOR;                  if (distance > 3)                      distance = 3;                  else if (distance <= 0)                      distance = 2 / ZOOM_FACTOR;              }
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,glControl1_MouseMove,The following statement contains a magic number: if (ev.Button == MouseButtons.Right)              {                  distance = (distanceS + (ev.Y - _mouseStartY)) / ZOOM_FACTOR;                  if (distance > 3)                      distance = 3;                  else if (distance <= 0)                      distance = 2 / ZOOM_FACTOR;              }
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,button1_Click,The following statement contains a magic number: ven.Size = new Size(530' 530);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,button1_Click,The following statement contains a magic number: ven.Size = new Size(530' 530);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.glControl1.Location = new System.Drawing.Point(3' 3);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.glControl1.Location = new System.Drawing.Point(3' 3);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.glControl1.Size = new System.Drawing.Size(506' 382);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.glControl1.Size = new System.Drawing.Size(506' 382);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(3' 388);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(3' 388);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(35' 13);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(35' 13);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(429' 469);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(429' 469);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(80' 40);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(80' 40);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.button1.TabIndex = 2;
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.numericPoly.Location = new System.Drawing.Point(90' 483);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.numericPoly.Location = new System.Drawing.Point(90' 483);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.numericPoly.Size = new System.Drawing.Size(63' 20);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.numericPoly.Size = new System.Drawing.Size(63' 20);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.numericPoly.TabIndex = 3;
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(3' 485);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(3' 485);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(81' 13);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(81' 13);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 4;
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.checkManual.Location = new System.Drawing.Point(4' 457);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.checkManual.Location = new System.Drawing.Point(4' 457);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.checkManual.Size = new System.Drawing.Size(68' 17);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.checkManual.Size = new System.Drawing.Size(68' 17);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.checkManual.TabIndex = 5;
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.button2.Location = new System.Drawing.Point(343' 469);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.button2.Location = new System.Drawing.Point(343' 469);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.button2.Size = new System.Drawing.Size(80' 40);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.button2.Size = new System.Drawing.Size(80' 40);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.button2.TabIndex = 6;
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(512' 512);
Magic Number,_3DModels,ModelControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\ModelControl.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(512' 512);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,ReadLanguage,The following statement contains a magic number: try              {                  System.Xml.Linq.XElement xml = System.Xml.Linq.XElement.Load(Application.StartupPath + Path.DirectorySeparatorChar +                      "Plugins" + Path.DirectorySeparatorChar + "3DModelsLang.xml");                  xml = xml.Element(pluginHost.Get_Language()).Element("TextureControl");                    columnProperty.Text = xml.Element("S00").Value;                  columnValue.Text = xml.Element("S01").Value;                  listProp.Items[0].Text = xml.Element("S02").Value;                  listProp.Items[0].SubItems[1].Text = xml.Element("S03").Value;                  listProp.Items[1].Text = xml.Element("S04").Value;                  listProp.Items[2].Text = xml.Element("S05").Value;                  listProp.Items[3].Text = xml.Element("S06").Value;                  listProp.Items[4].Text = xml.Element("S07").Value;                  listProp.Items[5].Text = xml.Element("S08").Value;                  listProp.Items[6].Text = xml.Element("S09").Value;                  listProp.Items[7].Text = xml.Element("S0A").Value;                  listProp.Items[8].Text = xml.Element("S0B").Value;                  listProp.Items[9].Text = xml.Element("S0C").Value;                  listProp.Items[10].Text = xml.Element("S0D").Value;                  listProp.Items[11].Text = xml.Element("S02").Value;                  listProp.Items[11].SubItems[1].Text = xml.Element("S0E").Value;                  listProp.Items[12].Text = xml.Element("S04").Value;                  label2.Text = xml.Element("S0F").Value;                  label1.Text = xml.Element("S10").Value;                  label3.Text = xml.Element("S11").Value;                  btnSetTransparent.Text = xml.Element("S12").Value;                  btnSave.Text = xml.Element("S13").Value;              }              catch { throw new NotSupportedException("There was an error reading the language file"); }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,ReadLanguage,The following statement contains a magic number: try              {                  System.Xml.Linq.XElement xml = System.Xml.Linq.XElement.Load(Application.StartupPath + Path.DirectorySeparatorChar +                      "Plugins" + Path.DirectorySeparatorChar + "3DModelsLang.xml");                  xml = xml.Element(pluginHost.Get_Language()).Element("TextureControl");                    columnProperty.Text = xml.Element("S00").Value;                  columnValue.Text = xml.Element("S01").Value;                  listProp.Items[0].Text = xml.Element("S02").Value;                  listProp.Items[0].SubItems[1].Text = xml.Element("S03").Value;                  listProp.Items[1].Text = xml.Element("S04").Value;                  listProp.Items[2].Text = xml.Element("S05").Value;                  listProp.Items[3].Text = xml.Element("S06").Value;                  listProp.Items[4].Text = xml.Element("S07").Value;                  listProp.Items[5].Text = xml.Element("S08").Value;                  listProp.Items[6].Text = xml.Element("S09").Value;                  listProp.Items[7].Text = xml.Element("S0A").Value;                  listProp.Items[8].Text = xml.Element("S0B").Value;                  listProp.Items[9].Text = xml.Element("S0C").Value;                  listProp.Items[10].Text = xml.Element("S0D").Value;                  listProp.Items[11].Text = xml.Element("S02").Value;                  listProp.Items[11].SubItems[1].Text = xml.Element("S0E").Value;                  listProp.Items[12].Text = xml.Element("S04").Value;                  label2.Text = xml.Element("S0F").Value;                  label1.Text = xml.Element("S10").Value;                  label3.Text = xml.Element("S11").Value;                  btnSetTransparent.Text = xml.Element("S12").Value;                  btnSave.Text = xml.Element("S13").Value;              }              catch { throw new NotSupportedException("There was an error reading the language file"); }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,ReadLanguage,The following statement contains a magic number: try              {                  System.Xml.Linq.XElement xml = System.Xml.Linq.XElement.Load(Application.StartupPath + Path.DirectorySeparatorChar +                      "Plugins" + Path.DirectorySeparatorChar + "3DModelsLang.xml");                  xml = xml.Element(pluginHost.Get_Language()).Element("TextureControl");                    columnProperty.Text = xml.Element("S00").Value;                  columnValue.Text = xml.Element("S01").Value;                  listProp.Items[0].Text = xml.Element("S02").Value;                  listProp.Items[0].SubItems[1].Text = xml.Element("S03").Value;                  listProp.Items[1].Text = xml.Element("S04").Value;                  listProp.Items[2].Text = xml.Element("S05").Value;                  listProp.Items[3].Text = xml.Element("S06").Value;                  listProp.Items[4].Text = xml.Element("S07").Value;                  listProp.Items[5].Text = xml.Element("S08").Value;                  listProp.Items[6].Text = xml.Element("S09").Value;                  listProp.Items[7].Text = xml.Element("S0A").Value;                  listProp.Items[8].Text = xml.Element("S0B").Value;                  listProp.Items[9].Text = xml.Element("S0C").Value;                  listProp.Items[10].Text = xml.Element("S0D").Value;                  listProp.Items[11].Text = xml.Element("S02").Value;                  listProp.Items[11].SubItems[1].Text = xml.Element("S0E").Value;                  listProp.Items[12].Text = xml.Element("S04").Value;                  label2.Text = xml.Element("S0F").Value;                  label1.Text = xml.Element("S10").Value;                  label3.Text = xml.Element("S11").Value;                  btnSetTransparent.Text = xml.Element("S12").Value;                  btnSave.Text = xml.Element("S13").Value;              }              catch { throw new NotSupportedException("There was an error reading the language file"); }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,ReadLanguage,The following statement contains a magic number: try              {                  System.Xml.Linq.XElement xml = System.Xml.Linq.XElement.Load(Application.StartupPath + Path.DirectorySeparatorChar +                      "Plugins" + Path.DirectorySeparatorChar + "3DModelsLang.xml");                  xml = xml.Element(pluginHost.Get_Language()).Element("TextureControl");                    columnProperty.Text = xml.Element("S00").Value;                  columnValue.Text = xml.Element("S01").Value;                  listProp.Items[0].Text = xml.Element("S02").Value;                  listProp.Items[0].SubItems[1].Text = xml.Element("S03").Value;                  listProp.Items[1].Text = xml.Element("S04").Value;                  listProp.Items[2].Text = xml.Element("S05").Value;                  listProp.Items[3].Text = xml.Element("S06").Value;                  listProp.Items[4].Text = xml.Element("S07").Value;                  listProp.Items[5].Text = xml.Element("S08").Value;                  listProp.Items[6].Text = xml.Element("S09").Value;                  listProp.Items[7].Text = xml.Element("S0A").Value;                  listProp.Items[8].Text = xml.Element("S0B").Value;                  listProp.Items[9].Text = xml.Element("S0C").Value;                  listProp.Items[10].Text = xml.Element("S0D").Value;                  listProp.Items[11].Text = xml.Element("S02").Value;                  listProp.Items[11].SubItems[1].Text = xml.Element("S0E").Value;                  listProp.Items[12].Text = xml.Element("S04").Value;                  label2.Text = xml.Element("S0F").Value;                  label1.Text = xml.Element("S10").Value;                  label3.Text = xml.Element("S11").Value;                  btnSetTransparent.Text = xml.Element("S12").Value;                  btnSave.Text = xml.Element("S13").Value;              }              catch { throw new NotSupportedException("There was an error reading the language file"); }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,ReadLanguage,The following statement contains a magic number: try              {                  System.Xml.Linq.XElement xml = System.Xml.Linq.XElement.Load(Application.StartupPath + Path.DirectorySeparatorChar +                      "Plugins" + Path.DirectorySeparatorChar + "3DModelsLang.xml");                  xml = xml.Element(pluginHost.Get_Language()).Element("TextureControl");                    columnProperty.Text = xml.Element("S00").Value;                  columnValue.Text = xml.Element("S01").Value;                  listProp.Items[0].Text = xml.Element("S02").Value;                  listProp.Items[0].SubItems[1].Text = xml.Element("S03").Value;                  listProp.Items[1].Text = xml.Element("S04").Value;                  listProp.Items[2].Text = xml.Element("S05").Value;                  listProp.Items[3].Text = xml.Element("S06").Value;                  listProp.Items[4].Text = xml.Element("S07").Value;                  listProp.Items[5].Text = xml.Element("S08").Value;                  listProp.Items[6].Text = xml.Element("S09").Value;                  listProp.Items[7].Text = xml.Element("S0A").Value;                  listProp.Items[8].Text = xml.Element("S0B").Value;                  listProp.Items[9].Text = xml.Element("S0C").Value;                  listProp.Items[10].Text = xml.Element("S0D").Value;                  listProp.Items[11].Text = xml.Element("S02").Value;                  listProp.Items[11].SubItems[1].Text = xml.Element("S0E").Value;                  listProp.Items[12].Text = xml.Element("S04").Value;                  label2.Text = xml.Element("S0F").Value;                  label1.Text = xml.Element("S10").Value;                  label3.Text = xml.Element("S11").Value;                  btnSetTransparent.Text = xml.Element("S12").Value;                  btnSave.Text = xml.Element("S13").Value;              }              catch { throw new NotSupportedException("There was an error reading the language file"); }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,ReadLanguage,The following statement contains a magic number: try              {                  System.Xml.Linq.XElement xml = System.Xml.Linq.XElement.Load(Application.StartupPath + Path.DirectorySeparatorChar +                      "Plugins" + Path.DirectorySeparatorChar + "3DModelsLang.xml");                  xml = xml.Element(pluginHost.Get_Language()).Element("TextureControl");                    columnProperty.Text = xml.Element("S00").Value;                  columnValue.Text = xml.Element("S01").Value;                  listProp.Items[0].Text = xml.Element("S02").Value;                  listProp.Items[0].SubItems[1].Text = xml.Element("S03").Value;                  listProp.Items[1].Text = xml.Element("S04").Value;                  listProp.Items[2].Text = xml.Element("S05").Value;                  listProp.Items[3].Text = xml.Element("S06").Value;                  listProp.Items[4].Text = xml.Element("S07").Value;                  listProp.Items[5].Text = xml.Element("S08").Value;                  listProp.Items[6].Text = xml.Element("S09").Value;                  listProp.Items[7].Text = xml.Element("S0A").Value;                  listProp.Items[8].Text = xml.Element("S0B").Value;                  listProp.Items[9].Text = xml.Element("S0C").Value;                  listProp.Items[10].Text = xml.Element("S0D").Value;                  listProp.Items[11].Text = xml.Element("S02").Value;                  listProp.Items[11].SubItems[1].Text = xml.Element("S0E").Value;                  listProp.Items[12].Text = xml.Element("S04").Value;                  label2.Text = xml.Element("S0F").Value;                  label1.Text = xml.Element("S10").Value;                  label3.Text = xml.Element("S11").Value;                  btnSetTransparent.Text = xml.Element("S12").Value;                  btnSave.Text = xml.Element("S13").Value;              }              catch { throw new NotSupportedException("There was an error reading the language file"); }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,ReadLanguage,The following statement contains a magic number: try              {                  System.Xml.Linq.XElement xml = System.Xml.Linq.XElement.Load(Application.StartupPath + Path.DirectorySeparatorChar +                      "Plugins" + Path.DirectorySeparatorChar + "3DModelsLang.xml");                  xml = xml.Element(pluginHost.Get_Language()).Element("TextureControl");                    columnProperty.Text = xml.Element("S00").Value;                  columnValue.Text = xml.Element("S01").Value;                  listProp.Items[0].Text = xml.Element("S02").Value;                  listProp.Items[0].SubItems[1].Text = xml.Element("S03").Value;                  listProp.Items[1].Text = xml.Element("S04").Value;                  listProp.Items[2].Text = xml.Element("S05").Value;                  listProp.Items[3].Text = xml.Element("S06").Value;                  listProp.Items[4].Text = xml.Element("S07").Value;                  listProp.Items[5].Text = xml.Element("S08").Value;                  listProp.Items[6].Text = xml.Element("S09").Value;                  listProp.Items[7].Text = xml.Element("S0A").Value;                  listProp.Items[8].Text = xml.Element("S0B").Value;                  listProp.Items[9].Text = xml.Element("S0C").Value;                  listProp.Items[10].Text = xml.Element("S0D").Value;                  listProp.Items[11].Text = xml.Element("S02").Value;                  listProp.Items[11].SubItems[1].Text = xml.Element("S0E").Value;                  listProp.Items[12].Text = xml.Element("S04").Value;                  label2.Text = xml.Element("S0F").Value;                  label1.Text = xml.Element("S10").Value;                  label3.Text = xml.Element("S11").Value;                  btnSetTransparent.Text = xml.Element("S12").Value;                  btnSave.Text = xml.Element("S13").Value;              }              catch { throw new NotSupportedException("There was an error reading the language file"); }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,ReadLanguage,The following statement contains a magic number: try              {                  System.Xml.Linq.XElement xml = System.Xml.Linq.XElement.Load(Application.StartupPath + Path.DirectorySeparatorChar +                      "Plugins" + Path.DirectorySeparatorChar + "3DModelsLang.xml");                  xml = xml.Element(pluginHost.Get_Language()).Element("TextureControl");                    columnProperty.Text = xml.Element("S00").Value;                  columnValue.Text = xml.Element("S01").Value;                  listProp.Items[0].Text = xml.Element("S02").Value;                  listProp.Items[0].SubItems[1].Text = xml.Element("S03").Value;                  listProp.Items[1].Text = xml.Element("S04").Value;                  listProp.Items[2].Text = xml.Element("S05").Value;                  listProp.Items[3].Text = xml.Element("S06").Value;                  listProp.Items[4].Text = xml.Element("S07").Value;                  listProp.Items[5].Text = xml.Element("S08").Value;                  listProp.Items[6].Text = xml.Element("S09").Value;                  listProp.Items[7].Text = xml.Element("S0A").Value;                  listProp.Items[8].Text = xml.Element("S0B").Value;                  listProp.Items[9].Text = xml.Element("S0C").Value;                  listProp.Items[10].Text = xml.Element("S0D").Value;                  listProp.Items[11].Text = xml.Element("S02").Value;                  listProp.Items[11].SubItems[1].Text = xml.Element("S0E").Value;                  listProp.Items[12].Text = xml.Element("S04").Value;                  label2.Text = xml.Element("S0F").Value;                  label1.Text = xml.Element("S10").Value;                  label3.Text = xml.Element("S11").Value;                  btnSetTransparent.Text = xml.Element("S12").Value;                  btnSave.Text = xml.Element("S13").Value;              }              catch { throw new NotSupportedException("There was an error reading the language file"); }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,ReadLanguage,The following statement contains a magic number: try              {                  System.Xml.Linq.XElement xml = System.Xml.Linq.XElement.Load(Application.StartupPath + Path.DirectorySeparatorChar +                      "Plugins" + Path.DirectorySeparatorChar + "3DModelsLang.xml");                  xml = xml.Element(pluginHost.Get_Language()).Element("TextureControl");                    columnProperty.Text = xml.Element("S00").Value;                  columnValue.Text = xml.Element("S01").Value;                  listProp.Items[0].Text = xml.Element("S02").Value;                  listProp.Items[0].SubItems[1].Text = xml.Element("S03").Value;                  listProp.Items[1].Text = xml.Element("S04").Value;                  listProp.Items[2].Text = xml.Element("S05").Value;                  listProp.Items[3].Text = xml.Element("S06").Value;                  listProp.Items[4].Text = xml.Element("S07").Value;                  listProp.Items[5].Text = xml.Element("S08").Value;                  listProp.Items[6].Text = xml.Element("S09").Value;                  listProp.Items[7].Text = xml.Element("S0A").Value;                  listProp.Items[8].Text = xml.Element("S0B").Value;                  listProp.Items[9].Text = xml.Element("S0C").Value;                  listProp.Items[10].Text = xml.Element("S0D").Value;                  listProp.Items[11].Text = xml.Element("S02").Value;                  listProp.Items[11].SubItems[1].Text = xml.Element("S0E").Value;                  listProp.Items[12].Text = xml.Element("S04").Value;                  label2.Text = xml.Element("S0F").Value;                  label1.Text = xml.Element("S10").Value;                  label3.Text = xml.Element("S11").Value;                  btnSetTransparent.Text = xml.Element("S12").Value;                  btnSave.Text = xml.Element("S13").Value;              }              catch { throw new NotSupportedException("There was an error reading the language file"); }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,ReadLanguage,The following statement contains a magic number: try              {                  System.Xml.Linq.XElement xml = System.Xml.Linq.XElement.Load(Application.StartupPath + Path.DirectorySeparatorChar +                      "Plugins" + Path.DirectorySeparatorChar + "3DModelsLang.xml");                  xml = xml.Element(pluginHost.Get_Language()).Element("TextureControl");                    columnProperty.Text = xml.Element("S00").Value;                  columnValue.Text = xml.Element("S01").Value;                  listProp.Items[0].Text = xml.Element("S02").Value;                  listProp.Items[0].SubItems[1].Text = xml.Element("S03").Value;                  listProp.Items[1].Text = xml.Element("S04").Value;                  listProp.Items[2].Text = xml.Element("S05").Value;                  listProp.Items[3].Text = xml.Element("S06").Value;                  listProp.Items[4].Text = xml.Element("S07").Value;                  listProp.Items[5].Text = xml.Element("S08").Value;                  listProp.Items[6].Text = xml.Element("S09").Value;                  listProp.Items[7].Text = xml.Element("S0A").Value;                  listProp.Items[8].Text = xml.Element("S0B").Value;                  listProp.Items[9].Text = xml.Element("S0C").Value;                  listProp.Items[10].Text = xml.Element("S0D").Value;                  listProp.Items[11].Text = xml.Element("S02").Value;                  listProp.Items[11].SubItems[1].Text = xml.Element("S0E").Value;                  listProp.Items[12].Text = xml.Element("S04").Value;                  label2.Text = xml.Element("S0F").Value;                  label1.Text = xml.Element("S10").Value;                  label3.Text = xml.Element("S11").Value;                  btnSetTransparent.Text = xml.Element("S12").Value;                  btnSave.Text = xml.Element("S13").Value;              }              catch { throw new NotSupportedException("There was an error reading the language file"); }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,ReadLanguage,The following statement contains a magic number: try              {                  System.Xml.Linq.XElement xml = System.Xml.Linq.XElement.Load(Application.StartupPath + Path.DirectorySeparatorChar +                      "Plugins" + Path.DirectorySeparatorChar + "3DModelsLang.xml");                  xml = xml.Element(pluginHost.Get_Language()).Element("TextureControl");                    columnProperty.Text = xml.Element("S00").Value;                  columnValue.Text = xml.Element("S01").Value;                  listProp.Items[0].Text = xml.Element("S02").Value;                  listProp.Items[0].SubItems[1].Text = xml.Element("S03").Value;                  listProp.Items[1].Text = xml.Element("S04").Value;                  listProp.Items[2].Text = xml.Element("S05").Value;                  listProp.Items[3].Text = xml.Element("S06").Value;                  listProp.Items[4].Text = xml.Element("S07").Value;                  listProp.Items[5].Text = xml.Element("S08").Value;                  listProp.Items[6].Text = xml.Element("S09").Value;                  listProp.Items[7].Text = xml.Element("S0A").Value;                  listProp.Items[8].Text = xml.Element("S0B").Value;                  listProp.Items[9].Text = xml.Element("S0C").Value;                  listProp.Items[10].Text = xml.Element("S0D").Value;                  listProp.Items[11].Text = xml.Element("S02").Value;                  listProp.Items[11].SubItems[1].Text = xml.Element("S0E").Value;                  listProp.Items[12].Text = xml.Element("S04").Value;                  label2.Text = xml.Element("S0F").Value;                  label1.Text = xml.Element("S10").Value;                  label3.Text = xml.Element("S11").Value;                  btnSetTransparent.Text = xml.Element("S12").Value;                  btnSave.Text = xml.Element("S13").Value;              }              catch { throw new NotSupportedException("There was an error reading the language file"); }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,ReadLanguage,The following statement contains a magic number: try              {                  System.Xml.Linq.XElement xml = System.Xml.Linq.XElement.Load(Application.StartupPath + Path.DirectorySeparatorChar +                      "Plugins" + Path.DirectorySeparatorChar + "3DModelsLang.xml");                  xml = xml.Element(pluginHost.Get_Language()).Element("TextureControl");                    columnProperty.Text = xml.Element("S00").Value;                  columnValue.Text = xml.Element("S01").Value;                  listProp.Items[0].Text = xml.Element("S02").Value;                  listProp.Items[0].SubItems[1].Text = xml.Element("S03").Value;                  listProp.Items[1].Text = xml.Element("S04").Value;                  listProp.Items[2].Text = xml.Element("S05").Value;                  listProp.Items[3].Text = xml.Element("S06").Value;                  listProp.Items[4].Text = xml.Element("S07").Value;                  listProp.Items[5].Text = xml.Element("S08").Value;                  listProp.Items[6].Text = xml.Element("S09").Value;                  listProp.Items[7].Text = xml.Element("S0A").Value;                  listProp.Items[8].Text = xml.Element("S0B").Value;                  listProp.Items[9].Text = xml.Element("S0C").Value;                  listProp.Items[10].Text = xml.Element("S0D").Value;                  listProp.Items[11].Text = xml.Element("S02").Value;                  listProp.Items[11].SubItems[1].Text = xml.Element("S0E").Value;                  listProp.Items[12].Text = xml.Element("S04").Value;                  label2.Text = xml.Element("S0F").Value;                  label1.Text = xml.Element("S10").Value;                  label3.Text = xml.Element("S11").Value;                  btnSetTransparent.Text = xml.Element("S12").Value;                  btnSave.Text = xml.Element("S13").Value;              }              catch { throw new NotSupportedException("There was an error reading the language file"); }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,UpdateTexture,The following statement contains a magic number: if (texInfo.format != 5)                  br.BaseStream.Position = texInfo.tex_offset * 8 + btx0.header.offset[0] + btx0.texture.header.textData_offset;              else                  br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.textCompressedData_offset + texInfo.tex_offset * 8;
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,UpdateTexture,The following statement contains a magic number: if (texInfo.format != 5)                  br.BaseStream.Position = texInfo.tex_offset * 8 + btx0.header.offset[0] + btx0.texture.header.textData_offset;              else                  br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.textCompressedData_offset + texInfo.tex_offset * 8;
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,UpdateTexture,The following statement contains a magic number: if (texInfo.format != 5)                  br.BaseStream.Position = texInfo.tex_offset * 8 + btx0.header.offset[0] + btx0.texture.header.textData_offset;              else                  br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.textCompressedData_offset + texInfo.tex_offset * 8;
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,UpdateTexture,The following statement contains a magic number: Byte[] tile_data = br.ReadBytes((int)(texInfo.width * texInfo.height * texInfo.depth / 8));
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,UpdateTexture,The following statement contains a magic number: br.BaseStream.Position += palInfo.palette_offset * 8;
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_Texture,The following statement contains a magic number: if (info.format == 5)                  return Draw_CompressedTexture(data' info);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_Texture,The following statement contains a magic number: if (info.format == 3) // 16-color 4 bits                  data = Ekona.Helper.BitsConverter.BytesToBit4(data);              else if (info.format == 2) // 4-color 2 bits                  data = Bit8ToBit2(data);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_Texture,The following statement contains a magic number: if (info.format == 3) // 16-color 4 bits                  data = Ekona.Helper.BitsConverter.BytesToBit4(data);              else if (info.format == 2) // 4-color 2 bits                  data = Bit8ToBit2(data);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_Texture,The following statement contains a magic number: for (int h = 0; h < info.height; h++)              {                  for (int w = 0; w < info.width; w++)                  {                      Color color = Color.Black;                      try                      {                          if (info.format == 2 || info.format == 3 || info.format == 4) // 2-4-8 bits per color                              color = palette[data[w + h * info.width]];                          else if (info.format == 1) // A3I5 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x1F;                              int alpha = (data[w + h * info.width] >> 5);                              alpha = ((alpha * 4) + (alpha / 2)) * 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 6) // A5I3 8-bit                          {                              int colorIndex = data[w + h * info.width] & 0x7;                              int alpha = (data[w + h * info.width] >> 3);                              alpha *= 8;                              color = Color.FromArgb(alpha'                                  palette[colorIndex].R'                                  palette[colorIndex].G'                                  palette[colorIndex].B);                          }                          else if (info.format == 7) // Direct texture 16-bit (not tested)                          {                              ushort byteColor = BitConverter.ToUInt16(data' (w + h * info.width) * 2);                              color = Color.FromArgb(                                  (byteColor >> 15) * 255'                                  (byteColor & 0x1F) * 8'                                  ((byteColor >> 5) & 0x1F) * 8'                                  ((byteColor >> 10) & 0x1F) * 8);                          }                      }                      catch { }                        imagen.SetPixel(w' h' color);                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following statement contains a magic number: for (int h = 0; h < info.height; h += 4)              {                  for (int w = 0; w < info.width; w += 4)                  {                      uint texData = BitConverter.ToUInt32(data' w + h * info.width / 4);                        // Get palette data for this block                      ushort pal_info = br.ReadUInt16();                      int pal_offset = pal_info & 0x3FFF;                      int pal_mode = (pal_info >> 14);                        long currPos = br.BaseStream.Position;                      br.BaseStream.Position = btx0.header.offset[0] + btx0.texture.header.paletteData_offset + palInfo.palette_offset * 8;                      br.BaseStream.Position += pal_offset * 4;                      if (br.BaseStream.Position >= br.BaseStream.Length)                          br.BaseStream.Position -= pal_offset * 4;                        Color[] palette = Actions.BGR555ToColor(br.ReadBytes(0x08));                      br.BaseStream.Position = currPos;                        for (int hTex = 0; hTex < 4; hTex++)                      {                          byte texel_row = (byte)((texData >> (hTex * 8)) & 0xFF);                          for (int wTex = 0; wTex < 4; wTex++)                          {                              byte texel = (byte)((texel_row >> (wTex * 2)) & 0x3);                                #region Get color from Texel and mode values                              Color color = Color.Black;                              if (palette.Length < 4 && pal_mode != 1 && pal_mode != 3)                                  goto Draw;                                switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }                              #endregion                            Draw:                              image.SetPixel(                                  w + wTex'                                  h + hTex'                                  color);                          }                      }                  }              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Bit8ToBit2,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  bit2.Add((byte)(data[i] & 0x3));                  bit2.Add((byte)((data[i] >> 2) & 0x3));                  bit2.Add((byte)((data[i] >> 4) & 0x3));                  bit2.Add((byte)((data[i] >> 6) & 0x3));              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Bit8ToBit2,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  bit2.Add((byte)(data[i] & 0x3));                  bit2.Add((byte)((data[i] >> 2) & 0x3));                  bit2.Add((byte)((data[i] >> 4) & 0x3));                  bit2.Add((byte)((data[i] >> 6) & 0x3));              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Bit8ToBit2,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  bit2.Add((byte)(data[i] & 0x3));                  bit2.Add((byte)((data[i] >> 2) & 0x3));                  bit2.Add((byte)((data[i] >> 4) & 0x3));                  bit2.Add((byte)((data[i] >> 6) & 0x3));              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Info,The following statement contains a magic number: for (int i = 1; i < 11; i++)                  if (listProp.Items[i].SubItems.Count > 1)                      listProp.Items[i].SubItems.RemoveAt(1);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Info,The following statement contains a magic number: if (listProp.Items[12].SubItems.Count > 1)                  listProp.Items[12].SubItems.RemoveAt(1);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Info,The following statement contains a magic number: if (listProp.Items[12].SubItems.Count > 1)                  listProp.Items[12].SubItems.RemoveAt(1);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Info,The following statement contains a magic number: listProp.Items[1].SubItems.Add((texInfo.tex_offset * 8).ToString("x"));
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Info,The following statement contains a magic number: listProp.Items[2].SubItems.Add(texInfo.repeat_X.ToString());
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Info,The following statement contains a magic number: listProp.Items[3].SubItems.Add(texInfo.repeat_Y.ToString());
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Info,The following statement contains a magic number: listProp.Items[4].SubItems.Add(texInfo.flip_X.ToString());
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Info,The following statement contains a magic number: listProp.Items[5].SubItems.Add(texInfo.flip_Y.ToString());
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Info,The following statement contains a magic number: listProp.Items[6].SubItems.Add(texInfo.width.ToString());
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Info,The following statement contains a magic number: listProp.Items[7].SubItems.Add(texInfo.height.ToString());
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Info,The following statement contains a magic number: listProp.Items[8].SubItems.Add(texInfo.format.ToString() + " (" + (TextureFormat)texInfo.format + ')');
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Info,The following statement contains a magic number: listProp.Items[9].SubItems.Add(texInfo.color0.ToString());
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Info,The following statement contains a magic number: listProp.Items[10].SubItems.Add(texInfo.coord_transf.ToString() + " (" + (TextureCoordTransf)texInfo.coord_transf + ')');
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Info,The following statement contains a magic number: palOffset *= (texInfo.format == 2 ? 8 : 16);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Info,The following statement contains a magic number: palOffset *= (texInfo.format == 2 ? 8 : 16);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Info,The following statement contains a magic number: palOffset *= (texInfo.format == 2 ? 8 : 16);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Info,The following statement contains a magic number: listProp.Items[12].SubItems.Add(palOffset.ToString("x"));
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,btnSave_Click,The following statement contains a magic number: if (o.ShowDialog() == DialogResult.OK)              {                  if (o.FilterIndex == 2)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Bmp);                  else if (o.FilterIndex == 1)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Png);                  else if (o.FilterIndex == 3)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Jpeg);                  else if (o.FilterIndex == 4)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Tiff);                  else if (o.FilterIndex == 5)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Gif);                  else if (o.FilterIndex == 6)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Icon);              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,btnSave_Click,The following statement contains a magic number: if (o.ShowDialog() == DialogResult.OK)              {                  if (o.FilterIndex == 2)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Bmp);                  else if (o.FilterIndex == 1)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Png);                  else if (o.FilterIndex == 3)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Jpeg);                  else if (o.FilterIndex == 4)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Tiff);                  else if (o.FilterIndex == 5)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Gif);                  else if (o.FilterIndex == 6)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Icon);              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,btnSave_Click,The following statement contains a magic number: if (o.ShowDialog() == DialogResult.OK)              {                  if (o.FilterIndex == 2)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Bmp);                  else if (o.FilterIndex == 1)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Png);                  else if (o.FilterIndex == 3)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Jpeg);                  else if (o.FilterIndex == 4)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Tiff);                  else if (o.FilterIndex == 5)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Gif);                  else if (o.FilterIndex == 6)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Icon);              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,btnSave_Click,The following statement contains a magic number: if (o.ShowDialog() == DialogResult.OK)              {                  if (o.FilterIndex == 2)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Bmp);                  else if (o.FilterIndex == 1)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Png);                  else if (o.FilterIndex == 3)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Jpeg);                  else if (o.FilterIndex == 4)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Tiff);                  else if (o.FilterIndex == 5)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Gif);                  else if (o.FilterIndex == 6)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Icon);              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,btnSave_Click,The following statement contains a magic number: if (o.ShowDialog() == DialogResult.OK)              {                  if (o.FilterIndex == 2)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Bmp);                  else if (o.FilterIndex == 1)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Png);                  else if (o.FilterIndex == 3)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Jpeg);                  else if (o.FilterIndex == 4)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Tiff);                  else if (o.FilterIndex == 5)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Gif);                  else if (o.FilterIndex == 6)                      picTex.Image.Save(o.FileName' System.Drawing.Imaging.ImageFormat.Icon);              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,button1_Click,The following statement contains a magic number: br.BaseStream.Position += palInfo.palette_offset * 8;
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,button1_Click,The following statement contains a magic number: if (o.FilterIndex == 3)              {                  RawPalette p = new RawPalette(palette' false' ColorFormat.colors256);                  p.Get_Image(0).Save(o.FileName' System.Drawing.Imaging.ImageFormat.Png);              }              else if (o.FilterIndex == 1 || o.FilterIndex == 2)              {                  Ekona.Images.Formats.PaletteWin palwin = new Ekona.Images.Formats.PaletteWin(palette);                  if (o.FilterIndex == 1)                      palwin.Gimp_Error = true;                  palwin.Write(o.FileName);              }              else if (o.FilterIndex == 4)              {                  Ekona.Images.Formats.ACO palaco = new Ekona.Images.Formats.ACO(palette);                  palaco.Write(o.FileName);              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,button1_Click,The following statement contains a magic number: if (o.FilterIndex == 3)              {                  RawPalette p = new RawPalette(palette' false' ColorFormat.colors256);                  p.Get_Image(0).Save(o.FileName' System.Drawing.Imaging.ImageFormat.Png);              }              else if (o.FilterIndex == 1 || o.FilterIndex == 2)              {                  Ekona.Images.Formats.PaletteWin palwin = new Ekona.Images.Formats.PaletteWin(palette);                  if (o.FilterIndex == 1)                      palwin.Gimp_Error = true;                  palwin.Write(o.FileName);              }              else if (o.FilterIndex == 4)              {                  Ekona.Images.Formats.ACO palaco = new Ekona.Images.Formats.ACO(palette);                  palaco.Write(o.FileName);              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,button1_Click,The following statement contains a magic number: if (o.FilterIndex == 3)              {                  RawPalette p = new RawPalette(palette' false' ColorFormat.colors256);                  p.Get_Image(0).Save(o.FileName' System.Drawing.Imaging.ImageFormat.Png);              }              else if (o.FilterIndex == 1 || o.FilterIndex == 2)              {                  Ekona.Images.Formats.PaletteWin palwin = new Ekona.Images.Formats.PaletteWin(palette);                  if (o.FilterIndex == 1)                      palwin.Gimp_Error = true;                  palwin.Write(o.FileName);              }              else if (o.FilterIndex == 4)              {                  Ekona.Images.Formats.ACO palaco = new Ekona.Images.Formats.ACO(palette);                  palaco.Write(o.FileName);              }
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.picTex.Size = new System.Drawing.Size(100' 100);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.picTex.Size = new System.Drawing.Size(100' 100);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.picPalette.Location = new System.Drawing.Point(349' 275);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.picPalette.Location = new System.Drawing.Point(349' 275);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.picPalette.Size = new System.Drawing.Size(160' 160);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.picPalette.Size = new System.Drawing.Size(160' 160);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(175' 386);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(175' 386);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(26' 13);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(26' 13);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.label1.TabIndex = 3;
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(175' 259);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(175' 259);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(26' 13);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(26' 13);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 5;
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.listProp.Location = new System.Drawing.Point(0' 259);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.listProp.Size = new System.Drawing.Size(169' 251);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.listProp.Size = new System.Drawing.Size(169' 251);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.listProp.TabIndex = 8;
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.columnProperty.Width = 62;
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.columnValue.Width = 89;
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.btnSetTransparent.Location = new System.Drawing.Point(349' 441);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.btnSetTransparent.Location = new System.Drawing.Point(349' 441);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.btnSetTransparent.Size = new System.Drawing.Size(160' 23);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.btnSetTransparent.Size = new System.Drawing.Size(160' 23);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.btnSetTransparent.TabIndex = 9;
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.listTextures.Location = new System.Drawing.Point(173' 275);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.listTextures.Location = new System.Drawing.Point(173' 275);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.listTextures.Size = new System.Drawing.Size(170' 108);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.listTextures.Size = new System.Drawing.Size(170' 108);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.listTextures.TabIndex = 11;
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.listPalettes.Location = new System.Drawing.Point(174' 401);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.listPalettes.Location = new System.Drawing.Point(174' 401);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.listPalettes.Size = new System.Drawing.Size(169' 108);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.listPalettes.Size = new System.Drawing.Size(169' 108);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.listPalettes.TabIndex = 12;
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.panelTex.Size = new System.Drawing.Size(512' 256);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.panelTex.Size = new System.Drawing.Size(512' 256);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.panelTex.TabIndex = 13;
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.btnSave.Location = new System.Drawing.Point(349' 470);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.btnSave.Location = new System.Drawing.Point(349' 470);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.btnSave.Size = new System.Drawing.Size(77' 37);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.btnSave.Size = new System.Drawing.Size(77' 37);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.btnSave.TabIndex = 2;
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(346' 259);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(346' 259);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(26' 13);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(26' 13);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 14;
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(430' 470);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(430' 470);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(77' 37);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(77' 37);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.button1.TabIndex = 15;
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(512' 512);
Magic Number,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(512' 512);
Duplicate Code,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The method contains a code clone-set at the following line numbers (starting from the method definition): ((24' 56)' (101' 133))
Duplicate Code,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The method contains a code clone-set at the following line numbers (starting from the method definition): ((314' 338)' (352' 376)' (401' 425)' (514' 538))
Duplicate Code,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The method contains a code clone-set at the following line numbers (starting from the method definition): ((314' 346)' (514' 546))
Duplicate Code,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The method contains a code clone-set at the following line numbers (starting from the method definition): ((351' 370)' (400' 419)' (513' 532))
Missing Default,_3DModels,BMD0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BMD0.cs,Read,The following switch statement is missing a default case: switch (cmd)                      {                          case 0x00:  // Padding                              command.size = 0;                              break;                          case 0x01:  // End of bones                              command.size = 0;                              break;                          case 0x02:                              command.size = 2;                              command.parameters = new byte[2];                              command.parameters[0] = br.ReadByte();  // Node ID                              command.parameters[1] = br.ReadByte();  // Visibility                              break;                          case 0x03:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();  // Set Polygon Stack ID?                              break;                          case 0x04:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x05:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x06:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              break;                          case 0x07:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x08:                              command.size = 1;                              command.parameters = new byte[1];                              command.parameters[0] = br.ReadByte();                              break;                          case 0x09:                              command.size = 8;                              command.parameters = new byte[8];                              command.parameters[0] = br.ReadByte();                              command.parameters[1] = br.ReadByte();                              command.parameters[2] = br.ReadByte();                              command.parameters[3] = br.ReadByte();                              command.parameters[4] = br.ReadByte();                              command.parameters[5] = br.ReadByte();                              command.parameters[6] = br.ReadByte();                              command.parameters[7] = br.ReadByte();                              break;                          case 0x0B:                              command.size = 0;   // Begin Polygon/Material pairing                              break;                          case 0x24:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x26:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              break;                          case 0x2B:                              command.size = 0;   // End Polygon/Material Pairing                              break;                          case 0x44:                              command.size = 3;                              command.parameters = new byte[3];                              command.parameters[0] = br.ReadByte();  // Material ID                              command.parameters[1] = br.ReadByte();  // 0x05                              command.parameters[2] = br.ReadByte();  // Polygon ID                              break;                          case 0x46:                              command.size = 4;                              command.parameters = new byte[4];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Restore ID                              break;                          case 0x66:                              command.size = 5;                              command.parameters = new byte[5];                              command.parameters[0] = br.ReadByte();  // Object ID                              command.parameters[1] = br.ReadByte();  // Parent ID                              command.parameters[2] = br.ReadByte();  // Dummy 0                              command.parameters[3] = br.ReadByte();  // Stack ID                              command.parameters[4] = br.ReadByte();  // Restore ID                              break;                      }
Missing Default,_3DModels,BTX0,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\BTX0.cs,Draw_CompressedTexture,The following switch statement is missing a default case: switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }
Missing Default,_3DModels,TextureControl,C:\repos\pleonex_tinke\Plugins\3DModels\3DModels\TextureControl.cs,Draw_CompressedTexture,The following switch statement is missing a default case: switch (pal_mode)                              {                                  case 0:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0);  // Transparent color                                      break;                                    case 1:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 1' 1);                                      else if (texel == 3) color = Color.FromArgb(0' 0' 0' 0); // Transparent color                                      break;                                    case 2:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = palette[2];                                      else if (texel == 3) color = palette[3];                                      break;                                    case 3:                                      if (texel == 0) color = palette[0];                                      else if (texel == 1) color = palette[1];                                      else if (texel == 2) color = SumColors(palette[0]' palette[1]' 5' 3);                                      else if (texel == 3) color = SumColors(palette[0]' palette[1]' 3' 5);                                      break;                              }
