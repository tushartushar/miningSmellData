Implementation smell,Namespace,Class,File,Method,Description
Long Method,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The method has 123 lines of code.
Long Method,DSDecmp,Main,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Main.cs,CompressBest,The method has 62 lines of code.
Long Method,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The method has 148 lines of code.
Long Method,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The method has 81 lines of code.
Long Method,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The method has 130 lines of code.
Long Method,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The method has 117 lines of code.
Long Method,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress8,The method has 113 lines of code.
Long Method,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Decompress,The method has 112 lines of code.
Long Method,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Compress,The method has 75 lines of code.
Long Method,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The method has 174 lines of code.
Long Method,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The method has 94 lines of code.
Long Method,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The method has 78 lines of code.
Long Method,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Decompress,The method has 87 lines of code.
Long Method,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Compress,The method has 96 lines of code.
Complex Method,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,checkLookAhead_CheckedChanged,Cyclomatic complexity of the method is 9
Complex Method,DSDecmp,Main,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Main.cs,Get_Format,Cyclomatic complexity of the method is 14
Complex Method,DSDecmp,Main,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Main.cs,Get_Format,Cyclomatic complexity of the method is 15
Complex Method,DSDecmp,Main,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Main.cs,DoCompress,Cyclomatic complexity of the method is 28
Complex Method,DSDecmp,Main,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Main.cs,CompressBest,Cyclomatic complexity of the method is 29
Complex Method,DSDecmp,Main,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Main.cs,Decompress,Cyclomatic complexity of the method is 10
Complex Method,DSDecmp,Main,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Main.cs,Decompress,Cyclomatic complexity of the method is 8
Complex Method,DSDecmp,Main,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Main.cs,Decompress,Cyclomatic complexity of the method is 18
Complex Method,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,Cyclomatic complexity of the method is 13
Complex Method,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionLengths,Cyclomatic complexity of the method is 8
Complex Method,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionPartLength,Cyclomatic complexity of the method is 7
Complex Method,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,Cyclomatic complexity of the method is 20
Complex Method,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,Cyclomatic complexity of the method is 17
Complex Method,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress8,Cyclomatic complexity of the method is 17
Complex Method,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Decompress,Cyclomatic complexity of the method is 17
Complex Method,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,GetOptimalCompressionLengths,Cyclomatic complexity of the method is 7
Complex Method,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,Cyclomatic complexity of the method is 24
Complex Method,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,GetOptimalCompressionLengths,Cyclomatic complexity of the method is 9
Complex Method,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Decompress,Cyclomatic complexity of the method is 17
Complex Method,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Compress,Cyclomatic complexity of the method is 22
Long Parameter List,DSDecmp,Main,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Main.cs,DoCompress,The method has 4 parameters.
Long Parameter List,DSDecmp,Main,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Main.cs,CompressBest,The method has 4 parameters.
Long Parameter List,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionLengths,The method has 4 parameters.
Long Parameter List,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,GetOptimalCompressionLengths,The method has 4 parameters.
Long Parameter List,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,GetOptimalCompressionLengths,The method has 4 parameters.
Long Parameter List,DSDecmp.Utils,LZUtil,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Utils\LZUtil.cs,GetOccurrenceLength,The method has 5 parameters.
Long Statement,DSDecmp,Main,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Main.cs,CompressGBA,The length of the statement  "	return CompressBest (infile' output' out actualFormat' FormatCompress.HUFF4' FormatCompress.HUFF8' FormatCompress.LZ10' FormatCompress.RLE); " is 140.
Long Statement,DSDecmp,Main,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Main.cs,CompressNDS,The length of the statement  "	return CompressBest (infile' output' out actualFormat' FormatCompress.HUFF4' FormatCompress.HUFF8' FormatCompress.LZ10' FormatCompress.LZ11' FormatCompress.RLE); " is 161.
Long Statement,DSDecmp,Main,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Main.cs,Get_Traduction,The length of the statement  "		XElement xml = XElement.Load (System.Windows.Forms.Application.StartupPath + Path.DirectorySeparatorChar + "Tinke.xml"); " is 120.
Long Statement,DSDecmp,Main,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Main.cs,Get_Traduction,The length of the statement  "		foreach (string langFile in Directory.GetFiles (System.Windows.Forms.Application.StartupPath + Path.DirectorySeparatorChar + "langs")) { " is 136.
Long Statement,DSDecmp,Main,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Main.cs,Get_Traduction,The length of the statement  "		XElement xml = XElement.Load (System.Windows.Forms.Application.StartupPath + Path.DirectorySeparatorChar + "Tinke.xml"); " is 120.
Long Statement,DSDecmp,Main,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Main.cs,Get_Traduction,The length of the statement  "		foreach (string langFile in Directory.GetFiles (System.Windows.Forms.Application.StartupPath + Path.DirectorySeparatorChar + "langs")) { " is 136.
Long Statement,DSDecmp,IOUtils,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Utils\IOUtils.cs,ToNDSu32,The length of the statement  "	return (uint)(buffer [offset] | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24)); " is 120.
Long Statement,DSDecmp.Formats,CompressionFormat,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\CompressionFormat.cs,Decompress,The length of the statement  "	using (FileStream inStream = new FileStream (infile' FileMode.Open)' outStream = new FileStream (outfile' FileMode.Create)) { " is 125.
Long Statement,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The length of the statement  "	using (FileStream inStream = new FileStream (infile' FileMode.Open)' outStream = new FileStream (outfile' FileMode.Create)) { " is 125.
Long Statement,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The length of the statement  "						throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X"))); " is 129.
Long Statement,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The length of the statement  "			int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp); " is 160.
Long Statement,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionLengths,The length of the statement  "		int maxLen = LZUtil.GetOccurrenceLength (indata + i' Math.Min (inLength - i' 0x12)' indata + i - oldLength' oldLength' out disps [i]); " is 134.
Long Statement,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The length of the statement  "	// use a breadth-first traversal to store the tree' such that we do not need to store/calculate the side of each sub-tree. " is 122.
Long Statement,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress8,The length of the statement  "	// use a breadth-first traversal to store the tree' such that we do not need to store/calculate the side of each sub-tree. " is 122.
Long Statement,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Decompress,The length of the statement  "				throw new InvalidDataException (String.Format (Main.Get_Traduction ("S01")' disp.ToString ("X")' currentOutSize.ToString ("X")' (instream.Position - 2).ToString ("X"))); " is 169.
Long Statement,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Compress,The length of the statement  "			int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp); " is 160.
Long Statement,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,GetOptimalCompressionLengths,The length of the statement  "		int maxLen = LZUtil.GetOccurrenceLength (indata + i' Math.Min (inLength - i' 0x12)' indata + i - oldLength' oldLength' out disps [i]); " is 134.
Long Statement,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The length of the statement  "				throw new InvalidDataException (String.Format (Main.Get_Traduction ("S04")' disp' currentOutSize.ToString ("X")' instream.Position.ToString ("X")' (byte1 >> 4).ToString ("X"))); " is 177.
Long Statement,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The length of the statement  "			int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x10110)' instart + readBytes - oldLength' oldLength' out disp); " is 163.
Long Statement,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,GetOptimalCompressionLengths,The length of the statement  "		int maxLen = LZUtil.GetOccurrenceLength (indata + i' Math.Min (inLength - i' 0x10110)' indata + i - oldLength' oldLength' out disps [i]); " is 137.
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.checkLookAhead.Location = new System.Drawing.Point (146' 97);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.checkLookAhead.Location = new System.Drawing.Point (146' 97);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.checkLookAhead.Size = new System.Drawing.Size (45' 17);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.checkLookAhead.Size = new System.Drawing.Size (45' 17);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.comboFormat.Location = new System.Drawing.Point (9' 93);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.comboFormat.Location = new System.Drawing.Point (9' 93);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.comboFormat.Size = new System.Drawing.Size (121' 21);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.comboFormat.Size = new System.Drawing.Size (121' 21);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.btnSearchCompression.Location = new System.Drawing.Point (124' 156);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.btnSearchCompression.Location = new System.Drawing.Point (124' 156);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.btnSearchCompression.Size = new System.Drawing.Size (100' 40);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.btnSearchCompression.Size = new System.Drawing.Size (100' 40);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.btnSearchCompression.TabIndex = 2;  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.btnCompress.Location = new System.Drawing.Point (9' 156);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.btnCompress.Location = new System.Drawing.Point (9' 156);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.btnCompress.Size = new System.Drawing.Size (90' 40);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.btnCompress.Size = new System.Drawing.Size (90' 40);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.btnCompress.TabIndex = 3;  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point (6' 77);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point (6' 77);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size (26' 13);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size (26' 13);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.label1.TabIndex = 4;  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point (6' 11);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point (6' 11);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size (26' 13);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size (26' 13);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 5;  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.txtBoxOlderCompress.Location = new System.Drawing.Point (9' 27);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.txtBoxOlderCompress.Location = new System.Drawing.Point (9' 27);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.txtBoxOlderCompress.Size = new System.Drawing.Size (100' 20);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.txtBoxOlderCompress.Size = new System.Drawing.Size (100' 20);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.txtBoxOlderCompress.TabIndex = 6;  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.txtBoxNewCompress.Location = new System.Drawing.Point (253' 27);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.txtBoxNewCompress.Location = new System.Drawing.Point (253' 27);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.txtBoxNewCompress.Size = new System.Drawing.Size (100' 20);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.txtBoxNewCompress.Size = new System.Drawing.Size (100' 20);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.txtBoxNewCompress.TabIndex = 7;  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point (253' 8);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point (253' 8);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size (26' 13);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size (26' 13);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 8;  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size (512' 512);  
Magic Number,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size (512' 512);  
Magic Number,DSDecmp,IOUtils,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Utils\IOUtils.cs,ToNDSu32,The following statement contains a magic number: return (uint)(buffer [offset] | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,DSDecmp,IOUtils,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Utils\IOUtils.cs,ToNDSu32,The following statement contains a magic number: return (uint)(buffer [offset] | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,DSDecmp,IOUtils,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Utils\IOUtils.cs,ToNDSu32,The following statement contains a magic number: return (uint)(buffer [offset] | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,DSDecmp,IOUtils,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Utils\IOUtils.cs,ToNDSu32,The following statement contains a magic number: return (uint)(buffer [offset] | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,DSDecmp,IOUtils,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Utils\IOUtils.cs,ToNDSu32,The following statement contains a magic number: return (uint)(buffer [offset] | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,DSDecmp,IOUtils,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Utils\IOUtils.cs,ToNDSs32,The following statement contains a magic number: return (int)(buffer [offset] | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,DSDecmp,IOUtils,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Utils\IOUtils.cs,ToNDSs32,The following statement contains a magic number: return (int)(buffer [offset] | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,DSDecmp,IOUtils,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Utils\IOUtils.cs,ToNDSs32,The following statement contains a magic number: return (int)(buffer [offset] | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,DSDecmp,IOUtils,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Utils\IOUtils.cs,ToNDSs32,The following statement contains a magic number: return (int)(buffer [offset] | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,DSDecmp,IOUtils,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Utils\IOUtils.cs,ToNDSs32,The following statement contains a magic number: return (int)(buffer [offset] | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,DSDecmp,IOUtils,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Utils\IOUtils.cs,FromNDSu32,The following statement contains a magic number: return new byte[] {  	(byte)(value & 0xFF)'  	(byte)((value >> 8) & 0xFF)'  	(byte)((value >> 16) & 0xFF)'  	(byte)((value >> 24) & 0xFF)  };  
Magic Number,DSDecmp,IOUtils,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Utils\IOUtils.cs,FromNDSu32,The following statement contains a magic number: return new byte[] {  	(byte)(value & 0xFF)'  	(byte)((value >> 8) & 0xFF)'  	(byte)((value >> 16) & 0xFF)'  	(byte)((value >> 24) & 0xFF)  };  
Magic Number,DSDecmp,IOUtils,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Utils\IOUtils.cs,FromNDSu32,The following statement contains a magic number: return new byte[] {  	(byte)(value & 0xFF)'  	(byte)((value >> 8) & 0xFF)'  	(byte)((value >> 16) & 0xFF)'  	(byte)((value >> 24) & 0xFF)  };  
Magic Number,DSDecmp,IOUtils,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Utils\IOUtils.cs,ToNDSu24,The following statement contains a magic number: return (int)(buffer [offset] | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16));  
Magic Number,DSDecmp,IOUtils,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Utils\IOUtils.cs,ToNDSu24,The following statement contains a magic number: return (int)(buffer [offset] | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16));  
Magic Number,DSDecmp,IOUtils,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Utils\IOUtils.cs,ToNDSu24,The following statement contains a magic number: return (int)(buffer [offset] | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16));  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Supports,The following statement contains a magic number: if (inLength < 4)  	return false;  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Supports,The following statement contains a magic number: if (header.Length < 8)  	return false;  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Supports,The following statement contains a magic number: for (int i = header.Length - 9; i >= header.Length - headerLen; i--)  	if (header [i] != 0xFF)  		return false;  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: instream.Position += inLength - 4;  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: try {  	instream.Read (buffer' 0' 4);  } catch (System.IO.EndOfStreamException) {  	// since we're immediately checking the end of the stream'   	// this is the only location where we have to check for an EOS to occur.  	throw new StreamTooShortException ();  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: instream.Read (buffer' 0' 4);  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: if (extraSize == 0) {  	#region just copy the input to the output  	// first go back to the start of the file. the current location is after the 'extraSize''  	// and thus at the end of the file.  	instream.Position -= inLength;  	// no buffering -> slow  	buffer = new byte[inLength - 4];  	instream.Read (buffer' 0' (int)(inLength - 4));  	outstream.Write (buffer' 0' (int)(inLength - 4));  	// make sure the input is positioned at the end of the file  	instream.Position += 4;  	return inLength - 4;  	#endregion  } else {  	// get the size of the compression header first.  	instream.Position -= 5;  	int headerSize = instream.ReadByte ();  	// then the compressed data size.  	instream.Position -= 4;  	instream.Read (buffer' 0' 3);  	int compressedSize = buffer [0] | (buffer [1] << 8) | (buffer [2] << 16);  	// the compressed size sometimes is the file size.  	if (compressedSize + headerSize >= inLength)  		compressedSize = (int)(inLength - headerSize);  	#region copy the non-compressed data  	// copy the non-compressed data first.  	buffer = new byte[inLength - headerSize - compressedSize];  	instream.Position -= (inLength - 5);  	instream.Read (buffer' 0' buffer.Length);  	outstream.Write (buffer' 0' buffer.Length);  	#endregion  	// buffer the compressed data' such that we don't need to keep  	// moving the input stream position back and forth  	buffer = new byte[compressedSize];  	instream.Read (buffer' 0' compressedSize);  	// we're filling the output from end to start' so we can't directly write the data.  	// buffer it instead (also use this data as buffer instead of a ring-buffer for  	// decompression)  	byte[] outbuffer = new byte[compressedSize + headerSize + extraSize];  	int currentOutSize = 0;  	int decompressedLength = outbuffer.Length;  	int readBytes = 0;  	byte flags = 0' mask = 1;  	while (currentOutSize < decompressedLength) {  		// (throws when requested new flags byte is not available)  		#region Update the mask. If all flag bits have been read' get a new set.  		// the current mask is the mask used in the previous run. So if it masks the  		// last flag bit' get a new flags byte.  		if (mask == 1) {  			if (readBytes >= compressedSize)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			flags = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			mask = 0x80;  		} else {  			mask >>= 1;  		}  		#endregion  		// bit = 1 <=> compressed.  		if ((flags & mask) > 0) {  			// (throws when < 2 bytes are available)  			#region Get length and displacement('disp') values from next 2 bytes  			// there are < 2 bytes available when the end is at most 1 byte away  			if (readBytes + 1 >= inLength) {  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			}  			int byte1 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			int byte2 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			// the number of bytes to copy  			int length = byte1 >> 4;  			length += 3;  			// from where the bytes should be copied (relatively)  			int disp = ((byte1 & 0x0F) << 8) | byte2;  			disp += 3;  			if (disp > currentOutSize) {  				if (currentOutSize < 2)  					throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  				// HACK. this seems to produce valid files' but isn't the most elegant solution.  				// although this _could_ be the actual way to use a disp of 2 in this format'  				// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  				disp = 2;  			}  			#endregion  			int bufIdx = currentOutSize - disp;  			for (int i = 0; i < length; i++) {  				byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  				bufIdx++;  				outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  				currentOutSize++;  			}  		} else {  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			byte next = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  			currentOutSize++;  		}  	}  	// write the decompressed data  	outstream.Write (outbuffer' 0' outbuffer.Length);  	// make sure the input is positioned at the end of the file; the stream is currently  	// at the compression header.  	instream.Position += headerSize;  	return decompressedLength + (inLength - headerSize - compressedSize);  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: if (extraSize == 0) {  	#region just copy the input to the output  	// first go back to the start of the file. the current location is after the 'extraSize''  	// and thus at the end of the file.  	instream.Position -= inLength;  	// no buffering -> slow  	buffer = new byte[inLength - 4];  	instream.Read (buffer' 0' (int)(inLength - 4));  	outstream.Write (buffer' 0' (int)(inLength - 4));  	// make sure the input is positioned at the end of the file  	instream.Position += 4;  	return inLength - 4;  	#endregion  } else {  	// get the size of the compression header first.  	instream.Position -= 5;  	int headerSize = instream.ReadByte ();  	// then the compressed data size.  	instream.Position -= 4;  	instream.Read (buffer' 0' 3);  	int compressedSize = buffer [0] | (buffer [1] << 8) | (buffer [2] << 16);  	// the compressed size sometimes is the file size.  	if (compressedSize + headerSize >= inLength)  		compressedSize = (int)(inLength - headerSize);  	#region copy the non-compressed data  	// copy the non-compressed data first.  	buffer = new byte[inLength - headerSize - compressedSize];  	instream.Position -= (inLength - 5);  	instream.Read (buffer' 0' buffer.Length);  	outstream.Write (buffer' 0' buffer.Length);  	#endregion  	// buffer the compressed data' such that we don't need to keep  	// moving the input stream position back and forth  	buffer = new byte[compressedSize];  	instream.Read (buffer' 0' compressedSize);  	// we're filling the output from end to start' so we can't directly write the data.  	// buffer it instead (also use this data as buffer instead of a ring-buffer for  	// decompression)  	byte[] outbuffer = new byte[compressedSize + headerSize + extraSize];  	int currentOutSize = 0;  	int decompressedLength = outbuffer.Length;  	int readBytes = 0;  	byte flags = 0' mask = 1;  	while (currentOutSize < decompressedLength) {  		// (throws when requested new flags byte is not available)  		#region Update the mask. If all flag bits have been read' get a new set.  		// the current mask is the mask used in the previous run. So if it masks the  		// last flag bit' get a new flags byte.  		if (mask == 1) {  			if (readBytes >= compressedSize)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			flags = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			mask = 0x80;  		} else {  			mask >>= 1;  		}  		#endregion  		// bit = 1 <=> compressed.  		if ((flags & mask) > 0) {  			// (throws when < 2 bytes are available)  			#region Get length and displacement('disp') values from next 2 bytes  			// there are < 2 bytes available when the end is at most 1 byte away  			if (readBytes + 1 >= inLength) {  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			}  			int byte1 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			int byte2 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			// the number of bytes to copy  			int length = byte1 >> 4;  			length += 3;  			// from where the bytes should be copied (relatively)  			int disp = ((byte1 & 0x0F) << 8) | byte2;  			disp += 3;  			if (disp > currentOutSize) {  				if (currentOutSize < 2)  					throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  				// HACK. this seems to produce valid files' but isn't the most elegant solution.  				// although this _could_ be the actual way to use a disp of 2 in this format'  				// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  				disp = 2;  			}  			#endregion  			int bufIdx = currentOutSize - disp;  			for (int i = 0; i < length; i++) {  				byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  				bufIdx++;  				outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  				currentOutSize++;  			}  		} else {  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			byte next = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  			currentOutSize++;  		}  	}  	// write the decompressed data  	outstream.Write (outbuffer' 0' outbuffer.Length);  	// make sure the input is positioned at the end of the file; the stream is currently  	// at the compression header.  	instream.Position += headerSize;  	return decompressedLength + (inLength - headerSize - compressedSize);  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: if (extraSize == 0) {  	#region just copy the input to the output  	// first go back to the start of the file. the current location is after the 'extraSize''  	// and thus at the end of the file.  	instream.Position -= inLength;  	// no buffering -> slow  	buffer = new byte[inLength - 4];  	instream.Read (buffer' 0' (int)(inLength - 4));  	outstream.Write (buffer' 0' (int)(inLength - 4));  	// make sure the input is positioned at the end of the file  	instream.Position += 4;  	return inLength - 4;  	#endregion  } else {  	// get the size of the compression header first.  	instream.Position -= 5;  	int headerSize = instream.ReadByte ();  	// then the compressed data size.  	instream.Position -= 4;  	instream.Read (buffer' 0' 3);  	int compressedSize = buffer [0] | (buffer [1] << 8) | (buffer [2] << 16);  	// the compressed size sometimes is the file size.  	if (compressedSize + headerSize >= inLength)  		compressedSize = (int)(inLength - headerSize);  	#region copy the non-compressed data  	// copy the non-compressed data first.  	buffer = new byte[inLength - headerSize - compressedSize];  	instream.Position -= (inLength - 5);  	instream.Read (buffer' 0' buffer.Length);  	outstream.Write (buffer' 0' buffer.Length);  	#endregion  	// buffer the compressed data' such that we don't need to keep  	// moving the input stream position back and forth  	buffer = new byte[compressedSize];  	instream.Read (buffer' 0' compressedSize);  	// we're filling the output from end to start' so we can't directly write the data.  	// buffer it instead (also use this data as buffer instead of a ring-buffer for  	// decompression)  	byte[] outbuffer = new byte[compressedSize + headerSize + extraSize];  	int currentOutSize = 0;  	int decompressedLength = outbuffer.Length;  	int readBytes = 0;  	byte flags = 0' mask = 1;  	while (currentOutSize < decompressedLength) {  		// (throws when requested new flags byte is not available)  		#region Update the mask. If all flag bits have been read' get a new set.  		// the current mask is the mask used in the previous run. So if it masks the  		// last flag bit' get a new flags byte.  		if (mask == 1) {  			if (readBytes >= compressedSize)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			flags = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			mask = 0x80;  		} else {  			mask >>= 1;  		}  		#endregion  		// bit = 1 <=> compressed.  		if ((flags & mask) > 0) {  			// (throws when < 2 bytes are available)  			#region Get length and displacement('disp') values from next 2 bytes  			// there are < 2 bytes available when the end is at most 1 byte away  			if (readBytes + 1 >= inLength) {  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			}  			int byte1 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			int byte2 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			// the number of bytes to copy  			int length = byte1 >> 4;  			length += 3;  			// from where the bytes should be copied (relatively)  			int disp = ((byte1 & 0x0F) << 8) | byte2;  			disp += 3;  			if (disp > currentOutSize) {  				if (currentOutSize < 2)  					throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  				// HACK. this seems to produce valid files' but isn't the most elegant solution.  				// although this _could_ be the actual way to use a disp of 2 in this format'  				// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  				disp = 2;  			}  			#endregion  			int bufIdx = currentOutSize - disp;  			for (int i = 0; i < length; i++) {  				byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  				bufIdx++;  				outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  				currentOutSize++;  			}  		} else {  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			byte next = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  			currentOutSize++;  		}  	}  	// write the decompressed data  	outstream.Write (outbuffer' 0' outbuffer.Length);  	// make sure the input is positioned at the end of the file; the stream is currently  	// at the compression header.  	instream.Position += headerSize;  	return decompressedLength + (inLength - headerSize - compressedSize);  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: if (extraSize == 0) {  	#region just copy the input to the output  	// first go back to the start of the file. the current location is after the 'extraSize''  	// and thus at the end of the file.  	instream.Position -= inLength;  	// no buffering -> slow  	buffer = new byte[inLength - 4];  	instream.Read (buffer' 0' (int)(inLength - 4));  	outstream.Write (buffer' 0' (int)(inLength - 4));  	// make sure the input is positioned at the end of the file  	instream.Position += 4;  	return inLength - 4;  	#endregion  } else {  	// get the size of the compression header first.  	instream.Position -= 5;  	int headerSize = instream.ReadByte ();  	// then the compressed data size.  	instream.Position -= 4;  	instream.Read (buffer' 0' 3);  	int compressedSize = buffer [0] | (buffer [1] << 8) | (buffer [2] << 16);  	// the compressed size sometimes is the file size.  	if (compressedSize + headerSize >= inLength)  		compressedSize = (int)(inLength - headerSize);  	#region copy the non-compressed data  	// copy the non-compressed data first.  	buffer = new byte[inLength - headerSize - compressedSize];  	instream.Position -= (inLength - 5);  	instream.Read (buffer' 0' buffer.Length);  	outstream.Write (buffer' 0' buffer.Length);  	#endregion  	// buffer the compressed data' such that we don't need to keep  	// moving the input stream position back and forth  	buffer = new byte[compressedSize];  	instream.Read (buffer' 0' compressedSize);  	// we're filling the output from end to start' so we can't directly write the data.  	// buffer it instead (also use this data as buffer instead of a ring-buffer for  	// decompression)  	byte[] outbuffer = new byte[compressedSize + headerSize + extraSize];  	int currentOutSize = 0;  	int decompressedLength = outbuffer.Length;  	int readBytes = 0;  	byte flags = 0' mask = 1;  	while (currentOutSize < decompressedLength) {  		// (throws when requested new flags byte is not available)  		#region Update the mask. If all flag bits have been read' get a new set.  		// the current mask is the mask used in the previous run. So if it masks the  		// last flag bit' get a new flags byte.  		if (mask == 1) {  			if (readBytes >= compressedSize)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			flags = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			mask = 0x80;  		} else {  			mask >>= 1;  		}  		#endregion  		// bit = 1 <=> compressed.  		if ((flags & mask) > 0) {  			// (throws when < 2 bytes are available)  			#region Get length and displacement('disp') values from next 2 bytes  			// there are < 2 bytes available when the end is at most 1 byte away  			if (readBytes + 1 >= inLength) {  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			}  			int byte1 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			int byte2 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			// the number of bytes to copy  			int length = byte1 >> 4;  			length += 3;  			// from where the bytes should be copied (relatively)  			int disp = ((byte1 & 0x0F) << 8) | byte2;  			disp += 3;  			if (disp > currentOutSize) {  				if (currentOutSize < 2)  					throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  				// HACK. this seems to produce valid files' but isn't the most elegant solution.  				// although this _could_ be the actual way to use a disp of 2 in this format'  				// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  				disp = 2;  			}  			#endregion  			int bufIdx = currentOutSize - disp;  			for (int i = 0; i < length; i++) {  				byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  				bufIdx++;  				outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  				currentOutSize++;  			}  		} else {  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			byte next = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  			currentOutSize++;  		}  	}  	// write the decompressed data  	outstream.Write (outbuffer' 0' outbuffer.Length);  	// make sure the input is positioned at the end of the file; the stream is currently  	// at the compression header.  	instream.Position += headerSize;  	return decompressedLength + (inLength - headerSize - compressedSize);  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: if (extraSize == 0) {  	#region just copy the input to the output  	// first go back to the start of the file. the current location is after the 'extraSize''  	// and thus at the end of the file.  	instream.Position -= inLength;  	// no buffering -> slow  	buffer = new byte[inLength - 4];  	instream.Read (buffer' 0' (int)(inLength - 4));  	outstream.Write (buffer' 0' (int)(inLength - 4));  	// make sure the input is positioned at the end of the file  	instream.Position += 4;  	return inLength - 4;  	#endregion  } else {  	// get the size of the compression header first.  	instream.Position -= 5;  	int headerSize = instream.ReadByte ();  	// then the compressed data size.  	instream.Position -= 4;  	instream.Read (buffer' 0' 3);  	int compressedSize = buffer [0] | (buffer [1] << 8) | (buffer [2] << 16);  	// the compressed size sometimes is the file size.  	if (compressedSize + headerSize >= inLength)  		compressedSize = (int)(inLength - headerSize);  	#region copy the non-compressed data  	// copy the non-compressed data first.  	buffer = new byte[inLength - headerSize - compressedSize];  	instream.Position -= (inLength - 5);  	instream.Read (buffer' 0' buffer.Length);  	outstream.Write (buffer' 0' buffer.Length);  	#endregion  	// buffer the compressed data' such that we don't need to keep  	// moving the input stream position back and forth  	buffer = new byte[compressedSize];  	instream.Read (buffer' 0' compressedSize);  	// we're filling the output from end to start' so we can't directly write the data.  	// buffer it instead (also use this data as buffer instead of a ring-buffer for  	// decompression)  	byte[] outbuffer = new byte[compressedSize + headerSize + extraSize];  	int currentOutSize = 0;  	int decompressedLength = outbuffer.Length;  	int readBytes = 0;  	byte flags = 0' mask = 1;  	while (currentOutSize < decompressedLength) {  		// (throws when requested new flags byte is not available)  		#region Update the mask. If all flag bits have been read' get a new set.  		// the current mask is the mask used in the previous run. So if it masks the  		// last flag bit' get a new flags byte.  		if (mask == 1) {  			if (readBytes >= compressedSize)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			flags = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			mask = 0x80;  		} else {  			mask >>= 1;  		}  		#endregion  		// bit = 1 <=> compressed.  		if ((flags & mask) > 0) {  			// (throws when < 2 bytes are available)  			#region Get length and displacement('disp') values from next 2 bytes  			// there are < 2 bytes available when the end is at most 1 byte away  			if (readBytes + 1 >= inLength) {  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			}  			int byte1 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			int byte2 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			// the number of bytes to copy  			int length = byte1 >> 4;  			length += 3;  			// from where the bytes should be copied (relatively)  			int disp = ((byte1 & 0x0F) << 8) | byte2;  			disp += 3;  			if (disp > currentOutSize) {  				if (currentOutSize < 2)  					throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  				// HACK. this seems to produce valid files' but isn't the most elegant solution.  				// although this _could_ be the actual way to use a disp of 2 in this format'  				// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  				disp = 2;  			}  			#endregion  			int bufIdx = currentOutSize - disp;  			for (int i = 0; i < length; i++) {  				byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  				bufIdx++;  				outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  				currentOutSize++;  			}  		} else {  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			byte next = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  			currentOutSize++;  		}  	}  	// write the decompressed data  	outstream.Write (outbuffer' 0' outbuffer.Length);  	// make sure the input is positioned at the end of the file; the stream is currently  	// at the compression header.  	instream.Position += headerSize;  	return decompressedLength + (inLength - headerSize - compressedSize);  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: if (extraSize == 0) {  	#region just copy the input to the output  	// first go back to the start of the file. the current location is after the 'extraSize''  	// and thus at the end of the file.  	instream.Position -= inLength;  	// no buffering -> slow  	buffer = new byte[inLength - 4];  	instream.Read (buffer' 0' (int)(inLength - 4));  	outstream.Write (buffer' 0' (int)(inLength - 4));  	// make sure the input is positioned at the end of the file  	instream.Position += 4;  	return inLength - 4;  	#endregion  } else {  	// get the size of the compression header first.  	instream.Position -= 5;  	int headerSize = instream.ReadByte ();  	// then the compressed data size.  	instream.Position -= 4;  	instream.Read (buffer' 0' 3);  	int compressedSize = buffer [0] | (buffer [1] << 8) | (buffer [2] << 16);  	// the compressed size sometimes is the file size.  	if (compressedSize + headerSize >= inLength)  		compressedSize = (int)(inLength - headerSize);  	#region copy the non-compressed data  	// copy the non-compressed data first.  	buffer = new byte[inLength - headerSize - compressedSize];  	instream.Position -= (inLength - 5);  	instream.Read (buffer' 0' buffer.Length);  	outstream.Write (buffer' 0' buffer.Length);  	#endregion  	// buffer the compressed data' such that we don't need to keep  	// moving the input stream position back and forth  	buffer = new byte[compressedSize];  	instream.Read (buffer' 0' compressedSize);  	// we're filling the output from end to start' so we can't directly write the data.  	// buffer it instead (also use this data as buffer instead of a ring-buffer for  	// decompression)  	byte[] outbuffer = new byte[compressedSize + headerSize + extraSize];  	int currentOutSize = 0;  	int decompressedLength = outbuffer.Length;  	int readBytes = 0;  	byte flags = 0' mask = 1;  	while (currentOutSize < decompressedLength) {  		// (throws when requested new flags byte is not available)  		#region Update the mask. If all flag bits have been read' get a new set.  		// the current mask is the mask used in the previous run. So if it masks the  		// last flag bit' get a new flags byte.  		if (mask == 1) {  			if (readBytes >= compressedSize)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			flags = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			mask = 0x80;  		} else {  			mask >>= 1;  		}  		#endregion  		// bit = 1 <=> compressed.  		if ((flags & mask) > 0) {  			// (throws when < 2 bytes are available)  			#region Get length and displacement('disp') values from next 2 bytes  			// there are < 2 bytes available when the end is at most 1 byte away  			if (readBytes + 1 >= inLength) {  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			}  			int byte1 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			int byte2 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			// the number of bytes to copy  			int length = byte1 >> 4;  			length += 3;  			// from where the bytes should be copied (relatively)  			int disp = ((byte1 & 0x0F) << 8) | byte2;  			disp += 3;  			if (disp > currentOutSize) {  				if (currentOutSize < 2)  					throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  				// HACK. this seems to produce valid files' but isn't the most elegant solution.  				// although this _could_ be the actual way to use a disp of 2 in this format'  				// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  				disp = 2;  			}  			#endregion  			int bufIdx = currentOutSize - disp;  			for (int i = 0; i < length; i++) {  				byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  				bufIdx++;  				outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  				currentOutSize++;  			}  		} else {  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			byte next = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  			currentOutSize++;  		}  	}  	// write the decompressed data  	outstream.Write (outbuffer' 0' outbuffer.Length);  	// make sure the input is positioned at the end of the file; the stream is currently  	// at the compression header.  	instream.Position += headerSize;  	return decompressedLength + (inLength - headerSize - compressedSize);  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: if (extraSize == 0) {  	#region just copy the input to the output  	// first go back to the start of the file. the current location is after the 'extraSize''  	// and thus at the end of the file.  	instream.Position -= inLength;  	// no buffering -> slow  	buffer = new byte[inLength - 4];  	instream.Read (buffer' 0' (int)(inLength - 4));  	outstream.Write (buffer' 0' (int)(inLength - 4));  	// make sure the input is positioned at the end of the file  	instream.Position += 4;  	return inLength - 4;  	#endregion  } else {  	// get the size of the compression header first.  	instream.Position -= 5;  	int headerSize = instream.ReadByte ();  	// then the compressed data size.  	instream.Position -= 4;  	instream.Read (buffer' 0' 3);  	int compressedSize = buffer [0] | (buffer [1] << 8) | (buffer [2] << 16);  	// the compressed size sometimes is the file size.  	if (compressedSize + headerSize >= inLength)  		compressedSize = (int)(inLength - headerSize);  	#region copy the non-compressed data  	// copy the non-compressed data first.  	buffer = new byte[inLength - headerSize - compressedSize];  	instream.Position -= (inLength - 5);  	instream.Read (buffer' 0' buffer.Length);  	outstream.Write (buffer' 0' buffer.Length);  	#endregion  	// buffer the compressed data' such that we don't need to keep  	// moving the input stream position back and forth  	buffer = new byte[compressedSize];  	instream.Read (buffer' 0' compressedSize);  	// we're filling the output from end to start' so we can't directly write the data.  	// buffer it instead (also use this data as buffer instead of a ring-buffer for  	// decompression)  	byte[] outbuffer = new byte[compressedSize + headerSize + extraSize];  	int currentOutSize = 0;  	int decompressedLength = outbuffer.Length;  	int readBytes = 0;  	byte flags = 0' mask = 1;  	while (currentOutSize < decompressedLength) {  		// (throws when requested new flags byte is not available)  		#region Update the mask. If all flag bits have been read' get a new set.  		// the current mask is the mask used in the previous run. So if it masks the  		// last flag bit' get a new flags byte.  		if (mask == 1) {  			if (readBytes >= compressedSize)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			flags = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			mask = 0x80;  		} else {  			mask >>= 1;  		}  		#endregion  		// bit = 1 <=> compressed.  		if ((flags & mask) > 0) {  			// (throws when < 2 bytes are available)  			#region Get length and displacement('disp') values from next 2 bytes  			// there are < 2 bytes available when the end is at most 1 byte away  			if (readBytes + 1 >= inLength) {  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			}  			int byte1 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			int byte2 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			// the number of bytes to copy  			int length = byte1 >> 4;  			length += 3;  			// from where the bytes should be copied (relatively)  			int disp = ((byte1 & 0x0F) << 8) | byte2;  			disp += 3;  			if (disp > currentOutSize) {  				if (currentOutSize < 2)  					throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  				// HACK. this seems to produce valid files' but isn't the most elegant solution.  				// although this _could_ be the actual way to use a disp of 2 in this format'  				// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  				disp = 2;  			}  			#endregion  			int bufIdx = currentOutSize - disp;  			for (int i = 0; i < length; i++) {  				byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  				bufIdx++;  				outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  				currentOutSize++;  			}  		} else {  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			byte next = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  			currentOutSize++;  		}  	}  	// write the decompressed data  	outstream.Write (outbuffer' 0' outbuffer.Length);  	// make sure the input is positioned at the end of the file; the stream is currently  	// at the compression header.  	instream.Position += headerSize;  	return decompressedLength + (inLength - headerSize - compressedSize);  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: if (extraSize == 0) {  	#region just copy the input to the output  	// first go back to the start of the file. the current location is after the 'extraSize''  	// and thus at the end of the file.  	instream.Position -= inLength;  	// no buffering -> slow  	buffer = new byte[inLength - 4];  	instream.Read (buffer' 0' (int)(inLength - 4));  	outstream.Write (buffer' 0' (int)(inLength - 4));  	// make sure the input is positioned at the end of the file  	instream.Position += 4;  	return inLength - 4;  	#endregion  } else {  	// get the size of the compression header first.  	instream.Position -= 5;  	int headerSize = instream.ReadByte ();  	// then the compressed data size.  	instream.Position -= 4;  	instream.Read (buffer' 0' 3);  	int compressedSize = buffer [0] | (buffer [1] << 8) | (buffer [2] << 16);  	// the compressed size sometimes is the file size.  	if (compressedSize + headerSize >= inLength)  		compressedSize = (int)(inLength - headerSize);  	#region copy the non-compressed data  	// copy the non-compressed data first.  	buffer = new byte[inLength - headerSize - compressedSize];  	instream.Position -= (inLength - 5);  	instream.Read (buffer' 0' buffer.Length);  	outstream.Write (buffer' 0' buffer.Length);  	#endregion  	// buffer the compressed data' such that we don't need to keep  	// moving the input stream position back and forth  	buffer = new byte[compressedSize];  	instream.Read (buffer' 0' compressedSize);  	// we're filling the output from end to start' so we can't directly write the data.  	// buffer it instead (also use this data as buffer instead of a ring-buffer for  	// decompression)  	byte[] outbuffer = new byte[compressedSize + headerSize + extraSize];  	int currentOutSize = 0;  	int decompressedLength = outbuffer.Length;  	int readBytes = 0;  	byte flags = 0' mask = 1;  	while (currentOutSize < decompressedLength) {  		// (throws when requested new flags byte is not available)  		#region Update the mask. If all flag bits have been read' get a new set.  		// the current mask is the mask used in the previous run. So if it masks the  		// last flag bit' get a new flags byte.  		if (mask == 1) {  			if (readBytes >= compressedSize)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			flags = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			mask = 0x80;  		} else {  			mask >>= 1;  		}  		#endregion  		// bit = 1 <=> compressed.  		if ((flags & mask) > 0) {  			// (throws when < 2 bytes are available)  			#region Get length and displacement('disp') values from next 2 bytes  			// there are < 2 bytes available when the end is at most 1 byte away  			if (readBytes + 1 >= inLength) {  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			}  			int byte1 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			int byte2 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			// the number of bytes to copy  			int length = byte1 >> 4;  			length += 3;  			// from where the bytes should be copied (relatively)  			int disp = ((byte1 & 0x0F) << 8) | byte2;  			disp += 3;  			if (disp > currentOutSize) {  				if (currentOutSize < 2)  					throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  				// HACK. this seems to produce valid files' but isn't the most elegant solution.  				// although this _could_ be the actual way to use a disp of 2 in this format'  				// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  				disp = 2;  			}  			#endregion  			int bufIdx = currentOutSize - disp;  			for (int i = 0; i < length; i++) {  				byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  				bufIdx++;  				outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  				currentOutSize++;  			}  		} else {  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			byte next = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  			currentOutSize++;  		}  	}  	// write the decompressed data  	outstream.Write (outbuffer' 0' outbuffer.Length);  	// make sure the input is positioned at the end of the file; the stream is currently  	// at the compression header.  	instream.Position += headerSize;  	return decompressedLength + (inLength - headerSize - compressedSize);  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: if (extraSize == 0) {  	#region just copy the input to the output  	// first go back to the start of the file. the current location is after the 'extraSize''  	// and thus at the end of the file.  	instream.Position -= inLength;  	// no buffering -> slow  	buffer = new byte[inLength - 4];  	instream.Read (buffer' 0' (int)(inLength - 4));  	outstream.Write (buffer' 0' (int)(inLength - 4));  	// make sure the input is positioned at the end of the file  	instream.Position += 4;  	return inLength - 4;  	#endregion  } else {  	// get the size of the compression header first.  	instream.Position -= 5;  	int headerSize = instream.ReadByte ();  	// then the compressed data size.  	instream.Position -= 4;  	instream.Read (buffer' 0' 3);  	int compressedSize = buffer [0] | (buffer [1] << 8) | (buffer [2] << 16);  	// the compressed size sometimes is the file size.  	if (compressedSize + headerSize >= inLength)  		compressedSize = (int)(inLength - headerSize);  	#region copy the non-compressed data  	// copy the non-compressed data first.  	buffer = new byte[inLength - headerSize - compressedSize];  	instream.Position -= (inLength - 5);  	instream.Read (buffer' 0' buffer.Length);  	outstream.Write (buffer' 0' buffer.Length);  	#endregion  	// buffer the compressed data' such that we don't need to keep  	// moving the input stream position back and forth  	buffer = new byte[compressedSize];  	instream.Read (buffer' 0' compressedSize);  	// we're filling the output from end to start' so we can't directly write the data.  	// buffer it instead (also use this data as buffer instead of a ring-buffer for  	// decompression)  	byte[] outbuffer = new byte[compressedSize + headerSize + extraSize];  	int currentOutSize = 0;  	int decompressedLength = outbuffer.Length;  	int readBytes = 0;  	byte flags = 0' mask = 1;  	while (currentOutSize < decompressedLength) {  		// (throws when requested new flags byte is not available)  		#region Update the mask. If all flag bits have been read' get a new set.  		// the current mask is the mask used in the previous run. So if it masks the  		// last flag bit' get a new flags byte.  		if (mask == 1) {  			if (readBytes >= compressedSize)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			flags = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			mask = 0x80;  		} else {  			mask >>= 1;  		}  		#endregion  		// bit = 1 <=> compressed.  		if ((flags & mask) > 0) {  			// (throws when < 2 bytes are available)  			#region Get length and displacement('disp') values from next 2 bytes  			// there are < 2 bytes available when the end is at most 1 byte away  			if (readBytes + 1 >= inLength) {  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			}  			int byte1 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			int byte2 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			// the number of bytes to copy  			int length = byte1 >> 4;  			length += 3;  			// from where the bytes should be copied (relatively)  			int disp = ((byte1 & 0x0F) << 8) | byte2;  			disp += 3;  			if (disp > currentOutSize) {  				if (currentOutSize < 2)  					throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  				// HACK. this seems to produce valid files' but isn't the most elegant solution.  				// although this _could_ be the actual way to use a disp of 2 in this format'  				// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  				disp = 2;  			}  			#endregion  			int bufIdx = currentOutSize - disp;  			for (int i = 0; i < length; i++) {  				byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  				bufIdx++;  				outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  				currentOutSize++;  			}  		} else {  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			byte next = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  			currentOutSize++;  		}  	}  	// write the decompressed data  	outstream.Write (outbuffer' 0' outbuffer.Length);  	// make sure the input is positioned at the end of the file; the stream is currently  	// at the compression header.  	instream.Position += headerSize;  	return decompressedLength + (inLength - headerSize - compressedSize);  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: if (extraSize == 0) {  	#region just copy the input to the output  	// first go back to the start of the file. the current location is after the 'extraSize''  	// and thus at the end of the file.  	instream.Position -= inLength;  	// no buffering -> slow  	buffer = new byte[inLength - 4];  	instream.Read (buffer' 0' (int)(inLength - 4));  	outstream.Write (buffer' 0' (int)(inLength - 4));  	// make sure the input is positioned at the end of the file  	instream.Position += 4;  	return inLength - 4;  	#endregion  } else {  	// get the size of the compression header first.  	instream.Position -= 5;  	int headerSize = instream.ReadByte ();  	// then the compressed data size.  	instream.Position -= 4;  	instream.Read (buffer' 0' 3);  	int compressedSize = buffer [0] | (buffer [1] << 8) | (buffer [2] << 16);  	// the compressed size sometimes is the file size.  	if (compressedSize + headerSize >= inLength)  		compressedSize = (int)(inLength - headerSize);  	#region copy the non-compressed data  	// copy the non-compressed data first.  	buffer = new byte[inLength - headerSize - compressedSize];  	instream.Position -= (inLength - 5);  	instream.Read (buffer' 0' buffer.Length);  	outstream.Write (buffer' 0' buffer.Length);  	#endregion  	// buffer the compressed data' such that we don't need to keep  	// moving the input stream position back and forth  	buffer = new byte[compressedSize];  	instream.Read (buffer' 0' compressedSize);  	// we're filling the output from end to start' so we can't directly write the data.  	// buffer it instead (also use this data as buffer instead of a ring-buffer for  	// decompression)  	byte[] outbuffer = new byte[compressedSize + headerSize + extraSize];  	int currentOutSize = 0;  	int decompressedLength = outbuffer.Length;  	int readBytes = 0;  	byte flags = 0' mask = 1;  	while (currentOutSize < decompressedLength) {  		// (throws when requested new flags byte is not available)  		#region Update the mask. If all flag bits have been read' get a new set.  		// the current mask is the mask used in the previous run. So if it masks the  		// last flag bit' get a new flags byte.  		if (mask == 1) {  			if (readBytes >= compressedSize)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			flags = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			mask = 0x80;  		} else {  			mask >>= 1;  		}  		#endregion  		// bit = 1 <=> compressed.  		if ((flags & mask) > 0) {  			// (throws when < 2 bytes are available)  			#region Get length and displacement('disp') values from next 2 bytes  			// there are < 2 bytes available when the end is at most 1 byte away  			if (readBytes + 1 >= inLength) {  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			}  			int byte1 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			int byte2 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			// the number of bytes to copy  			int length = byte1 >> 4;  			length += 3;  			// from where the bytes should be copied (relatively)  			int disp = ((byte1 & 0x0F) << 8) | byte2;  			disp += 3;  			if (disp > currentOutSize) {  				if (currentOutSize < 2)  					throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  				// HACK. this seems to produce valid files' but isn't the most elegant solution.  				// although this _could_ be the actual way to use a disp of 2 in this format'  				// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  				disp = 2;  			}  			#endregion  			int bufIdx = currentOutSize - disp;  			for (int i = 0; i < length; i++) {  				byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  				bufIdx++;  				outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  				currentOutSize++;  			}  		} else {  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			byte next = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  			currentOutSize++;  		}  	}  	// write the decompressed data  	outstream.Write (outbuffer' 0' outbuffer.Length);  	// make sure the input is positioned at the end of the file; the stream is currently  	// at the compression header.  	instream.Position += headerSize;  	return decompressedLength + (inLength - headerSize - compressedSize);  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: if (extraSize == 0) {  	#region just copy the input to the output  	// first go back to the start of the file. the current location is after the 'extraSize''  	// and thus at the end of the file.  	instream.Position -= inLength;  	// no buffering -> slow  	buffer = new byte[inLength - 4];  	instream.Read (buffer' 0' (int)(inLength - 4));  	outstream.Write (buffer' 0' (int)(inLength - 4));  	// make sure the input is positioned at the end of the file  	instream.Position += 4;  	return inLength - 4;  	#endregion  } else {  	// get the size of the compression header first.  	instream.Position -= 5;  	int headerSize = instream.ReadByte ();  	// then the compressed data size.  	instream.Position -= 4;  	instream.Read (buffer' 0' 3);  	int compressedSize = buffer [0] | (buffer [1] << 8) | (buffer [2] << 16);  	// the compressed size sometimes is the file size.  	if (compressedSize + headerSize >= inLength)  		compressedSize = (int)(inLength - headerSize);  	#region copy the non-compressed data  	// copy the non-compressed data first.  	buffer = new byte[inLength - headerSize - compressedSize];  	instream.Position -= (inLength - 5);  	instream.Read (buffer' 0' buffer.Length);  	outstream.Write (buffer' 0' buffer.Length);  	#endregion  	// buffer the compressed data' such that we don't need to keep  	// moving the input stream position back and forth  	buffer = new byte[compressedSize];  	instream.Read (buffer' 0' compressedSize);  	// we're filling the output from end to start' so we can't directly write the data.  	// buffer it instead (also use this data as buffer instead of a ring-buffer for  	// decompression)  	byte[] outbuffer = new byte[compressedSize + headerSize + extraSize];  	int currentOutSize = 0;  	int decompressedLength = outbuffer.Length;  	int readBytes = 0;  	byte flags = 0' mask = 1;  	while (currentOutSize < decompressedLength) {  		// (throws when requested new flags byte is not available)  		#region Update the mask. If all flag bits have been read' get a new set.  		// the current mask is the mask used in the previous run. So if it masks the  		// last flag bit' get a new flags byte.  		if (mask == 1) {  			if (readBytes >= compressedSize)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			flags = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			mask = 0x80;  		} else {  			mask >>= 1;  		}  		#endregion  		// bit = 1 <=> compressed.  		if ((flags & mask) > 0) {  			// (throws when < 2 bytes are available)  			#region Get length and displacement('disp') values from next 2 bytes  			// there are < 2 bytes available when the end is at most 1 byte away  			if (readBytes + 1 >= inLength) {  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			}  			int byte1 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			int byte2 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			// the number of bytes to copy  			int length = byte1 >> 4;  			length += 3;  			// from where the bytes should be copied (relatively)  			int disp = ((byte1 & 0x0F) << 8) | byte2;  			disp += 3;  			if (disp > currentOutSize) {  				if (currentOutSize < 2)  					throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  				// HACK. this seems to produce valid files' but isn't the most elegant solution.  				// although this _could_ be the actual way to use a disp of 2 in this format'  				// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  				disp = 2;  			}  			#endregion  			int bufIdx = currentOutSize - disp;  			for (int i = 0; i < length; i++) {  				byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  				bufIdx++;  				outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  				currentOutSize++;  			}  		} else {  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			byte next = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  			currentOutSize++;  		}  	}  	// write the decompressed data  	outstream.Write (outbuffer' 0' outbuffer.Length);  	// make sure the input is positioned at the end of the file; the stream is currently  	// at the compression header.  	instream.Position += headerSize;  	return decompressedLength + (inLength - headerSize - compressedSize);  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: if (extraSize == 0) {  	#region just copy the input to the output  	// first go back to the start of the file. the current location is after the 'extraSize''  	// and thus at the end of the file.  	instream.Position -= inLength;  	// no buffering -> slow  	buffer = new byte[inLength - 4];  	instream.Read (buffer' 0' (int)(inLength - 4));  	outstream.Write (buffer' 0' (int)(inLength - 4));  	// make sure the input is positioned at the end of the file  	instream.Position += 4;  	return inLength - 4;  	#endregion  } else {  	// get the size of the compression header first.  	instream.Position -= 5;  	int headerSize = instream.ReadByte ();  	// then the compressed data size.  	instream.Position -= 4;  	instream.Read (buffer' 0' 3);  	int compressedSize = buffer [0] | (buffer [1] << 8) | (buffer [2] << 16);  	// the compressed size sometimes is the file size.  	if (compressedSize + headerSize >= inLength)  		compressedSize = (int)(inLength - headerSize);  	#region copy the non-compressed data  	// copy the non-compressed data first.  	buffer = new byte[inLength - headerSize - compressedSize];  	instream.Position -= (inLength - 5);  	instream.Read (buffer' 0' buffer.Length);  	outstream.Write (buffer' 0' buffer.Length);  	#endregion  	// buffer the compressed data' such that we don't need to keep  	// moving the input stream position back and forth  	buffer = new byte[compressedSize];  	instream.Read (buffer' 0' compressedSize);  	// we're filling the output from end to start' so we can't directly write the data.  	// buffer it instead (also use this data as buffer instead of a ring-buffer for  	// decompression)  	byte[] outbuffer = new byte[compressedSize + headerSize + extraSize];  	int currentOutSize = 0;  	int decompressedLength = outbuffer.Length;  	int readBytes = 0;  	byte flags = 0' mask = 1;  	while (currentOutSize < decompressedLength) {  		// (throws when requested new flags byte is not available)  		#region Update the mask. If all flag bits have been read' get a new set.  		// the current mask is the mask used in the previous run. So if it masks the  		// last flag bit' get a new flags byte.  		if (mask == 1) {  			if (readBytes >= compressedSize)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			flags = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			mask = 0x80;  		} else {  			mask >>= 1;  		}  		#endregion  		// bit = 1 <=> compressed.  		if ((flags & mask) > 0) {  			// (throws when < 2 bytes are available)  			#region Get length and displacement('disp') values from next 2 bytes  			// there are < 2 bytes available when the end is at most 1 byte away  			if (readBytes + 1 >= inLength) {  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			}  			int byte1 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			int byte2 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			// the number of bytes to copy  			int length = byte1 >> 4;  			length += 3;  			// from where the bytes should be copied (relatively)  			int disp = ((byte1 & 0x0F) << 8) | byte2;  			disp += 3;  			if (disp > currentOutSize) {  				if (currentOutSize < 2)  					throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  				// HACK. this seems to produce valid files' but isn't the most elegant solution.  				// although this _could_ be the actual way to use a disp of 2 in this format'  				// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  				disp = 2;  			}  			#endregion  			int bufIdx = currentOutSize - disp;  			for (int i = 0; i < length; i++) {  				byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  				bufIdx++;  				outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  				currentOutSize++;  			}  		} else {  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			byte next = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  			currentOutSize++;  		}  	}  	// write the decompressed data  	outstream.Write (outbuffer' 0' outbuffer.Length);  	// make sure the input is positioned at the end of the file; the stream is currently  	// at the compression header.  	instream.Position += headerSize;  	return decompressedLength + (inLength - headerSize - compressedSize);  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: if (extraSize == 0) {  	#region just copy the input to the output  	// first go back to the start of the file. the current location is after the 'extraSize''  	// and thus at the end of the file.  	instream.Position -= inLength;  	// no buffering -> slow  	buffer = new byte[inLength - 4];  	instream.Read (buffer' 0' (int)(inLength - 4));  	outstream.Write (buffer' 0' (int)(inLength - 4));  	// make sure the input is positioned at the end of the file  	instream.Position += 4;  	return inLength - 4;  	#endregion  } else {  	// get the size of the compression header first.  	instream.Position -= 5;  	int headerSize = instream.ReadByte ();  	// then the compressed data size.  	instream.Position -= 4;  	instream.Read (buffer' 0' 3);  	int compressedSize = buffer [0] | (buffer [1] << 8) | (buffer [2] << 16);  	// the compressed size sometimes is the file size.  	if (compressedSize + headerSize >= inLength)  		compressedSize = (int)(inLength - headerSize);  	#region copy the non-compressed data  	// copy the non-compressed data first.  	buffer = new byte[inLength - headerSize - compressedSize];  	instream.Position -= (inLength - 5);  	instream.Read (buffer' 0' buffer.Length);  	outstream.Write (buffer' 0' buffer.Length);  	#endregion  	// buffer the compressed data' such that we don't need to keep  	// moving the input stream position back and forth  	buffer = new byte[compressedSize];  	instream.Read (buffer' 0' compressedSize);  	// we're filling the output from end to start' so we can't directly write the data.  	// buffer it instead (also use this data as buffer instead of a ring-buffer for  	// decompression)  	byte[] outbuffer = new byte[compressedSize + headerSize + extraSize];  	int currentOutSize = 0;  	int decompressedLength = outbuffer.Length;  	int readBytes = 0;  	byte flags = 0' mask = 1;  	while (currentOutSize < decompressedLength) {  		// (throws when requested new flags byte is not available)  		#region Update the mask. If all flag bits have been read' get a new set.  		// the current mask is the mask used in the previous run. So if it masks the  		// last flag bit' get a new flags byte.  		if (mask == 1) {  			if (readBytes >= compressedSize)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			flags = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			mask = 0x80;  		} else {  			mask >>= 1;  		}  		#endregion  		// bit = 1 <=> compressed.  		if ((flags & mask) > 0) {  			// (throws when < 2 bytes are available)  			#region Get length and displacement('disp') values from next 2 bytes  			// there are < 2 bytes available when the end is at most 1 byte away  			if (readBytes + 1 >= inLength) {  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			}  			int byte1 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			int byte2 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			// the number of bytes to copy  			int length = byte1 >> 4;  			length += 3;  			// from where the bytes should be copied (relatively)  			int disp = ((byte1 & 0x0F) << 8) | byte2;  			disp += 3;  			if (disp > currentOutSize) {  				if (currentOutSize < 2)  					throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  				// HACK. this seems to produce valid files' but isn't the most elegant solution.  				// although this _could_ be the actual way to use a disp of 2 in this format'  				// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  				disp = 2;  			}  			#endregion  			int bufIdx = currentOutSize - disp;  			for (int i = 0; i < length; i++) {  				byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  				bufIdx++;  				outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  				currentOutSize++;  			}  		} else {  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			byte next = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  			currentOutSize++;  		}  	}  	// write the decompressed data  	outstream.Write (outbuffer' 0' outbuffer.Length);  	// make sure the input is positioned at the end of the file; the stream is currently  	// at the compression header.  	instream.Position += headerSize;  	return decompressedLength + (inLength - headerSize - compressedSize);  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: if (extraSize == 0) {  	#region just copy the input to the output  	// first go back to the start of the file. the current location is after the 'extraSize''  	// and thus at the end of the file.  	instream.Position -= inLength;  	// no buffering -> slow  	buffer = new byte[inLength - 4];  	instream.Read (buffer' 0' (int)(inLength - 4));  	outstream.Write (buffer' 0' (int)(inLength - 4));  	// make sure the input is positioned at the end of the file  	instream.Position += 4;  	return inLength - 4;  	#endregion  } else {  	// get the size of the compression header first.  	instream.Position -= 5;  	int headerSize = instream.ReadByte ();  	// then the compressed data size.  	instream.Position -= 4;  	instream.Read (buffer' 0' 3);  	int compressedSize = buffer [0] | (buffer [1] << 8) | (buffer [2] << 16);  	// the compressed size sometimes is the file size.  	if (compressedSize + headerSize >= inLength)  		compressedSize = (int)(inLength - headerSize);  	#region copy the non-compressed data  	// copy the non-compressed data first.  	buffer = new byte[inLength - headerSize - compressedSize];  	instream.Position -= (inLength - 5);  	instream.Read (buffer' 0' buffer.Length);  	outstream.Write (buffer' 0' buffer.Length);  	#endregion  	// buffer the compressed data' such that we don't need to keep  	// moving the input stream position back and forth  	buffer = new byte[compressedSize];  	instream.Read (buffer' 0' compressedSize);  	// we're filling the output from end to start' so we can't directly write the data.  	// buffer it instead (also use this data as buffer instead of a ring-buffer for  	// decompression)  	byte[] outbuffer = new byte[compressedSize + headerSize + extraSize];  	int currentOutSize = 0;  	int decompressedLength = outbuffer.Length;  	int readBytes = 0;  	byte flags = 0' mask = 1;  	while (currentOutSize < decompressedLength) {  		// (throws when requested new flags byte is not available)  		#region Update the mask. If all flag bits have been read' get a new set.  		// the current mask is the mask used in the previous run. So if it masks the  		// last flag bit' get a new flags byte.  		if (mask == 1) {  			if (readBytes >= compressedSize)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			flags = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			mask = 0x80;  		} else {  			mask >>= 1;  		}  		#endregion  		// bit = 1 <=> compressed.  		if ((flags & mask) > 0) {  			// (throws when < 2 bytes are available)  			#region Get length and displacement('disp') values from next 2 bytes  			// there are < 2 bytes available when the end is at most 1 byte away  			if (readBytes + 1 >= inLength) {  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			}  			int byte1 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			int byte2 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			// the number of bytes to copy  			int length = byte1 >> 4;  			length += 3;  			// from where the bytes should be copied (relatively)  			int disp = ((byte1 & 0x0F) << 8) | byte2;  			disp += 3;  			if (disp > currentOutSize) {  				if (currentOutSize < 2)  					throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  				// HACK. this seems to produce valid files' but isn't the most elegant solution.  				// although this _could_ be the actual way to use a disp of 2 in this format'  				// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  				disp = 2;  			}  			#endregion  			int bufIdx = currentOutSize - disp;  			for (int i = 0; i < length; i++) {  				byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  				bufIdx++;  				outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  				currentOutSize++;  			}  		} else {  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			byte next = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  			currentOutSize++;  		}  	}  	// write the decompressed data  	outstream.Write (outbuffer' 0' outbuffer.Length);  	// make sure the input is positioned at the end of the file; the stream is currently  	// at the compression header.  	instream.Position += headerSize;  	return decompressedLength + (inLength - headerSize - compressedSize);  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: if (extraSize == 0) {  	#region just copy the input to the output  	// first go back to the start of the file. the current location is after the 'extraSize''  	// and thus at the end of the file.  	instream.Position -= inLength;  	// no buffering -> slow  	buffer = new byte[inLength - 4];  	instream.Read (buffer' 0' (int)(inLength - 4));  	outstream.Write (buffer' 0' (int)(inLength - 4));  	// make sure the input is positioned at the end of the file  	instream.Position += 4;  	return inLength - 4;  	#endregion  } else {  	// get the size of the compression header first.  	instream.Position -= 5;  	int headerSize = instream.ReadByte ();  	// then the compressed data size.  	instream.Position -= 4;  	instream.Read (buffer' 0' 3);  	int compressedSize = buffer [0] | (buffer [1] << 8) | (buffer [2] << 16);  	// the compressed size sometimes is the file size.  	if (compressedSize + headerSize >= inLength)  		compressedSize = (int)(inLength - headerSize);  	#region copy the non-compressed data  	// copy the non-compressed data first.  	buffer = new byte[inLength - headerSize - compressedSize];  	instream.Position -= (inLength - 5);  	instream.Read (buffer' 0' buffer.Length);  	outstream.Write (buffer' 0' buffer.Length);  	#endregion  	// buffer the compressed data' such that we don't need to keep  	// moving the input stream position back and forth  	buffer = new byte[compressedSize];  	instream.Read (buffer' 0' compressedSize);  	// we're filling the output from end to start' so we can't directly write the data.  	// buffer it instead (also use this data as buffer instead of a ring-buffer for  	// decompression)  	byte[] outbuffer = new byte[compressedSize + headerSize + extraSize];  	int currentOutSize = 0;  	int decompressedLength = outbuffer.Length;  	int readBytes = 0;  	byte flags = 0' mask = 1;  	while (currentOutSize < decompressedLength) {  		// (throws when requested new flags byte is not available)  		#region Update the mask. If all flag bits have been read' get a new set.  		// the current mask is the mask used in the previous run. So if it masks the  		// last flag bit' get a new flags byte.  		if (mask == 1) {  			if (readBytes >= compressedSize)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			flags = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			mask = 0x80;  		} else {  			mask >>= 1;  		}  		#endregion  		// bit = 1 <=> compressed.  		if ((flags & mask) > 0) {  			// (throws when < 2 bytes are available)  			#region Get length and displacement('disp') values from next 2 bytes  			// there are < 2 bytes available when the end is at most 1 byte away  			if (readBytes + 1 >= inLength) {  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			}  			int byte1 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			int byte2 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			// the number of bytes to copy  			int length = byte1 >> 4;  			length += 3;  			// from where the bytes should be copied (relatively)  			int disp = ((byte1 & 0x0F) << 8) | byte2;  			disp += 3;  			if (disp > currentOutSize) {  				if (currentOutSize < 2)  					throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  				// HACK. this seems to produce valid files' but isn't the most elegant solution.  				// although this _could_ be the actual way to use a disp of 2 in this format'  				// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  				disp = 2;  			}  			#endregion  			int bufIdx = currentOutSize - disp;  			for (int i = 0; i < length; i++) {  				byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  				bufIdx++;  				outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  				currentOutSize++;  			}  		} else {  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			byte next = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  			currentOutSize++;  		}  	}  	// write the decompressed data  	outstream.Write (outbuffer' 0' outbuffer.Length);  	// make sure the input is positioned at the end of the file; the stream is currently  	// at the compression header.  	instream.Position += headerSize;  	return decompressedLength + (inLength - headerSize - compressedSize);  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: if (extraSize == 0) {  	#region just copy the input to the output  	// first go back to the start of the file. the current location is after the 'extraSize''  	// and thus at the end of the file.  	instream.Position -= inLength;  	// no buffering -> slow  	buffer = new byte[inLength - 4];  	instream.Read (buffer' 0' (int)(inLength - 4));  	outstream.Write (buffer' 0' (int)(inLength - 4));  	// make sure the input is positioned at the end of the file  	instream.Position += 4;  	return inLength - 4;  	#endregion  } else {  	// get the size of the compression header first.  	instream.Position -= 5;  	int headerSize = instream.ReadByte ();  	// then the compressed data size.  	instream.Position -= 4;  	instream.Read (buffer' 0' 3);  	int compressedSize = buffer [0] | (buffer [1] << 8) | (buffer [2] << 16);  	// the compressed size sometimes is the file size.  	if (compressedSize + headerSize >= inLength)  		compressedSize = (int)(inLength - headerSize);  	#region copy the non-compressed data  	// copy the non-compressed data first.  	buffer = new byte[inLength - headerSize - compressedSize];  	instream.Position -= (inLength - 5);  	instream.Read (buffer' 0' buffer.Length);  	outstream.Write (buffer' 0' buffer.Length);  	#endregion  	// buffer the compressed data' such that we don't need to keep  	// moving the input stream position back and forth  	buffer = new byte[compressedSize];  	instream.Read (buffer' 0' compressedSize);  	// we're filling the output from end to start' so we can't directly write the data.  	// buffer it instead (also use this data as buffer instead of a ring-buffer for  	// decompression)  	byte[] outbuffer = new byte[compressedSize + headerSize + extraSize];  	int currentOutSize = 0;  	int decompressedLength = outbuffer.Length;  	int readBytes = 0;  	byte flags = 0' mask = 1;  	while (currentOutSize < decompressedLength) {  		// (throws when requested new flags byte is not available)  		#region Update the mask. If all flag bits have been read' get a new set.  		// the current mask is the mask used in the previous run. So if it masks the  		// last flag bit' get a new flags byte.  		if (mask == 1) {  			if (readBytes >= compressedSize)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			flags = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			mask = 0x80;  		} else {  			mask >>= 1;  		}  		#endregion  		// bit = 1 <=> compressed.  		if ((flags & mask) > 0) {  			// (throws when < 2 bytes are available)  			#region Get length and displacement('disp') values from next 2 bytes  			// there are < 2 bytes available when the end is at most 1 byte away  			if (readBytes + 1 >= inLength) {  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			}  			int byte1 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			int byte2 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			// the number of bytes to copy  			int length = byte1 >> 4;  			length += 3;  			// from where the bytes should be copied (relatively)  			int disp = ((byte1 & 0x0F) << 8) | byte2;  			disp += 3;  			if (disp > currentOutSize) {  				if (currentOutSize < 2)  					throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  				// HACK. this seems to produce valid files' but isn't the most elegant solution.  				// although this _could_ be the actual way to use a disp of 2 in this format'  				// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  				disp = 2;  			}  			#endregion  			int bufIdx = currentOutSize - disp;  			for (int i = 0; i < length; i++) {  				byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  				bufIdx++;  				outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  				currentOutSize++;  			}  		} else {  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			byte next = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  			currentOutSize++;  		}  	}  	// write the decompressed data  	outstream.Write (outbuffer' 0' outbuffer.Length);  	// make sure the input is positioned at the end of the file; the stream is currently  	// at the compression header.  	instream.Position += headerSize;  	return decompressedLength + (inLength - headerSize - compressedSize);  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: if (extraSize == 0) {  	#region just copy the input to the output  	// first go back to the start of the file. the current location is after the 'extraSize''  	// and thus at the end of the file.  	instream.Position -= inLength;  	// no buffering -> slow  	buffer = new byte[inLength - 4];  	instream.Read (buffer' 0' (int)(inLength - 4));  	outstream.Write (buffer' 0' (int)(inLength - 4));  	// make sure the input is positioned at the end of the file  	instream.Position += 4;  	return inLength - 4;  	#endregion  } else {  	// get the size of the compression header first.  	instream.Position -= 5;  	int headerSize = instream.ReadByte ();  	// then the compressed data size.  	instream.Position -= 4;  	instream.Read (buffer' 0' 3);  	int compressedSize = buffer [0] | (buffer [1] << 8) | (buffer [2] << 16);  	// the compressed size sometimes is the file size.  	if (compressedSize + headerSize >= inLength)  		compressedSize = (int)(inLength - headerSize);  	#region copy the non-compressed data  	// copy the non-compressed data first.  	buffer = new byte[inLength - headerSize - compressedSize];  	instream.Position -= (inLength - 5);  	instream.Read (buffer' 0' buffer.Length);  	outstream.Write (buffer' 0' buffer.Length);  	#endregion  	// buffer the compressed data' such that we don't need to keep  	// moving the input stream position back and forth  	buffer = new byte[compressedSize];  	instream.Read (buffer' 0' compressedSize);  	// we're filling the output from end to start' so we can't directly write the data.  	// buffer it instead (also use this data as buffer instead of a ring-buffer for  	// decompression)  	byte[] outbuffer = new byte[compressedSize + headerSize + extraSize];  	int currentOutSize = 0;  	int decompressedLength = outbuffer.Length;  	int readBytes = 0;  	byte flags = 0' mask = 1;  	while (currentOutSize < decompressedLength) {  		// (throws when requested new flags byte is not available)  		#region Update the mask. If all flag bits have been read' get a new set.  		// the current mask is the mask used in the previous run. So if it masks the  		// last flag bit' get a new flags byte.  		if (mask == 1) {  			if (readBytes >= compressedSize)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			flags = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			mask = 0x80;  		} else {  			mask >>= 1;  		}  		#endregion  		// bit = 1 <=> compressed.  		if ((flags & mask) > 0) {  			// (throws when < 2 bytes are available)  			#region Get length and displacement('disp') values from next 2 bytes  			// there are < 2 bytes available when the end is at most 1 byte away  			if (readBytes + 1 >= inLength) {  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			}  			int byte1 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			int byte2 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			// the number of bytes to copy  			int length = byte1 >> 4;  			length += 3;  			// from where the bytes should be copied (relatively)  			int disp = ((byte1 & 0x0F) << 8) | byte2;  			disp += 3;  			if (disp > currentOutSize) {  				if (currentOutSize < 2)  					throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  				// HACK. this seems to produce valid files' but isn't the most elegant solution.  				// although this _could_ be the actual way to use a disp of 2 in this format'  				// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  				disp = 2;  			}  			#endregion  			int bufIdx = currentOutSize - disp;  			for (int i = 0; i < length; i++) {  				byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  				bufIdx++;  				outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  				currentOutSize++;  			}  		} else {  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			byte next = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  			currentOutSize++;  		}  	}  	// write the decompressed data  	outstream.Write (outbuffer' 0' outbuffer.Length);  	// make sure the input is positioned at the end of the file; the stream is currently  	// at the compression header.  	instream.Position += headerSize;  	return decompressedLength + (inLength - headerSize - compressedSize);  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: if (extraSize == 0) {  	#region just copy the input to the output  	// first go back to the start of the file. the current location is after the 'extraSize''  	// and thus at the end of the file.  	instream.Position -= inLength;  	// no buffering -> slow  	buffer = new byte[inLength - 4];  	instream.Read (buffer' 0' (int)(inLength - 4));  	outstream.Write (buffer' 0' (int)(inLength - 4));  	// make sure the input is positioned at the end of the file  	instream.Position += 4;  	return inLength - 4;  	#endregion  } else {  	// get the size of the compression header first.  	instream.Position -= 5;  	int headerSize = instream.ReadByte ();  	// then the compressed data size.  	instream.Position -= 4;  	instream.Read (buffer' 0' 3);  	int compressedSize = buffer [0] | (buffer [1] << 8) | (buffer [2] << 16);  	// the compressed size sometimes is the file size.  	if (compressedSize + headerSize >= inLength)  		compressedSize = (int)(inLength - headerSize);  	#region copy the non-compressed data  	// copy the non-compressed data first.  	buffer = new byte[inLength - headerSize - compressedSize];  	instream.Position -= (inLength - 5);  	instream.Read (buffer' 0' buffer.Length);  	outstream.Write (buffer' 0' buffer.Length);  	#endregion  	// buffer the compressed data' such that we don't need to keep  	// moving the input stream position back and forth  	buffer = new byte[compressedSize];  	instream.Read (buffer' 0' compressedSize);  	// we're filling the output from end to start' so we can't directly write the data.  	// buffer it instead (also use this data as buffer instead of a ring-buffer for  	// decompression)  	byte[] outbuffer = new byte[compressedSize + headerSize + extraSize];  	int currentOutSize = 0;  	int decompressedLength = outbuffer.Length;  	int readBytes = 0;  	byte flags = 0' mask = 1;  	while (currentOutSize < decompressedLength) {  		// (throws when requested new flags byte is not available)  		#region Update the mask. If all flag bits have been read' get a new set.  		// the current mask is the mask used in the previous run. So if it masks the  		// last flag bit' get a new flags byte.  		if (mask == 1) {  			if (readBytes >= compressedSize)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			flags = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			mask = 0x80;  		} else {  			mask >>= 1;  		}  		#endregion  		// bit = 1 <=> compressed.  		if ((flags & mask) > 0) {  			// (throws when < 2 bytes are available)  			#region Get length and displacement('disp') values from next 2 bytes  			// there are < 2 bytes available when the end is at most 1 byte away  			if (readBytes + 1 >= inLength) {  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			}  			int byte1 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			int byte2 = buffer [compressedSize - 1 - readBytes];  			readBytes++;  			// the number of bytes to copy  			int length = byte1 >> 4;  			length += 3;  			// from where the bytes should be copied (relatively)  			int disp = ((byte1 & 0x0F) << 8) | byte2;  			disp += 3;  			if (disp > currentOutSize) {  				if (currentOutSize < 2)  					throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  				// HACK. this seems to produce valid files' but isn't the most elegant solution.  				// although this _could_ be the actual way to use a disp of 2 in this format'  				// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  				disp = 2;  			}  			#endregion  			int bufIdx = currentOutSize - disp;  			for (int i = 0; i < length; i++) {  				byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  				bufIdx++;  				outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  				currentOutSize++;  			}  		} else {  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedLength);  			byte next = buffer [buffer.Length - 1 - readBytes];  			readBytes++;  			outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  			currentOutSize++;  		}  	}  	// write the decompressed data  	outstream.Write (outbuffer' 0' outbuffer.Length);  	// make sure the input is positioned at the end of the file; the stream is currently  	// at the compression header.  	instream.Position += headerSize;  	return decompressedLength + (inLength - headerSize - compressedSize);  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: buffer = new byte[inLength - 4];  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: instream.Read (buffer' 0' (int)(inLength - 4));  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: outstream.Write (buffer' 0' (int)(inLength - 4));  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: instream.Position += 4;  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: return inLength - 4;  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: instream.Position -= 5;  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: instream.Position -= 4;  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: instream.Read (buffer' 0' 3);  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: instream.Position -= (inLength - 5);  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: while (currentOutSize < decompressedLength) {  	// (throws when requested new flags byte is not available)  	#region Update the mask. If all flag bits have been read' get a new set.  	// the current mask is the mask used in the previous run. So if it masks the  	// last flag bit' get a new flags byte.  	if (mask == 1) {  		if (readBytes >= compressedSize)  			throw new NotEnoughDataException (currentOutSize' decompressedLength);  		flags = buffer [buffer.Length - 1 - readBytes];  		readBytes++;  		mask = 0x80;  	} else {  		mask >>= 1;  	}  	#endregion  	// bit = 1 <=> compressed.  	if ((flags & mask) > 0) {  		// (throws when < 2 bytes are available)  		#region Get length and displacement('disp') values from next 2 bytes  		// there are < 2 bytes available when the end is at most 1 byte away  		if (readBytes + 1 >= inLength) {  			throw new NotEnoughDataException (currentOutSize' decompressedLength);  		}  		int byte1 = buffer [compressedSize - 1 - readBytes];  		readBytes++;  		int byte2 = buffer [compressedSize - 1 - readBytes];  		readBytes++;  		// the number of bytes to copy  		int length = byte1 >> 4;  		length += 3;  		// from where the bytes should be copied (relatively)  		int disp = ((byte1 & 0x0F) << 8) | byte2;  		disp += 3;  		if (disp > currentOutSize) {  			if (currentOutSize < 2)  				throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  			// HACK. this seems to produce valid files' but isn't the most elegant solution.  			// although this _could_ be the actual way to use a disp of 2 in this format'  			// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  			disp = 2;  		}  		#endregion  		int bufIdx = currentOutSize - disp;  		for (int i = 0; i < length; i++) {  			byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  			bufIdx++;  			outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  			currentOutSize++;  		}  	} else {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedLength);  		byte next = buffer [buffer.Length - 1 - readBytes];  		readBytes++;  		outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  		currentOutSize++;  	}  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: while (currentOutSize < decompressedLength) {  	// (throws when requested new flags byte is not available)  	#region Update the mask. If all flag bits have been read' get a new set.  	// the current mask is the mask used in the previous run. So if it masks the  	// last flag bit' get a new flags byte.  	if (mask == 1) {  		if (readBytes >= compressedSize)  			throw new NotEnoughDataException (currentOutSize' decompressedLength);  		flags = buffer [buffer.Length - 1 - readBytes];  		readBytes++;  		mask = 0x80;  	} else {  		mask >>= 1;  	}  	#endregion  	// bit = 1 <=> compressed.  	if ((flags & mask) > 0) {  		// (throws when < 2 bytes are available)  		#region Get length and displacement('disp') values from next 2 bytes  		// there are < 2 bytes available when the end is at most 1 byte away  		if (readBytes + 1 >= inLength) {  			throw new NotEnoughDataException (currentOutSize' decompressedLength);  		}  		int byte1 = buffer [compressedSize - 1 - readBytes];  		readBytes++;  		int byte2 = buffer [compressedSize - 1 - readBytes];  		readBytes++;  		// the number of bytes to copy  		int length = byte1 >> 4;  		length += 3;  		// from where the bytes should be copied (relatively)  		int disp = ((byte1 & 0x0F) << 8) | byte2;  		disp += 3;  		if (disp > currentOutSize) {  			if (currentOutSize < 2)  				throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  			// HACK. this seems to produce valid files' but isn't the most elegant solution.  			// although this _could_ be the actual way to use a disp of 2 in this format'  			// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  			disp = 2;  		}  		#endregion  		int bufIdx = currentOutSize - disp;  		for (int i = 0; i < length; i++) {  			byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  			bufIdx++;  			outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  			currentOutSize++;  		}  	} else {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedLength);  		byte next = buffer [buffer.Length - 1 - readBytes];  		readBytes++;  		outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  		currentOutSize++;  	}  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: while (currentOutSize < decompressedLength) {  	// (throws when requested new flags byte is not available)  	#region Update the mask. If all flag bits have been read' get a new set.  	// the current mask is the mask used in the previous run. So if it masks the  	// last flag bit' get a new flags byte.  	if (mask == 1) {  		if (readBytes >= compressedSize)  			throw new NotEnoughDataException (currentOutSize' decompressedLength);  		flags = buffer [buffer.Length - 1 - readBytes];  		readBytes++;  		mask = 0x80;  	} else {  		mask >>= 1;  	}  	#endregion  	// bit = 1 <=> compressed.  	if ((flags & mask) > 0) {  		// (throws when < 2 bytes are available)  		#region Get length and displacement('disp') values from next 2 bytes  		// there are < 2 bytes available when the end is at most 1 byte away  		if (readBytes + 1 >= inLength) {  			throw new NotEnoughDataException (currentOutSize' decompressedLength);  		}  		int byte1 = buffer [compressedSize - 1 - readBytes];  		readBytes++;  		int byte2 = buffer [compressedSize - 1 - readBytes];  		readBytes++;  		// the number of bytes to copy  		int length = byte1 >> 4;  		length += 3;  		// from where the bytes should be copied (relatively)  		int disp = ((byte1 & 0x0F) << 8) | byte2;  		disp += 3;  		if (disp > currentOutSize) {  			if (currentOutSize < 2)  				throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  			// HACK. this seems to produce valid files' but isn't the most elegant solution.  			// although this _could_ be the actual way to use a disp of 2 in this format'  			// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  			disp = 2;  		}  		#endregion  		int bufIdx = currentOutSize - disp;  		for (int i = 0; i < length; i++) {  			byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  			bufIdx++;  			outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  			currentOutSize++;  		}  	} else {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedLength);  		byte next = buffer [buffer.Length - 1 - readBytes];  		readBytes++;  		outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  		currentOutSize++;  	}  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: while (currentOutSize < decompressedLength) {  	// (throws when requested new flags byte is not available)  	#region Update the mask. If all flag bits have been read' get a new set.  	// the current mask is the mask used in the previous run. So if it masks the  	// last flag bit' get a new flags byte.  	if (mask == 1) {  		if (readBytes >= compressedSize)  			throw new NotEnoughDataException (currentOutSize' decompressedLength);  		flags = buffer [buffer.Length - 1 - readBytes];  		readBytes++;  		mask = 0x80;  	} else {  		mask >>= 1;  	}  	#endregion  	// bit = 1 <=> compressed.  	if ((flags & mask) > 0) {  		// (throws when < 2 bytes are available)  		#region Get length and displacement('disp') values from next 2 bytes  		// there are < 2 bytes available when the end is at most 1 byte away  		if (readBytes + 1 >= inLength) {  			throw new NotEnoughDataException (currentOutSize' decompressedLength);  		}  		int byte1 = buffer [compressedSize - 1 - readBytes];  		readBytes++;  		int byte2 = buffer [compressedSize - 1 - readBytes];  		readBytes++;  		// the number of bytes to copy  		int length = byte1 >> 4;  		length += 3;  		// from where the bytes should be copied (relatively)  		int disp = ((byte1 & 0x0F) << 8) | byte2;  		disp += 3;  		if (disp > currentOutSize) {  			if (currentOutSize < 2)  				throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  			// HACK. this seems to produce valid files' but isn't the most elegant solution.  			// although this _could_ be the actual way to use a disp of 2 in this format'  			// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  			disp = 2;  		}  		#endregion  		int bufIdx = currentOutSize - disp;  		for (int i = 0; i < length; i++) {  			byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  			bufIdx++;  			outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  			currentOutSize++;  		}  	} else {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedLength);  		byte next = buffer [buffer.Length - 1 - readBytes];  		readBytes++;  		outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  		currentOutSize++;  	}  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: while (currentOutSize < decompressedLength) {  	// (throws when requested new flags byte is not available)  	#region Update the mask. If all flag bits have been read' get a new set.  	// the current mask is the mask used in the previous run. So if it masks the  	// last flag bit' get a new flags byte.  	if (mask == 1) {  		if (readBytes >= compressedSize)  			throw new NotEnoughDataException (currentOutSize' decompressedLength);  		flags = buffer [buffer.Length - 1 - readBytes];  		readBytes++;  		mask = 0x80;  	} else {  		mask >>= 1;  	}  	#endregion  	// bit = 1 <=> compressed.  	if ((flags & mask) > 0) {  		// (throws when < 2 bytes are available)  		#region Get length and displacement('disp') values from next 2 bytes  		// there are < 2 bytes available when the end is at most 1 byte away  		if (readBytes + 1 >= inLength) {  			throw new NotEnoughDataException (currentOutSize' decompressedLength);  		}  		int byte1 = buffer [compressedSize - 1 - readBytes];  		readBytes++;  		int byte2 = buffer [compressedSize - 1 - readBytes];  		readBytes++;  		// the number of bytes to copy  		int length = byte1 >> 4;  		length += 3;  		// from where the bytes should be copied (relatively)  		int disp = ((byte1 & 0x0F) << 8) | byte2;  		disp += 3;  		if (disp > currentOutSize) {  			if (currentOutSize < 2)  				throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  			// HACK. this seems to produce valid files' but isn't the most elegant solution.  			// although this _could_ be the actual way to use a disp of 2 in this format'  			// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  			disp = 2;  		}  		#endregion  		int bufIdx = currentOutSize - disp;  		for (int i = 0; i < length; i++) {  			byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  			bufIdx++;  			outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  			currentOutSize++;  		}  	} else {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedLength);  		byte next = buffer [buffer.Length - 1 - readBytes];  		readBytes++;  		outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  		currentOutSize++;  	}  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: while (currentOutSize < decompressedLength) {  	// (throws when requested new flags byte is not available)  	#region Update the mask. If all flag bits have been read' get a new set.  	// the current mask is the mask used in the previous run. So if it masks the  	// last flag bit' get a new flags byte.  	if (mask == 1) {  		if (readBytes >= compressedSize)  			throw new NotEnoughDataException (currentOutSize' decompressedLength);  		flags = buffer [buffer.Length - 1 - readBytes];  		readBytes++;  		mask = 0x80;  	} else {  		mask >>= 1;  	}  	#endregion  	// bit = 1 <=> compressed.  	if ((flags & mask) > 0) {  		// (throws when < 2 bytes are available)  		#region Get length and displacement('disp') values from next 2 bytes  		// there are < 2 bytes available when the end is at most 1 byte away  		if (readBytes + 1 >= inLength) {  			throw new NotEnoughDataException (currentOutSize' decompressedLength);  		}  		int byte1 = buffer [compressedSize - 1 - readBytes];  		readBytes++;  		int byte2 = buffer [compressedSize - 1 - readBytes];  		readBytes++;  		// the number of bytes to copy  		int length = byte1 >> 4;  		length += 3;  		// from where the bytes should be copied (relatively)  		int disp = ((byte1 & 0x0F) << 8) | byte2;  		disp += 3;  		if (disp > currentOutSize) {  			if (currentOutSize < 2)  				throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  			// HACK. this seems to produce valid files' but isn't the most elegant solution.  			// although this _could_ be the actual way to use a disp of 2 in this format'  			// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  			disp = 2;  		}  		#endregion  		int bufIdx = currentOutSize - disp;  		for (int i = 0; i < length; i++) {  			byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  			bufIdx++;  			outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  			currentOutSize++;  		}  	} else {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedLength);  		byte next = buffer [buffer.Length - 1 - readBytes];  		readBytes++;  		outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  		currentOutSize++;  	}  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: if ((flags & mask) > 0) {  	// (throws when < 2 bytes are available)  	#region Get length and displacement('disp') values from next 2 bytes  	// there are < 2 bytes available when the end is at most 1 byte away  	if (readBytes + 1 >= inLength) {  		throw new NotEnoughDataException (currentOutSize' decompressedLength);  	}  	int byte1 = buffer [compressedSize - 1 - readBytes];  	readBytes++;  	int byte2 = buffer [compressedSize - 1 - readBytes];  	readBytes++;  	// the number of bytes to copy  	int length = byte1 >> 4;  	length += 3;  	// from where the bytes should be copied (relatively)  	int disp = ((byte1 & 0x0F) << 8) | byte2;  	disp += 3;  	if (disp > currentOutSize) {  		if (currentOutSize < 2)  			throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  		// HACK. this seems to produce valid files' but isn't the most elegant solution.  		// although this _could_ be the actual way to use a disp of 2 in this format'  		// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  		disp = 2;  	}  	#endregion  	int bufIdx = currentOutSize - disp;  	for (int i = 0; i < length; i++) {  		byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  		bufIdx++;  		outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  		currentOutSize++;  	}  } else {  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedLength);  	byte next = buffer [buffer.Length - 1 - readBytes];  	readBytes++;  	outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  	currentOutSize++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: if ((flags & mask) > 0) {  	// (throws when < 2 bytes are available)  	#region Get length and displacement('disp') values from next 2 bytes  	// there are < 2 bytes available when the end is at most 1 byte away  	if (readBytes + 1 >= inLength) {  		throw new NotEnoughDataException (currentOutSize' decompressedLength);  	}  	int byte1 = buffer [compressedSize - 1 - readBytes];  	readBytes++;  	int byte2 = buffer [compressedSize - 1 - readBytes];  	readBytes++;  	// the number of bytes to copy  	int length = byte1 >> 4;  	length += 3;  	// from where the bytes should be copied (relatively)  	int disp = ((byte1 & 0x0F) << 8) | byte2;  	disp += 3;  	if (disp > currentOutSize) {  		if (currentOutSize < 2)  			throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  		// HACK. this seems to produce valid files' but isn't the most elegant solution.  		// although this _could_ be the actual way to use a disp of 2 in this format'  		// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  		disp = 2;  	}  	#endregion  	int bufIdx = currentOutSize - disp;  	for (int i = 0; i < length; i++) {  		byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  		bufIdx++;  		outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  		currentOutSize++;  	}  } else {  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedLength);  	byte next = buffer [buffer.Length - 1 - readBytes];  	readBytes++;  	outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  	currentOutSize++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: if ((flags & mask) > 0) {  	// (throws when < 2 bytes are available)  	#region Get length and displacement('disp') values from next 2 bytes  	// there are < 2 bytes available when the end is at most 1 byte away  	if (readBytes + 1 >= inLength) {  		throw new NotEnoughDataException (currentOutSize' decompressedLength);  	}  	int byte1 = buffer [compressedSize - 1 - readBytes];  	readBytes++;  	int byte2 = buffer [compressedSize - 1 - readBytes];  	readBytes++;  	// the number of bytes to copy  	int length = byte1 >> 4;  	length += 3;  	// from where the bytes should be copied (relatively)  	int disp = ((byte1 & 0x0F) << 8) | byte2;  	disp += 3;  	if (disp > currentOutSize) {  		if (currentOutSize < 2)  			throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  		// HACK. this seems to produce valid files' but isn't the most elegant solution.  		// although this _could_ be the actual way to use a disp of 2 in this format'  		// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  		disp = 2;  	}  	#endregion  	int bufIdx = currentOutSize - disp;  	for (int i = 0; i < length; i++) {  		byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  		bufIdx++;  		outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  		currentOutSize++;  	}  } else {  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedLength);  	byte next = buffer [buffer.Length - 1 - readBytes];  	readBytes++;  	outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  	currentOutSize++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: if ((flags & mask) > 0) {  	// (throws when < 2 bytes are available)  	#region Get length and displacement('disp') values from next 2 bytes  	// there are < 2 bytes available when the end is at most 1 byte away  	if (readBytes + 1 >= inLength) {  		throw new NotEnoughDataException (currentOutSize' decompressedLength);  	}  	int byte1 = buffer [compressedSize - 1 - readBytes];  	readBytes++;  	int byte2 = buffer [compressedSize - 1 - readBytes];  	readBytes++;  	// the number of bytes to copy  	int length = byte1 >> 4;  	length += 3;  	// from where the bytes should be copied (relatively)  	int disp = ((byte1 & 0x0F) << 8) | byte2;  	disp += 3;  	if (disp > currentOutSize) {  		if (currentOutSize < 2)  			throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  		// HACK. this seems to produce valid files' but isn't the most elegant solution.  		// although this _could_ be the actual way to use a disp of 2 in this format'  		// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  		disp = 2;  	}  	#endregion  	int bufIdx = currentOutSize - disp;  	for (int i = 0; i < length; i++) {  		byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  		bufIdx++;  		outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  		currentOutSize++;  	}  } else {  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedLength);  	byte next = buffer [buffer.Length - 1 - readBytes];  	readBytes++;  	outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  	currentOutSize++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: if ((flags & mask) > 0) {  	// (throws when < 2 bytes are available)  	#region Get length and displacement('disp') values from next 2 bytes  	// there are < 2 bytes available when the end is at most 1 byte away  	if (readBytes + 1 >= inLength) {  		throw new NotEnoughDataException (currentOutSize' decompressedLength);  	}  	int byte1 = buffer [compressedSize - 1 - readBytes];  	readBytes++;  	int byte2 = buffer [compressedSize - 1 - readBytes];  	readBytes++;  	// the number of bytes to copy  	int length = byte1 >> 4;  	length += 3;  	// from where the bytes should be copied (relatively)  	int disp = ((byte1 & 0x0F) << 8) | byte2;  	disp += 3;  	if (disp > currentOutSize) {  		if (currentOutSize < 2)  			throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  		// HACK. this seems to produce valid files' but isn't the most elegant solution.  		// although this _could_ be the actual way to use a disp of 2 in this format'  		// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  		disp = 2;  	}  	#endregion  	int bufIdx = currentOutSize - disp;  	for (int i = 0; i < length; i++) {  		byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  		bufIdx++;  		outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  		currentOutSize++;  	}  } else {  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedLength);  	byte next = buffer [buffer.Length - 1 - readBytes];  	readBytes++;  	outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  	currentOutSize++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: if ((flags & mask) > 0) {  	// (throws when < 2 bytes are available)  	#region Get length and displacement('disp') values from next 2 bytes  	// there are < 2 bytes available when the end is at most 1 byte away  	if (readBytes + 1 >= inLength) {  		throw new NotEnoughDataException (currentOutSize' decompressedLength);  	}  	int byte1 = buffer [compressedSize - 1 - readBytes];  	readBytes++;  	int byte2 = buffer [compressedSize - 1 - readBytes];  	readBytes++;  	// the number of bytes to copy  	int length = byte1 >> 4;  	length += 3;  	// from where the bytes should be copied (relatively)  	int disp = ((byte1 & 0x0F) << 8) | byte2;  	disp += 3;  	if (disp > currentOutSize) {  		if (currentOutSize < 2)  			throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  		// HACK. this seems to produce valid files' but isn't the most elegant solution.  		// although this _could_ be the actual way to use a disp of 2 in this format'  		// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  		disp = 2;  	}  	#endregion  	int bufIdx = currentOutSize - disp;  	for (int i = 0; i < length; i++) {  		byte next = outbuffer [outbuffer.Length - 1 - bufIdx];  		bufIdx++;  		outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  		currentOutSize++;  	}  } else {  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedLength);  	byte next = buffer [buffer.Length - 1 - readBytes];  	readBytes++;  	outbuffer [outbuffer.Length - 1 - currentOutSize] = next;  	currentOutSize++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: length += 3;  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: disp += 3;  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: if (disp > currentOutSize) {  	if (currentOutSize < 2)  		throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  	// HACK. this seems to produce valid files' but isn't the most elegant solution.  	// although this _could_ be the actual way to use a disp of 2 in this format'  	// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  	disp = 2;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: if (disp > currentOutSize) {  	if (currentOutSize < 2)  		throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  	// HACK. this seems to produce valid files' but isn't the most elegant solution.  	// although this _could_ be the actual way to use a disp of 2 in this format'  	// as otherwise the minimum would be 3 (and 0 is undefined' and 1 is less useful).  	disp = 2;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: if (currentOutSize < 2)  	throw new InvalidDataException (String.Format (Main.Get_Traduction ("S0D")' disp.ToString ("X")' currentOutSize.ToString ("X")));  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Decompress,The following statement contains a magic number: disp = 2;  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Compress,The following statement contains a magic number: if (totalCompFileLength % 4 != 0)  	totalCompFileLength += 4 - totalCompFileLength % 4;  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Compress,The following statement contains a magic number: if (totalCompFileLength % 4 != 0)  	totalCompFileLength += 4 - totalCompFileLength % 4;  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Compress,The following statement contains a magic number: if (totalCompFileLength % 4 != 0)  	totalCompFileLength += 4 - totalCompFileLength % 4;  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Compress,The following statement contains a magic number: totalCompFileLength += 4 - totalCompFileLength % 4;  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Compress,The following statement contains a magic number: totalCompFileLength += 4 - totalCompFileLength % 4;  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Compress,The following statement contains a magic number: if (totalCompFileLength < inLength) {  	byte[] compData = outMemStream.ToArray ();  	Array.Reverse (compData);  	outstream.Write (compData' 0' compData.Length);  	int writtenBytes = compData.Length;  	// there always seem to be some padding FFs. Let's pad to make the file 4-byte aligned  	while (writtenBytes % 4 != 0) {  		outstream.WriteByte (0xFF);  		writtenBytes++;  	}  	outstream.WriteByte ((byte)((compressedLength) & 0xFF));  	outstream.WriteByte ((byte)((compressedLength >> 8) & 0xFF));  	outstream.WriteByte ((byte)((compressedLength >> 16) & 0xFF));  	int headerLength = totalCompFileLength - compData.Length;  	outstream.WriteByte ((byte)headerLength);  	int extraSize = (int)inLength - totalCompFileLength;  	outstream.WriteByte ((byte)((extraSize) & 0xFF));  	outstream.WriteByte ((byte)((extraSize >> 8) & 0xFF));  	outstream.WriteByte ((byte)((extraSize >> 16) & 0xFF));  	outstream.WriteByte ((byte)((extraSize >> 24) & 0xFF));  	return totalCompFileLength;  } else {  	Array.Reverse (indata);  	outstream.Write (indata' 0' (int)inLength);  	outstream.WriteByte (0);  	outstream.WriteByte (0);  	outstream.WriteByte (0);  	outstream.WriteByte (0);  	return (int)inLength + 4;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Compress,The following statement contains a magic number: if (totalCompFileLength < inLength) {  	byte[] compData = outMemStream.ToArray ();  	Array.Reverse (compData);  	outstream.Write (compData' 0' compData.Length);  	int writtenBytes = compData.Length;  	// there always seem to be some padding FFs. Let's pad to make the file 4-byte aligned  	while (writtenBytes % 4 != 0) {  		outstream.WriteByte (0xFF);  		writtenBytes++;  	}  	outstream.WriteByte ((byte)((compressedLength) & 0xFF));  	outstream.WriteByte ((byte)((compressedLength >> 8) & 0xFF));  	outstream.WriteByte ((byte)((compressedLength >> 16) & 0xFF));  	int headerLength = totalCompFileLength - compData.Length;  	outstream.WriteByte ((byte)headerLength);  	int extraSize = (int)inLength - totalCompFileLength;  	outstream.WriteByte ((byte)((extraSize) & 0xFF));  	outstream.WriteByte ((byte)((extraSize >> 8) & 0xFF));  	outstream.WriteByte ((byte)((extraSize >> 16) & 0xFF));  	outstream.WriteByte ((byte)((extraSize >> 24) & 0xFF));  	return totalCompFileLength;  } else {  	Array.Reverse (indata);  	outstream.Write (indata' 0' (int)inLength);  	outstream.WriteByte (0);  	outstream.WriteByte (0);  	outstream.WriteByte (0);  	outstream.WriteByte (0);  	return (int)inLength + 4;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Compress,The following statement contains a magic number: if (totalCompFileLength < inLength) {  	byte[] compData = outMemStream.ToArray ();  	Array.Reverse (compData);  	outstream.Write (compData' 0' compData.Length);  	int writtenBytes = compData.Length;  	// there always seem to be some padding FFs. Let's pad to make the file 4-byte aligned  	while (writtenBytes % 4 != 0) {  		outstream.WriteByte (0xFF);  		writtenBytes++;  	}  	outstream.WriteByte ((byte)((compressedLength) & 0xFF));  	outstream.WriteByte ((byte)((compressedLength >> 8) & 0xFF));  	outstream.WriteByte ((byte)((compressedLength >> 16) & 0xFF));  	int headerLength = totalCompFileLength - compData.Length;  	outstream.WriteByte ((byte)headerLength);  	int extraSize = (int)inLength - totalCompFileLength;  	outstream.WriteByte ((byte)((extraSize) & 0xFF));  	outstream.WriteByte ((byte)((extraSize >> 8) & 0xFF));  	outstream.WriteByte ((byte)((extraSize >> 16) & 0xFF));  	outstream.WriteByte ((byte)((extraSize >> 24) & 0xFF));  	return totalCompFileLength;  } else {  	Array.Reverse (indata);  	outstream.Write (indata' 0' (int)inLength);  	outstream.WriteByte (0);  	outstream.WriteByte (0);  	outstream.WriteByte (0);  	outstream.WriteByte (0);  	return (int)inLength + 4;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Compress,The following statement contains a magic number: if (totalCompFileLength < inLength) {  	byte[] compData = outMemStream.ToArray ();  	Array.Reverse (compData);  	outstream.Write (compData' 0' compData.Length);  	int writtenBytes = compData.Length;  	// there always seem to be some padding FFs. Let's pad to make the file 4-byte aligned  	while (writtenBytes % 4 != 0) {  		outstream.WriteByte (0xFF);  		writtenBytes++;  	}  	outstream.WriteByte ((byte)((compressedLength) & 0xFF));  	outstream.WriteByte ((byte)((compressedLength >> 8) & 0xFF));  	outstream.WriteByte ((byte)((compressedLength >> 16) & 0xFF));  	int headerLength = totalCompFileLength - compData.Length;  	outstream.WriteByte ((byte)headerLength);  	int extraSize = (int)inLength - totalCompFileLength;  	outstream.WriteByte ((byte)((extraSize) & 0xFF));  	outstream.WriteByte ((byte)((extraSize >> 8) & 0xFF));  	outstream.WriteByte ((byte)((extraSize >> 16) & 0xFF));  	outstream.WriteByte ((byte)((extraSize >> 24) & 0xFF));  	return totalCompFileLength;  } else {  	Array.Reverse (indata);  	outstream.Write (indata' 0' (int)inLength);  	outstream.WriteByte (0);  	outstream.WriteByte (0);  	outstream.WriteByte (0);  	outstream.WriteByte (0);  	return (int)inLength + 4;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Compress,The following statement contains a magic number: if (totalCompFileLength < inLength) {  	byte[] compData = outMemStream.ToArray ();  	Array.Reverse (compData);  	outstream.Write (compData' 0' compData.Length);  	int writtenBytes = compData.Length;  	// there always seem to be some padding FFs. Let's pad to make the file 4-byte aligned  	while (writtenBytes % 4 != 0) {  		outstream.WriteByte (0xFF);  		writtenBytes++;  	}  	outstream.WriteByte ((byte)((compressedLength) & 0xFF));  	outstream.WriteByte ((byte)((compressedLength >> 8) & 0xFF));  	outstream.WriteByte ((byte)((compressedLength >> 16) & 0xFF));  	int headerLength = totalCompFileLength - compData.Length;  	outstream.WriteByte ((byte)headerLength);  	int extraSize = (int)inLength - totalCompFileLength;  	outstream.WriteByte ((byte)((extraSize) & 0xFF));  	outstream.WriteByte ((byte)((extraSize >> 8) & 0xFF));  	outstream.WriteByte ((byte)((extraSize >> 16) & 0xFF));  	outstream.WriteByte ((byte)((extraSize >> 24) & 0xFF));  	return totalCompFileLength;  } else {  	Array.Reverse (indata);  	outstream.Write (indata' 0' (int)inLength);  	outstream.WriteByte (0);  	outstream.WriteByte (0);  	outstream.WriteByte (0);  	outstream.WriteByte (0);  	return (int)inLength + 4;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Compress,The following statement contains a magic number: if (totalCompFileLength < inLength) {  	byte[] compData = outMemStream.ToArray ();  	Array.Reverse (compData);  	outstream.Write (compData' 0' compData.Length);  	int writtenBytes = compData.Length;  	// there always seem to be some padding FFs. Let's pad to make the file 4-byte aligned  	while (writtenBytes % 4 != 0) {  		outstream.WriteByte (0xFF);  		writtenBytes++;  	}  	outstream.WriteByte ((byte)((compressedLength) & 0xFF));  	outstream.WriteByte ((byte)((compressedLength >> 8) & 0xFF));  	outstream.WriteByte ((byte)((compressedLength >> 16) & 0xFF));  	int headerLength = totalCompFileLength - compData.Length;  	outstream.WriteByte ((byte)headerLength);  	int extraSize = (int)inLength - totalCompFileLength;  	outstream.WriteByte ((byte)((extraSize) & 0xFF));  	outstream.WriteByte ((byte)((extraSize >> 8) & 0xFF));  	outstream.WriteByte ((byte)((extraSize >> 16) & 0xFF));  	outstream.WriteByte ((byte)((extraSize >> 24) & 0xFF));  	return totalCompFileLength;  } else {  	Array.Reverse (indata);  	outstream.Write (indata' 0' (int)inLength);  	outstream.WriteByte (0);  	outstream.WriteByte (0);  	outstream.WriteByte (0);  	outstream.WriteByte (0);  	return (int)inLength + 4;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Compress,The following statement contains a magic number: if (totalCompFileLength < inLength) {  	byte[] compData = outMemStream.ToArray ();  	Array.Reverse (compData);  	outstream.Write (compData' 0' compData.Length);  	int writtenBytes = compData.Length;  	// there always seem to be some padding FFs. Let's pad to make the file 4-byte aligned  	while (writtenBytes % 4 != 0) {  		outstream.WriteByte (0xFF);  		writtenBytes++;  	}  	outstream.WriteByte ((byte)((compressedLength) & 0xFF));  	outstream.WriteByte ((byte)((compressedLength >> 8) & 0xFF));  	outstream.WriteByte ((byte)((compressedLength >> 16) & 0xFF));  	int headerLength = totalCompFileLength - compData.Length;  	outstream.WriteByte ((byte)headerLength);  	int extraSize = (int)inLength - totalCompFileLength;  	outstream.WriteByte ((byte)((extraSize) & 0xFF));  	outstream.WriteByte ((byte)((extraSize >> 8) & 0xFF));  	outstream.WriteByte ((byte)((extraSize >> 16) & 0xFF));  	outstream.WriteByte ((byte)((extraSize >> 24) & 0xFF));  	return totalCompFileLength;  } else {  	Array.Reverse (indata);  	outstream.Write (indata' 0' (int)inLength);  	outstream.WriteByte (0);  	outstream.WriteByte (0);  	outstream.WriteByte (0);  	outstream.WriteByte (0);  	return (int)inLength + 4;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Compress,The following statement contains a magic number: while (writtenBytes % 4 != 0) {  	outstream.WriteByte (0xFF);  	writtenBytes++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Compress,The following statement contains a magic number: outstream.WriteByte ((byte)((compressedLength >> 8) & 0xFF));  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Compress,The following statement contains a magic number: outstream.WriteByte ((byte)((compressedLength >> 16) & 0xFF));  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Compress,The following statement contains a magic number: outstream.WriteByte ((byte)((extraSize >> 8) & 0xFF));  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Compress,The following statement contains a magic number: outstream.WriteByte ((byte)((extraSize >> 16) & 0xFF));  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Compress,The following statement contains a magic number: outstream.WriteByte ((byte)((extraSize >> 24) & 0xFF));  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,Compress,The following statement contains a magic number: return (int)inLength + 4;  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1001);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  		// disp = 1 cannot be stored.  		if (disp == 1) {  			length = 1;  		} // disp = 2 cannot be saved properly. use a too large disp instead.  		// however since I'm not sure if that's actually how that's handled' don't compress instead.  		else if (disp == 2) {  			length = 1;  			/*if (readBytes < 0x1001)                             disp = readBytes + 1;                         else                             length = 1;/**/}  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disp - 3) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 3) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1001);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  		// disp = 1 cannot be stored.  		if (disp == 1) {  			length = 1;  		} // disp = 2 cannot be saved properly. use a too large disp instead.  		// however since I'm not sure if that's actually how that's handled' don't compress instead.  		else if (disp == 2) {  			length = 1;  			/*if (readBytes < 0x1001)                             disp = readBytes + 1;                         else                             length = 1;/**/}  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disp - 3) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 3) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1001);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  		// disp = 1 cannot be stored.  		if (disp == 1) {  			length = 1;  		} // disp = 2 cannot be saved properly. use a too large disp instead.  		// however since I'm not sure if that's actually how that's handled' don't compress instead.  		else if (disp == 2) {  			length = 1;  			/*if (readBytes < 0x1001)                             disp = readBytes + 1;                         else                             length = 1;/**/}  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disp - 3) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 3) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1001);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  		// disp = 1 cannot be stored.  		if (disp == 1) {  			length = 1;  		} // disp = 2 cannot be saved properly. use a too large disp instead.  		// however since I'm not sure if that's actually how that's handled' don't compress instead.  		else if (disp == 2) {  			length = 1;  			/*if (readBytes < 0x1001)                             disp = readBytes + 1;                         else                             length = 1;/**/}  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disp - 3) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 3) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1001);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  		// disp = 1 cannot be stored.  		if (disp == 1) {  			length = 1;  		} // disp = 2 cannot be saved properly. use a too large disp instead.  		// however since I'm not sure if that's actually how that's handled' don't compress instead.  		else if (disp == 2) {  			length = 1;  			/*if (readBytes < 0x1001)                             disp = readBytes + 1;                         else                             length = 1;/**/}  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disp - 3) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 3) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1001);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  		// disp = 1 cannot be stored.  		if (disp == 1) {  			length = 1;  		} // disp = 2 cannot be saved properly. use a too large disp instead.  		// however since I'm not sure if that's actually how that's handled' don't compress instead.  		else if (disp == 2) {  			length = 1;  			/*if (readBytes < 0x1001)                             disp = readBytes + 1;                         else                             length = 1;/**/}  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disp - 3) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 3) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1001);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  		// disp = 1 cannot be stored.  		if (disp == 1) {  			length = 1;  		} // disp = 2 cannot be saved properly. use a too large disp instead.  		// however since I'm not sure if that's actually how that's handled' don't compress instead.  		else if (disp == 2) {  			length = 1;  			/*if (readBytes < 0x1001)                             disp = readBytes + 1;                         else                             length = 1;/**/}  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disp - 3) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 3) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1001);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  		// disp = 1 cannot be stored.  		if (disp == 1) {  			length = 1;  		} // disp = 2 cannot be saved properly. use a too large disp instead.  		// however since I'm not sure if that's actually how that's handled' don't compress instead.  		else if (disp == 2) {  			length = 1;  			/*if (readBytes < 0x1001)                             disp = readBytes + 1;                         else                             length = 1;/**/}  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disp - 3) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 3) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1001);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  		// disp = 1 cannot be stored.  		if (disp == 1) {  			length = 1;  		} // disp = 2 cannot be saved properly. use a too large disp instead.  		// however since I'm not sure if that's actually how that's handled' don't compress instead.  		else if (disp == 2) {  			length = 1;  			/*if (readBytes < 0x1001)                             disp = readBytes + 1;                         else                             length = 1;/**/}  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disp - 3) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 3) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1001);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  		// disp = 1 cannot be stored.  		if (disp == 1) {  			length = 1;  		} // disp = 2 cannot be saved properly. use a too large disp instead.  		// however since I'm not sure if that's actually how that's handled' don't compress instead.  		else if (disp == 2) {  			length = 1;  			/*if (readBytes < 0x1001)                             disp = readBytes + 1;                         else                             length = 1;/**/}  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disp - 3) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 3) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1001);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  		// disp = 1 cannot be stored.  		if (disp == 1) {  			length = 1;  		} // disp = 2 cannot be saved properly. use a too large disp instead.  		// however since I'm not sure if that's actually how that's handled' don't compress instead.  		else if (disp == 2) {  			length = 1;  			/*if (readBytes < 0x1001)                             disp = readBytes + 1;                         else                             length = 1;/**/}  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disp - 3) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 3) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: while (readBytes < inLength) {  	#region If 8 blocks are bufferd' write them and reset the buffer  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	#endregion  	// determine if we're dealing with a compressed or raw block.  	// it is a compressed block when the next 3 or more bytes can be copied from  	// somewhere in the set of already compressed bytes.  	int disp;  	int oldLength = Math.Min (readBytes' 0x1001);  	int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  	// disp = 1 cannot be stored.  	if (disp == 1) {  		length = 1;  	} // disp = 2 cannot be saved properly. use a too large disp instead.  	// however since I'm not sure if that's actually how that's handled' don't compress instead.  	else if (disp == 2) {  		length = 1;  		/*if (readBytes < 0x1001)                             disp = readBytes + 1;                         else                             length = 1;/**/}  	// length not 3 or more? next byte is raw data  	if (length < 3) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  		readBytes += length;  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  		outbuffer [bufferlength] |= (byte)(((disp - 3) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disp - 3) & 0xFF);  		bufferlength++;  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: while (readBytes < inLength) {  	#region If 8 blocks are bufferd' write them and reset the buffer  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	#endregion  	// determine if we're dealing with a compressed or raw block.  	// it is a compressed block when the next 3 or more bytes can be copied from  	// somewhere in the set of already compressed bytes.  	int disp;  	int oldLength = Math.Min (readBytes' 0x1001);  	int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  	// disp = 1 cannot be stored.  	if (disp == 1) {  		length = 1;  	} // disp = 2 cannot be saved properly. use a too large disp instead.  	// however since I'm not sure if that's actually how that's handled' don't compress instead.  	else if (disp == 2) {  		length = 1;  		/*if (readBytes < 0x1001)                             disp = readBytes + 1;                         else                             length = 1;/**/}  	// length not 3 or more? next byte is raw data  	if (length < 3) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  		readBytes += length;  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  		outbuffer [bufferlength] |= (byte)(((disp - 3) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disp - 3) & 0xFF);  		bufferlength++;  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: while (readBytes < inLength) {  	#region If 8 blocks are bufferd' write them and reset the buffer  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	#endregion  	// determine if we're dealing with a compressed or raw block.  	// it is a compressed block when the next 3 or more bytes can be copied from  	// somewhere in the set of already compressed bytes.  	int disp;  	int oldLength = Math.Min (readBytes' 0x1001);  	int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  	// disp = 1 cannot be stored.  	if (disp == 1) {  		length = 1;  	} // disp = 2 cannot be saved properly. use a too large disp instead.  	// however since I'm not sure if that's actually how that's handled' don't compress instead.  	else if (disp == 2) {  		length = 1;  		/*if (readBytes < 0x1001)                             disp = readBytes + 1;                         else                             length = 1;/**/}  	// length not 3 or more? next byte is raw data  	if (length < 3) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  		readBytes += length;  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  		outbuffer [bufferlength] |= (byte)(((disp - 3) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disp - 3) & 0xFF);  		bufferlength++;  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: while (readBytes < inLength) {  	#region If 8 blocks are bufferd' write them and reset the buffer  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	#endregion  	// determine if we're dealing with a compressed or raw block.  	// it is a compressed block when the next 3 or more bytes can be copied from  	// somewhere in the set of already compressed bytes.  	int disp;  	int oldLength = Math.Min (readBytes' 0x1001);  	int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  	// disp = 1 cannot be stored.  	if (disp == 1) {  		length = 1;  	} // disp = 2 cannot be saved properly. use a too large disp instead.  	// however since I'm not sure if that's actually how that's handled' don't compress instead.  	else if (disp == 2) {  		length = 1;  		/*if (readBytes < 0x1001)                             disp = readBytes + 1;                         else                             length = 1;/**/}  	// length not 3 or more? next byte is raw data  	if (length < 3) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  		readBytes += length;  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  		outbuffer [bufferlength] |= (byte)(((disp - 3) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disp - 3) & 0xFF);  		bufferlength++;  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: while (readBytes < inLength) {  	#region If 8 blocks are bufferd' write them and reset the buffer  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	#endregion  	// determine if we're dealing with a compressed or raw block.  	// it is a compressed block when the next 3 or more bytes can be copied from  	// somewhere in the set of already compressed bytes.  	int disp;  	int oldLength = Math.Min (readBytes' 0x1001);  	int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  	// disp = 1 cannot be stored.  	if (disp == 1) {  		length = 1;  	} // disp = 2 cannot be saved properly. use a too large disp instead.  	// however since I'm not sure if that's actually how that's handled' don't compress instead.  	else if (disp == 2) {  		length = 1;  		/*if (readBytes < 0x1001)                             disp = readBytes + 1;                         else                             length = 1;/**/}  	// length not 3 or more? next byte is raw data  	if (length < 3) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  		readBytes += length;  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  		outbuffer [bufferlength] |= (byte)(((disp - 3) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disp - 3) & 0xFF);  		bufferlength++;  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: while (readBytes < inLength) {  	#region If 8 blocks are bufferd' write them and reset the buffer  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	#endregion  	// determine if we're dealing with a compressed or raw block.  	// it is a compressed block when the next 3 or more bytes can be copied from  	// somewhere in the set of already compressed bytes.  	int disp;  	int oldLength = Math.Min (readBytes' 0x1001);  	int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  	// disp = 1 cannot be stored.  	if (disp == 1) {  		length = 1;  	} // disp = 2 cannot be saved properly. use a too large disp instead.  	// however since I'm not sure if that's actually how that's handled' don't compress instead.  	else if (disp == 2) {  		length = 1;  		/*if (readBytes < 0x1001)                             disp = readBytes + 1;                         else                             length = 1;/**/}  	// length not 3 or more? next byte is raw data  	if (length < 3) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  		readBytes += length;  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  		outbuffer [bufferlength] |= (byte)(((disp - 3) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disp - 3) & 0xFF);  		bufferlength++;  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: while (readBytes < inLength) {  	#region If 8 blocks are bufferd' write them and reset the buffer  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	#endregion  	// determine if we're dealing with a compressed or raw block.  	// it is a compressed block when the next 3 or more bytes can be copied from  	// somewhere in the set of already compressed bytes.  	int disp;  	int oldLength = Math.Min (readBytes' 0x1001);  	int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  	// disp = 1 cannot be stored.  	if (disp == 1) {  		length = 1;  	} // disp = 2 cannot be saved properly. use a too large disp instead.  	// however since I'm not sure if that's actually how that's handled' don't compress instead.  	else if (disp == 2) {  		length = 1;  		/*if (readBytes < 0x1001)                             disp = readBytes + 1;                         else                             length = 1;/**/}  	// length not 3 or more? next byte is raw data  	if (length < 3) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  		readBytes += length;  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  		outbuffer [bufferlength] |= (byte)(((disp - 3) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disp - 3) & 0xFF);  		bufferlength++;  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: while (readBytes < inLength) {  	#region If 8 blocks are bufferd' write them and reset the buffer  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	#endregion  	// determine if we're dealing with a compressed or raw block.  	// it is a compressed block when the next 3 or more bytes can be copied from  	// somewhere in the set of already compressed bytes.  	int disp;  	int oldLength = Math.Min (readBytes' 0x1001);  	int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  	// disp = 1 cannot be stored.  	if (disp == 1) {  		length = 1;  	} // disp = 2 cannot be saved properly. use a too large disp instead.  	// however since I'm not sure if that's actually how that's handled' don't compress instead.  	else if (disp == 2) {  		length = 1;  		/*if (readBytes < 0x1001)                             disp = readBytes + 1;                         else                             length = 1;/**/}  	// length not 3 or more? next byte is raw data  	if (length < 3) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  		readBytes += length;  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  		outbuffer [bufferlength] |= (byte)(((disp - 3) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disp - 3) & 0xFF);  		bufferlength++;  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: while (readBytes < inLength) {  	#region If 8 blocks are bufferd' write them and reset the buffer  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	#endregion  	// determine if we're dealing with a compressed or raw block.  	// it is a compressed block when the next 3 or more bytes can be copied from  	// somewhere in the set of already compressed bytes.  	int disp;  	int oldLength = Math.Min (readBytes' 0x1001);  	int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  	// disp = 1 cannot be stored.  	if (disp == 1) {  		length = 1;  	} // disp = 2 cannot be saved properly. use a too large disp instead.  	// however since I'm not sure if that's actually how that's handled' don't compress instead.  	else if (disp == 2) {  		length = 1;  		/*if (readBytes < 0x1001)                             disp = readBytes + 1;                         else                             length = 1;/**/}  	// length not 3 or more? next byte is raw data  	if (length < 3) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  		readBytes += length;  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  		outbuffer [bufferlength] |= (byte)(((disp - 3) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disp - 3) & 0xFF);  		bufferlength++;  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: if (bufferedBlocks == 8) {  	outstream.Write (outbuffer' 0' bufferlength);  	compressedLength += bufferlength;  	// reset the buffer  	outbuffer [0] = 0;  	bufferlength = 1;  	bufferedBlocks = 0;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: if (disp == 1) {  	length = 1;  } // disp = 2 cannot be saved properly. use a too large disp instead.  // however since I'm not sure if that's actually how that's handled' don't compress instead.  else if (disp == 2) {  	length = 1;  	/*if (readBytes < 0x1001)                             disp = readBytes + 1;                         else                             length = 1;/**/}  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: if (disp == 2) {  	length = 1;  	/*if (readBytes < 0x1001)                             disp = readBytes + 1;                         else                             length = 1;/**/}  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: if (length < 3) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  	readBytes += length;  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  	outbuffer [bufferlength] |= (byte)(((disp - 3) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disp - 3) & 0xFF);  	bufferlength++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: if (length < 3) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  	readBytes += length;  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  	outbuffer [bufferlength] |= (byte)(((disp - 3) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disp - 3) & 0xFF);  	bufferlength++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: if (length < 3) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  	readBytes += length;  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  	outbuffer [bufferlength] |= (byte)(((disp - 3) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disp - 3) & 0xFF);  	bufferlength++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: if (length < 3) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  	readBytes += length;  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  	outbuffer [bufferlength] |= (byte)(((disp - 3) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disp - 3) & 0xFF);  	bufferlength++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: if (length < 3) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  	readBytes += length;  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  	outbuffer [bufferlength] |= (byte)(((disp - 3) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disp - 3) & 0xFF);  	bufferlength++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: if (length < 3) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  	readBytes += length;  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  	outbuffer [bufferlength] |= (byte)(((disp - 3) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disp - 3) & 0xFF);  	bufferlength++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: if (length < 3) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  	readBytes += length;  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  	outbuffer [bufferlength] |= (byte)(((disp - 3) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disp - 3) & 0xFF);  	bufferlength++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: outbuffer [bufferlength] |= (byte)(((disp - 3) >> 8) & 0x0F);  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: outbuffer [bufferlength] |= (byte)(((disp - 3) >> 8) & 0x0F);  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressNormal,The following statement contains a magic number: outbuffer [bufferlength] = (byte)((disp - 3) & 0xFF);  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressWithLA,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	// get the optimal choices for len and disp  	int[] lengths' disps;  	this.GetOptimalCompressionLengths (instart' indata.Length' out lengths' out disps);  	int optCompressionLength = this.GetOptimalCompressionPartLength (lengths);  	while (readBytes < optCompressionLength) {  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		if (lengths [readBytes] == 1) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 3) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disps [readBytes] - 3) & 0xFF);  			bufferlength++;  			readBytes += lengths [readBytes];  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  	}  	while (readBytes < inLength)  		outstream.WriteByte (*(instart + (readBytes++)));  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressWithLA,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	// get the optimal choices for len and disp  	int[] lengths' disps;  	this.GetOptimalCompressionLengths (instart' indata.Length' out lengths' out disps);  	int optCompressionLength = this.GetOptimalCompressionPartLength (lengths);  	while (readBytes < optCompressionLength) {  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		if (lengths [readBytes] == 1) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 3) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disps [readBytes] - 3) & 0xFF);  			bufferlength++;  			readBytes += lengths [readBytes];  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  	}  	while (readBytes < inLength)  		outstream.WriteByte (*(instart + (readBytes++)));  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressWithLA,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	// get the optimal choices for len and disp  	int[] lengths' disps;  	this.GetOptimalCompressionLengths (instart' indata.Length' out lengths' out disps);  	int optCompressionLength = this.GetOptimalCompressionPartLength (lengths);  	while (readBytes < optCompressionLength) {  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		if (lengths [readBytes] == 1) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 3) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disps [readBytes] - 3) & 0xFF);  			bufferlength++;  			readBytes += lengths [readBytes];  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  	}  	while (readBytes < inLength)  		outstream.WriteByte (*(instart + (readBytes++)));  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressWithLA,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	// get the optimal choices for len and disp  	int[] lengths' disps;  	this.GetOptimalCompressionLengths (instart' indata.Length' out lengths' out disps);  	int optCompressionLength = this.GetOptimalCompressionPartLength (lengths);  	while (readBytes < optCompressionLength) {  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		if (lengths [readBytes] == 1) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 3) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disps [readBytes] - 3) & 0xFF);  			bufferlength++;  			readBytes += lengths [readBytes];  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  	}  	while (readBytes < inLength)  		outstream.WriteByte (*(instart + (readBytes++)));  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressWithLA,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	// get the optimal choices for len and disp  	int[] lengths' disps;  	this.GetOptimalCompressionLengths (instart' indata.Length' out lengths' out disps);  	int optCompressionLength = this.GetOptimalCompressionPartLength (lengths);  	while (readBytes < optCompressionLength) {  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		if (lengths [readBytes] == 1) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 3) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disps [readBytes] - 3) & 0xFF);  			bufferlength++;  			readBytes += lengths [readBytes];  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  	}  	while (readBytes < inLength)  		outstream.WriteByte (*(instart + (readBytes++)));  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressWithLA,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	// get the optimal choices for len and disp  	int[] lengths' disps;  	this.GetOptimalCompressionLengths (instart' indata.Length' out lengths' out disps);  	int optCompressionLength = this.GetOptimalCompressionPartLength (lengths);  	while (readBytes < optCompressionLength) {  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		if (lengths [readBytes] == 1) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 3) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disps [readBytes] - 3) & 0xFF);  			bufferlength++;  			readBytes += lengths [readBytes];  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  	}  	while (readBytes < inLength)  		outstream.WriteByte (*(instart + (readBytes++)));  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressWithLA,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	// get the optimal choices for len and disp  	int[] lengths' disps;  	this.GetOptimalCompressionLengths (instart' indata.Length' out lengths' out disps);  	int optCompressionLength = this.GetOptimalCompressionPartLength (lengths);  	while (readBytes < optCompressionLength) {  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		if (lengths [readBytes] == 1) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 3) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disps [readBytes] - 3) & 0xFF);  			bufferlength++;  			readBytes += lengths [readBytes];  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  	}  	while (readBytes < inLength)  		outstream.WriteByte (*(instart + (readBytes++)));  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressWithLA,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	// get the optimal choices for len and disp  	int[] lengths' disps;  	this.GetOptimalCompressionLengths (instart' indata.Length' out lengths' out disps);  	int optCompressionLength = this.GetOptimalCompressionPartLength (lengths);  	while (readBytes < optCompressionLength) {  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		if (lengths [readBytes] == 1) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 3) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disps [readBytes] - 3) & 0xFF);  			bufferlength++;  			readBytes += lengths [readBytes];  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  	}  	while (readBytes < inLength)  		outstream.WriteByte (*(instart + (readBytes++)));  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressWithLA,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	// get the optimal choices for len and disp  	int[] lengths' disps;  	this.GetOptimalCompressionLengths (instart' indata.Length' out lengths' out disps);  	int optCompressionLength = this.GetOptimalCompressionPartLength (lengths);  	while (readBytes < optCompressionLength) {  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		if (lengths [readBytes] == 1) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 3) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disps [readBytes] - 3) & 0xFF);  			bufferlength++;  			readBytes += lengths [readBytes];  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  	}  	while (readBytes < inLength)  		outstream.WriteByte (*(instart + (readBytes++)));  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressWithLA,The following statement contains a magic number: while (readBytes < optCompressionLength) {  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	if (lengths [readBytes] == 1) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  		outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 3) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disps [readBytes] - 3) & 0xFF);  		bufferlength++;  		readBytes += lengths [readBytes];  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressWithLA,The following statement contains a magic number: while (readBytes < optCompressionLength) {  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	if (lengths [readBytes] == 1) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  		outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 3) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disps [readBytes] - 3) & 0xFF);  		bufferlength++;  		readBytes += lengths [readBytes];  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressWithLA,The following statement contains a magic number: while (readBytes < optCompressionLength) {  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	if (lengths [readBytes] == 1) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  		outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 3) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disps [readBytes] - 3) & 0xFF);  		bufferlength++;  		readBytes += lengths [readBytes];  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressWithLA,The following statement contains a magic number: while (readBytes < optCompressionLength) {  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	if (lengths [readBytes] == 1) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  		outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 3) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disps [readBytes] - 3) & 0xFF);  		bufferlength++;  		readBytes += lengths [readBytes];  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressWithLA,The following statement contains a magic number: while (readBytes < optCompressionLength) {  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	if (lengths [readBytes] == 1) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  		outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 3) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disps [readBytes] - 3) & 0xFF);  		bufferlength++;  		readBytes += lengths [readBytes];  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressWithLA,The following statement contains a magic number: while (readBytes < optCompressionLength) {  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	if (lengths [readBytes] == 1) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  		outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 3) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disps [readBytes] - 3) & 0xFF);  		bufferlength++;  		readBytes += lengths [readBytes];  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressWithLA,The following statement contains a magic number: while (readBytes < optCompressionLength) {  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	if (lengths [readBytes] == 1) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  		outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 3) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disps [readBytes] - 3) & 0xFF);  		bufferlength++;  		readBytes += lengths [readBytes];  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressWithLA,The following statement contains a magic number: if (bufferedBlocks == 8) {  	outstream.Write (outbuffer' 0' bufferlength);  	compressedLength += bufferlength;  	// reset the buffer  	outbuffer [0] = 0;  	bufferlength = 1;  	bufferedBlocks = 0;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressWithLA,The following statement contains a magic number: if (lengths [readBytes] == 1) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  	outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 3) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disps [readBytes] - 3) & 0xFF);  	bufferlength++;  	readBytes += lengths [readBytes];  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressWithLA,The following statement contains a magic number: if (lengths [readBytes] == 1) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  	outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 3) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disps [readBytes] - 3) & 0xFF);  	bufferlength++;  	readBytes += lengths [readBytes];  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressWithLA,The following statement contains a magic number: if (lengths [readBytes] == 1) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  	outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 3) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disps [readBytes] - 3) & 0xFF);  	bufferlength++;  	readBytes += lengths [readBytes];  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressWithLA,The following statement contains a magic number: if (lengths [readBytes] == 1) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  	outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 3) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disps [readBytes] - 3) & 0xFF);  	bufferlength++;  	readBytes += lengths [readBytes];  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressWithLA,The following statement contains a magic number: if (lengths [readBytes] == 1) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  	outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 3) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disps [readBytes] - 3) & 0xFF);  	bufferlength++;  	readBytes += lengths [readBytes];  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressWithLA,The following statement contains a magic number: if (lengths [readBytes] == 1) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  	outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 3) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disps [readBytes] - 3) & 0xFF);  	bufferlength++;  	readBytes += lengths [readBytes];  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressWithLA,The following statement contains a magic number: outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressWithLA,The following statement contains a magic number: outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressWithLA,The following statement contains a magic number: outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressWithLA,The following statement contains a magic number: outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 3) >> 8) & 0x0F);  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressWithLA,The following statement contains a magic number: outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 3) >> 8) & 0x0F);  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,CompressWithLA,The following statement contains a magic number: outbuffer [bufferlength] = (byte)((disps [readBytes] - 3) & 0xFF);  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionLengths,The following statement contains a magic number: for (int i = inLength - 1; i >= 0; i--) {  	// first get the compression length when the next byte is not compressed  	minLengths [i] = int.MaxValue;  	lengths [i] = 1;  	if (i + 1 >= inLength)  		minLengths [i] = 1;  	else  		minLengths [i] = 1 + minLengths [i + 1];  	// then the optimal compressed length  	int oldLength = Math.Min (0x1001' i);  	// get the appropriate disp while at it. Takes at most O(n) time if oldLength is considered O(n)  	// be sure to bound the input length with 0x12' as that's the maximum length for LZ-Ovl compressed blocks.  	int maxLen = LZUtil.GetOccurrenceLength (indata + i' Math.Min (inLength - i' 0x12)' indata + i - oldLength' oldLength' out disps [i]);  	if (disps [i] > i)  		throw new Exception (Main.Get_Traduction ("S02"));  	// disp < 3 cannot be stored explicitly.  	if (disps [i] < 3)  		maxLen = 1;  	for (int j = 3; j <= maxLen; j++) {  		int newCompLen;  		if (i + j >= inLength)  			newCompLen = 2;  		else  			newCompLen = 2 + minLengths [i + j];  		if (newCompLen < minLengths [i]) {  			lengths [i] = j;  			minLengths [i] = newCompLen;  		}  	}  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionLengths,The following statement contains a magic number: for (int i = inLength - 1; i >= 0; i--) {  	// first get the compression length when the next byte is not compressed  	minLengths [i] = int.MaxValue;  	lengths [i] = 1;  	if (i + 1 >= inLength)  		minLengths [i] = 1;  	else  		minLengths [i] = 1 + minLengths [i + 1];  	// then the optimal compressed length  	int oldLength = Math.Min (0x1001' i);  	// get the appropriate disp while at it. Takes at most O(n) time if oldLength is considered O(n)  	// be sure to bound the input length with 0x12' as that's the maximum length for LZ-Ovl compressed blocks.  	int maxLen = LZUtil.GetOccurrenceLength (indata + i' Math.Min (inLength - i' 0x12)' indata + i - oldLength' oldLength' out disps [i]);  	if (disps [i] > i)  		throw new Exception (Main.Get_Traduction ("S02"));  	// disp < 3 cannot be stored explicitly.  	if (disps [i] < 3)  		maxLen = 1;  	for (int j = 3; j <= maxLen; j++) {  		int newCompLen;  		if (i + j >= inLength)  			newCompLen = 2;  		else  			newCompLen = 2 + minLengths [i + j];  		if (newCompLen < minLengths [i]) {  			lengths [i] = j;  			minLengths [i] = newCompLen;  		}  	}  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionLengths,The following statement contains a magic number: for (int i = inLength - 1; i >= 0; i--) {  	// first get the compression length when the next byte is not compressed  	minLengths [i] = int.MaxValue;  	lengths [i] = 1;  	if (i + 1 >= inLength)  		minLengths [i] = 1;  	else  		minLengths [i] = 1 + minLengths [i + 1];  	// then the optimal compressed length  	int oldLength = Math.Min (0x1001' i);  	// get the appropriate disp while at it. Takes at most O(n) time if oldLength is considered O(n)  	// be sure to bound the input length with 0x12' as that's the maximum length for LZ-Ovl compressed blocks.  	int maxLen = LZUtil.GetOccurrenceLength (indata + i' Math.Min (inLength - i' 0x12)' indata + i - oldLength' oldLength' out disps [i]);  	if (disps [i] > i)  		throw new Exception (Main.Get_Traduction ("S02"));  	// disp < 3 cannot be stored explicitly.  	if (disps [i] < 3)  		maxLen = 1;  	for (int j = 3; j <= maxLen; j++) {  		int newCompLen;  		if (i + j >= inLength)  			newCompLen = 2;  		else  			newCompLen = 2 + minLengths [i + j];  		if (newCompLen < minLengths [i]) {  			lengths [i] = j;  			minLengths [i] = newCompLen;  		}  	}  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionLengths,The following statement contains a magic number: for (int i = inLength - 1; i >= 0; i--) {  	// first get the compression length when the next byte is not compressed  	minLengths [i] = int.MaxValue;  	lengths [i] = 1;  	if (i + 1 >= inLength)  		minLengths [i] = 1;  	else  		minLengths [i] = 1 + minLengths [i + 1];  	// then the optimal compressed length  	int oldLength = Math.Min (0x1001' i);  	// get the appropriate disp while at it. Takes at most O(n) time if oldLength is considered O(n)  	// be sure to bound the input length with 0x12' as that's the maximum length for LZ-Ovl compressed blocks.  	int maxLen = LZUtil.GetOccurrenceLength (indata + i' Math.Min (inLength - i' 0x12)' indata + i - oldLength' oldLength' out disps [i]);  	if (disps [i] > i)  		throw new Exception (Main.Get_Traduction ("S02"));  	// disp < 3 cannot be stored explicitly.  	if (disps [i] < 3)  		maxLen = 1;  	for (int j = 3; j <= maxLen; j++) {  		int newCompLen;  		if (i + j >= inLength)  			newCompLen = 2;  		else  			newCompLen = 2 + minLengths [i + j];  		if (newCompLen < minLengths [i]) {  			lengths [i] = j;  			minLengths [i] = newCompLen;  		}  	}  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionLengths,The following statement contains a magic number: if (disps [i] < 3)  	maxLen = 1;  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionLengths,The following statement contains a magic number: for (int j = 3; j <= maxLen; j++) {  	int newCompLen;  	if (i + j >= inLength)  		newCompLen = 2;  	else  		newCompLen = 2 + minLengths [i + j];  	if (newCompLen < minLengths [i]) {  		lengths [i] = j;  		minLengths [i] = newCompLen;  	}  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionLengths,The following statement contains a magic number: for (int j = 3; j <= maxLen; j++) {  	int newCompLen;  	if (i + j >= inLength)  		newCompLen = 2;  	else  		newCompLen = 2 + minLengths [i + j];  	if (newCompLen < minLengths [i]) {  		lengths [i] = j;  		minLengths [i] = newCompLen;  	}  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionLengths,The following statement contains a magic number: for (int j = 3; j <= maxLen; j++) {  	int newCompLen;  	if (i + j >= inLength)  		newCompLen = 2;  	else  		newCompLen = 2 + minLengths [i + j];  	if (newCompLen < minLengths [i]) {  		lengths [i] = j;  		minLengths [i] = newCompLen;  	}  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionLengths,The following statement contains a magic number: if (i + j >= inLength)  	newCompLen = 2;  else  	newCompLen = 2 + minLengths [i + j];  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionLengths,The following statement contains a magic number: if (i + j >= inLength)  	newCompLen = 2;  else  	newCompLen = 2 + minLengths [i + j];  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionLengths,The following statement contains a magic number: newCompLen = 2;  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionLengths,The following statement contains a magic number: newCompLen = 2 + minLengths [i + j];  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionPartLength,The following statement contains a magic number: for (int i = 0; i < blocklengths.Length;) {  	if (insideBlockIdx == 8) {  		block8Idx++;  		insideBlockIdx = 0;  		totalCompLength++;  	}  	insideBlockIdx++;  	if (blocklengths [i] >= 3)  		totalCompLength += 2;  	else  		totalCompLength++;  	i += blocklengths [i];  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionPartLength,The following statement contains a magic number: for (int i = 0; i < blocklengths.Length;) {  	if (insideBlockIdx == 8) {  		block8Idx++;  		insideBlockIdx = 0;  		totalCompLength++;  	}  	insideBlockIdx++;  	if (blocklengths [i] >= 3)  		totalCompLength += 2;  	else  		totalCompLength++;  	i += blocklengths [i];  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionPartLength,The following statement contains a magic number: for (int i = 0; i < blocklengths.Length;) {  	if (insideBlockIdx == 8) {  		block8Idx++;  		insideBlockIdx = 0;  		totalCompLength++;  	}  	insideBlockIdx++;  	if (blocklengths [i] >= 3)  		totalCompLength += 2;  	else  		totalCompLength++;  	i += blocklengths [i];  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionPartLength,The following statement contains a magic number: if (insideBlockIdx == 8) {  	block8Idx++;  	insideBlockIdx = 0;  	totalCompLength++;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionPartLength,The following statement contains a magic number: if (blocklengths [i] >= 3)  	totalCompLength += 2;  else  	totalCompLength++;  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionPartLength,The following statement contains a magic number: if (blocklengths [i] >= 3)  	totalCompLength += 2;  else  	totalCompLength++;  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionPartLength,The following statement contains a magic number: totalCompLength += 2;  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionPartLength,The following statement contains a magic number: for (int i = 0; i < blocklengths.Length;) {  	if (insideBlockIdx == 8) {  		block8Idx++;  		insideBlockIdx = 0;  		totalCompLength--;  	}  	if (blocklengths [i] >= 3)  		totalCompLength -= 2;  	else  		totalCompLength--;  	actualRestCompLengths [i] = totalCompLength;  	i += blocklengths [i];  	insideBlockIdx++;  	if (totalCompLength > (blocklengths.Length - i))  		return i;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionPartLength,The following statement contains a magic number: for (int i = 0; i < blocklengths.Length;) {  	if (insideBlockIdx == 8) {  		block8Idx++;  		insideBlockIdx = 0;  		totalCompLength--;  	}  	if (blocklengths [i] >= 3)  		totalCompLength -= 2;  	else  		totalCompLength--;  	actualRestCompLengths [i] = totalCompLength;  	i += blocklengths [i];  	insideBlockIdx++;  	if (totalCompLength > (blocklengths.Length - i))  		return i;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionPartLength,The following statement contains a magic number: for (int i = 0; i < blocklengths.Length;) {  	if (insideBlockIdx == 8) {  		block8Idx++;  		insideBlockIdx = 0;  		totalCompLength--;  	}  	if (blocklengths [i] >= 3)  		totalCompLength -= 2;  	else  		totalCompLength--;  	actualRestCompLengths [i] = totalCompLength;  	i += blocklengths [i];  	insideBlockIdx++;  	if (totalCompLength > (blocklengths.Length - i))  		return i;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionPartLength,The following statement contains a magic number: if (insideBlockIdx == 8) {  	block8Idx++;  	insideBlockIdx = 0;  	totalCompLength--;  }  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionPartLength,The following statement contains a magic number: if (blocklengths [i] >= 3)  	totalCompLength -= 2;  else  	totalCompLength--;  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionPartLength,The following statement contains a magic number: if (blocklengths [i] >= 3)  	totalCompLength -= 2;  else  	totalCompLength--;  
Magic Number,DSDecmp.Formats,LZOvl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\LZOvl.cs,GetOptimalCompressionPartLength,The following statement contains a magic number: totalCompLength -= 2;  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The following statement contains a magic number: instream.Read (sizeBytes' 0' 3);  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The following statement contains a magic number: readBytes += 4;  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The following statement contains a magic number: if (decompressedSize == 0) {  	sizeBytes = new byte[4];  	instream.Read (sizeBytes' 0' 4);  	decompressedSize = IOUtils.ToNDSs32 (sizeBytes' 0);  	readBytes += 4;  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The following statement contains a magic number: if (decompressedSize == 0) {  	sizeBytes = new byte[4];  	instream.Read (sizeBytes' 0' 4);  	decompressedSize = IOUtils.ToNDSs32 (sizeBytes' 0);  	readBytes += 4;  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The following statement contains a magic number: if (decompressedSize == 0) {  	sizeBytes = new byte[4];  	instream.Read (sizeBytes' 0' 4);  	decompressedSize = IOUtils.ToNDSs32 (sizeBytes' 0);  	readBytes += 4;  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The following statement contains a magic number: sizeBytes = new byte[4];  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The following statement contains a magic number: instream.Read (sizeBytes' 0' 4);  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The following statement contains a magic number: readBytes += 4;  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The following statement contains a magic number: treeSize = (treeSize + 1) * 2;  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The following statement contains a magic number: while (currentSize < decompressedSize) {  	#region find the next reference to a data node  	while (!currentNode.IsData) {  		// if there are no bits left to read in the data' get a new byte from the input  		if (bitsLeft == 0) {  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentSize' decompressedSize);  			int nRead = instream.Read (buffer' 0' 4);  			if (nRead < 4)  				throw new StreamTooShortException ();  			readBytes += nRead;  			data = IOUtils.ToNDSu32 (buffer' 0);  			bitsLeft = 32;  		}  		// get the next bit  		bitsLeft--;  		bool nextIsOne = (data & (1 << bitsLeft)) != 0;  		// go to the next node' the direction of the child depending on the value of the current/next bit  		currentNode = nextIsOne ? currentNode.Child1 : currentNode.Child0;  	}  	#endregion  	#region write the data in the current node (when possible)  	switch (blockSize) {  	case BlockSize.EIGHTBIT: {  		// just copy the data if the block size is a full byte  		outstream.WriteByte (currentNode.Data);  		currentSize++;  		break;  	}  	case BlockSize.FOURBIT: {  		// cache the first half of the data if the block size is a half byte  		if (cachedByte < 0) {  			cachedByte = currentNode.Data << 4;  		} else {  			// if we already cached a half-byte' combine the two halves and write the full byte.  			cachedByte |= currentNode.Data;  			outstream.WriteByte ((byte)cachedByte);  			currentSize++;  			// be sure to forget the two written half-bytes  			cachedByte = -1;  		}  		break;  	}  	default:  		throw new Exception (String.Format (Main.Get_Traduction ("S08")' blockSize.ToString ()));  	}  	#endregion  	outstream.Flush ();  	// make sure to start over next round  	currentNode = rootNode;  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The following statement contains a magic number: while (currentSize < decompressedSize) {  	#region find the next reference to a data node  	while (!currentNode.IsData) {  		// if there are no bits left to read in the data' get a new byte from the input  		if (bitsLeft == 0) {  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentSize' decompressedSize);  			int nRead = instream.Read (buffer' 0' 4);  			if (nRead < 4)  				throw new StreamTooShortException ();  			readBytes += nRead;  			data = IOUtils.ToNDSu32 (buffer' 0);  			bitsLeft = 32;  		}  		// get the next bit  		bitsLeft--;  		bool nextIsOne = (data & (1 << bitsLeft)) != 0;  		// go to the next node' the direction of the child depending on the value of the current/next bit  		currentNode = nextIsOne ? currentNode.Child1 : currentNode.Child0;  	}  	#endregion  	#region write the data in the current node (when possible)  	switch (blockSize) {  	case BlockSize.EIGHTBIT: {  		// just copy the data if the block size is a full byte  		outstream.WriteByte (currentNode.Data);  		currentSize++;  		break;  	}  	case BlockSize.FOURBIT: {  		// cache the first half of the data if the block size is a half byte  		if (cachedByte < 0) {  			cachedByte = currentNode.Data << 4;  		} else {  			// if we already cached a half-byte' combine the two halves and write the full byte.  			cachedByte |= currentNode.Data;  			outstream.WriteByte ((byte)cachedByte);  			currentSize++;  			// be sure to forget the two written half-bytes  			cachedByte = -1;  		}  		break;  	}  	default:  		throw new Exception (String.Format (Main.Get_Traduction ("S08")' blockSize.ToString ()));  	}  	#endregion  	outstream.Flush ();  	// make sure to start over next round  	currentNode = rootNode;  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The following statement contains a magic number: while (currentSize < decompressedSize) {  	#region find the next reference to a data node  	while (!currentNode.IsData) {  		// if there are no bits left to read in the data' get a new byte from the input  		if (bitsLeft == 0) {  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentSize' decompressedSize);  			int nRead = instream.Read (buffer' 0' 4);  			if (nRead < 4)  				throw new StreamTooShortException ();  			readBytes += nRead;  			data = IOUtils.ToNDSu32 (buffer' 0);  			bitsLeft = 32;  		}  		// get the next bit  		bitsLeft--;  		bool nextIsOne = (data & (1 << bitsLeft)) != 0;  		// go to the next node' the direction of the child depending on the value of the current/next bit  		currentNode = nextIsOne ? currentNode.Child1 : currentNode.Child0;  	}  	#endregion  	#region write the data in the current node (when possible)  	switch (blockSize) {  	case BlockSize.EIGHTBIT: {  		// just copy the data if the block size is a full byte  		outstream.WriteByte (currentNode.Data);  		currentSize++;  		break;  	}  	case BlockSize.FOURBIT: {  		// cache the first half of the data if the block size is a half byte  		if (cachedByte < 0) {  			cachedByte = currentNode.Data << 4;  		} else {  			// if we already cached a half-byte' combine the two halves and write the full byte.  			cachedByte |= currentNode.Data;  			outstream.WriteByte ((byte)cachedByte);  			currentSize++;  			// be sure to forget the two written half-bytes  			cachedByte = -1;  		}  		break;  	}  	default:  		throw new Exception (String.Format (Main.Get_Traduction ("S08")' blockSize.ToString ()));  	}  	#endregion  	outstream.Flush ();  	// make sure to start over next round  	currentNode = rootNode;  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The following statement contains a magic number: while (currentSize < decompressedSize) {  	#region find the next reference to a data node  	while (!currentNode.IsData) {  		// if there are no bits left to read in the data' get a new byte from the input  		if (bitsLeft == 0) {  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentSize' decompressedSize);  			int nRead = instream.Read (buffer' 0' 4);  			if (nRead < 4)  				throw new StreamTooShortException ();  			readBytes += nRead;  			data = IOUtils.ToNDSu32 (buffer' 0);  			bitsLeft = 32;  		}  		// get the next bit  		bitsLeft--;  		bool nextIsOne = (data & (1 << bitsLeft)) != 0;  		// go to the next node' the direction of the child depending on the value of the current/next bit  		currentNode = nextIsOne ? currentNode.Child1 : currentNode.Child0;  	}  	#endregion  	#region write the data in the current node (when possible)  	switch (blockSize) {  	case BlockSize.EIGHTBIT: {  		// just copy the data if the block size is a full byte  		outstream.WriteByte (currentNode.Data);  		currentSize++;  		break;  	}  	case BlockSize.FOURBIT: {  		// cache the first half of the data if the block size is a half byte  		if (cachedByte < 0) {  			cachedByte = currentNode.Data << 4;  		} else {  			// if we already cached a half-byte' combine the two halves and write the full byte.  			cachedByte |= currentNode.Data;  			outstream.WriteByte ((byte)cachedByte);  			currentSize++;  			// be sure to forget the two written half-bytes  			cachedByte = -1;  		}  		break;  	}  	default:  		throw new Exception (String.Format (Main.Get_Traduction ("S08")' blockSize.ToString ()));  	}  	#endregion  	outstream.Flush ();  	// make sure to start over next round  	currentNode = rootNode;  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The following statement contains a magic number: while (!currentNode.IsData) {  	// if there are no bits left to read in the data' get a new byte from the input  	if (bitsLeft == 0) {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentSize' decompressedSize);  		int nRead = instream.Read (buffer' 0' 4);  		if (nRead < 4)  			throw new StreamTooShortException ();  		readBytes += nRead;  		data = IOUtils.ToNDSu32 (buffer' 0);  		bitsLeft = 32;  	}  	// get the next bit  	bitsLeft--;  	bool nextIsOne = (data & (1 << bitsLeft)) != 0;  	// go to the next node' the direction of the child depending on the value of the current/next bit  	currentNode = nextIsOne ? currentNode.Child1 : currentNode.Child0;  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The following statement contains a magic number: while (!currentNode.IsData) {  	// if there are no bits left to read in the data' get a new byte from the input  	if (bitsLeft == 0) {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentSize' decompressedSize);  		int nRead = instream.Read (buffer' 0' 4);  		if (nRead < 4)  			throw new StreamTooShortException ();  		readBytes += nRead;  		data = IOUtils.ToNDSu32 (buffer' 0);  		bitsLeft = 32;  	}  	// get the next bit  	bitsLeft--;  	bool nextIsOne = (data & (1 << bitsLeft)) != 0;  	// go to the next node' the direction of the child depending on the value of the current/next bit  	currentNode = nextIsOne ? currentNode.Child1 : currentNode.Child0;  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The following statement contains a magic number: while (!currentNode.IsData) {  	// if there are no bits left to read in the data' get a new byte from the input  	if (bitsLeft == 0) {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentSize' decompressedSize);  		int nRead = instream.Read (buffer' 0' 4);  		if (nRead < 4)  			throw new StreamTooShortException ();  		readBytes += nRead;  		data = IOUtils.ToNDSu32 (buffer' 0);  		bitsLeft = 32;  	}  	// get the next bit  	bitsLeft--;  	bool nextIsOne = (data & (1 << bitsLeft)) != 0;  	// go to the next node' the direction of the child depending on the value of the current/next bit  	currentNode = nextIsOne ? currentNode.Child1 : currentNode.Child0;  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The following statement contains a magic number: if (bitsLeft == 0) {  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentSize' decompressedSize);  	int nRead = instream.Read (buffer' 0' 4);  	if (nRead < 4)  		throw new StreamTooShortException ();  	readBytes += nRead;  	data = IOUtils.ToNDSu32 (buffer' 0);  	bitsLeft = 32;  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The following statement contains a magic number: if (bitsLeft == 0) {  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentSize' decompressedSize);  	int nRead = instream.Read (buffer' 0' 4);  	if (nRead < 4)  		throw new StreamTooShortException ();  	readBytes += nRead;  	data = IOUtils.ToNDSu32 (buffer' 0);  	bitsLeft = 32;  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The following statement contains a magic number: if (bitsLeft == 0) {  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentSize' decompressedSize);  	int nRead = instream.Read (buffer' 0' 4);  	if (nRead < 4)  		throw new StreamTooShortException ();  	readBytes += nRead;  	data = IOUtils.ToNDSu32 (buffer' 0);  	bitsLeft = 32;  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The following statement contains a magic number: if (nRead < 4)  	throw new StreamTooShortException ();  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The following statement contains a magic number: bitsLeft = 32;  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The following statement contains a magic number: switch (blockSize) {  case BlockSize.EIGHTBIT: {  	// just copy the data if the block size is a full byte  	outstream.WriteByte (currentNode.Data);  	currentSize++;  	break;  }  case BlockSize.FOURBIT: {  	// cache the first half of the data if the block size is a half byte  	if (cachedByte < 0) {  		cachedByte = currentNode.Data << 4;  	} else {  		// if we already cached a half-byte' combine the two halves and write the full byte.  		cachedByte |= currentNode.Data;  		outstream.WriteByte ((byte)cachedByte);  		currentSize++;  		// be sure to forget the two written half-bytes  		cachedByte = -1;  	}  	break;  }  default:  	throw new Exception (String.Format (Main.Get_Traduction ("S08")' blockSize.ToString ()));  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The following statement contains a magic number: if (cachedByte < 0) {  	cachedByte = currentNode.Data << 4;  } else {  	// if we already cached a half-byte' combine the two halves and write the full byte.  	cachedByte |= currentNode.Data;  	outstream.WriteByte ((byte)cachedByte);  	currentSize++;  	// be sure to forget the two written half-bytes  	cachedByte = -1;  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The following statement contains a magic number: cachedByte = currentNode.Data << 4;  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The following statement contains a magic number: if (readBytes % 4 != 0)  	readBytes += 4 - (readBytes % 4);  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The following statement contains a magic number: if (readBytes % 4 != 0)  	readBytes += 4 - (readBytes % 4);  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The following statement contains a magic number: if (readBytes % 4 != 0)  	readBytes += 4 - (readBytes % 4);  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The following statement contains a magic number: readBytes += 4 - (readBytes % 4);  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Decompress,The following statement contains a magic number: readBytes += 4 - (readBytes % 4);  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: for (int i = 0; i < inLength; i++) {  	frequencies [inputData [i] & 0xF]++;  	frequencies [(inputData [i] >> 4) & 0xF]++;  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: frequencies [(inputData [i] >> 4) & 0xF]++;  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: outstream.WriteByte ((byte)((inLength >> 8) & 0xFF));  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: outstream.WriteByte ((byte)((inLength >> 16) & 0xFF));  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: outstream.WriteByte ((byte)((nodeCount - 1) / 2));  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: while (printQueue.Count > 0) {  	HuffTreeNode node = printQueue.First.Value;  	printQueue.RemoveFirst ();  	if (node.IsData) {  		outstream.WriteByte (node.Data);  	} else {  		// bits 0-5: 'offset' = # nodes in queue left  		// bit 6: node1 end flag  		// bit 7: node0 end flag  		byte data = (byte)(printQueue.Count / 2);  		data = (byte)(data & 0x3F);  		if (node.Child0.IsData)  			data |= 0x80;  		if (node.Child1.IsData)  			data |= 0x40;  		outstream.WriteByte (data);  		printQueue.AddLast (node.Child0);  		printQueue.AddLast (node.Child1);  	}  	compressedLength++;  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: if (node.IsData) {  	outstream.WriteByte (node.Data);  } else {  	// bits 0-5: 'offset' = # nodes in queue left  	// bit 6: node1 end flag  	// bit 7: node0 end flag  	byte data = (byte)(printQueue.Count / 2);  	data = (byte)(data & 0x3F);  	if (node.Child0.IsData)  		data |= 0x80;  	if (node.Child1.IsData)  		data |= 0x40;  	outstream.WriteByte (data);  	printQueue.AddLast (node.Child0);  	printQueue.AddLast (node.Child1);  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: for (int i = 0; i < inLength; i++) {  	byte data = inputData [i];  	for (int j = 0; j < 2; j++) {  		HuffTreeNode node = leaves [(data >> (4 - j * 4)) & 0xF];  		// the depth of the node is the length of the codeword required to encode the byte  		int depth = node.Depth;  		bool[] path = new bool[depth];  		for (int d = 0; d < depth; d++) {  			path [depth - d - 1] = node.IsChild1;  			node = node.Parent;  		}  		for (int d = 0; d < depth; d++) {  			if (bitsLeftToWrite == 0) {  				outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  				compressedLength += 4;  				datablock = 0;  				bitsLeftToWrite = 32;  			}  			bitsLeftToWrite--;  			if (path [d])  				datablock |= (uint)(1 << bitsLeftToWrite);  			// no need to OR the buffer with 0 if it is child0  		}  	}  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: for (int i = 0; i < inLength; i++) {  	byte data = inputData [i];  	for (int j = 0; j < 2; j++) {  		HuffTreeNode node = leaves [(data >> (4 - j * 4)) & 0xF];  		// the depth of the node is the length of the codeword required to encode the byte  		int depth = node.Depth;  		bool[] path = new bool[depth];  		for (int d = 0; d < depth; d++) {  			path [depth - d - 1] = node.IsChild1;  			node = node.Parent;  		}  		for (int d = 0; d < depth; d++) {  			if (bitsLeftToWrite == 0) {  				outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  				compressedLength += 4;  				datablock = 0;  				bitsLeftToWrite = 32;  			}  			bitsLeftToWrite--;  			if (path [d])  				datablock |= (uint)(1 << bitsLeftToWrite);  			// no need to OR the buffer with 0 if it is child0  		}  	}  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: for (int i = 0; i < inLength; i++) {  	byte data = inputData [i];  	for (int j = 0; j < 2; j++) {  		HuffTreeNode node = leaves [(data >> (4 - j * 4)) & 0xF];  		// the depth of the node is the length of the codeword required to encode the byte  		int depth = node.Depth;  		bool[] path = new bool[depth];  		for (int d = 0; d < depth; d++) {  			path [depth - d - 1] = node.IsChild1;  			node = node.Parent;  		}  		for (int d = 0; d < depth; d++) {  			if (bitsLeftToWrite == 0) {  				outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  				compressedLength += 4;  				datablock = 0;  				bitsLeftToWrite = 32;  			}  			bitsLeftToWrite--;  			if (path [d])  				datablock |= (uint)(1 << bitsLeftToWrite);  			// no need to OR the buffer with 0 if it is child0  		}  	}  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: for (int i = 0; i < inLength; i++) {  	byte data = inputData [i];  	for (int j = 0; j < 2; j++) {  		HuffTreeNode node = leaves [(data >> (4 - j * 4)) & 0xF];  		// the depth of the node is the length of the codeword required to encode the byte  		int depth = node.Depth;  		bool[] path = new bool[depth];  		for (int d = 0; d < depth; d++) {  			path [depth - d - 1] = node.IsChild1;  			node = node.Parent;  		}  		for (int d = 0; d < depth; d++) {  			if (bitsLeftToWrite == 0) {  				outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  				compressedLength += 4;  				datablock = 0;  				bitsLeftToWrite = 32;  			}  			bitsLeftToWrite--;  			if (path [d])  				datablock |= (uint)(1 << bitsLeftToWrite);  			// no need to OR the buffer with 0 if it is child0  		}  	}  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: for (int i = 0; i < inLength; i++) {  	byte data = inputData [i];  	for (int j = 0; j < 2; j++) {  		HuffTreeNode node = leaves [(data >> (4 - j * 4)) & 0xF];  		// the depth of the node is the length of the codeword required to encode the byte  		int depth = node.Depth;  		bool[] path = new bool[depth];  		for (int d = 0; d < depth; d++) {  			path [depth - d - 1] = node.IsChild1;  			node = node.Parent;  		}  		for (int d = 0; d < depth; d++) {  			if (bitsLeftToWrite == 0) {  				outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  				compressedLength += 4;  				datablock = 0;  				bitsLeftToWrite = 32;  			}  			bitsLeftToWrite--;  			if (path [d])  				datablock |= (uint)(1 << bitsLeftToWrite);  			// no need to OR the buffer with 0 if it is child0  		}  	}  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: for (int i = 0; i < inLength; i++) {  	byte data = inputData [i];  	for (int j = 0; j < 2; j++) {  		HuffTreeNode node = leaves [(data >> (4 - j * 4)) & 0xF];  		// the depth of the node is the length of the codeword required to encode the byte  		int depth = node.Depth;  		bool[] path = new bool[depth];  		for (int d = 0; d < depth; d++) {  			path [depth - d - 1] = node.IsChild1;  			node = node.Parent;  		}  		for (int d = 0; d < depth; d++) {  			if (bitsLeftToWrite == 0) {  				outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  				compressedLength += 4;  				datablock = 0;  				bitsLeftToWrite = 32;  			}  			bitsLeftToWrite--;  			if (path [d])  				datablock |= (uint)(1 << bitsLeftToWrite);  			// no need to OR the buffer with 0 if it is child0  		}  	}  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: for (int j = 0; j < 2; j++) {  	HuffTreeNode node = leaves [(data >> (4 - j * 4)) & 0xF];  	// the depth of the node is the length of the codeword required to encode the byte  	int depth = node.Depth;  	bool[] path = new bool[depth];  	for (int d = 0; d < depth; d++) {  		path [depth - d - 1] = node.IsChild1;  		node = node.Parent;  	}  	for (int d = 0; d < depth; d++) {  		if (bitsLeftToWrite == 0) {  			outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  			compressedLength += 4;  			datablock = 0;  			bitsLeftToWrite = 32;  		}  		bitsLeftToWrite--;  		if (path [d])  			datablock |= (uint)(1 << bitsLeftToWrite);  		// no need to OR the buffer with 0 if it is child0  	}  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: for (int j = 0; j < 2; j++) {  	HuffTreeNode node = leaves [(data >> (4 - j * 4)) & 0xF];  	// the depth of the node is the length of the codeword required to encode the byte  	int depth = node.Depth;  	bool[] path = new bool[depth];  	for (int d = 0; d < depth; d++) {  		path [depth - d - 1] = node.IsChild1;  		node = node.Parent;  	}  	for (int d = 0; d < depth; d++) {  		if (bitsLeftToWrite == 0) {  			outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  			compressedLength += 4;  			datablock = 0;  			bitsLeftToWrite = 32;  		}  		bitsLeftToWrite--;  		if (path [d])  			datablock |= (uint)(1 << bitsLeftToWrite);  		// no need to OR the buffer with 0 if it is child0  	}  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: for (int j = 0; j < 2; j++) {  	HuffTreeNode node = leaves [(data >> (4 - j * 4)) & 0xF];  	// the depth of the node is the length of the codeword required to encode the byte  	int depth = node.Depth;  	bool[] path = new bool[depth];  	for (int d = 0; d < depth; d++) {  		path [depth - d - 1] = node.IsChild1;  		node = node.Parent;  	}  	for (int d = 0; d < depth; d++) {  		if (bitsLeftToWrite == 0) {  			outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  			compressedLength += 4;  			datablock = 0;  			bitsLeftToWrite = 32;  		}  		bitsLeftToWrite--;  		if (path [d])  			datablock |= (uint)(1 << bitsLeftToWrite);  		// no need to OR the buffer with 0 if it is child0  	}  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: for (int j = 0; j < 2; j++) {  	HuffTreeNode node = leaves [(data >> (4 - j * 4)) & 0xF];  	// the depth of the node is the length of the codeword required to encode the byte  	int depth = node.Depth;  	bool[] path = new bool[depth];  	for (int d = 0; d < depth; d++) {  		path [depth - d - 1] = node.IsChild1;  		node = node.Parent;  	}  	for (int d = 0; d < depth; d++) {  		if (bitsLeftToWrite == 0) {  			outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  			compressedLength += 4;  			datablock = 0;  			bitsLeftToWrite = 32;  		}  		bitsLeftToWrite--;  		if (path [d])  			datablock |= (uint)(1 << bitsLeftToWrite);  		// no need to OR the buffer with 0 if it is child0  	}  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: for (int j = 0; j < 2; j++) {  	HuffTreeNode node = leaves [(data >> (4 - j * 4)) & 0xF];  	// the depth of the node is the length of the codeword required to encode the byte  	int depth = node.Depth;  	bool[] path = new bool[depth];  	for (int d = 0; d < depth; d++) {  		path [depth - d - 1] = node.IsChild1;  		node = node.Parent;  	}  	for (int d = 0; d < depth; d++) {  		if (bitsLeftToWrite == 0) {  			outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  			compressedLength += 4;  			datablock = 0;  			bitsLeftToWrite = 32;  		}  		bitsLeftToWrite--;  		if (path [d])  			datablock |= (uint)(1 << bitsLeftToWrite);  		// no need to OR the buffer with 0 if it is child0  	}  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: for (int j = 0; j < 2; j++) {  	HuffTreeNode node = leaves [(data >> (4 - j * 4)) & 0xF];  	// the depth of the node is the length of the codeword required to encode the byte  	int depth = node.Depth;  	bool[] path = new bool[depth];  	for (int d = 0; d < depth; d++) {  		path [depth - d - 1] = node.IsChild1;  		node = node.Parent;  	}  	for (int d = 0; d < depth; d++) {  		if (bitsLeftToWrite == 0) {  			outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  			compressedLength += 4;  			datablock = 0;  			bitsLeftToWrite = 32;  		}  		bitsLeftToWrite--;  		if (path [d])  			datablock |= (uint)(1 << bitsLeftToWrite);  		// no need to OR the buffer with 0 if it is child0  	}  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: for (int d = 0; d < depth; d++) {  	if (bitsLeftToWrite == 0) {  		outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  		compressedLength += 4;  		datablock = 0;  		bitsLeftToWrite = 32;  	}  	bitsLeftToWrite--;  	if (path [d])  		datablock |= (uint)(1 << bitsLeftToWrite);  	// no need to OR the buffer with 0 if it is child0  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: for (int d = 0; d < depth; d++) {  	if (bitsLeftToWrite == 0) {  		outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  		compressedLength += 4;  		datablock = 0;  		bitsLeftToWrite = 32;  	}  	bitsLeftToWrite--;  	if (path [d])  		datablock |= (uint)(1 << bitsLeftToWrite);  	// no need to OR the buffer with 0 if it is child0  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: for (int d = 0; d < depth; d++) {  	if (bitsLeftToWrite == 0) {  		outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  		compressedLength += 4;  		datablock = 0;  		bitsLeftToWrite = 32;  	}  	bitsLeftToWrite--;  	if (path [d])  		datablock |= (uint)(1 << bitsLeftToWrite);  	// no need to OR the buffer with 0 if it is child0  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: if (bitsLeftToWrite == 0) {  	outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  	compressedLength += 4;  	datablock = 0;  	bitsLeftToWrite = 32;  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: if (bitsLeftToWrite == 0) {  	outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  	compressedLength += 4;  	datablock = 0;  	bitsLeftToWrite = 32;  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: if (bitsLeftToWrite == 0) {  	outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  	compressedLength += 4;  	datablock = 0;  	bitsLeftToWrite = 32;  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: compressedLength += 4;  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: bitsLeftToWrite = 32;  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: if (bitsLeftToWrite != 32) {  	outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  	compressedLength += 4;  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: if (bitsLeftToWrite != 32) {  	outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  	compressedLength += 4;  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: if (bitsLeftToWrite != 32) {  	outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  	compressedLength += 4;  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress4,The following statement contains a magic number: compressedLength += 4;  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress8,The following statement contains a magic number: outstream.WriteByte ((byte)((inLength >> 8) & 0xFF));  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress8,The following statement contains a magic number: outstream.WriteByte ((byte)((inLength >> 16) & 0xFF));  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress8,The following statement contains a magic number: outstream.WriteByte ((byte)((nodeCount - 1) / 2));  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress8,The following statement contains a magic number: while (printQueue.Count > 0) {  	HuffTreeNode node = printQueue.First.Value;  	printQueue.RemoveFirst ();  	if (node.IsData) {  		outstream.WriteByte (node.Data);  	} else {  		// bits 0-5: 'offset' = # nodes in queue left  		// bit 6: node1 end flag  		// bit 7: node0 end flag  		byte data = (byte)(printQueue.Count / 2);  		data = (byte)(data & 0x3F);  		if (node.Child0.IsData)  			data |= 0x80;  		if (node.Child1.IsData)  			data |= 0x40;  		outstream.WriteByte (data);  		printQueue.AddLast (node.Child0);  		printQueue.AddLast (node.Child1);  	}  	compressedLength++;  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress8,The following statement contains a magic number: if (node.IsData) {  	outstream.WriteByte (node.Data);  } else {  	// bits 0-5: 'offset' = # nodes in queue left  	// bit 6: node1 end flag  	// bit 7: node0 end flag  	byte data = (byte)(printQueue.Count / 2);  	data = (byte)(data & 0x3F);  	if (node.Child0.IsData)  		data |= 0x80;  	if (node.Child1.IsData)  		data |= 0x40;  	outstream.WriteByte (data);  	printQueue.AddLast (node.Child0);  	printQueue.AddLast (node.Child1);  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress8,The following statement contains a magic number: for (int i = 0; i < inLength; i++) {  	byte data = inputData [i];  	HuffTreeNode node = leaves [data];  	// the depth of the node is the length of the codeword required to encode the byte  	int depth = node.Depth;  	bool[] path = new bool[depth];  	for (int d = 0; d < depth; d++) {  		path [depth - d - 1] = node.IsChild1;  		node = node.Parent;  	}  	for (int d = 0; d < depth; d++) {  		if (bitsLeftToWrite == 0) {  			outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  			compressedLength += 4;  			datablock = 0;  			bitsLeftToWrite = 32;  		}  		bitsLeftToWrite--;  		if (path [d])  			datablock |= (uint)(1 << bitsLeftToWrite);  		// no need to OR the buffer with 0 if it is child0  	}  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress8,The following statement contains a magic number: for (int i = 0; i < inLength; i++) {  	byte data = inputData [i];  	HuffTreeNode node = leaves [data];  	// the depth of the node is the length of the codeword required to encode the byte  	int depth = node.Depth;  	bool[] path = new bool[depth];  	for (int d = 0; d < depth; d++) {  		path [depth - d - 1] = node.IsChild1;  		node = node.Parent;  	}  	for (int d = 0; d < depth; d++) {  		if (bitsLeftToWrite == 0) {  			outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  			compressedLength += 4;  			datablock = 0;  			bitsLeftToWrite = 32;  		}  		bitsLeftToWrite--;  		if (path [d])  			datablock |= (uint)(1 << bitsLeftToWrite);  		// no need to OR the buffer with 0 if it is child0  	}  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress8,The following statement contains a magic number: for (int i = 0; i < inLength; i++) {  	byte data = inputData [i];  	HuffTreeNode node = leaves [data];  	// the depth of the node is the length of the codeword required to encode the byte  	int depth = node.Depth;  	bool[] path = new bool[depth];  	for (int d = 0; d < depth; d++) {  		path [depth - d - 1] = node.IsChild1;  		node = node.Parent;  	}  	for (int d = 0; d < depth; d++) {  		if (bitsLeftToWrite == 0) {  			outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  			compressedLength += 4;  			datablock = 0;  			bitsLeftToWrite = 32;  		}  		bitsLeftToWrite--;  		if (path [d])  			datablock |= (uint)(1 << bitsLeftToWrite);  		// no need to OR the buffer with 0 if it is child0  	}  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress8,The following statement contains a magic number: for (int d = 0; d < depth; d++) {  	if (bitsLeftToWrite == 0) {  		outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  		compressedLength += 4;  		datablock = 0;  		bitsLeftToWrite = 32;  	}  	bitsLeftToWrite--;  	if (path [d])  		datablock |= (uint)(1 << bitsLeftToWrite);  	// no need to OR the buffer with 0 if it is child0  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress8,The following statement contains a magic number: for (int d = 0; d < depth; d++) {  	if (bitsLeftToWrite == 0) {  		outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  		compressedLength += 4;  		datablock = 0;  		bitsLeftToWrite = 32;  	}  	bitsLeftToWrite--;  	if (path [d])  		datablock |= (uint)(1 << bitsLeftToWrite);  	// no need to OR the buffer with 0 if it is child0  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress8,The following statement contains a magic number: for (int d = 0; d < depth; d++) {  	if (bitsLeftToWrite == 0) {  		outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  		compressedLength += 4;  		datablock = 0;  		bitsLeftToWrite = 32;  	}  	bitsLeftToWrite--;  	if (path [d])  		datablock |= (uint)(1 << bitsLeftToWrite);  	// no need to OR the buffer with 0 if it is child0  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress8,The following statement contains a magic number: if (bitsLeftToWrite == 0) {  	outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  	compressedLength += 4;  	datablock = 0;  	bitsLeftToWrite = 32;  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress8,The following statement contains a magic number: if (bitsLeftToWrite == 0) {  	outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  	compressedLength += 4;  	datablock = 0;  	bitsLeftToWrite = 32;  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress8,The following statement contains a magic number: if (bitsLeftToWrite == 0) {  	outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  	compressedLength += 4;  	datablock = 0;  	bitsLeftToWrite = 32;  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress8,The following statement contains a magic number: outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress8,The following statement contains a magic number: compressedLength += 4;  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress8,The following statement contains a magic number: bitsLeftToWrite = 32;  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress8,The following statement contains a magic number: if (bitsLeftToWrite != 32) {  	outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  	compressedLength += 4;  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress8,The following statement contains a magic number: if (bitsLeftToWrite != 32) {  	outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  	compressedLength += 4;  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress8,The following statement contains a magic number: if (bitsLeftToWrite != 32) {  	outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  	compressedLength += 4;  }  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress8,The following statement contains a magic number: outstream.Write (IOUtils.FromNDSu32 (datablock)' 0' 4);  
Magic Number,DSDecmp.Formats.Nitro,Huffman,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\Huffman.cs,Compress8,The following statement contains a magic number: compressedLength += 4;  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Decompress,The following statement contains a magic number: instream.Read (sizeBytes' 0' 3);  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Decompress,The following statement contains a magic number: readBytes += 4;  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Decompress,The following statement contains a magic number: if (decompressedSize == 0) {  	sizeBytes = new byte[4];  	instream.Read (sizeBytes' 0' 4);  	decompressedSize = IOUtils.ToNDSs32 (sizeBytes' 0);  	readBytes += 4;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Decompress,The following statement contains a magic number: if (decompressedSize == 0) {  	sizeBytes = new byte[4];  	instream.Read (sizeBytes' 0' 4);  	decompressedSize = IOUtils.ToNDSs32 (sizeBytes' 0);  	readBytes += 4;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Decompress,The following statement contains a magic number: if (decompressedSize == 0) {  	sizeBytes = new byte[4];  	instream.Read (sizeBytes' 0' 4);  	decompressedSize = IOUtils.ToNDSs32 (sizeBytes' 0);  	readBytes += 4;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Decompress,The following statement contains a magic number: sizeBytes = new byte[4];  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Decompress,The following statement contains a magic number: instream.Read (sizeBytes' 0' 4);  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Decompress,The following statement contains a magic number: readBytes += 4;  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Decompress,The following statement contains a magic number: while (currentOutSize < decompressedSize) {  	// (throws when requested new flags byte is not available)  	#region Update the mask. If all flag bits have been read' get a new set.  	// the current mask is the mask used in the previous run. So if it masks the  	// last flag bit' get a new flags byte.  	if (mask == 1) {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		flags = instream.ReadByte ();  		readBytes++;  		if (flags < 0)  			throw new StreamTooShortException ();  		mask = 0x80;  	} else {  		mask >>= 1;  	}  	#endregion  	// bit = 1 <=> compressed.  	if ((flags & mask) > 0) {  		// (throws when < 2 bytes are available)  		#region Get length and displacement('disp') values from next 2 bytes  		// there are < 2 bytes available when the end is at most 1 byte away  		if (readBytes + 1 >= inLength) {  			// make sure the stream is at the end  			if (readBytes < inLength) {  				instream.ReadByte ();  				readBytes++;  			}  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		}  		int byte1 = instream.ReadByte ();  		readBytes++;  		int byte2 = instream.ReadByte ();  		readBytes++;  		if (byte2 < 0)  			throw new StreamTooShortException ();  		// the number of bytes to copy  		int length = byte1 >> 4;  		length += 3;  		// from where the bytes should be copied (relatively)  		int disp = ((byte1 & 0x0F) << 8) | byte2;  		disp += 1;  		if (disp > currentOutSize)  			throw new InvalidDataException (String.Format (Main.Get_Traduction ("S01")' disp.ToString ("X")' currentOutSize.ToString ("X")' (instream.Position - 2).ToString ("X")));  		#endregion  		int bufIdx = bufferOffset + bufferLength - disp;  		for (int i = 0; i < length; i++) {  			byte next = buffer [bufIdx % bufferLength];  			bufIdx++;  			outstream.WriteByte (next);  			buffer [bufferOffset] = next;  			bufferOffset = (bufferOffset + 1) % bufferLength;  		}  		currentOutSize += length;  	} else {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int next = instream.ReadByte ();  		readBytes++;  		if (next < 0)  			throw new StreamTooShortException ();  		currentOutSize++;  		outstream.WriteByte ((byte)next);  		buffer [bufferOffset] = (byte)next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  	outstream.Flush ();  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Decompress,The following statement contains a magic number: while (currentOutSize < decompressedSize) {  	// (throws when requested new flags byte is not available)  	#region Update the mask. If all flag bits have been read' get a new set.  	// the current mask is the mask used in the previous run. So if it masks the  	// last flag bit' get a new flags byte.  	if (mask == 1) {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		flags = instream.ReadByte ();  		readBytes++;  		if (flags < 0)  			throw new StreamTooShortException ();  		mask = 0x80;  	} else {  		mask >>= 1;  	}  	#endregion  	// bit = 1 <=> compressed.  	if ((flags & mask) > 0) {  		// (throws when < 2 bytes are available)  		#region Get length and displacement('disp') values from next 2 bytes  		// there are < 2 bytes available when the end is at most 1 byte away  		if (readBytes + 1 >= inLength) {  			// make sure the stream is at the end  			if (readBytes < inLength) {  				instream.ReadByte ();  				readBytes++;  			}  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		}  		int byte1 = instream.ReadByte ();  		readBytes++;  		int byte2 = instream.ReadByte ();  		readBytes++;  		if (byte2 < 0)  			throw new StreamTooShortException ();  		// the number of bytes to copy  		int length = byte1 >> 4;  		length += 3;  		// from where the bytes should be copied (relatively)  		int disp = ((byte1 & 0x0F) << 8) | byte2;  		disp += 1;  		if (disp > currentOutSize)  			throw new InvalidDataException (String.Format (Main.Get_Traduction ("S01")' disp.ToString ("X")' currentOutSize.ToString ("X")' (instream.Position - 2).ToString ("X")));  		#endregion  		int bufIdx = bufferOffset + bufferLength - disp;  		for (int i = 0; i < length; i++) {  			byte next = buffer [bufIdx % bufferLength];  			bufIdx++;  			outstream.WriteByte (next);  			buffer [bufferOffset] = next;  			bufferOffset = (bufferOffset + 1) % bufferLength;  		}  		currentOutSize += length;  	} else {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int next = instream.ReadByte ();  		readBytes++;  		if (next < 0)  			throw new StreamTooShortException ();  		currentOutSize++;  		outstream.WriteByte ((byte)next);  		buffer [bufferOffset] = (byte)next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  	outstream.Flush ();  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Decompress,The following statement contains a magic number: while (currentOutSize < decompressedSize) {  	// (throws when requested new flags byte is not available)  	#region Update the mask. If all flag bits have been read' get a new set.  	// the current mask is the mask used in the previous run. So if it masks the  	// last flag bit' get a new flags byte.  	if (mask == 1) {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		flags = instream.ReadByte ();  		readBytes++;  		if (flags < 0)  			throw new StreamTooShortException ();  		mask = 0x80;  	} else {  		mask >>= 1;  	}  	#endregion  	// bit = 1 <=> compressed.  	if ((flags & mask) > 0) {  		// (throws when < 2 bytes are available)  		#region Get length and displacement('disp') values from next 2 bytes  		// there are < 2 bytes available when the end is at most 1 byte away  		if (readBytes + 1 >= inLength) {  			// make sure the stream is at the end  			if (readBytes < inLength) {  				instream.ReadByte ();  				readBytes++;  			}  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		}  		int byte1 = instream.ReadByte ();  		readBytes++;  		int byte2 = instream.ReadByte ();  		readBytes++;  		if (byte2 < 0)  			throw new StreamTooShortException ();  		// the number of bytes to copy  		int length = byte1 >> 4;  		length += 3;  		// from where the bytes should be copied (relatively)  		int disp = ((byte1 & 0x0F) << 8) | byte2;  		disp += 1;  		if (disp > currentOutSize)  			throw new InvalidDataException (String.Format (Main.Get_Traduction ("S01")' disp.ToString ("X")' currentOutSize.ToString ("X")' (instream.Position - 2).ToString ("X")));  		#endregion  		int bufIdx = bufferOffset + bufferLength - disp;  		for (int i = 0; i < length; i++) {  			byte next = buffer [bufIdx % bufferLength];  			bufIdx++;  			outstream.WriteByte (next);  			buffer [bufferOffset] = next;  			bufferOffset = (bufferOffset + 1) % bufferLength;  		}  		currentOutSize += length;  	} else {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int next = instream.ReadByte ();  		readBytes++;  		if (next < 0)  			throw new StreamTooShortException ();  		currentOutSize++;  		outstream.WriteByte ((byte)next);  		buffer [bufferOffset] = (byte)next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  	outstream.Flush ();  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Decompress,The following statement contains a magic number: while (currentOutSize < decompressedSize) {  	// (throws when requested new flags byte is not available)  	#region Update the mask. If all flag bits have been read' get a new set.  	// the current mask is the mask used in the previous run. So if it masks the  	// last flag bit' get a new flags byte.  	if (mask == 1) {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		flags = instream.ReadByte ();  		readBytes++;  		if (flags < 0)  			throw new StreamTooShortException ();  		mask = 0x80;  	} else {  		mask >>= 1;  	}  	#endregion  	// bit = 1 <=> compressed.  	if ((flags & mask) > 0) {  		// (throws when < 2 bytes are available)  		#region Get length and displacement('disp') values from next 2 bytes  		// there are < 2 bytes available when the end is at most 1 byte away  		if (readBytes + 1 >= inLength) {  			// make sure the stream is at the end  			if (readBytes < inLength) {  				instream.ReadByte ();  				readBytes++;  			}  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		}  		int byte1 = instream.ReadByte ();  		readBytes++;  		int byte2 = instream.ReadByte ();  		readBytes++;  		if (byte2 < 0)  			throw new StreamTooShortException ();  		// the number of bytes to copy  		int length = byte1 >> 4;  		length += 3;  		// from where the bytes should be copied (relatively)  		int disp = ((byte1 & 0x0F) << 8) | byte2;  		disp += 1;  		if (disp > currentOutSize)  			throw new InvalidDataException (String.Format (Main.Get_Traduction ("S01")' disp.ToString ("X")' currentOutSize.ToString ("X")' (instream.Position - 2).ToString ("X")));  		#endregion  		int bufIdx = bufferOffset + bufferLength - disp;  		for (int i = 0; i < length; i++) {  			byte next = buffer [bufIdx % bufferLength];  			bufIdx++;  			outstream.WriteByte (next);  			buffer [bufferOffset] = next;  			bufferOffset = (bufferOffset + 1) % bufferLength;  		}  		currentOutSize += length;  	} else {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int next = instream.ReadByte ();  		readBytes++;  		if (next < 0)  			throw new StreamTooShortException ();  		currentOutSize++;  		outstream.WriteByte ((byte)next);  		buffer [bufferOffset] = (byte)next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  	outstream.Flush ();  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Decompress,The following statement contains a magic number: if ((flags & mask) > 0) {  	// (throws when < 2 bytes are available)  	#region Get length and displacement('disp') values from next 2 bytes  	// there are < 2 bytes available when the end is at most 1 byte away  	if (readBytes + 1 >= inLength) {  		// make sure the stream is at the end  		if (readBytes < inLength) {  			instream.ReadByte ();  			readBytes++;  		}  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	}  	int byte1 = instream.ReadByte ();  	readBytes++;  	int byte2 = instream.ReadByte ();  	readBytes++;  	if (byte2 < 0)  		throw new StreamTooShortException ();  	// the number of bytes to copy  	int length = byte1 >> 4;  	length += 3;  	// from where the bytes should be copied (relatively)  	int disp = ((byte1 & 0x0F) << 8) | byte2;  	disp += 1;  	if (disp > currentOutSize)  		throw new InvalidDataException (String.Format (Main.Get_Traduction ("S01")' disp.ToString ("X")' currentOutSize.ToString ("X")' (instream.Position - 2).ToString ("X")));  	#endregion  	int bufIdx = bufferOffset + bufferLength - disp;  	for (int i = 0; i < length; i++) {  		byte next = buffer [bufIdx % bufferLength];  		bufIdx++;  		outstream.WriteByte (next);  		buffer [bufferOffset] = next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  	currentOutSize += length;  } else {  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int next = instream.ReadByte ();  	readBytes++;  	if (next < 0)  		throw new StreamTooShortException ();  	currentOutSize++;  	outstream.WriteByte ((byte)next);  	buffer [bufferOffset] = (byte)next;  	bufferOffset = (bufferOffset + 1) % bufferLength;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Decompress,The following statement contains a magic number: if ((flags & mask) > 0) {  	// (throws when < 2 bytes are available)  	#region Get length and displacement('disp') values from next 2 bytes  	// there are < 2 bytes available when the end is at most 1 byte away  	if (readBytes + 1 >= inLength) {  		// make sure the stream is at the end  		if (readBytes < inLength) {  			instream.ReadByte ();  			readBytes++;  		}  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	}  	int byte1 = instream.ReadByte ();  	readBytes++;  	int byte2 = instream.ReadByte ();  	readBytes++;  	if (byte2 < 0)  		throw new StreamTooShortException ();  	// the number of bytes to copy  	int length = byte1 >> 4;  	length += 3;  	// from where the bytes should be copied (relatively)  	int disp = ((byte1 & 0x0F) << 8) | byte2;  	disp += 1;  	if (disp > currentOutSize)  		throw new InvalidDataException (String.Format (Main.Get_Traduction ("S01")' disp.ToString ("X")' currentOutSize.ToString ("X")' (instream.Position - 2).ToString ("X")));  	#endregion  	int bufIdx = bufferOffset + bufferLength - disp;  	for (int i = 0; i < length; i++) {  		byte next = buffer [bufIdx % bufferLength];  		bufIdx++;  		outstream.WriteByte (next);  		buffer [bufferOffset] = next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  	currentOutSize += length;  } else {  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int next = instream.ReadByte ();  	readBytes++;  	if (next < 0)  		throw new StreamTooShortException ();  	currentOutSize++;  	outstream.WriteByte ((byte)next);  	buffer [bufferOffset] = (byte)next;  	bufferOffset = (bufferOffset + 1) % bufferLength;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Decompress,The following statement contains a magic number: if ((flags & mask) > 0) {  	// (throws when < 2 bytes are available)  	#region Get length and displacement('disp') values from next 2 bytes  	// there are < 2 bytes available when the end is at most 1 byte away  	if (readBytes + 1 >= inLength) {  		// make sure the stream is at the end  		if (readBytes < inLength) {  			instream.ReadByte ();  			readBytes++;  		}  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	}  	int byte1 = instream.ReadByte ();  	readBytes++;  	int byte2 = instream.ReadByte ();  	readBytes++;  	if (byte2 < 0)  		throw new StreamTooShortException ();  	// the number of bytes to copy  	int length = byte1 >> 4;  	length += 3;  	// from where the bytes should be copied (relatively)  	int disp = ((byte1 & 0x0F) << 8) | byte2;  	disp += 1;  	if (disp > currentOutSize)  		throw new InvalidDataException (String.Format (Main.Get_Traduction ("S01")' disp.ToString ("X")' currentOutSize.ToString ("X")' (instream.Position - 2).ToString ("X")));  	#endregion  	int bufIdx = bufferOffset + bufferLength - disp;  	for (int i = 0; i < length; i++) {  		byte next = buffer [bufIdx % bufferLength];  		bufIdx++;  		outstream.WriteByte (next);  		buffer [bufferOffset] = next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  	currentOutSize += length;  } else {  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int next = instream.ReadByte ();  	readBytes++;  	if (next < 0)  		throw new StreamTooShortException ();  	currentOutSize++;  	outstream.WriteByte ((byte)next);  	buffer [bufferOffset] = (byte)next;  	bufferOffset = (bufferOffset + 1) % bufferLength;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Decompress,The following statement contains a magic number: if ((flags & mask) > 0) {  	// (throws when < 2 bytes are available)  	#region Get length and displacement('disp') values from next 2 bytes  	// there are < 2 bytes available when the end is at most 1 byte away  	if (readBytes + 1 >= inLength) {  		// make sure the stream is at the end  		if (readBytes < inLength) {  			instream.ReadByte ();  			readBytes++;  		}  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	}  	int byte1 = instream.ReadByte ();  	readBytes++;  	int byte2 = instream.ReadByte ();  	readBytes++;  	if (byte2 < 0)  		throw new StreamTooShortException ();  	// the number of bytes to copy  	int length = byte1 >> 4;  	length += 3;  	// from where the bytes should be copied (relatively)  	int disp = ((byte1 & 0x0F) << 8) | byte2;  	disp += 1;  	if (disp > currentOutSize)  		throw new InvalidDataException (String.Format (Main.Get_Traduction ("S01")' disp.ToString ("X")' currentOutSize.ToString ("X")' (instream.Position - 2).ToString ("X")));  	#endregion  	int bufIdx = bufferOffset + bufferLength - disp;  	for (int i = 0; i < length; i++) {  		byte next = buffer [bufIdx % bufferLength];  		bufIdx++;  		outstream.WriteByte (next);  		buffer [bufferOffset] = next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  	currentOutSize += length;  } else {  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int next = instream.ReadByte ();  	readBytes++;  	if (next < 0)  		throw new StreamTooShortException ();  	currentOutSize++;  	outstream.WriteByte ((byte)next);  	buffer [bufferOffset] = (byte)next;  	bufferOffset = (bufferOffset + 1) % bufferLength;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Decompress,The following statement contains a magic number: length += 3;  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Decompress,The following statement contains a magic number: if (disp > currentOutSize)  	throw new InvalidDataException (String.Format (Main.Get_Traduction ("S01")' disp.ToString ("X")' currentOutSize.ToString ("X")' (instream.Position - 2).ToString ("X")));  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Decompress,The following statement contains a magic number: throw new InvalidDataException (String.Format (Main.Get_Traduction ("S01")' disp.ToString ("X")' currentOutSize.ToString ("X")' (instream.Position - 2).ToString ("X")));  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Decompress,The following statement contains a magic number: if (readBytes < inLength) {  	// the input may be 4-byte aligned.  	if ((readBytes ^ (readBytes & 3)) + 4 < inLength)  		throw new TooMuchInputException (readBytes' inLength);  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Decompress,The following statement contains a magic number: if (readBytes < inLength) {  	// the input may be 4-byte aligned.  	if ((readBytes ^ (readBytes & 3)) + 4 < inLength)  		throw new TooMuchInputException (readBytes' inLength);  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Decompress,The following statement contains a magic number: if ((readBytes ^ (readBytes & 3)) + 4 < inLength)  	throw new TooMuchInputException (readBytes' inLength);  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Decompress,The following statement contains a magic number: if ((readBytes ^ (readBytes & 3)) + 4 < inLength)  	throw new TooMuchInputException (readBytes' inLength);  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Compress,The following statement contains a magic number: outstream.WriteByte ((byte)((inLength >> 8) & 0xFF));  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Compress,The following statement contains a magic number: outstream.WriteByte ((byte)((inLength >> 16) & 0xFF));  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Compress,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1000);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Compress,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1000);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Compress,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1000);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Compress,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1000);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Compress,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1000);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Compress,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1000);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Compress,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1000);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Compress,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1000);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Compress,The following statement contains a magic number: while (readBytes < inLength) {  	#region If 8 blocks are bufferd' write them and reset the buffer  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	#endregion  	// determine if we're dealing with a compressed or raw block.  	// it is a compressed block when the next 3 or more bytes can be copied from  	// somewhere in the set of already compressed bytes.  	int disp;  	int oldLength = Math.Min (readBytes' 0x1000);  	int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  	// length not 3 or more? next byte is raw data  	if (length < 3) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  		readBytes += length;  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  		outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  		bufferlength++;  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Compress,The following statement contains a magic number: while (readBytes < inLength) {  	#region If 8 blocks are bufferd' write them and reset the buffer  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	#endregion  	// determine if we're dealing with a compressed or raw block.  	// it is a compressed block when the next 3 or more bytes can be copied from  	// somewhere in the set of already compressed bytes.  	int disp;  	int oldLength = Math.Min (readBytes' 0x1000);  	int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  	// length not 3 or more? next byte is raw data  	if (length < 3) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  		readBytes += length;  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  		outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  		bufferlength++;  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Compress,The following statement contains a magic number: while (readBytes < inLength) {  	#region If 8 blocks are bufferd' write them and reset the buffer  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	#endregion  	// determine if we're dealing with a compressed or raw block.  	// it is a compressed block when the next 3 or more bytes can be copied from  	// somewhere in the set of already compressed bytes.  	int disp;  	int oldLength = Math.Min (readBytes' 0x1000);  	int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  	// length not 3 or more? next byte is raw data  	if (length < 3) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  		readBytes += length;  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  		outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  		bufferlength++;  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Compress,The following statement contains a magic number: while (readBytes < inLength) {  	#region If 8 blocks are bufferd' write them and reset the buffer  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	#endregion  	// determine if we're dealing with a compressed or raw block.  	// it is a compressed block when the next 3 or more bytes can be copied from  	// somewhere in the set of already compressed bytes.  	int disp;  	int oldLength = Math.Min (readBytes' 0x1000);  	int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  	// length not 3 or more? next byte is raw data  	if (length < 3) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  		readBytes += length;  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  		outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  		bufferlength++;  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Compress,The following statement contains a magic number: while (readBytes < inLength) {  	#region If 8 blocks are bufferd' write them and reset the buffer  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	#endregion  	// determine if we're dealing with a compressed or raw block.  	// it is a compressed block when the next 3 or more bytes can be copied from  	// somewhere in the set of already compressed bytes.  	int disp;  	int oldLength = Math.Min (readBytes' 0x1000);  	int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  	// length not 3 or more? next byte is raw data  	if (length < 3) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  		readBytes += length;  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  		outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  		bufferlength++;  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Compress,The following statement contains a magic number: while (readBytes < inLength) {  	#region If 8 blocks are bufferd' write them and reset the buffer  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	#endregion  	// determine if we're dealing with a compressed or raw block.  	// it is a compressed block when the next 3 or more bytes can be copied from  	// somewhere in the set of already compressed bytes.  	int disp;  	int oldLength = Math.Min (readBytes' 0x1000);  	int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x12)' instart + readBytes - oldLength' oldLength' out disp);  	// length not 3 or more? next byte is raw data  	if (length < 3) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  		readBytes += length;  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  		outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  		bufferlength++;  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Compress,The following statement contains a magic number: if (bufferedBlocks == 8) {  	outstream.Write (outbuffer' 0' bufferlength);  	compressedLength += bufferlength;  	// reset the buffer  	outbuffer [0] = 0;  	bufferlength = 1;  	bufferedBlocks = 0;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Compress,The following statement contains a magic number: if (length < 3) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  	readBytes += length;  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  	outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  	bufferlength++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Compress,The following statement contains a magic number: if (length < 3) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  	readBytes += length;  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  	outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  	bufferlength++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Compress,The following statement contains a magic number: if (length < 3) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  	readBytes += length;  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  	outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  	bufferlength++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Compress,The following statement contains a magic number: if (length < 3) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  	readBytes += length;  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  	outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  	bufferlength++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Compress,The following statement contains a magic number: if (length < 3) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  	readBytes += length;  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  	outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  	bufferlength++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Compress,The following statement contains a magic number: outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Compress,The following statement contains a magic number: outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Compress,The following statement contains a magic number: outbuffer [bufferlength] = (byte)(((length - 3) << 4) & 0xF0);  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,Compress,The following statement contains a magic number: outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,CompressWithLA,The following statement contains a magic number: outstream.WriteByte ((byte)((inLength >> 8) & 0xFF));  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,CompressWithLA,The following statement contains a magic number: outstream.WriteByte ((byte)((inLength >> 16) & 0xFF));  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,CompressWithLA,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	// get the optimal choices for len and disp  	int[] lengths' disps;  	this.GetOptimalCompressionLengths (instart' indata.Length' out lengths' out disps);  	while (readBytes < inLength) {  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		if (lengths [readBytes] == 1) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  			bufferlength++;  			readBytes += lengths [readBytes];  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,CompressWithLA,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	// get the optimal choices for len and disp  	int[] lengths' disps;  	this.GetOptimalCompressionLengths (instart' indata.Length' out lengths' out disps);  	while (readBytes < inLength) {  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		if (lengths [readBytes] == 1) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  			bufferlength++;  			readBytes += lengths [readBytes];  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,CompressWithLA,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	// get the optimal choices for len and disp  	int[] lengths' disps;  	this.GetOptimalCompressionLengths (instart' indata.Length' out lengths' out disps);  	while (readBytes < inLength) {  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		if (lengths [readBytes] == 1) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  			bufferlength++;  			readBytes += lengths [readBytes];  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,CompressWithLA,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	// get the optimal choices for len and disp  	int[] lengths' disps;  	this.GetOptimalCompressionLengths (instart' indata.Length' out lengths' out disps);  	while (readBytes < inLength) {  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		if (lengths [readBytes] == 1) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  			bufferlength++;  			readBytes += lengths [readBytes];  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,CompressWithLA,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	// get the optimal choices for len and disp  	int[] lengths' disps;  	this.GetOptimalCompressionLengths (instart' indata.Length' out lengths' out disps);  	while (readBytes < inLength) {  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		if (lengths [readBytes] == 1) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  			bufferlength++;  			readBytes += lengths [readBytes];  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,CompressWithLA,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	// get the optimal choices for len and disp  	int[] lengths' disps;  	this.GetOptimalCompressionLengths (instart' indata.Length' out lengths' out disps);  	while (readBytes < inLength) {  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		if (lengths [readBytes] == 1) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  			bufferlength++;  			readBytes += lengths [readBytes];  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,CompressWithLA,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	byte[] outbuffer = new byte[8 * 2 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	// get the optimal choices for len and disp  	int[] lengths' disps;  	this.GetOptimalCompressionLengths (instart' indata.Length' out lengths' out disps);  	while (readBytes < inLength) {  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		if (lengths [readBytes] == 1) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  			outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  			bufferlength++;  			readBytes += lengths [readBytes];  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,CompressWithLA,The following statement contains a magic number: while (readBytes < inLength) {  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	if (lengths [readBytes] == 1) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  		outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  		bufferlength++;  		readBytes += lengths [readBytes];  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,CompressWithLA,The following statement contains a magic number: while (readBytes < inLength) {  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	if (lengths [readBytes] == 1) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  		outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  		bufferlength++;  		readBytes += lengths [readBytes];  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,CompressWithLA,The following statement contains a magic number: while (readBytes < inLength) {  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	if (lengths [readBytes] == 1) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  		outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  		bufferlength++;  		readBytes += lengths [readBytes];  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,CompressWithLA,The following statement contains a magic number: while (readBytes < inLength) {  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	if (lengths [readBytes] == 1) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  		outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  		bufferlength++;  		readBytes += lengths [readBytes];  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,CompressWithLA,The following statement contains a magic number: while (readBytes < inLength) {  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	if (lengths [readBytes] == 1) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  		outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  		bufferlength++;  		readBytes += lengths [readBytes];  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,CompressWithLA,The following statement contains a magic number: if (bufferedBlocks == 8) {  	outstream.Write (outbuffer' 0' bufferlength);  	compressedLength += bufferlength;  	// reset the buffer  	outbuffer [0] = 0;  	bufferlength = 1;  	bufferedBlocks = 0;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,CompressWithLA,The following statement contains a magic number: if (lengths [readBytes] == 1) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  	outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  	bufferlength++;  	readBytes += lengths [readBytes];  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,CompressWithLA,The following statement contains a magic number: if (lengths [readBytes] == 1) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  	outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  	bufferlength++;  	readBytes += lengths [readBytes];  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,CompressWithLA,The following statement contains a magic number: if (lengths [readBytes] == 1) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  	outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  	bufferlength++;  	readBytes += lengths [readBytes];  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,CompressWithLA,The following statement contains a magic number: if (lengths [readBytes] == 1) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  	outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  	bufferlength++;  	readBytes += lengths [readBytes];  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,CompressWithLA,The following statement contains a magic number: outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,CompressWithLA,The following statement contains a magic number: outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,CompressWithLA,The following statement contains a magic number: outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 3) << 4) & 0xF0);  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,CompressWithLA,The following statement contains a magic number: outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,GetOptimalCompressionLengths,The following statement contains a magic number: for (int i = inLength - 1; i >= 0; i--) {  	// first get the compression length when the next byte is not compressed  	minLengths [i] = int.MaxValue;  	lengths [i] = 1;  	if (i + 1 >= inLength)  		minLengths [i] = 1;  	else  		minLengths [i] = 1 + minLengths [i + 1];  	// then the optimal compressed length  	int oldLength = Math.Min (0x1000' i);  	// get the appropriate disp while at it. Takes at most O(n) time if oldLength is considered O(n)  	// be sure to bound the input length with 0x12' as that's the maximum length for LZ-10 compressed blocks.  	int maxLen = LZUtil.GetOccurrenceLength (indata + i' Math.Min (inLength - i' 0x12)' indata + i - oldLength' oldLength' out disps [i]);  	if (disps [i] > i)  		throw new Exception (Main.Get_Traduction ("S02"));  	for (int j = 3; j <= maxLen; j++) {  		int newCompLen;  		if (i + j >= inLength)  			newCompLen = 2;  		else  			newCompLen = 2 + minLengths [i + j];  		if (newCompLen < minLengths [i]) {  			lengths [i] = j;  			minLengths [i] = newCompLen;  		}  	}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,GetOptimalCompressionLengths,The following statement contains a magic number: for (int i = inLength - 1; i >= 0; i--) {  	// first get the compression length when the next byte is not compressed  	minLengths [i] = int.MaxValue;  	lengths [i] = 1;  	if (i + 1 >= inLength)  		minLengths [i] = 1;  	else  		minLengths [i] = 1 + minLengths [i + 1];  	// then the optimal compressed length  	int oldLength = Math.Min (0x1000' i);  	// get the appropriate disp while at it. Takes at most O(n) time if oldLength is considered O(n)  	// be sure to bound the input length with 0x12' as that's the maximum length for LZ-10 compressed blocks.  	int maxLen = LZUtil.GetOccurrenceLength (indata + i' Math.Min (inLength - i' 0x12)' indata + i - oldLength' oldLength' out disps [i]);  	if (disps [i] > i)  		throw new Exception (Main.Get_Traduction ("S02"));  	for (int j = 3; j <= maxLen; j++) {  		int newCompLen;  		if (i + j >= inLength)  			newCompLen = 2;  		else  			newCompLen = 2 + minLengths [i + j];  		if (newCompLen < minLengths [i]) {  			lengths [i] = j;  			minLengths [i] = newCompLen;  		}  	}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,GetOptimalCompressionLengths,The following statement contains a magic number: for (int i = inLength - 1; i >= 0; i--) {  	// first get the compression length when the next byte is not compressed  	minLengths [i] = int.MaxValue;  	lengths [i] = 1;  	if (i + 1 >= inLength)  		minLengths [i] = 1;  	else  		minLengths [i] = 1 + minLengths [i + 1];  	// then the optimal compressed length  	int oldLength = Math.Min (0x1000' i);  	// get the appropriate disp while at it. Takes at most O(n) time if oldLength is considered O(n)  	// be sure to bound the input length with 0x12' as that's the maximum length for LZ-10 compressed blocks.  	int maxLen = LZUtil.GetOccurrenceLength (indata + i' Math.Min (inLength - i' 0x12)' indata + i - oldLength' oldLength' out disps [i]);  	if (disps [i] > i)  		throw new Exception (Main.Get_Traduction ("S02"));  	for (int j = 3; j <= maxLen; j++) {  		int newCompLen;  		if (i + j >= inLength)  			newCompLen = 2;  		else  			newCompLen = 2 + minLengths [i + j];  		if (newCompLen < minLengths [i]) {  			lengths [i] = j;  			minLengths [i] = newCompLen;  		}  	}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,GetOptimalCompressionLengths,The following statement contains a magic number: for (int j = 3; j <= maxLen; j++) {  	int newCompLen;  	if (i + j >= inLength)  		newCompLen = 2;  	else  		newCompLen = 2 + minLengths [i + j];  	if (newCompLen < minLengths [i]) {  		lengths [i] = j;  		minLengths [i] = newCompLen;  	}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,GetOptimalCompressionLengths,The following statement contains a magic number: for (int j = 3; j <= maxLen; j++) {  	int newCompLen;  	if (i + j >= inLength)  		newCompLen = 2;  	else  		newCompLen = 2 + minLengths [i + j];  	if (newCompLen < minLengths [i]) {  		lengths [i] = j;  		minLengths [i] = newCompLen;  	}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,GetOptimalCompressionLengths,The following statement contains a magic number: for (int j = 3; j <= maxLen; j++) {  	int newCompLen;  	if (i + j >= inLength)  		newCompLen = 2;  	else  		newCompLen = 2 + minLengths [i + j];  	if (newCompLen < minLengths [i]) {  		lengths [i] = j;  		minLengths [i] = newCompLen;  	}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,GetOptimalCompressionLengths,The following statement contains a magic number: if (i + j >= inLength)  	newCompLen = 2;  else  	newCompLen = 2 + minLengths [i + j];  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,GetOptimalCompressionLengths,The following statement contains a magic number: if (i + j >= inLength)  	newCompLen = 2;  else  	newCompLen = 2 + minLengths [i + j];  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,GetOptimalCompressionLengths,The following statement contains a magic number: newCompLen = 2;  
Magic Number,DSDecmp.Formats.Nitro,LZ10,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ10.cs,GetOptimalCompressionLengths,The following statement contains a magic number: newCompLen = 2 + minLengths [i + j];  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: instream.Read (sizeBytes' 0' 3);  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: readBytes += 4;  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if (decompressedSize == 0) {  	sizeBytes = new byte[4];  	instream.Read (sizeBytes' 0' 4);  	decompressedSize = IOUtils.ToNDSs32 (sizeBytes' 0);  	readBytes += 4;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if (decompressedSize == 0) {  	sizeBytes = new byte[4];  	instream.Read (sizeBytes' 0' 4);  	decompressedSize = IOUtils.ToNDSs32 (sizeBytes' 0);  	readBytes += 4;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if (decompressedSize == 0) {  	sizeBytes = new byte[4];  	instream.Read (sizeBytes' 0' 4);  	decompressedSize = IOUtils.ToNDSs32 (sizeBytes' 0);  	readBytes += 4;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: sizeBytes = new byte[4];  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: instream.Read (sizeBytes' 0' 4);  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: readBytes += 4;  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: while (currentOutSize < decompressedSize) {  	// (throws when requested new flags byte is not available)  	#region Update the mask. If all flag bits have been read' get a new set.  	// the current mask is the mask used in the previous run. So if it masks the  	// last flag bit' get a new flags byte.  	if (mask == 1) {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		flags = instream.ReadByte ();  		readBytes++;  		if (flags < 0)  			throw new StreamTooShortException ();  		mask = 0x80;  	} else {  		mask >>= 1;  	}  	#endregion  	// bit = 1 <=> compressed.  	if ((flags & mask) > 0) {  		// (throws when not enough bytes are available)  		#region Get length and displacement('disp') values from next 2' 3 or 4 bytes  		// read the first byte first' which also signals the size of the compressed block  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte1 = instream.ReadByte ();  		readBytes++;  		if (byte1 < 0)  			throw new StreamTooShortException ();  		int length = byte1 >> 4;  		int disp = -1;  		if (length == 0) {  			#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			// case 0:  			// data = AB CD EF (with A=0)  			// LEN = ABC + 0x11 == BC + 0x11  			// DISP = DEF + 1  			// we need two more bytes available  			if (readBytes + 1 >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			int byte3 = instream.ReadByte ();  			readBytes++;  			if (byte3 < 0)  				throw new StreamTooShortException ();  			length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  			disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  			#endregion  		} else if (length == 1) {  			#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			// case 1:  			// data = AB CD EF GH (with A=1)  			// LEN = BCDE + 0x111  			// DISP = FGH + 1  			// we need three more bytes available  			if (readBytes + 2 >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			int byte3 = instream.ReadByte ();  			readBytes++;  			int byte4 = instream.ReadByte ();  			readBytes++;  			if (byte4 < 0)  				throw new StreamTooShortException ();  			length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  			disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  			#endregion  		} else {  			#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			// case other:  			// data = AB CD  			// LEN = A + 1  			// DISP = BCD + 1  			// we need only one more byte available  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			if (byte2 < 0)  				throw new StreamTooShortException ();  			length = ((byte1 & 0xF0) >> 4) + 0x1;  			disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  			#endregion  		}  		if (disp > currentOutSize)  			throw new InvalidDataException (String.Format (Main.Get_Traduction ("S04")' disp' currentOutSize.ToString ("X")' instream.Position.ToString ("X")' (byte1 >> 4).ToString ("X")));  		#endregion  		int bufIdx = bufferOffset + bufferLength - disp;  		for (int i = 0; i < length; i++) {  			byte next = buffer [bufIdx % bufferLength];  			bufIdx++;  			outstream.WriteByte (next);  			buffer [bufferOffset] = next;  			bufferOffset = (bufferOffset + 1) % bufferLength;  		}  		currentOutSize += length;  	} else {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int next = instream.ReadByte ();  		readBytes++;  		if (next < 0)  			throw new StreamTooShortException ();  		outstream.WriteByte ((byte)next);  		currentOutSize++;  		buffer [bufferOffset] = (byte)next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: while (currentOutSize < decompressedSize) {  	// (throws when requested new flags byte is not available)  	#region Update the mask. If all flag bits have been read' get a new set.  	// the current mask is the mask used in the previous run. So if it masks the  	// last flag bit' get a new flags byte.  	if (mask == 1) {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		flags = instream.ReadByte ();  		readBytes++;  		if (flags < 0)  			throw new StreamTooShortException ();  		mask = 0x80;  	} else {  		mask >>= 1;  	}  	#endregion  	// bit = 1 <=> compressed.  	if ((flags & mask) > 0) {  		// (throws when not enough bytes are available)  		#region Get length and displacement('disp') values from next 2' 3 or 4 bytes  		// read the first byte first' which also signals the size of the compressed block  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte1 = instream.ReadByte ();  		readBytes++;  		if (byte1 < 0)  			throw new StreamTooShortException ();  		int length = byte1 >> 4;  		int disp = -1;  		if (length == 0) {  			#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			// case 0:  			// data = AB CD EF (with A=0)  			// LEN = ABC + 0x11 == BC + 0x11  			// DISP = DEF + 1  			// we need two more bytes available  			if (readBytes + 1 >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			int byte3 = instream.ReadByte ();  			readBytes++;  			if (byte3 < 0)  				throw new StreamTooShortException ();  			length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  			disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  			#endregion  		} else if (length == 1) {  			#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			// case 1:  			// data = AB CD EF GH (with A=1)  			// LEN = BCDE + 0x111  			// DISP = FGH + 1  			// we need three more bytes available  			if (readBytes + 2 >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			int byte3 = instream.ReadByte ();  			readBytes++;  			int byte4 = instream.ReadByte ();  			readBytes++;  			if (byte4 < 0)  				throw new StreamTooShortException ();  			length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  			disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  			#endregion  		} else {  			#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			// case other:  			// data = AB CD  			// LEN = A + 1  			// DISP = BCD + 1  			// we need only one more byte available  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			if (byte2 < 0)  				throw new StreamTooShortException ();  			length = ((byte1 & 0xF0) >> 4) + 0x1;  			disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  			#endregion  		}  		if (disp > currentOutSize)  			throw new InvalidDataException (String.Format (Main.Get_Traduction ("S04")' disp' currentOutSize.ToString ("X")' instream.Position.ToString ("X")' (byte1 >> 4).ToString ("X")));  		#endregion  		int bufIdx = bufferOffset + bufferLength - disp;  		for (int i = 0; i < length; i++) {  			byte next = buffer [bufIdx % bufferLength];  			bufIdx++;  			outstream.WriteByte (next);  			buffer [bufferOffset] = next;  			bufferOffset = (bufferOffset + 1) % bufferLength;  		}  		currentOutSize += length;  	} else {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int next = instream.ReadByte ();  		readBytes++;  		if (next < 0)  			throw new StreamTooShortException ();  		outstream.WriteByte ((byte)next);  		currentOutSize++;  		buffer [bufferOffset] = (byte)next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: while (currentOutSize < decompressedSize) {  	// (throws when requested new flags byte is not available)  	#region Update the mask. If all flag bits have been read' get a new set.  	// the current mask is the mask used in the previous run. So if it masks the  	// last flag bit' get a new flags byte.  	if (mask == 1) {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		flags = instream.ReadByte ();  		readBytes++;  		if (flags < 0)  			throw new StreamTooShortException ();  		mask = 0x80;  	} else {  		mask >>= 1;  	}  	#endregion  	// bit = 1 <=> compressed.  	if ((flags & mask) > 0) {  		// (throws when not enough bytes are available)  		#region Get length and displacement('disp') values from next 2' 3 or 4 bytes  		// read the first byte first' which also signals the size of the compressed block  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte1 = instream.ReadByte ();  		readBytes++;  		if (byte1 < 0)  			throw new StreamTooShortException ();  		int length = byte1 >> 4;  		int disp = -1;  		if (length == 0) {  			#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			// case 0:  			// data = AB CD EF (with A=0)  			// LEN = ABC + 0x11 == BC + 0x11  			// DISP = DEF + 1  			// we need two more bytes available  			if (readBytes + 1 >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			int byte3 = instream.ReadByte ();  			readBytes++;  			if (byte3 < 0)  				throw new StreamTooShortException ();  			length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  			disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  			#endregion  		} else if (length == 1) {  			#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			// case 1:  			// data = AB CD EF GH (with A=1)  			// LEN = BCDE + 0x111  			// DISP = FGH + 1  			// we need three more bytes available  			if (readBytes + 2 >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			int byte3 = instream.ReadByte ();  			readBytes++;  			int byte4 = instream.ReadByte ();  			readBytes++;  			if (byte4 < 0)  				throw new StreamTooShortException ();  			length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  			disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  			#endregion  		} else {  			#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			// case other:  			// data = AB CD  			// LEN = A + 1  			// DISP = BCD + 1  			// we need only one more byte available  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			if (byte2 < 0)  				throw new StreamTooShortException ();  			length = ((byte1 & 0xF0) >> 4) + 0x1;  			disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  			#endregion  		}  		if (disp > currentOutSize)  			throw new InvalidDataException (String.Format (Main.Get_Traduction ("S04")' disp' currentOutSize.ToString ("X")' instream.Position.ToString ("X")' (byte1 >> 4).ToString ("X")));  		#endregion  		int bufIdx = bufferOffset + bufferLength - disp;  		for (int i = 0; i < length; i++) {  			byte next = buffer [bufIdx % bufferLength];  			bufIdx++;  			outstream.WriteByte (next);  			buffer [bufferOffset] = next;  			bufferOffset = (bufferOffset + 1) % bufferLength;  		}  		currentOutSize += length;  	} else {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int next = instream.ReadByte ();  		readBytes++;  		if (next < 0)  			throw new StreamTooShortException ();  		outstream.WriteByte ((byte)next);  		currentOutSize++;  		buffer [bufferOffset] = (byte)next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: while (currentOutSize < decompressedSize) {  	// (throws when requested new flags byte is not available)  	#region Update the mask. If all flag bits have been read' get a new set.  	// the current mask is the mask used in the previous run. So if it masks the  	// last flag bit' get a new flags byte.  	if (mask == 1) {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		flags = instream.ReadByte ();  		readBytes++;  		if (flags < 0)  			throw new StreamTooShortException ();  		mask = 0x80;  	} else {  		mask >>= 1;  	}  	#endregion  	// bit = 1 <=> compressed.  	if ((flags & mask) > 0) {  		// (throws when not enough bytes are available)  		#region Get length and displacement('disp') values from next 2' 3 or 4 bytes  		// read the first byte first' which also signals the size of the compressed block  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte1 = instream.ReadByte ();  		readBytes++;  		if (byte1 < 0)  			throw new StreamTooShortException ();  		int length = byte1 >> 4;  		int disp = -1;  		if (length == 0) {  			#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			// case 0:  			// data = AB CD EF (with A=0)  			// LEN = ABC + 0x11 == BC + 0x11  			// DISP = DEF + 1  			// we need two more bytes available  			if (readBytes + 1 >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			int byte3 = instream.ReadByte ();  			readBytes++;  			if (byte3 < 0)  				throw new StreamTooShortException ();  			length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  			disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  			#endregion  		} else if (length == 1) {  			#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			// case 1:  			// data = AB CD EF GH (with A=1)  			// LEN = BCDE + 0x111  			// DISP = FGH + 1  			// we need three more bytes available  			if (readBytes + 2 >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			int byte3 = instream.ReadByte ();  			readBytes++;  			int byte4 = instream.ReadByte ();  			readBytes++;  			if (byte4 < 0)  				throw new StreamTooShortException ();  			length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  			disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  			#endregion  		} else {  			#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			// case other:  			// data = AB CD  			// LEN = A + 1  			// DISP = BCD + 1  			// we need only one more byte available  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			if (byte2 < 0)  				throw new StreamTooShortException ();  			length = ((byte1 & 0xF0) >> 4) + 0x1;  			disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  			#endregion  		}  		if (disp > currentOutSize)  			throw new InvalidDataException (String.Format (Main.Get_Traduction ("S04")' disp' currentOutSize.ToString ("X")' instream.Position.ToString ("X")' (byte1 >> 4).ToString ("X")));  		#endregion  		int bufIdx = bufferOffset + bufferLength - disp;  		for (int i = 0; i < length; i++) {  			byte next = buffer [bufIdx % bufferLength];  			bufIdx++;  			outstream.WriteByte (next);  			buffer [bufferOffset] = next;  			bufferOffset = (bufferOffset + 1) % bufferLength;  		}  		currentOutSize += length;  	} else {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int next = instream.ReadByte ();  		readBytes++;  		if (next < 0)  			throw new StreamTooShortException ();  		outstream.WriteByte ((byte)next);  		currentOutSize++;  		buffer [bufferOffset] = (byte)next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: while (currentOutSize < decompressedSize) {  	// (throws when requested new flags byte is not available)  	#region Update the mask. If all flag bits have been read' get a new set.  	// the current mask is the mask used in the previous run. So if it masks the  	// last flag bit' get a new flags byte.  	if (mask == 1) {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		flags = instream.ReadByte ();  		readBytes++;  		if (flags < 0)  			throw new StreamTooShortException ();  		mask = 0x80;  	} else {  		mask >>= 1;  	}  	#endregion  	// bit = 1 <=> compressed.  	if ((flags & mask) > 0) {  		// (throws when not enough bytes are available)  		#region Get length and displacement('disp') values from next 2' 3 or 4 bytes  		// read the first byte first' which also signals the size of the compressed block  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte1 = instream.ReadByte ();  		readBytes++;  		if (byte1 < 0)  			throw new StreamTooShortException ();  		int length = byte1 >> 4;  		int disp = -1;  		if (length == 0) {  			#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			// case 0:  			// data = AB CD EF (with A=0)  			// LEN = ABC + 0x11 == BC + 0x11  			// DISP = DEF + 1  			// we need two more bytes available  			if (readBytes + 1 >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			int byte3 = instream.ReadByte ();  			readBytes++;  			if (byte3 < 0)  				throw new StreamTooShortException ();  			length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  			disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  			#endregion  		} else if (length == 1) {  			#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			// case 1:  			// data = AB CD EF GH (with A=1)  			// LEN = BCDE + 0x111  			// DISP = FGH + 1  			// we need three more bytes available  			if (readBytes + 2 >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			int byte3 = instream.ReadByte ();  			readBytes++;  			int byte4 = instream.ReadByte ();  			readBytes++;  			if (byte4 < 0)  				throw new StreamTooShortException ();  			length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  			disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  			#endregion  		} else {  			#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			// case other:  			// data = AB CD  			// LEN = A + 1  			// DISP = BCD + 1  			// we need only one more byte available  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			if (byte2 < 0)  				throw new StreamTooShortException ();  			length = ((byte1 & 0xF0) >> 4) + 0x1;  			disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  			#endregion  		}  		if (disp > currentOutSize)  			throw new InvalidDataException (String.Format (Main.Get_Traduction ("S04")' disp' currentOutSize.ToString ("X")' instream.Position.ToString ("X")' (byte1 >> 4).ToString ("X")));  		#endregion  		int bufIdx = bufferOffset + bufferLength - disp;  		for (int i = 0; i < length; i++) {  			byte next = buffer [bufIdx % bufferLength];  			bufIdx++;  			outstream.WriteByte (next);  			buffer [bufferOffset] = next;  			bufferOffset = (bufferOffset + 1) % bufferLength;  		}  		currentOutSize += length;  	} else {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int next = instream.ReadByte ();  		readBytes++;  		if (next < 0)  			throw new StreamTooShortException ();  		outstream.WriteByte ((byte)next);  		currentOutSize++;  		buffer [bufferOffset] = (byte)next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: while (currentOutSize < decompressedSize) {  	// (throws when requested new flags byte is not available)  	#region Update the mask. If all flag bits have been read' get a new set.  	// the current mask is the mask used in the previous run. So if it masks the  	// last flag bit' get a new flags byte.  	if (mask == 1) {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		flags = instream.ReadByte ();  		readBytes++;  		if (flags < 0)  			throw new StreamTooShortException ();  		mask = 0x80;  	} else {  		mask >>= 1;  	}  	#endregion  	// bit = 1 <=> compressed.  	if ((flags & mask) > 0) {  		// (throws when not enough bytes are available)  		#region Get length and displacement('disp') values from next 2' 3 or 4 bytes  		// read the first byte first' which also signals the size of the compressed block  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte1 = instream.ReadByte ();  		readBytes++;  		if (byte1 < 0)  			throw new StreamTooShortException ();  		int length = byte1 >> 4;  		int disp = -1;  		if (length == 0) {  			#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			// case 0:  			// data = AB CD EF (with A=0)  			// LEN = ABC + 0x11 == BC + 0x11  			// DISP = DEF + 1  			// we need two more bytes available  			if (readBytes + 1 >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			int byte3 = instream.ReadByte ();  			readBytes++;  			if (byte3 < 0)  				throw new StreamTooShortException ();  			length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  			disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  			#endregion  		} else if (length == 1) {  			#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			// case 1:  			// data = AB CD EF GH (with A=1)  			// LEN = BCDE + 0x111  			// DISP = FGH + 1  			// we need three more bytes available  			if (readBytes + 2 >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			int byte3 = instream.ReadByte ();  			readBytes++;  			int byte4 = instream.ReadByte ();  			readBytes++;  			if (byte4 < 0)  				throw new StreamTooShortException ();  			length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  			disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  			#endregion  		} else {  			#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			// case other:  			// data = AB CD  			// LEN = A + 1  			// DISP = BCD + 1  			// we need only one more byte available  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			if (byte2 < 0)  				throw new StreamTooShortException ();  			length = ((byte1 & 0xF0) >> 4) + 0x1;  			disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  			#endregion  		}  		if (disp > currentOutSize)  			throw new InvalidDataException (String.Format (Main.Get_Traduction ("S04")' disp' currentOutSize.ToString ("X")' instream.Position.ToString ("X")' (byte1 >> 4).ToString ("X")));  		#endregion  		int bufIdx = bufferOffset + bufferLength - disp;  		for (int i = 0; i < length; i++) {  			byte next = buffer [bufIdx % bufferLength];  			bufIdx++;  			outstream.WriteByte (next);  			buffer [bufferOffset] = next;  			bufferOffset = (bufferOffset + 1) % bufferLength;  		}  		currentOutSize += length;  	} else {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int next = instream.ReadByte ();  		readBytes++;  		if (next < 0)  			throw new StreamTooShortException ();  		outstream.WriteByte ((byte)next);  		currentOutSize++;  		buffer [bufferOffset] = (byte)next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: while (currentOutSize < decompressedSize) {  	// (throws when requested new flags byte is not available)  	#region Update the mask. If all flag bits have been read' get a new set.  	// the current mask is the mask used in the previous run. So if it masks the  	// last flag bit' get a new flags byte.  	if (mask == 1) {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		flags = instream.ReadByte ();  		readBytes++;  		if (flags < 0)  			throw new StreamTooShortException ();  		mask = 0x80;  	} else {  		mask >>= 1;  	}  	#endregion  	// bit = 1 <=> compressed.  	if ((flags & mask) > 0) {  		// (throws when not enough bytes are available)  		#region Get length and displacement('disp') values from next 2' 3 or 4 bytes  		// read the first byte first' which also signals the size of the compressed block  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte1 = instream.ReadByte ();  		readBytes++;  		if (byte1 < 0)  			throw new StreamTooShortException ();  		int length = byte1 >> 4;  		int disp = -1;  		if (length == 0) {  			#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			// case 0:  			// data = AB CD EF (with A=0)  			// LEN = ABC + 0x11 == BC + 0x11  			// DISP = DEF + 1  			// we need two more bytes available  			if (readBytes + 1 >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			int byte3 = instream.ReadByte ();  			readBytes++;  			if (byte3 < 0)  				throw new StreamTooShortException ();  			length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  			disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  			#endregion  		} else if (length == 1) {  			#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			// case 1:  			// data = AB CD EF GH (with A=1)  			// LEN = BCDE + 0x111  			// DISP = FGH + 1  			// we need three more bytes available  			if (readBytes + 2 >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			int byte3 = instream.ReadByte ();  			readBytes++;  			int byte4 = instream.ReadByte ();  			readBytes++;  			if (byte4 < 0)  				throw new StreamTooShortException ();  			length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  			disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  			#endregion  		} else {  			#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			// case other:  			// data = AB CD  			// LEN = A + 1  			// DISP = BCD + 1  			// we need only one more byte available  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			if (byte2 < 0)  				throw new StreamTooShortException ();  			length = ((byte1 & 0xF0) >> 4) + 0x1;  			disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  			#endregion  		}  		if (disp > currentOutSize)  			throw new InvalidDataException (String.Format (Main.Get_Traduction ("S04")' disp' currentOutSize.ToString ("X")' instream.Position.ToString ("X")' (byte1 >> 4).ToString ("X")));  		#endregion  		int bufIdx = bufferOffset + bufferLength - disp;  		for (int i = 0; i < length; i++) {  			byte next = buffer [bufIdx % bufferLength];  			bufIdx++;  			outstream.WriteByte (next);  			buffer [bufferOffset] = next;  			bufferOffset = (bufferOffset + 1) % bufferLength;  		}  		currentOutSize += length;  	} else {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int next = instream.ReadByte ();  		readBytes++;  		if (next < 0)  			throw new StreamTooShortException ();  		outstream.WriteByte ((byte)next);  		currentOutSize++;  		buffer [bufferOffset] = (byte)next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: while (currentOutSize < decompressedSize) {  	// (throws when requested new flags byte is not available)  	#region Update the mask. If all flag bits have been read' get a new set.  	// the current mask is the mask used in the previous run. So if it masks the  	// last flag bit' get a new flags byte.  	if (mask == 1) {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		flags = instream.ReadByte ();  		readBytes++;  		if (flags < 0)  			throw new StreamTooShortException ();  		mask = 0x80;  	} else {  		mask >>= 1;  	}  	#endregion  	// bit = 1 <=> compressed.  	if ((flags & mask) > 0) {  		// (throws when not enough bytes are available)  		#region Get length and displacement('disp') values from next 2' 3 or 4 bytes  		// read the first byte first' which also signals the size of the compressed block  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte1 = instream.ReadByte ();  		readBytes++;  		if (byte1 < 0)  			throw new StreamTooShortException ();  		int length = byte1 >> 4;  		int disp = -1;  		if (length == 0) {  			#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			// case 0:  			// data = AB CD EF (with A=0)  			// LEN = ABC + 0x11 == BC + 0x11  			// DISP = DEF + 1  			// we need two more bytes available  			if (readBytes + 1 >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			int byte3 = instream.ReadByte ();  			readBytes++;  			if (byte3 < 0)  				throw new StreamTooShortException ();  			length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  			disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  			#endregion  		} else if (length == 1) {  			#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			// case 1:  			// data = AB CD EF GH (with A=1)  			// LEN = BCDE + 0x111  			// DISP = FGH + 1  			// we need three more bytes available  			if (readBytes + 2 >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			int byte3 = instream.ReadByte ();  			readBytes++;  			int byte4 = instream.ReadByte ();  			readBytes++;  			if (byte4 < 0)  				throw new StreamTooShortException ();  			length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  			disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  			#endregion  		} else {  			#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			// case other:  			// data = AB CD  			// LEN = A + 1  			// DISP = BCD + 1  			// we need only one more byte available  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			if (byte2 < 0)  				throw new StreamTooShortException ();  			length = ((byte1 & 0xF0) >> 4) + 0x1;  			disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  			#endregion  		}  		if (disp > currentOutSize)  			throw new InvalidDataException (String.Format (Main.Get_Traduction ("S04")' disp' currentOutSize.ToString ("X")' instream.Position.ToString ("X")' (byte1 >> 4).ToString ("X")));  		#endregion  		int bufIdx = bufferOffset + bufferLength - disp;  		for (int i = 0; i < length; i++) {  			byte next = buffer [bufIdx % bufferLength];  			bufIdx++;  			outstream.WriteByte (next);  			buffer [bufferOffset] = next;  			bufferOffset = (bufferOffset + 1) % bufferLength;  		}  		currentOutSize += length;  	} else {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int next = instream.ReadByte ();  		readBytes++;  		if (next < 0)  			throw new StreamTooShortException ();  		outstream.WriteByte ((byte)next);  		currentOutSize++;  		buffer [bufferOffset] = (byte)next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: while (currentOutSize < decompressedSize) {  	// (throws when requested new flags byte is not available)  	#region Update the mask. If all flag bits have been read' get a new set.  	// the current mask is the mask used in the previous run. So if it masks the  	// last flag bit' get a new flags byte.  	if (mask == 1) {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		flags = instream.ReadByte ();  		readBytes++;  		if (flags < 0)  			throw new StreamTooShortException ();  		mask = 0x80;  	} else {  		mask >>= 1;  	}  	#endregion  	// bit = 1 <=> compressed.  	if ((flags & mask) > 0) {  		// (throws when not enough bytes are available)  		#region Get length and displacement('disp') values from next 2' 3 or 4 bytes  		// read the first byte first' which also signals the size of the compressed block  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte1 = instream.ReadByte ();  		readBytes++;  		if (byte1 < 0)  			throw new StreamTooShortException ();  		int length = byte1 >> 4;  		int disp = -1;  		if (length == 0) {  			#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			// case 0:  			// data = AB CD EF (with A=0)  			// LEN = ABC + 0x11 == BC + 0x11  			// DISP = DEF + 1  			// we need two more bytes available  			if (readBytes + 1 >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			int byte3 = instream.ReadByte ();  			readBytes++;  			if (byte3 < 0)  				throw new StreamTooShortException ();  			length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  			disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  			#endregion  		} else if (length == 1) {  			#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			// case 1:  			// data = AB CD EF GH (with A=1)  			// LEN = BCDE + 0x111  			// DISP = FGH + 1  			// we need three more bytes available  			if (readBytes + 2 >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			int byte3 = instream.ReadByte ();  			readBytes++;  			int byte4 = instream.ReadByte ();  			readBytes++;  			if (byte4 < 0)  				throw new StreamTooShortException ();  			length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  			disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  			#endregion  		} else {  			#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			// case other:  			// data = AB CD  			// LEN = A + 1  			// DISP = BCD + 1  			// we need only one more byte available  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			if (byte2 < 0)  				throw new StreamTooShortException ();  			length = ((byte1 & 0xF0) >> 4) + 0x1;  			disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  			#endregion  		}  		if (disp > currentOutSize)  			throw new InvalidDataException (String.Format (Main.Get_Traduction ("S04")' disp' currentOutSize.ToString ("X")' instream.Position.ToString ("X")' (byte1 >> 4).ToString ("X")));  		#endregion  		int bufIdx = bufferOffset + bufferLength - disp;  		for (int i = 0; i < length; i++) {  			byte next = buffer [bufIdx % bufferLength];  			bufIdx++;  			outstream.WriteByte (next);  			buffer [bufferOffset] = next;  			bufferOffset = (bufferOffset + 1) % bufferLength;  		}  		currentOutSize += length;  	} else {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int next = instream.ReadByte ();  		readBytes++;  		if (next < 0)  			throw new StreamTooShortException ();  		outstream.WriteByte ((byte)next);  		currentOutSize++;  		buffer [bufferOffset] = (byte)next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: while (currentOutSize < decompressedSize) {  	// (throws when requested new flags byte is not available)  	#region Update the mask. If all flag bits have been read' get a new set.  	// the current mask is the mask used in the previous run. So if it masks the  	// last flag bit' get a new flags byte.  	if (mask == 1) {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		flags = instream.ReadByte ();  		readBytes++;  		if (flags < 0)  			throw new StreamTooShortException ();  		mask = 0x80;  	} else {  		mask >>= 1;  	}  	#endregion  	// bit = 1 <=> compressed.  	if ((flags & mask) > 0) {  		// (throws when not enough bytes are available)  		#region Get length and displacement('disp') values from next 2' 3 or 4 bytes  		// read the first byte first' which also signals the size of the compressed block  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte1 = instream.ReadByte ();  		readBytes++;  		if (byte1 < 0)  			throw new StreamTooShortException ();  		int length = byte1 >> 4;  		int disp = -1;  		if (length == 0) {  			#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			// case 0:  			// data = AB CD EF (with A=0)  			// LEN = ABC + 0x11 == BC + 0x11  			// DISP = DEF + 1  			// we need two more bytes available  			if (readBytes + 1 >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			int byte3 = instream.ReadByte ();  			readBytes++;  			if (byte3 < 0)  				throw new StreamTooShortException ();  			length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  			disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  			#endregion  		} else if (length == 1) {  			#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			// case 1:  			// data = AB CD EF GH (with A=1)  			// LEN = BCDE + 0x111  			// DISP = FGH + 1  			// we need three more bytes available  			if (readBytes + 2 >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			int byte3 = instream.ReadByte ();  			readBytes++;  			int byte4 = instream.ReadByte ();  			readBytes++;  			if (byte4 < 0)  				throw new StreamTooShortException ();  			length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  			disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  			#endregion  		} else {  			#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			// case other:  			// data = AB CD  			// LEN = A + 1  			// DISP = BCD + 1  			// we need only one more byte available  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			if (byte2 < 0)  				throw new StreamTooShortException ();  			length = ((byte1 & 0xF0) >> 4) + 0x1;  			disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  			#endregion  		}  		if (disp > currentOutSize)  			throw new InvalidDataException (String.Format (Main.Get_Traduction ("S04")' disp' currentOutSize.ToString ("X")' instream.Position.ToString ("X")' (byte1 >> 4).ToString ("X")));  		#endregion  		int bufIdx = bufferOffset + bufferLength - disp;  		for (int i = 0; i < length; i++) {  			byte next = buffer [bufIdx % bufferLength];  			bufIdx++;  			outstream.WriteByte (next);  			buffer [bufferOffset] = next;  			bufferOffset = (bufferOffset + 1) % bufferLength;  		}  		currentOutSize += length;  	} else {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int next = instream.ReadByte ();  		readBytes++;  		if (next < 0)  			throw new StreamTooShortException ();  		outstream.WriteByte ((byte)next);  		currentOutSize++;  		buffer [bufferOffset] = (byte)next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: while (currentOutSize < decompressedSize) {  	// (throws when requested new flags byte is not available)  	#region Update the mask. If all flag bits have been read' get a new set.  	// the current mask is the mask used in the previous run. So if it masks the  	// last flag bit' get a new flags byte.  	if (mask == 1) {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		flags = instream.ReadByte ();  		readBytes++;  		if (flags < 0)  			throw new StreamTooShortException ();  		mask = 0x80;  	} else {  		mask >>= 1;  	}  	#endregion  	// bit = 1 <=> compressed.  	if ((flags & mask) > 0) {  		// (throws when not enough bytes are available)  		#region Get length and displacement('disp') values from next 2' 3 or 4 bytes  		// read the first byte first' which also signals the size of the compressed block  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte1 = instream.ReadByte ();  		readBytes++;  		if (byte1 < 0)  			throw new StreamTooShortException ();  		int length = byte1 >> 4;  		int disp = -1;  		if (length == 0) {  			#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			// case 0:  			// data = AB CD EF (with A=0)  			// LEN = ABC + 0x11 == BC + 0x11  			// DISP = DEF + 1  			// we need two more bytes available  			if (readBytes + 1 >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			int byte3 = instream.ReadByte ();  			readBytes++;  			if (byte3 < 0)  				throw new StreamTooShortException ();  			length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  			disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  			#endregion  		} else if (length == 1) {  			#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			// case 1:  			// data = AB CD EF GH (with A=1)  			// LEN = BCDE + 0x111  			// DISP = FGH + 1  			// we need three more bytes available  			if (readBytes + 2 >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			int byte3 = instream.ReadByte ();  			readBytes++;  			int byte4 = instream.ReadByte ();  			readBytes++;  			if (byte4 < 0)  				throw new StreamTooShortException ();  			length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  			disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  			#endregion  		} else {  			#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			// case other:  			// data = AB CD  			// LEN = A + 1  			// DISP = BCD + 1  			// we need only one more byte available  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			if (byte2 < 0)  				throw new StreamTooShortException ();  			length = ((byte1 & 0xF0) >> 4) + 0x1;  			disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  			#endregion  		}  		if (disp > currentOutSize)  			throw new InvalidDataException (String.Format (Main.Get_Traduction ("S04")' disp' currentOutSize.ToString ("X")' instream.Position.ToString ("X")' (byte1 >> 4).ToString ("X")));  		#endregion  		int bufIdx = bufferOffset + bufferLength - disp;  		for (int i = 0; i < length; i++) {  			byte next = buffer [bufIdx % bufferLength];  			bufIdx++;  			outstream.WriteByte (next);  			buffer [bufferOffset] = next;  			bufferOffset = (bufferOffset + 1) % bufferLength;  		}  		currentOutSize += length;  	} else {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int next = instream.ReadByte ();  		readBytes++;  		if (next < 0)  			throw new StreamTooShortException ();  		outstream.WriteByte ((byte)next);  		currentOutSize++;  		buffer [bufferOffset] = (byte)next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: while (currentOutSize < decompressedSize) {  	// (throws when requested new flags byte is not available)  	#region Update the mask. If all flag bits have been read' get a new set.  	// the current mask is the mask used in the previous run. So if it masks the  	// last flag bit' get a new flags byte.  	if (mask == 1) {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		flags = instream.ReadByte ();  		readBytes++;  		if (flags < 0)  			throw new StreamTooShortException ();  		mask = 0x80;  	} else {  		mask >>= 1;  	}  	#endregion  	// bit = 1 <=> compressed.  	if ((flags & mask) > 0) {  		// (throws when not enough bytes are available)  		#region Get length and displacement('disp') values from next 2' 3 or 4 bytes  		// read the first byte first' which also signals the size of the compressed block  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte1 = instream.ReadByte ();  		readBytes++;  		if (byte1 < 0)  			throw new StreamTooShortException ();  		int length = byte1 >> 4;  		int disp = -1;  		if (length == 0) {  			#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			// case 0:  			// data = AB CD EF (with A=0)  			// LEN = ABC + 0x11 == BC + 0x11  			// DISP = DEF + 1  			// we need two more bytes available  			if (readBytes + 1 >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			int byte3 = instream.ReadByte ();  			readBytes++;  			if (byte3 < 0)  				throw new StreamTooShortException ();  			length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  			disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  			#endregion  		} else if (length == 1) {  			#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			// case 1:  			// data = AB CD EF GH (with A=1)  			// LEN = BCDE + 0x111  			// DISP = FGH + 1  			// we need three more bytes available  			if (readBytes + 2 >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			int byte3 = instream.ReadByte ();  			readBytes++;  			int byte4 = instream.ReadByte ();  			readBytes++;  			if (byte4 < 0)  				throw new StreamTooShortException ();  			length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  			disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  			#endregion  		} else {  			#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			// case other:  			// data = AB CD  			// LEN = A + 1  			// DISP = BCD + 1  			// we need only one more byte available  			if (readBytes >= inLength)  				throw new NotEnoughDataException (currentOutSize' decompressedSize);  			int byte2 = instream.ReadByte ();  			readBytes++;  			if (byte2 < 0)  				throw new StreamTooShortException ();  			length = ((byte1 & 0xF0) >> 4) + 0x1;  			disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  			#endregion  		}  		if (disp > currentOutSize)  			throw new InvalidDataException (String.Format (Main.Get_Traduction ("S04")' disp' currentOutSize.ToString ("X")' instream.Position.ToString ("X")' (byte1 >> 4).ToString ("X")));  		#endregion  		int bufIdx = bufferOffset + bufferLength - disp;  		for (int i = 0; i < length; i++) {  			byte next = buffer [bufIdx % bufferLength];  			bufIdx++;  			outstream.WriteByte (next);  			buffer [bufferOffset] = next;  			bufferOffset = (bufferOffset + 1) % bufferLength;  		}  		currentOutSize += length;  	} else {  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int next = instream.ReadByte ();  		readBytes++;  		if (next < 0)  			throw new StreamTooShortException ();  		outstream.WriteByte ((byte)next);  		currentOutSize++;  		buffer [bufferOffset] = (byte)next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if ((flags & mask) > 0) {  	// (throws when not enough bytes are available)  	#region Get length and displacement('disp') values from next 2' 3 or 4 bytes  	// read the first byte first' which also signals the size of the compressed block  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte1 = instream.ReadByte ();  	readBytes++;  	if (byte1 < 0)  		throw new StreamTooShortException ();  	int length = byte1 >> 4;  	int disp = -1;  	if (length == 0) {  		#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  		// case 0:  		// data = AB CD EF (with A=0)  		// LEN = ABC + 0x11 == BC + 0x11  		// DISP = DEF + 1  		// we need two more bytes available  		if (readBytes + 1 >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		int byte3 = instream.ReadByte ();  		readBytes++;  		if (byte3 < 0)  			throw new StreamTooShortException ();  		length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  		disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  		#endregion  	} else if (length == 1) {  		#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  		// case 1:  		// data = AB CD EF GH (with A=1)  		// LEN = BCDE + 0x111  		// DISP = FGH + 1  		// we need three more bytes available  		if (readBytes + 2 >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		int byte3 = instream.ReadByte ();  		readBytes++;  		int byte4 = instream.ReadByte ();  		readBytes++;  		if (byte4 < 0)  			throw new StreamTooShortException ();  		length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  		disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  		#endregion  	} else {  		#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  		// case other:  		// data = AB CD  		// LEN = A + 1  		// DISP = BCD + 1  		// we need only one more byte available  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		if (byte2 < 0)  			throw new StreamTooShortException ();  		length = ((byte1 & 0xF0) >> 4) + 0x1;  		disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  		#endregion  	}  	if (disp > currentOutSize)  		throw new InvalidDataException (String.Format (Main.Get_Traduction ("S04")' disp' currentOutSize.ToString ("X")' instream.Position.ToString ("X")' (byte1 >> 4).ToString ("X")));  	#endregion  	int bufIdx = bufferOffset + bufferLength - disp;  	for (int i = 0; i < length; i++) {  		byte next = buffer [bufIdx % bufferLength];  		bufIdx++;  		outstream.WriteByte (next);  		buffer [bufferOffset] = next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  	currentOutSize += length;  } else {  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int next = instream.ReadByte ();  	readBytes++;  	if (next < 0)  		throw new StreamTooShortException ();  	outstream.WriteByte ((byte)next);  	currentOutSize++;  	buffer [bufferOffset] = (byte)next;  	bufferOffset = (bufferOffset + 1) % bufferLength;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if ((flags & mask) > 0) {  	// (throws when not enough bytes are available)  	#region Get length and displacement('disp') values from next 2' 3 or 4 bytes  	// read the first byte first' which also signals the size of the compressed block  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte1 = instream.ReadByte ();  	readBytes++;  	if (byte1 < 0)  		throw new StreamTooShortException ();  	int length = byte1 >> 4;  	int disp = -1;  	if (length == 0) {  		#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  		// case 0:  		// data = AB CD EF (with A=0)  		// LEN = ABC + 0x11 == BC + 0x11  		// DISP = DEF + 1  		// we need two more bytes available  		if (readBytes + 1 >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		int byte3 = instream.ReadByte ();  		readBytes++;  		if (byte3 < 0)  			throw new StreamTooShortException ();  		length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  		disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  		#endregion  	} else if (length == 1) {  		#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  		// case 1:  		// data = AB CD EF GH (with A=1)  		// LEN = BCDE + 0x111  		// DISP = FGH + 1  		// we need three more bytes available  		if (readBytes + 2 >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		int byte3 = instream.ReadByte ();  		readBytes++;  		int byte4 = instream.ReadByte ();  		readBytes++;  		if (byte4 < 0)  			throw new StreamTooShortException ();  		length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  		disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  		#endregion  	} else {  		#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  		// case other:  		// data = AB CD  		// LEN = A + 1  		// DISP = BCD + 1  		// we need only one more byte available  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		if (byte2 < 0)  			throw new StreamTooShortException ();  		length = ((byte1 & 0xF0) >> 4) + 0x1;  		disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  		#endregion  	}  	if (disp > currentOutSize)  		throw new InvalidDataException (String.Format (Main.Get_Traduction ("S04")' disp' currentOutSize.ToString ("X")' instream.Position.ToString ("X")' (byte1 >> 4).ToString ("X")));  	#endregion  	int bufIdx = bufferOffset + bufferLength - disp;  	for (int i = 0; i < length; i++) {  		byte next = buffer [bufIdx % bufferLength];  		bufIdx++;  		outstream.WriteByte (next);  		buffer [bufferOffset] = next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  	currentOutSize += length;  } else {  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int next = instream.ReadByte ();  	readBytes++;  	if (next < 0)  		throw new StreamTooShortException ();  	outstream.WriteByte ((byte)next);  	currentOutSize++;  	buffer [bufferOffset] = (byte)next;  	bufferOffset = (bufferOffset + 1) % bufferLength;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if ((flags & mask) > 0) {  	// (throws when not enough bytes are available)  	#region Get length and displacement('disp') values from next 2' 3 or 4 bytes  	// read the first byte first' which also signals the size of the compressed block  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte1 = instream.ReadByte ();  	readBytes++;  	if (byte1 < 0)  		throw new StreamTooShortException ();  	int length = byte1 >> 4;  	int disp = -1;  	if (length == 0) {  		#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  		// case 0:  		// data = AB CD EF (with A=0)  		// LEN = ABC + 0x11 == BC + 0x11  		// DISP = DEF + 1  		// we need two more bytes available  		if (readBytes + 1 >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		int byte3 = instream.ReadByte ();  		readBytes++;  		if (byte3 < 0)  			throw new StreamTooShortException ();  		length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  		disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  		#endregion  	} else if (length == 1) {  		#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  		// case 1:  		// data = AB CD EF GH (with A=1)  		// LEN = BCDE + 0x111  		// DISP = FGH + 1  		// we need three more bytes available  		if (readBytes + 2 >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		int byte3 = instream.ReadByte ();  		readBytes++;  		int byte4 = instream.ReadByte ();  		readBytes++;  		if (byte4 < 0)  			throw new StreamTooShortException ();  		length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  		disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  		#endregion  	} else {  		#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  		// case other:  		// data = AB CD  		// LEN = A + 1  		// DISP = BCD + 1  		// we need only one more byte available  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		if (byte2 < 0)  			throw new StreamTooShortException ();  		length = ((byte1 & 0xF0) >> 4) + 0x1;  		disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  		#endregion  	}  	if (disp > currentOutSize)  		throw new InvalidDataException (String.Format (Main.Get_Traduction ("S04")' disp' currentOutSize.ToString ("X")' instream.Position.ToString ("X")' (byte1 >> 4).ToString ("X")));  	#endregion  	int bufIdx = bufferOffset + bufferLength - disp;  	for (int i = 0; i < length; i++) {  		byte next = buffer [bufIdx % bufferLength];  		bufIdx++;  		outstream.WriteByte (next);  		buffer [bufferOffset] = next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  	currentOutSize += length;  } else {  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int next = instream.ReadByte ();  	readBytes++;  	if (next < 0)  		throw new StreamTooShortException ();  	outstream.WriteByte ((byte)next);  	currentOutSize++;  	buffer [bufferOffset] = (byte)next;  	bufferOffset = (bufferOffset + 1) % bufferLength;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if ((flags & mask) > 0) {  	// (throws when not enough bytes are available)  	#region Get length and displacement('disp') values from next 2' 3 or 4 bytes  	// read the first byte first' which also signals the size of the compressed block  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte1 = instream.ReadByte ();  	readBytes++;  	if (byte1 < 0)  		throw new StreamTooShortException ();  	int length = byte1 >> 4;  	int disp = -1;  	if (length == 0) {  		#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  		// case 0:  		// data = AB CD EF (with A=0)  		// LEN = ABC + 0x11 == BC + 0x11  		// DISP = DEF + 1  		// we need two more bytes available  		if (readBytes + 1 >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		int byte3 = instream.ReadByte ();  		readBytes++;  		if (byte3 < 0)  			throw new StreamTooShortException ();  		length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  		disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  		#endregion  	} else if (length == 1) {  		#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  		// case 1:  		// data = AB CD EF GH (with A=1)  		// LEN = BCDE + 0x111  		// DISP = FGH + 1  		// we need three more bytes available  		if (readBytes + 2 >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		int byte3 = instream.ReadByte ();  		readBytes++;  		int byte4 = instream.ReadByte ();  		readBytes++;  		if (byte4 < 0)  			throw new StreamTooShortException ();  		length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  		disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  		#endregion  	} else {  		#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  		// case other:  		// data = AB CD  		// LEN = A + 1  		// DISP = BCD + 1  		// we need only one more byte available  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		if (byte2 < 0)  			throw new StreamTooShortException ();  		length = ((byte1 & 0xF0) >> 4) + 0x1;  		disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  		#endregion  	}  	if (disp > currentOutSize)  		throw new InvalidDataException (String.Format (Main.Get_Traduction ("S04")' disp' currentOutSize.ToString ("X")' instream.Position.ToString ("X")' (byte1 >> 4).ToString ("X")));  	#endregion  	int bufIdx = bufferOffset + bufferLength - disp;  	for (int i = 0; i < length; i++) {  		byte next = buffer [bufIdx % bufferLength];  		bufIdx++;  		outstream.WriteByte (next);  		buffer [bufferOffset] = next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  	currentOutSize += length;  } else {  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int next = instream.ReadByte ();  	readBytes++;  	if (next < 0)  		throw new StreamTooShortException ();  	outstream.WriteByte ((byte)next);  	currentOutSize++;  	buffer [bufferOffset] = (byte)next;  	bufferOffset = (bufferOffset + 1) % bufferLength;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if ((flags & mask) > 0) {  	// (throws when not enough bytes are available)  	#region Get length and displacement('disp') values from next 2' 3 or 4 bytes  	// read the first byte first' which also signals the size of the compressed block  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte1 = instream.ReadByte ();  	readBytes++;  	if (byte1 < 0)  		throw new StreamTooShortException ();  	int length = byte1 >> 4;  	int disp = -1;  	if (length == 0) {  		#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  		// case 0:  		// data = AB CD EF (with A=0)  		// LEN = ABC + 0x11 == BC + 0x11  		// DISP = DEF + 1  		// we need two more bytes available  		if (readBytes + 1 >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		int byte3 = instream.ReadByte ();  		readBytes++;  		if (byte3 < 0)  			throw new StreamTooShortException ();  		length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  		disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  		#endregion  	} else if (length == 1) {  		#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  		// case 1:  		// data = AB CD EF GH (with A=1)  		// LEN = BCDE + 0x111  		// DISP = FGH + 1  		// we need three more bytes available  		if (readBytes + 2 >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		int byte3 = instream.ReadByte ();  		readBytes++;  		int byte4 = instream.ReadByte ();  		readBytes++;  		if (byte4 < 0)  			throw new StreamTooShortException ();  		length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  		disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  		#endregion  	} else {  		#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  		// case other:  		// data = AB CD  		// LEN = A + 1  		// DISP = BCD + 1  		// we need only one more byte available  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		if (byte2 < 0)  			throw new StreamTooShortException ();  		length = ((byte1 & 0xF0) >> 4) + 0x1;  		disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  		#endregion  	}  	if (disp > currentOutSize)  		throw new InvalidDataException (String.Format (Main.Get_Traduction ("S04")' disp' currentOutSize.ToString ("X")' instream.Position.ToString ("X")' (byte1 >> 4).ToString ("X")));  	#endregion  	int bufIdx = bufferOffset + bufferLength - disp;  	for (int i = 0; i < length; i++) {  		byte next = buffer [bufIdx % bufferLength];  		bufIdx++;  		outstream.WriteByte (next);  		buffer [bufferOffset] = next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  	currentOutSize += length;  } else {  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int next = instream.ReadByte ();  	readBytes++;  	if (next < 0)  		throw new StreamTooShortException ();  	outstream.WriteByte ((byte)next);  	currentOutSize++;  	buffer [bufferOffset] = (byte)next;  	bufferOffset = (bufferOffset + 1) % bufferLength;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if ((flags & mask) > 0) {  	// (throws when not enough bytes are available)  	#region Get length and displacement('disp') values from next 2' 3 or 4 bytes  	// read the first byte first' which also signals the size of the compressed block  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte1 = instream.ReadByte ();  	readBytes++;  	if (byte1 < 0)  		throw new StreamTooShortException ();  	int length = byte1 >> 4;  	int disp = -1;  	if (length == 0) {  		#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  		// case 0:  		// data = AB CD EF (with A=0)  		// LEN = ABC + 0x11 == BC + 0x11  		// DISP = DEF + 1  		// we need two more bytes available  		if (readBytes + 1 >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		int byte3 = instream.ReadByte ();  		readBytes++;  		if (byte3 < 0)  			throw new StreamTooShortException ();  		length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  		disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  		#endregion  	} else if (length == 1) {  		#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  		// case 1:  		// data = AB CD EF GH (with A=1)  		// LEN = BCDE + 0x111  		// DISP = FGH + 1  		// we need three more bytes available  		if (readBytes + 2 >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		int byte3 = instream.ReadByte ();  		readBytes++;  		int byte4 = instream.ReadByte ();  		readBytes++;  		if (byte4 < 0)  			throw new StreamTooShortException ();  		length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  		disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  		#endregion  	} else {  		#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  		// case other:  		// data = AB CD  		// LEN = A + 1  		// DISP = BCD + 1  		// we need only one more byte available  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		if (byte2 < 0)  			throw new StreamTooShortException ();  		length = ((byte1 & 0xF0) >> 4) + 0x1;  		disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  		#endregion  	}  	if (disp > currentOutSize)  		throw new InvalidDataException (String.Format (Main.Get_Traduction ("S04")' disp' currentOutSize.ToString ("X")' instream.Position.ToString ("X")' (byte1 >> 4).ToString ("X")));  	#endregion  	int bufIdx = bufferOffset + bufferLength - disp;  	for (int i = 0; i < length; i++) {  		byte next = buffer [bufIdx % bufferLength];  		bufIdx++;  		outstream.WriteByte (next);  		buffer [bufferOffset] = next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  	currentOutSize += length;  } else {  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int next = instream.ReadByte ();  	readBytes++;  	if (next < 0)  		throw new StreamTooShortException ();  	outstream.WriteByte ((byte)next);  	currentOutSize++;  	buffer [bufferOffset] = (byte)next;  	bufferOffset = (bufferOffset + 1) % bufferLength;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if ((flags & mask) > 0) {  	// (throws when not enough bytes are available)  	#region Get length and displacement('disp') values from next 2' 3 or 4 bytes  	// read the first byte first' which also signals the size of the compressed block  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte1 = instream.ReadByte ();  	readBytes++;  	if (byte1 < 0)  		throw new StreamTooShortException ();  	int length = byte1 >> 4;  	int disp = -1;  	if (length == 0) {  		#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  		// case 0:  		// data = AB CD EF (with A=0)  		// LEN = ABC + 0x11 == BC + 0x11  		// DISP = DEF + 1  		// we need two more bytes available  		if (readBytes + 1 >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		int byte3 = instream.ReadByte ();  		readBytes++;  		if (byte3 < 0)  			throw new StreamTooShortException ();  		length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  		disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  		#endregion  	} else if (length == 1) {  		#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  		// case 1:  		// data = AB CD EF GH (with A=1)  		// LEN = BCDE + 0x111  		// DISP = FGH + 1  		// we need three more bytes available  		if (readBytes + 2 >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		int byte3 = instream.ReadByte ();  		readBytes++;  		int byte4 = instream.ReadByte ();  		readBytes++;  		if (byte4 < 0)  			throw new StreamTooShortException ();  		length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  		disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  		#endregion  	} else {  		#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  		// case other:  		// data = AB CD  		// LEN = A + 1  		// DISP = BCD + 1  		// we need only one more byte available  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		if (byte2 < 0)  			throw new StreamTooShortException ();  		length = ((byte1 & 0xF0) >> 4) + 0x1;  		disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  		#endregion  	}  	if (disp > currentOutSize)  		throw new InvalidDataException (String.Format (Main.Get_Traduction ("S04")' disp' currentOutSize.ToString ("X")' instream.Position.ToString ("X")' (byte1 >> 4).ToString ("X")));  	#endregion  	int bufIdx = bufferOffset + bufferLength - disp;  	for (int i = 0; i < length; i++) {  		byte next = buffer [bufIdx % bufferLength];  		bufIdx++;  		outstream.WriteByte (next);  		buffer [bufferOffset] = next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  	currentOutSize += length;  } else {  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int next = instream.ReadByte ();  	readBytes++;  	if (next < 0)  		throw new StreamTooShortException ();  	outstream.WriteByte ((byte)next);  	currentOutSize++;  	buffer [bufferOffset] = (byte)next;  	bufferOffset = (bufferOffset + 1) % bufferLength;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if ((flags & mask) > 0) {  	// (throws when not enough bytes are available)  	#region Get length and displacement('disp') values from next 2' 3 or 4 bytes  	// read the first byte first' which also signals the size of the compressed block  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte1 = instream.ReadByte ();  	readBytes++;  	if (byte1 < 0)  		throw new StreamTooShortException ();  	int length = byte1 >> 4;  	int disp = -1;  	if (length == 0) {  		#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  		// case 0:  		// data = AB CD EF (with A=0)  		// LEN = ABC + 0x11 == BC + 0x11  		// DISP = DEF + 1  		// we need two more bytes available  		if (readBytes + 1 >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		int byte3 = instream.ReadByte ();  		readBytes++;  		if (byte3 < 0)  			throw new StreamTooShortException ();  		length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  		disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  		#endregion  	} else if (length == 1) {  		#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  		// case 1:  		// data = AB CD EF GH (with A=1)  		// LEN = BCDE + 0x111  		// DISP = FGH + 1  		// we need three more bytes available  		if (readBytes + 2 >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		int byte3 = instream.ReadByte ();  		readBytes++;  		int byte4 = instream.ReadByte ();  		readBytes++;  		if (byte4 < 0)  			throw new StreamTooShortException ();  		length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  		disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  		#endregion  	} else {  		#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  		// case other:  		// data = AB CD  		// LEN = A + 1  		// DISP = BCD + 1  		// we need only one more byte available  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		if (byte2 < 0)  			throw new StreamTooShortException ();  		length = ((byte1 & 0xF0) >> 4) + 0x1;  		disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  		#endregion  	}  	if (disp > currentOutSize)  		throw new InvalidDataException (String.Format (Main.Get_Traduction ("S04")' disp' currentOutSize.ToString ("X")' instream.Position.ToString ("X")' (byte1 >> 4).ToString ("X")));  	#endregion  	int bufIdx = bufferOffset + bufferLength - disp;  	for (int i = 0; i < length; i++) {  		byte next = buffer [bufIdx % bufferLength];  		bufIdx++;  		outstream.WriteByte (next);  		buffer [bufferOffset] = next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  	currentOutSize += length;  } else {  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int next = instream.ReadByte ();  	readBytes++;  	if (next < 0)  		throw new StreamTooShortException ();  	outstream.WriteByte ((byte)next);  	currentOutSize++;  	buffer [bufferOffset] = (byte)next;  	bufferOffset = (bufferOffset + 1) % bufferLength;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if ((flags & mask) > 0) {  	// (throws when not enough bytes are available)  	#region Get length and displacement('disp') values from next 2' 3 or 4 bytes  	// read the first byte first' which also signals the size of the compressed block  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte1 = instream.ReadByte ();  	readBytes++;  	if (byte1 < 0)  		throw new StreamTooShortException ();  	int length = byte1 >> 4;  	int disp = -1;  	if (length == 0) {  		#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  		// case 0:  		// data = AB CD EF (with A=0)  		// LEN = ABC + 0x11 == BC + 0x11  		// DISP = DEF + 1  		// we need two more bytes available  		if (readBytes + 1 >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		int byte3 = instream.ReadByte ();  		readBytes++;  		if (byte3 < 0)  			throw new StreamTooShortException ();  		length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  		disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  		#endregion  	} else if (length == 1) {  		#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  		// case 1:  		// data = AB CD EF GH (with A=1)  		// LEN = BCDE + 0x111  		// DISP = FGH + 1  		// we need three more bytes available  		if (readBytes + 2 >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		int byte3 = instream.ReadByte ();  		readBytes++;  		int byte4 = instream.ReadByte ();  		readBytes++;  		if (byte4 < 0)  			throw new StreamTooShortException ();  		length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  		disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  		#endregion  	} else {  		#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  		// case other:  		// data = AB CD  		// LEN = A + 1  		// DISP = BCD + 1  		// we need only one more byte available  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		if (byte2 < 0)  			throw new StreamTooShortException ();  		length = ((byte1 & 0xF0) >> 4) + 0x1;  		disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  		#endregion  	}  	if (disp > currentOutSize)  		throw new InvalidDataException (String.Format (Main.Get_Traduction ("S04")' disp' currentOutSize.ToString ("X")' instream.Position.ToString ("X")' (byte1 >> 4).ToString ("X")));  	#endregion  	int bufIdx = bufferOffset + bufferLength - disp;  	for (int i = 0; i < length; i++) {  		byte next = buffer [bufIdx % bufferLength];  		bufIdx++;  		outstream.WriteByte (next);  		buffer [bufferOffset] = next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  	currentOutSize += length;  } else {  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int next = instream.ReadByte ();  	readBytes++;  	if (next < 0)  		throw new StreamTooShortException ();  	outstream.WriteByte ((byte)next);  	currentOutSize++;  	buffer [bufferOffset] = (byte)next;  	bufferOffset = (bufferOffset + 1) % bufferLength;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if ((flags & mask) > 0) {  	// (throws when not enough bytes are available)  	#region Get length and displacement('disp') values from next 2' 3 or 4 bytes  	// read the first byte first' which also signals the size of the compressed block  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte1 = instream.ReadByte ();  	readBytes++;  	if (byte1 < 0)  		throw new StreamTooShortException ();  	int length = byte1 >> 4;  	int disp = -1;  	if (length == 0) {  		#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  		// case 0:  		// data = AB CD EF (with A=0)  		// LEN = ABC + 0x11 == BC + 0x11  		// DISP = DEF + 1  		// we need two more bytes available  		if (readBytes + 1 >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		int byte3 = instream.ReadByte ();  		readBytes++;  		if (byte3 < 0)  			throw new StreamTooShortException ();  		length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  		disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  		#endregion  	} else if (length == 1) {  		#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  		// case 1:  		// data = AB CD EF GH (with A=1)  		// LEN = BCDE + 0x111  		// DISP = FGH + 1  		// we need three more bytes available  		if (readBytes + 2 >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		int byte3 = instream.ReadByte ();  		readBytes++;  		int byte4 = instream.ReadByte ();  		readBytes++;  		if (byte4 < 0)  			throw new StreamTooShortException ();  		length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  		disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  		#endregion  	} else {  		#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  		// case other:  		// data = AB CD  		// LEN = A + 1  		// DISP = BCD + 1  		// we need only one more byte available  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		if (byte2 < 0)  			throw new StreamTooShortException ();  		length = ((byte1 & 0xF0) >> 4) + 0x1;  		disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  		#endregion  	}  	if (disp > currentOutSize)  		throw new InvalidDataException (String.Format (Main.Get_Traduction ("S04")' disp' currentOutSize.ToString ("X")' instream.Position.ToString ("X")' (byte1 >> 4).ToString ("X")));  	#endregion  	int bufIdx = bufferOffset + bufferLength - disp;  	for (int i = 0; i < length; i++) {  		byte next = buffer [bufIdx % bufferLength];  		bufIdx++;  		outstream.WriteByte (next);  		buffer [bufferOffset] = next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  	currentOutSize += length;  } else {  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int next = instream.ReadByte ();  	readBytes++;  	if (next < 0)  		throw new StreamTooShortException ();  	outstream.WriteByte ((byte)next);  	currentOutSize++;  	buffer [bufferOffset] = (byte)next;  	bufferOffset = (bufferOffset + 1) % bufferLength;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if ((flags & mask) > 0) {  	// (throws when not enough bytes are available)  	#region Get length and displacement('disp') values from next 2' 3 or 4 bytes  	// read the first byte first' which also signals the size of the compressed block  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte1 = instream.ReadByte ();  	readBytes++;  	if (byte1 < 0)  		throw new StreamTooShortException ();  	int length = byte1 >> 4;  	int disp = -1;  	if (length == 0) {  		#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  		// case 0:  		// data = AB CD EF (with A=0)  		// LEN = ABC + 0x11 == BC + 0x11  		// DISP = DEF + 1  		// we need two more bytes available  		if (readBytes + 1 >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		int byte3 = instream.ReadByte ();  		readBytes++;  		if (byte3 < 0)  			throw new StreamTooShortException ();  		length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  		disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  		#endregion  	} else if (length == 1) {  		#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  		// case 1:  		// data = AB CD EF GH (with A=1)  		// LEN = BCDE + 0x111  		// DISP = FGH + 1  		// we need three more bytes available  		if (readBytes + 2 >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		int byte3 = instream.ReadByte ();  		readBytes++;  		int byte4 = instream.ReadByte ();  		readBytes++;  		if (byte4 < 0)  			throw new StreamTooShortException ();  		length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  		disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  		#endregion  	} else {  		#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  		// case other:  		// data = AB CD  		// LEN = A + 1  		// DISP = BCD + 1  		// we need only one more byte available  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		if (byte2 < 0)  			throw new StreamTooShortException ();  		length = ((byte1 & 0xF0) >> 4) + 0x1;  		disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  		#endregion  	}  	if (disp > currentOutSize)  		throw new InvalidDataException (String.Format (Main.Get_Traduction ("S04")' disp' currentOutSize.ToString ("X")' instream.Position.ToString ("X")' (byte1 >> 4).ToString ("X")));  	#endregion  	int bufIdx = bufferOffset + bufferLength - disp;  	for (int i = 0; i < length; i++) {  		byte next = buffer [bufIdx % bufferLength];  		bufIdx++;  		outstream.WriteByte (next);  		buffer [bufferOffset] = next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  	currentOutSize += length;  } else {  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int next = instream.ReadByte ();  	readBytes++;  	if (next < 0)  		throw new StreamTooShortException ();  	outstream.WriteByte ((byte)next);  	currentOutSize++;  	buffer [bufferOffset] = (byte)next;  	bufferOffset = (bufferOffset + 1) % bufferLength;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if ((flags & mask) > 0) {  	// (throws when not enough bytes are available)  	#region Get length and displacement('disp') values from next 2' 3 or 4 bytes  	// read the first byte first' which also signals the size of the compressed block  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte1 = instream.ReadByte ();  	readBytes++;  	if (byte1 < 0)  		throw new StreamTooShortException ();  	int length = byte1 >> 4;  	int disp = -1;  	if (length == 0) {  		#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  		// case 0:  		// data = AB CD EF (with A=0)  		// LEN = ABC + 0x11 == BC + 0x11  		// DISP = DEF + 1  		// we need two more bytes available  		if (readBytes + 1 >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		int byte3 = instream.ReadByte ();  		readBytes++;  		if (byte3 < 0)  			throw new StreamTooShortException ();  		length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  		disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  		#endregion  	} else if (length == 1) {  		#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  		// case 1:  		// data = AB CD EF GH (with A=1)  		// LEN = BCDE + 0x111  		// DISP = FGH + 1  		// we need three more bytes available  		if (readBytes + 2 >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		int byte3 = instream.ReadByte ();  		readBytes++;  		int byte4 = instream.ReadByte ();  		readBytes++;  		if (byte4 < 0)  			throw new StreamTooShortException ();  		length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  		disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  		#endregion  	} else {  		#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  		// case other:  		// data = AB CD  		// LEN = A + 1  		// DISP = BCD + 1  		// we need only one more byte available  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int byte2 = instream.ReadByte ();  		readBytes++;  		if (byte2 < 0)  			throw new StreamTooShortException ();  		length = ((byte1 & 0xF0) >> 4) + 0x1;  		disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  		#endregion  	}  	if (disp > currentOutSize)  		throw new InvalidDataException (String.Format (Main.Get_Traduction ("S04")' disp' currentOutSize.ToString ("X")' instream.Position.ToString ("X")' (byte1 >> 4).ToString ("X")));  	#endregion  	int bufIdx = bufferOffset + bufferLength - disp;  	for (int i = 0; i < length; i++) {  		byte next = buffer [bufIdx % bufferLength];  		bufIdx++;  		outstream.WriteByte (next);  		buffer [bufferOffset] = next;  		bufferOffset = (bufferOffset + 1) % bufferLength;  	}  	currentOutSize += length;  } else {  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int next = instream.ReadByte ();  	readBytes++;  	if (next < 0)  		throw new StreamTooShortException ();  	outstream.WriteByte ((byte)next);  	currentOutSize++;  	buffer [bufferOffset] = (byte)next;  	bufferOffset = (bufferOffset + 1) % bufferLength;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if (length == 0) {  	#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  	// case 0:  	// data = AB CD EF (with A=0)  	// LEN = ABC + 0x11 == BC + 0x11  	// DISP = DEF + 1  	// we need two more bytes available  	if (readBytes + 1 >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	int byte3 = instream.ReadByte ();  	readBytes++;  	if (byte3 < 0)  		throw new StreamTooShortException ();  	length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  	disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  	#endregion  } else if (length == 1) {  	#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  	// case 1:  	// data = AB CD EF GH (with A=1)  	// LEN = BCDE + 0x111  	// DISP = FGH + 1  	// we need three more bytes available  	if (readBytes + 2 >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	int byte3 = instream.ReadByte ();  	readBytes++;  	int byte4 = instream.ReadByte ();  	readBytes++;  	if (byte4 < 0)  		throw new StreamTooShortException ();  	length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  	disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  	#endregion  } else {  	#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	// case other:  	// data = AB CD  	// LEN = A + 1  	// DISP = BCD + 1  	// we need only one more byte available  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	if (byte2 < 0)  		throw new StreamTooShortException ();  	length = ((byte1 & 0xF0) >> 4) + 0x1;  	disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  	#endregion  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if (length == 0) {  	#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  	// case 0:  	// data = AB CD EF (with A=0)  	// LEN = ABC + 0x11 == BC + 0x11  	// DISP = DEF + 1  	// we need two more bytes available  	if (readBytes + 1 >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	int byte3 = instream.ReadByte ();  	readBytes++;  	if (byte3 < 0)  		throw new StreamTooShortException ();  	length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  	disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  	#endregion  } else if (length == 1) {  	#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  	// case 1:  	// data = AB CD EF GH (with A=1)  	// LEN = BCDE + 0x111  	// DISP = FGH + 1  	// we need three more bytes available  	if (readBytes + 2 >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	int byte3 = instream.ReadByte ();  	readBytes++;  	int byte4 = instream.ReadByte ();  	readBytes++;  	if (byte4 < 0)  		throw new StreamTooShortException ();  	length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  	disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  	#endregion  } else {  	#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	// case other:  	// data = AB CD  	// LEN = A + 1  	// DISP = BCD + 1  	// we need only one more byte available  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	if (byte2 < 0)  		throw new StreamTooShortException ();  	length = ((byte1 & 0xF0) >> 4) + 0x1;  	disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  	#endregion  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if (length == 0) {  	#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  	// case 0:  	// data = AB CD EF (with A=0)  	// LEN = ABC + 0x11 == BC + 0x11  	// DISP = DEF + 1  	// we need two more bytes available  	if (readBytes + 1 >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	int byte3 = instream.ReadByte ();  	readBytes++;  	if (byte3 < 0)  		throw new StreamTooShortException ();  	length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  	disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  	#endregion  } else if (length == 1) {  	#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  	// case 1:  	// data = AB CD EF GH (with A=1)  	// LEN = BCDE + 0x111  	// DISP = FGH + 1  	// we need three more bytes available  	if (readBytes + 2 >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	int byte3 = instream.ReadByte ();  	readBytes++;  	int byte4 = instream.ReadByte ();  	readBytes++;  	if (byte4 < 0)  		throw new StreamTooShortException ();  	length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  	disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  	#endregion  } else {  	#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	// case other:  	// data = AB CD  	// LEN = A + 1  	// DISP = BCD + 1  	// we need only one more byte available  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	if (byte2 < 0)  		throw new StreamTooShortException ();  	length = ((byte1 & 0xF0) >> 4) + 0x1;  	disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  	#endregion  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if (length == 0) {  	#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  	// case 0:  	// data = AB CD EF (with A=0)  	// LEN = ABC + 0x11 == BC + 0x11  	// DISP = DEF + 1  	// we need two more bytes available  	if (readBytes + 1 >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	int byte3 = instream.ReadByte ();  	readBytes++;  	if (byte3 < 0)  		throw new StreamTooShortException ();  	length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  	disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  	#endregion  } else if (length == 1) {  	#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  	// case 1:  	// data = AB CD EF GH (with A=1)  	// LEN = BCDE + 0x111  	// DISP = FGH + 1  	// we need three more bytes available  	if (readBytes + 2 >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	int byte3 = instream.ReadByte ();  	readBytes++;  	int byte4 = instream.ReadByte ();  	readBytes++;  	if (byte4 < 0)  		throw new StreamTooShortException ();  	length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  	disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  	#endregion  } else {  	#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	// case other:  	// data = AB CD  	// LEN = A + 1  	// DISP = BCD + 1  	// we need only one more byte available  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	if (byte2 < 0)  		throw new StreamTooShortException ();  	length = ((byte1 & 0xF0) >> 4) + 0x1;  	disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  	#endregion  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if (length == 0) {  	#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  	// case 0:  	// data = AB CD EF (with A=0)  	// LEN = ABC + 0x11 == BC + 0x11  	// DISP = DEF + 1  	// we need two more bytes available  	if (readBytes + 1 >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	int byte3 = instream.ReadByte ();  	readBytes++;  	if (byte3 < 0)  		throw new StreamTooShortException ();  	length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  	disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  	#endregion  } else if (length == 1) {  	#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  	// case 1:  	// data = AB CD EF GH (with A=1)  	// LEN = BCDE + 0x111  	// DISP = FGH + 1  	// we need three more bytes available  	if (readBytes + 2 >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	int byte3 = instream.ReadByte ();  	readBytes++;  	int byte4 = instream.ReadByte ();  	readBytes++;  	if (byte4 < 0)  		throw new StreamTooShortException ();  	length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  	disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  	#endregion  } else {  	#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	// case other:  	// data = AB CD  	// LEN = A + 1  	// DISP = BCD + 1  	// we need only one more byte available  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	if (byte2 < 0)  		throw new StreamTooShortException ();  	length = ((byte1 & 0xF0) >> 4) + 0x1;  	disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  	#endregion  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if (length == 0) {  	#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  	// case 0:  	// data = AB CD EF (with A=0)  	// LEN = ABC + 0x11 == BC + 0x11  	// DISP = DEF + 1  	// we need two more bytes available  	if (readBytes + 1 >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	int byte3 = instream.ReadByte ();  	readBytes++;  	if (byte3 < 0)  		throw new StreamTooShortException ();  	length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  	disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  	#endregion  } else if (length == 1) {  	#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  	// case 1:  	// data = AB CD EF GH (with A=1)  	// LEN = BCDE + 0x111  	// DISP = FGH + 1  	// we need three more bytes available  	if (readBytes + 2 >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	int byte3 = instream.ReadByte ();  	readBytes++;  	int byte4 = instream.ReadByte ();  	readBytes++;  	if (byte4 < 0)  		throw new StreamTooShortException ();  	length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  	disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  	#endregion  } else {  	#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	// case other:  	// data = AB CD  	// LEN = A + 1  	// DISP = BCD + 1  	// we need only one more byte available  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	if (byte2 < 0)  		throw new StreamTooShortException ();  	length = ((byte1 & 0xF0) >> 4) + 0x1;  	disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  	#endregion  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if (length == 0) {  	#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  	// case 0:  	// data = AB CD EF (with A=0)  	// LEN = ABC + 0x11 == BC + 0x11  	// DISP = DEF + 1  	// we need two more bytes available  	if (readBytes + 1 >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	int byte3 = instream.ReadByte ();  	readBytes++;  	if (byte3 < 0)  		throw new StreamTooShortException ();  	length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  	disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  	#endregion  } else if (length == 1) {  	#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  	// case 1:  	// data = AB CD EF GH (with A=1)  	// LEN = BCDE + 0x111  	// DISP = FGH + 1  	// we need three more bytes available  	if (readBytes + 2 >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	int byte3 = instream.ReadByte ();  	readBytes++;  	int byte4 = instream.ReadByte ();  	readBytes++;  	if (byte4 < 0)  		throw new StreamTooShortException ();  	length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  	disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  	#endregion  } else {  	#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	// case other:  	// data = AB CD  	// LEN = A + 1  	// DISP = BCD + 1  	// we need only one more byte available  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	if (byte2 < 0)  		throw new StreamTooShortException ();  	length = ((byte1 & 0xF0) >> 4) + 0x1;  	disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  	#endregion  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if (length == 0) {  	#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  	// case 0:  	// data = AB CD EF (with A=0)  	// LEN = ABC + 0x11 == BC + 0x11  	// DISP = DEF + 1  	// we need two more bytes available  	if (readBytes + 1 >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	int byte3 = instream.ReadByte ();  	readBytes++;  	if (byte3 < 0)  		throw new StreamTooShortException ();  	length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  	disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  	#endregion  } else if (length == 1) {  	#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  	// case 1:  	// data = AB CD EF GH (with A=1)  	// LEN = BCDE + 0x111  	// DISP = FGH + 1  	// we need three more bytes available  	if (readBytes + 2 >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	int byte3 = instream.ReadByte ();  	readBytes++;  	int byte4 = instream.ReadByte ();  	readBytes++;  	if (byte4 < 0)  		throw new StreamTooShortException ();  	length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  	disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  	#endregion  } else {  	#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	// case other:  	// data = AB CD  	// LEN = A + 1  	// DISP = BCD + 1  	// we need only one more byte available  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	if (byte2 < 0)  		throw new StreamTooShortException ();  	length = ((byte1 & 0xF0) >> 4) + 0x1;  	disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  	#endregion  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if (length == 0) {  	#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  	// case 0:  	// data = AB CD EF (with A=0)  	// LEN = ABC + 0x11 == BC + 0x11  	// DISP = DEF + 1  	// we need two more bytes available  	if (readBytes + 1 >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	int byte3 = instream.ReadByte ();  	readBytes++;  	if (byte3 < 0)  		throw new StreamTooShortException ();  	length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  	disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  	#endregion  } else if (length == 1) {  	#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  	// case 1:  	// data = AB CD EF GH (with A=1)  	// LEN = BCDE + 0x111  	// DISP = FGH + 1  	// we need three more bytes available  	if (readBytes + 2 >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	int byte3 = instream.ReadByte ();  	readBytes++;  	int byte4 = instream.ReadByte ();  	readBytes++;  	if (byte4 < 0)  		throw new StreamTooShortException ();  	length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  	disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  	#endregion  } else {  	#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	// case other:  	// data = AB CD  	// LEN = A + 1  	// DISP = BCD + 1  	// we need only one more byte available  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	if (byte2 < 0)  		throw new StreamTooShortException ();  	length = ((byte1 & 0xF0) >> 4) + 0x1;  	disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  	#endregion  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if (length == 0) {  	#region case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  	// case 0:  	// data = AB CD EF (with A=0)  	// LEN = ABC + 0x11 == BC + 0x11  	// DISP = DEF + 1  	// we need two more bytes available  	if (readBytes + 1 >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	int byte3 = instream.ReadByte ();  	readBytes++;  	if (byte3 < 0)  		throw new StreamTooShortException ();  	length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  	disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  	#endregion  } else if (length == 1) {  	#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  	// case 1:  	// data = AB CD EF GH (with A=1)  	// LEN = BCDE + 0x111  	// DISP = FGH + 1  	// we need three more bytes available  	if (readBytes + 2 >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	int byte3 = instream.ReadByte ();  	readBytes++;  	int byte4 = instream.ReadByte ();  	readBytes++;  	if (byte4 < 0)  		throw new StreamTooShortException ();  	length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  	disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  	#endregion  } else {  	#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	// case other:  	// data = AB CD  	// LEN = A + 1  	// DISP = BCD + 1  	// we need only one more byte available  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	if (byte2 < 0)  		throw new StreamTooShortException ();  	length = ((byte1 & 0xF0) >> 4) + 0x1;  	disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  	#endregion  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: length = (((byte1 & 0x0F) << 4) | (byte2 >> 4)) + 0x11;  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: disp = (((byte2 & 0x0F) << 8) | byte3) + 0x1;  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if (length == 1) {  	#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  	// case 1:  	// data = AB CD EF GH (with A=1)  	// LEN = BCDE + 0x111  	// DISP = FGH + 1  	// we need three more bytes available  	if (readBytes + 2 >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	int byte3 = instream.ReadByte ();  	readBytes++;  	int byte4 = instream.ReadByte ();  	readBytes++;  	if (byte4 < 0)  		throw new StreamTooShortException ();  	length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  	disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  	#endregion  } else {  	#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	// case other:  	// data = AB CD  	// LEN = A + 1  	// DISP = BCD + 1  	// we need only one more byte available  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	if (byte2 < 0)  		throw new StreamTooShortException ();  	length = ((byte1 & 0xF0) >> 4) + 0x1;  	disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  	#endregion  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if (length == 1) {  	#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  	// case 1:  	// data = AB CD EF GH (with A=1)  	// LEN = BCDE + 0x111  	// DISP = FGH + 1  	// we need three more bytes available  	if (readBytes + 2 >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	int byte3 = instream.ReadByte ();  	readBytes++;  	int byte4 = instream.ReadByte ();  	readBytes++;  	if (byte4 < 0)  		throw new StreamTooShortException ();  	length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  	disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  	#endregion  } else {  	#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	// case other:  	// data = AB CD  	// LEN = A + 1  	// DISP = BCD + 1  	// we need only one more byte available  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	if (byte2 < 0)  		throw new StreamTooShortException ();  	length = ((byte1 & 0xF0) >> 4) + 0x1;  	disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  	#endregion  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if (length == 1) {  	#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  	// case 1:  	// data = AB CD EF GH (with A=1)  	// LEN = BCDE + 0x111  	// DISP = FGH + 1  	// we need three more bytes available  	if (readBytes + 2 >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	int byte3 = instream.ReadByte ();  	readBytes++;  	int byte4 = instream.ReadByte ();  	readBytes++;  	if (byte4 < 0)  		throw new StreamTooShortException ();  	length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  	disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  	#endregion  } else {  	#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	// case other:  	// data = AB CD  	// LEN = A + 1  	// DISP = BCD + 1  	// we need only one more byte available  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	if (byte2 < 0)  		throw new StreamTooShortException ();  	length = ((byte1 & 0xF0) >> 4) + 0x1;  	disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  	#endregion  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if (length == 1) {  	#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  	// case 1:  	// data = AB CD EF GH (with A=1)  	// LEN = BCDE + 0x111  	// DISP = FGH + 1  	// we need three more bytes available  	if (readBytes + 2 >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	int byte3 = instream.ReadByte ();  	readBytes++;  	int byte4 = instream.ReadByte ();  	readBytes++;  	if (byte4 < 0)  		throw new StreamTooShortException ();  	length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  	disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  	#endregion  } else {  	#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	// case other:  	// data = AB CD  	// LEN = A + 1  	// DISP = BCD + 1  	// we need only one more byte available  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	if (byte2 < 0)  		throw new StreamTooShortException ();  	length = ((byte1 & 0xF0) >> 4) + 0x1;  	disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  	#endregion  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if (length == 1) {  	#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  	// case 1:  	// data = AB CD EF GH (with A=1)  	// LEN = BCDE + 0x111  	// DISP = FGH + 1  	// we need three more bytes available  	if (readBytes + 2 >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	int byte3 = instream.ReadByte ();  	readBytes++;  	int byte4 = instream.ReadByte ();  	readBytes++;  	if (byte4 < 0)  		throw new StreamTooShortException ();  	length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  	disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  	#endregion  } else {  	#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	// case other:  	// data = AB CD  	// LEN = A + 1  	// DISP = BCD + 1  	// we need only one more byte available  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	if (byte2 < 0)  		throw new StreamTooShortException ();  	length = ((byte1 & 0xF0) >> 4) + 0x1;  	disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  	#endregion  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if (length == 1) {  	#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  	// case 1:  	// data = AB CD EF GH (with A=1)  	// LEN = BCDE + 0x111  	// DISP = FGH + 1  	// we need three more bytes available  	if (readBytes + 2 >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	int byte3 = instream.ReadByte ();  	readBytes++;  	int byte4 = instream.ReadByte ();  	readBytes++;  	if (byte4 < 0)  		throw new StreamTooShortException ();  	length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  	disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  	#endregion  } else {  	#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	// case other:  	// data = AB CD  	// LEN = A + 1  	// DISP = BCD + 1  	// we need only one more byte available  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	if (byte2 < 0)  		throw new StreamTooShortException ();  	length = ((byte1 & 0xF0) >> 4) + 0x1;  	disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  	#endregion  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if (length == 1) {  	#region case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  	// case 1:  	// data = AB CD EF GH (with A=1)  	// LEN = BCDE + 0x111  	// DISP = FGH + 1  	// we need three more bytes available  	if (readBytes + 2 >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	int byte3 = instream.ReadByte ();  	readBytes++;  	int byte4 = instream.ReadByte ();  	readBytes++;  	if (byte4 < 0)  		throw new StreamTooShortException ();  	length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  	disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  	#endregion  } else {  	#region case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	// case other:  	// data = AB CD  	// LEN = A + 1  	// DISP = BCD + 1  	// we need only one more byte available  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int byte2 = instream.ReadByte ();  	readBytes++;  	if (byte2 < 0)  		throw new StreamTooShortException ();  	length = ((byte1 & 0xF0) >> 4) + 0x1;  	disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  	#endregion  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if (readBytes + 2 >= inLength)  	throw new NotEnoughDataException (currentOutSize' decompressedSize);  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: length = (((byte1 & 0x0F) << 12) | (byte2 << 4) | (byte3 >> 4)) + 0x111;  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: disp = (((byte3 & 0x0F) << 8) | byte4) + 0x1;  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: length = ((byte1 & 0xF0) >> 4) + 0x1;  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: disp = (((byte1 & 0x0F) << 8) | byte2) + 0x1;  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if (disp > currentOutSize)  	throw new InvalidDataException (String.Format (Main.Get_Traduction ("S04")' disp' currentOutSize.ToString ("X")' instream.Position.ToString ("X")' (byte1 >> 4).ToString ("X")));  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: throw new InvalidDataException (String.Format (Main.Get_Traduction ("S04")' disp' currentOutSize.ToString ("X")' instream.Position.ToString ("X")' (byte1 >> 4).ToString ("X")));  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if (readBytes < inLength) {  	// the input may be 4-byte aligned.  	if ((readBytes ^ (readBytes & 3)) + 4 < inLength)  		throw new TooMuchInputException (readBytes' inLength);  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if (readBytes < inLength) {  	// the input may be 4-byte aligned.  	if ((readBytes ^ (readBytes & 3)) + 4 < inLength)  		throw new TooMuchInputException (readBytes' inLength);  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if ((readBytes ^ (readBytes & 3)) + 4 < inLength)  	throw new TooMuchInputException (readBytes' inLength);  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Decompress,The following statement contains a magic number: if ((readBytes ^ (readBytes & 3)) + 4 < inLength)  	throw new TooMuchInputException (readBytes' inLength);  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: outstream.WriteByte ((byte)((inLength >> 8) & 0xFF));  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: outstream.WriteByte ((byte)((inLength >> 16) & 0xFF));  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	// (a block is at most 4 bytes long)  	byte[] outbuffer = new byte[8 * 4 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1000);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x10110)' instart + readBytes - oldLength' oldLength' out disp);  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			if (length > 0x110) {  				// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x10;  				outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  			} else if (length > 0x10) {  				// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x00;  				outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  			} else {  				// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  			}  			// the last 1.5 bytes are always the disp  			outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	// (a block is at most 4 bytes long)  	byte[] outbuffer = new byte[8 * 4 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1000);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x10110)' instart + readBytes - oldLength' oldLength' out disp);  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			if (length > 0x110) {  				// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x10;  				outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  			} else if (length > 0x10) {  				// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x00;  				outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  			} else {  				// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  			}  			// the last 1.5 bytes are always the disp  			outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	// (a block is at most 4 bytes long)  	byte[] outbuffer = new byte[8 * 4 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1000);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x10110)' instart + readBytes - oldLength' oldLength' out disp);  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			if (length > 0x110) {  				// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x10;  				outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  			} else if (length > 0x10) {  				// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x00;  				outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  			} else {  				// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  			}  			// the last 1.5 bytes are always the disp  			outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	// (a block is at most 4 bytes long)  	byte[] outbuffer = new byte[8 * 4 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1000);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x10110)' instart + readBytes - oldLength' oldLength' out disp);  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			if (length > 0x110) {  				// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x10;  				outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  			} else if (length > 0x10) {  				// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x00;  				outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  			} else {  				// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  			}  			// the last 1.5 bytes are always the disp  			outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	// (a block is at most 4 bytes long)  	byte[] outbuffer = new byte[8 * 4 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1000);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x10110)' instart + readBytes - oldLength' oldLength' out disp);  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			if (length > 0x110) {  				// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x10;  				outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  			} else if (length > 0x10) {  				// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x00;  				outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  			} else {  				// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  			}  			// the last 1.5 bytes are always the disp  			outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	// (a block is at most 4 bytes long)  	byte[] outbuffer = new byte[8 * 4 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1000);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x10110)' instart + readBytes - oldLength' oldLength' out disp);  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			if (length > 0x110) {  				// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x10;  				outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  			} else if (length > 0x10) {  				// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x00;  				outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  			} else {  				// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  			}  			// the last 1.5 bytes are always the disp  			outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	// (a block is at most 4 bytes long)  	byte[] outbuffer = new byte[8 * 4 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1000);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x10110)' instart + readBytes - oldLength' oldLength' out disp);  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			if (length > 0x110) {  				// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x10;  				outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  			} else if (length > 0x10) {  				// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x00;  				outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  			} else {  				// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  			}  			// the last 1.5 bytes are always the disp  			outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	// (a block is at most 4 bytes long)  	byte[] outbuffer = new byte[8 * 4 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1000);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x10110)' instart + readBytes - oldLength' oldLength' out disp);  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			if (length > 0x110) {  				// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x10;  				outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  			} else if (length > 0x10) {  				// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x00;  				outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  			} else {  				// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  			}  			// the last 1.5 bytes are always the disp  			outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	// (a block is at most 4 bytes long)  	byte[] outbuffer = new byte[8 * 4 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1000);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x10110)' instart + readBytes - oldLength' oldLength' out disp);  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			if (length > 0x110) {  				// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x10;  				outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  			} else if (length > 0x10) {  				// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x00;  				outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  			} else {  				// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  			}  			// the last 1.5 bytes are always the disp  			outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	// (a block is at most 4 bytes long)  	byte[] outbuffer = new byte[8 * 4 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1000);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x10110)' instart + readBytes - oldLength' oldLength' out disp);  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			if (length > 0x110) {  				// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x10;  				outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  			} else if (length > 0x10) {  				// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x00;  				outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  			} else {  				// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  			}  			// the last 1.5 bytes are always the disp  			outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	// (a block is at most 4 bytes long)  	byte[] outbuffer = new byte[8 * 4 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1000);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x10110)' instart + readBytes - oldLength' oldLength' out disp);  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			if (length > 0x110) {  				// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x10;  				outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  			} else if (length > 0x10) {  				// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x00;  				outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  			} else {  				// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  			}  			// the last 1.5 bytes are always the disp  			outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	// (a block is at most 4 bytes long)  	byte[] outbuffer = new byte[8 * 4 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	while (readBytes < inLength) {  		#region If 8 blocks are bufferd' write them and reset the buffer  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		#endregion  		// determine if we're dealing with a compressed or raw block.  		// it is a compressed block when the next 3 or more bytes can be copied from  		// somewhere in the set of already compressed bytes.  		int disp;  		int oldLength = Math.Min (readBytes' 0x1000);  		int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x10110)' instart + readBytes - oldLength' oldLength' out disp);  		// length not 3 or more? next byte is raw data  		if (length < 3) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  			readBytes += length;  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			if (length > 0x110) {  				// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x10;  				outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  			} else if (length > 0x10) {  				// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x00;  				outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  			} else {  				// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  			}  			// the last 1.5 bytes are always the disp  			outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  			bufferlength++;  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: while (readBytes < inLength) {  	#region If 8 blocks are bufferd' write them and reset the buffer  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	#endregion  	// determine if we're dealing with a compressed or raw block.  	// it is a compressed block when the next 3 or more bytes can be copied from  	// somewhere in the set of already compressed bytes.  	int disp;  	int oldLength = Math.Min (readBytes' 0x1000);  	int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x10110)' instart + readBytes - oldLength' oldLength' out disp);  	// length not 3 or more? next byte is raw data  	if (length < 3) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  		readBytes += length;  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		if (length > 0x110) {  			// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x10;  			outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  		} else if (length > 0x10) {  			// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x00;  			outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  		} else {  			// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  		}  		// the last 1.5 bytes are always the disp  		outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  		bufferlength++;  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: while (readBytes < inLength) {  	#region If 8 blocks are bufferd' write them and reset the buffer  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	#endregion  	// determine if we're dealing with a compressed or raw block.  	// it is a compressed block when the next 3 or more bytes can be copied from  	// somewhere in the set of already compressed bytes.  	int disp;  	int oldLength = Math.Min (readBytes' 0x1000);  	int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x10110)' instart + readBytes - oldLength' oldLength' out disp);  	// length not 3 or more? next byte is raw data  	if (length < 3) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  		readBytes += length;  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		if (length > 0x110) {  			// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x10;  			outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  		} else if (length > 0x10) {  			// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x00;  			outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  		} else {  			// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  		}  		// the last 1.5 bytes are always the disp  		outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  		bufferlength++;  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: while (readBytes < inLength) {  	#region If 8 blocks are bufferd' write them and reset the buffer  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	#endregion  	// determine if we're dealing with a compressed or raw block.  	// it is a compressed block when the next 3 or more bytes can be copied from  	// somewhere in the set of already compressed bytes.  	int disp;  	int oldLength = Math.Min (readBytes' 0x1000);  	int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x10110)' instart + readBytes - oldLength' oldLength' out disp);  	// length not 3 or more? next byte is raw data  	if (length < 3) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  		readBytes += length;  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		if (length > 0x110) {  			// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x10;  			outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  		} else if (length > 0x10) {  			// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x00;  			outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  		} else {  			// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  		}  		// the last 1.5 bytes are always the disp  		outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  		bufferlength++;  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: while (readBytes < inLength) {  	#region If 8 blocks are bufferd' write them and reset the buffer  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	#endregion  	// determine if we're dealing with a compressed or raw block.  	// it is a compressed block when the next 3 or more bytes can be copied from  	// somewhere in the set of already compressed bytes.  	int disp;  	int oldLength = Math.Min (readBytes' 0x1000);  	int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x10110)' instart + readBytes - oldLength' oldLength' out disp);  	// length not 3 or more? next byte is raw data  	if (length < 3) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  		readBytes += length;  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		if (length > 0x110) {  			// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x10;  			outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  		} else if (length > 0x10) {  			// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x00;  			outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  		} else {  			// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  		}  		// the last 1.5 bytes are always the disp  		outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  		bufferlength++;  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: while (readBytes < inLength) {  	#region If 8 blocks are bufferd' write them and reset the buffer  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	#endregion  	// determine if we're dealing with a compressed or raw block.  	// it is a compressed block when the next 3 or more bytes can be copied from  	// somewhere in the set of already compressed bytes.  	int disp;  	int oldLength = Math.Min (readBytes' 0x1000);  	int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x10110)' instart + readBytes - oldLength' oldLength' out disp);  	// length not 3 or more? next byte is raw data  	if (length < 3) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  		readBytes += length;  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		if (length > 0x110) {  			// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x10;  			outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  		} else if (length > 0x10) {  			// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x00;  			outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  		} else {  			// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  		}  		// the last 1.5 bytes are always the disp  		outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  		bufferlength++;  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: while (readBytes < inLength) {  	#region If 8 blocks are bufferd' write them and reset the buffer  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	#endregion  	// determine if we're dealing with a compressed or raw block.  	// it is a compressed block when the next 3 or more bytes can be copied from  	// somewhere in the set of already compressed bytes.  	int disp;  	int oldLength = Math.Min (readBytes' 0x1000);  	int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x10110)' instart + readBytes - oldLength' oldLength' out disp);  	// length not 3 or more? next byte is raw data  	if (length < 3) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  		readBytes += length;  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		if (length > 0x110) {  			// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x10;  			outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  		} else if (length > 0x10) {  			// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x00;  			outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  		} else {  			// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  		}  		// the last 1.5 bytes are always the disp  		outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  		bufferlength++;  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: while (readBytes < inLength) {  	#region If 8 blocks are bufferd' write them and reset the buffer  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	#endregion  	// determine if we're dealing with a compressed or raw block.  	// it is a compressed block when the next 3 or more bytes can be copied from  	// somewhere in the set of already compressed bytes.  	int disp;  	int oldLength = Math.Min (readBytes' 0x1000);  	int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x10110)' instart + readBytes - oldLength' oldLength' out disp);  	// length not 3 or more? next byte is raw data  	if (length < 3) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  		readBytes += length;  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		if (length > 0x110) {  			// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x10;  			outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  		} else if (length > 0x10) {  			// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x00;  			outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  		} else {  			// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  		}  		// the last 1.5 bytes are always the disp  		outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  		bufferlength++;  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: while (readBytes < inLength) {  	#region If 8 blocks are bufferd' write them and reset the buffer  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	#endregion  	// determine if we're dealing with a compressed or raw block.  	// it is a compressed block when the next 3 or more bytes can be copied from  	// somewhere in the set of already compressed bytes.  	int disp;  	int oldLength = Math.Min (readBytes' 0x1000);  	int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x10110)' instart + readBytes - oldLength' oldLength' out disp);  	// length not 3 or more? next byte is raw data  	if (length < 3) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  		readBytes += length;  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		if (length > 0x110) {  			// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x10;  			outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  		} else if (length > 0x10) {  			// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x00;  			outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  		} else {  			// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  		}  		// the last 1.5 bytes are always the disp  		outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  		bufferlength++;  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: while (readBytes < inLength) {  	#region If 8 blocks are bufferd' write them and reset the buffer  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	#endregion  	// determine if we're dealing with a compressed or raw block.  	// it is a compressed block when the next 3 or more bytes can be copied from  	// somewhere in the set of already compressed bytes.  	int disp;  	int oldLength = Math.Min (readBytes' 0x1000);  	int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x10110)' instart + readBytes - oldLength' oldLength' out disp);  	// length not 3 or more? next byte is raw data  	if (length < 3) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  		readBytes += length;  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		if (length > 0x110) {  			// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x10;  			outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  		} else if (length > 0x10) {  			// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x00;  			outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  		} else {  			// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  		}  		// the last 1.5 bytes are always the disp  		outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  		bufferlength++;  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: while (readBytes < inLength) {  	#region If 8 blocks are bufferd' write them and reset the buffer  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	#endregion  	// determine if we're dealing with a compressed or raw block.  	// it is a compressed block when the next 3 or more bytes can be copied from  	// somewhere in the set of already compressed bytes.  	int disp;  	int oldLength = Math.Min (readBytes' 0x1000);  	int length = LZUtil.GetOccurrenceLength (instart + readBytes' (int)Math.Min (inLength - readBytes' 0x10110)' instart + readBytes - oldLength' oldLength' out disp);  	// length not 3 or more? next byte is raw data  	if (length < 3) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  		readBytes += length;  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		if (length > 0x110) {  			// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x10;  			outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  		} else if (length > 0x10) {  			// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x00;  			outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  		} else {  			// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  		}  		// the last 1.5 bytes are always the disp  		outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  		bufferlength++;  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: if (bufferedBlocks == 8) {  	outstream.Write (outbuffer' 0' bufferlength);  	compressedLength += bufferlength;  	// reset the buffer  	outbuffer [0] = 0;  	bufferlength = 1;  	bufferedBlocks = 0;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: if (length < 3) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  	readBytes += length;  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	if (length > 0x110) {  		// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x10;  		outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  	} else if (length > 0x10) {  		// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x00;  		outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  	} else {  		// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  	}  	// the last 1.5 bytes are always the disp  	outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  	bufferlength++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: if (length < 3) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  	readBytes += length;  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	if (length > 0x110) {  		// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x10;  		outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  	} else if (length > 0x10) {  		// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x00;  		outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  	} else {  		// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  	}  	// the last 1.5 bytes are always the disp  	outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  	bufferlength++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: if (length < 3) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  	readBytes += length;  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	if (length > 0x110) {  		// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x10;  		outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  	} else if (length > 0x10) {  		// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x00;  		outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  	} else {  		// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  	}  	// the last 1.5 bytes are always the disp  	outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  	bufferlength++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: if (length < 3) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  	readBytes += length;  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	if (length > 0x110) {  		// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x10;  		outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  	} else if (length > 0x10) {  		// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x00;  		outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  	} else {  		// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  	}  	// the last 1.5 bytes are always the disp  	outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  	bufferlength++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: if (length < 3) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  	readBytes += length;  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	if (length > 0x110) {  		// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x10;  		outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  	} else if (length > 0x10) {  		// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x00;  		outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  	} else {  		// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  	}  	// the last 1.5 bytes are always the disp  	outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  	bufferlength++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: if (length < 3) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  	readBytes += length;  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	if (length > 0x110) {  		// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x10;  		outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  	} else if (length > 0x10) {  		// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x00;  		outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  	} else {  		// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  	}  	// the last 1.5 bytes are always the disp  	outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  	bufferlength++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: if (length < 3) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  	readBytes += length;  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	if (length > 0x110) {  		// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x10;  		outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  	} else if (length > 0x10) {  		// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x00;  		outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  	} else {  		// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  	}  	// the last 1.5 bytes are always the disp  	outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  	bufferlength++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: if (length < 3) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  	readBytes += length;  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	if (length > 0x110) {  		// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x10;  		outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  	} else if (length > 0x10) {  		// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x00;  		outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  	} else {  		// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  	}  	// the last 1.5 bytes are always the disp  	outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  	bufferlength++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: if (length < 3) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// 3 or more bytes can be copied? next (length) bytes will be compressed into 2 bytes  	readBytes += length;  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	if (length > 0x110) {  		// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x10;  		outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  	} else if (length > 0x10) {  		// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x00;  		outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  	} else {  		// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  	}  	// the last 1.5 bytes are always the disp  	outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disp - 1) & 0xFF);  	bufferlength++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: if (length > 0x110) {  	// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x10;  	outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  } else if (length > 0x10) {  	// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x00;  	outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  } else {  	// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: if (length > 0x110) {  	// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x10;  	outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  } else if (length > 0x10) {  	// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x00;  	outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  } else {  	// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: if (length > 0x110) {  	// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x10;  	outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  } else if (length > 0x10) {  	// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x00;  	outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  } else {  	// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: if (length > 0x110) {  	// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x10;  	outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  } else if (length > 0x10) {  	// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x00;  	outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  } else {  	// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: if (length > 0x110) {  	// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x10;  	outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  } else if (length > 0x10) {  	// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x00;  	outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  } else {  	// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: if (length > 0x110) {  	// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x10;  	outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  } else if (length > 0x10) {  	// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x00;  	outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  } else {  	// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 12) & 0x0F);  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: outbuffer [bufferlength] = (byte)(((length - 0x111) >> 4) & 0xFF);  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: if (length > 0x10) {  	// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x00;  	outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  } else {  	// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: if (length > 0x10) {  	// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x00;  	outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  } else {  	// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: if (length > 0x10) {  	// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x00;  	outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  } else {  	// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: outbuffer [bufferlength] |= (byte)(((length - 0x111) >> 4) & 0x0F);  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: outbuffer [bufferlength] = (byte)(((length - 0x111) << 4) & 0xF0);  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: outbuffer [bufferlength] = (byte)(((length - 1) << 4) & 0xF0);  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,Compress,The following statement contains a magic number: outbuffer [bufferlength] |= (byte)(((disp - 1) >> 8) & 0x0F);  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: outstream.WriteByte ((byte)((inLength >> 8) & 0xFF));  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: outstream.WriteByte ((byte)((inLength >> 16) & 0xFF));  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	// blocks are at most 4 bytes long.  	byte[] outbuffer = new byte[8 * 4 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	// get the optimal choices for len and disp  	int[] lengths' disps;  	this.GetOptimalCompressionLengths (instart' indata.Length' out lengths' out disps);  	while (readBytes < inLength) {  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		if (lengths [readBytes] == 1) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			if (lengths [readBytes] > 0x110) {  				// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x10;  				outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  			} else if (lengths [readBytes] > 0x10) {  				// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x00;  				outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  			} else {  				// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  			}  			// the last 1.5 bytes are always the disp  			outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  			bufferlength++;  			readBytes += lengths [readBytes];  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	// blocks are at most 4 bytes long.  	byte[] outbuffer = new byte[8 * 4 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	// get the optimal choices for len and disp  	int[] lengths' disps;  	this.GetOptimalCompressionLengths (instart' indata.Length' out lengths' out disps);  	while (readBytes < inLength) {  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		if (lengths [readBytes] == 1) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			if (lengths [readBytes] > 0x110) {  				// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x10;  				outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  			} else if (lengths [readBytes] > 0x10) {  				// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x00;  				outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  			} else {  				// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  			}  			// the last 1.5 bytes are always the disp  			outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  			bufferlength++;  			readBytes += lengths [readBytes];  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	// blocks are at most 4 bytes long.  	byte[] outbuffer = new byte[8 * 4 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	// get the optimal choices for len and disp  	int[] lengths' disps;  	this.GetOptimalCompressionLengths (instart' indata.Length' out lengths' out disps);  	while (readBytes < inLength) {  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		if (lengths [readBytes] == 1) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			if (lengths [readBytes] > 0x110) {  				// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x10;  				outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  			} else if (lengths [readBytes] > 0x10) {  				// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x00;  				outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  			} else {  				// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  			}  			// the last 1.5 bytes are always the disp  			outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  			bufferlength++;  			readBytes += lengths [readBytes];  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	// blocks are at most 4 bytes long.  	byte[] outbuffer = new byte[8 * 4 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	// get the optimal choices for len and disp  	int[] lengths' disps;  	this.GetOptimalCompressionLengths (instart' indata.Length' out lengths' out disps);  	while (readBytes < inLength) {  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		if (lengths [readBytes] == 1) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			if (lengths [readBytes] > 0x110) {  				// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x10;  				outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  			} else if (lengths [readBytes] > 0x10) {  				// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x00;  				outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  			} else {  				// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  			}  			// the last 1.5 bytes are always the disp  			outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  			bufferlength++;  			readBytes += lengths [readBytes];  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	// blocks are at most 4 bytes long.  	byte[] outbuffer = new byte[8 * 4 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	// get the optimal choices for len and disp  	int[] lengths' disps;  	this.GetOptimalCompressionLengths (instart' indata.Length' out lengths' out disps);  	while (readBytes < inLength) {  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		if (lengths [readBytes] == 1) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			if (lengths [readBytes] > 0x110) {  				// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x10;  				outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  			} else if (lengths [readBytes] > 0x10) {  				// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x00;  				outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  			} else {  				// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  			}  			// the last 1.5 bytes are always the disp  			outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  			bufferlength++;  			readBytes += lengths [readBytes];  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	// blocks are at most 4 bytes long.  	byte[] outbuffer = new byte[8 * 4 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	// get the optimal choices for len and disp  	int[] lengths' disps;  	this.GetOptimalCompressionLengths (instart' indata.Length' out lengths' out disps);  	while (readBytes < inLength) {  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		if (lengths [readBytes] == 1) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			if (lengths [readBytes] > 0x110) {  				// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x10;  				outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  			} else if (lengths [readBytes] > 0x10) {  				// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x00;  				outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  			} else {  				// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  			}  			// the last 1.5 bytes are always the disp  			outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  			bufferlength++;  			readBytes += lengths [readBytes];  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	// blocks are at most 4 bytes long.  	byte[] outbuffer = new byte[8 * 4 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	// get the optimal choices for len and disp  	int[] lengths' disps;  	this.GetOptimalCompressionLengths (instart' indata.Length' out lengths' out disps);  	while (readBytes < inLength) {  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		if (lengths [readBytes] == 1) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			if (lengths [readBytes] > 0x110) {  				// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x10;  				outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  			} else if (lengths [readBytes] > 0x10) {  				// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x00;  				outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  			} else {  				// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  			}  			// the last 1.5 bytes are always the disp  			outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  			bufferlength++;  			readBytes += lengths [readBytes];  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	// blocks are at most 4 bytes long.  	byte[] outbuffer = new byte[8 * 4 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	// get the optimal choices for len and disp  	int[] lengths' disps;  	this.GetOptimalCompressionLengths (instart' indata.Length' out lengths' out disps);  	while (readBytes < inLength) {  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		if (lengths [readBytes] == 1) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			if (lengths [readBytes] > 0x110) {  				// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x10;  				outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  			} else if (lengths [readBytes] > 0x10) {  				// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x00;  				outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  			} else {  				// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  			}  			// the last 1.5 bytes are always the disp  			outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  			bufferlength++;  			readBytes += lengths [readBytes];  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	// blocks are at most 4 bytes long.  	byte[] outbuffer = new byte[8 * 4 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	// get the optimal choices for len and disp  	int[] lengths' disps;  	this.GetOptimalCompressionLengths (instart' indata.Length' out lengths' out disps);  	while (readBytes < inLength) {  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		if (lengths [readBytes] == 1) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			if (lengths [readBytes] > 0x110) {  				// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x10;  				outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  			} else if (lengths [readBytes] > 0x10) {  				// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x00;  				outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  			} else {  				// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  			}  			// the last 1.5 bytes are always the disp  			outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  			bufferlength++;  			readBytes += lengths [readBytes];  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	// blocks are at most 4 bytes long.  	byte[] outbuffer = new byte[8 * 4 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	// get the optimal choices for len and disp  	int[] lengths' disps;  	this.GetOptimalCompressionLengths (instart' indata.Length' out lengths' out disps);  	while (readBytes < inLength) {  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		if (lengths [readBytes] == 1) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			if (lengths [readBytes] > 0x110) {  				// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x10;  				outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  			} else if (lengths [readBytes] > 0x10) {  				// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x00;  				outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  			} else {  				// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  			}  			// the last 1.5 bytes are always the disp  			outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  			bufferlength++;  			readBytes += lengths [readBytes];  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: fixed (byte* instart = &indata [0]) {  	// we do need to buffer the output' as the first byte indicates which blocks are compressed.  	// this version does not use a look-ahead' so we do not need to buffer more than 8 blocks at a time.  	// blocks are at most 4 bytes long.  	byte[] outbuffer = new byte[8 * 4 + 1];  	outbuffer [0] = 0;  	int bufferlength = 1' bufferedBlocks = 0;  	int readBytes = 0;  	// get the optimal choices for len and disp  	int[] lengths' disps;  	this.GetOptimalCompressionLengths (instart' indata.Length' out lengths' out disps);  	while (readBytes < inLength) {  		// we can only buffer 8 blocks at a time.  		if (bufferedBlocks == 8) {  			outstream.Write (outbuffer' 0' bufferlength);  			compressedLength += bufferlength;  			// reset the buffer  			outbuffer [0] = 0;  			bufferlength = 1;  			bufferedBlocks = 0;  		}  		if (lengths [readBytes] == 1) {  			outbuffer [bufferlength++] = *(instart + (readBytes++));  		} else {  			// mark the next block as compressed  			outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  			if (lengths [readBytes] > 0x110) {  				// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x10;  				outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  			} else if (lengths [readBytes] > 0x10) {  				// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = 0x00;  				outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  				bufferlength++;  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  			} else {  				// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  				outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  			}  			// the last 1.5 bytes are always the disp  			outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  			bufferlength++;  			readBytes += lengths [readBytes];  		}  		bufferedBlocks++;  	}  	// copy the remaining blocks to the output  	if (bufferedBlocks > 0) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		/*/ make the compressed file 4-byte aligned.                     while ((compressedLength % 4) != 0)                     {                         outstream.WriteByte(0);                         compressedLength++;                     }/**/}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: while (readBytes < inLength) {  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	if (lengths [readBytes] == 1) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		if (lengths [readBytes] > 0x110) {  			// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x10;  			outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  		} else if (lengths [readBytes] > 0x10) {  			// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x00;  			outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  		} else {  			// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  		}  		// the last 1.5 bytes are always the disp  		outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  		bufferlength++;  		readBytes += lengths [readBytes];  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: while (readBytes < inLength) {  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	if (lengths [readBytes] == 1) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		if (lengths [readBytes] > 0x110) {  			// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x10;  			outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  		} else if (lengths [readBytes] > 0x10) {  			// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x00;  			outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  		} else {  			// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  		}  		// the last 1.5 bytes are always the disp  		outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  		bufferlength++;  		readBytes += lengths [readBytes];  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: while (readBytes < inLength) {  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	if (lengths [readBytes] == 1) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		if (lengths [readBytes] > 0x110) {  			// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x10;  			outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  		} else if (lengths [readBytes] > 0x10) {  			// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x00;  			outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  		} else {  			// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  		}  		// the last 1.5 bytes are always the disp  		outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  		bufferlength++;  		readBytes += lengths [readBytes];  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: while (readBytes < inLength) {  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	if (lengths [readBytes] == 1) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		if (lengths [readBytes] > 0x110) {  			// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x10;  			outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  		} else if (lengths [readBytes] > 0x10) {  			// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x00;  			outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  		} else {  			// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  		}  		// the last 1.5 bytes are always the disp  		outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  		bufferlength++;  		readBytes += lengths [readBytes];  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: while (readBytes < inLength) {  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	if (lengths [readBytes] == 1) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		if (lengths [readBytes] > 0x110) {  			// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x10;  			outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  		} else if (lengths [readBytes] > 0x10) {  			// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x00;  			outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  		} else {  			// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  		}  		// the last 1.5 bytes are always the disp  		outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  		bufferlength++;  		readBytes += lengths [readBytes];  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: while (readBytes < inLength) {  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	if (lengths [readBytes] == 1) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		if (lengths [readBytes] > 0x110) {  			// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x10;  			outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  		} else if (lengths [readBytes] > 0x10) {  			// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x00;  			outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  		} else {  			// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  		}  		// the last 1.5 bytes are always the disp  		outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  		bufferlength++;  		readBytes += lengths [readBytes];  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: while (readBytes < inLength) {  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	if (lengths [readBytes] == 1) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		if (lengths [readBytes] > 0x110) {  			// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x10;  			outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  		} else if (lengths [readBytes] > 0x10) {  			// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x00;  			outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  		} else {  			// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  		}  		// the last 1.5 bytes are always the disp  		outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  		bufferlength++;  		readBytes += lengths [readBytes];  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: while (readBytes < inLength) {  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	if (lengths [readBytes] == 1) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		if (lengths [readBytes] > 0x110) {  			// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x10;  			outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  		} else if (lengths [readBytes] > 0x10) {  			// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x00;  			outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  		} else {  			// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  		}  		// the last 1.5 bytes are always the disp  		outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  		bufferlength++;  		readBytes += lengths [readBytes];  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: while (readBytes < inLength) {  	// we can only buffer 8 blocks at a time.  	if (bufferedBlocks == 8) {  		outstream.Write (outbuffer' 0' bufferlength);  		compressedLength += bufferlength;  		// reset the buffer  		outbuffer [0] = 0;  		bufferlength = 1;  		bufferedBlocks = 0;  	}  	if (lengths [readBytes] == 1) {  		outbuffer [bufferlength++] = *(instart + (readBytes++));  	} else {  		// mark the next block as compressed  		outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  		if (lengths [readBytes] > 0x110) {  			// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x10;  			outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  		} else if (lengths [readBytes] > 0x10) {  			// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = 0x00;  			outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  			bufferlength++;  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  		} else {  			// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  			outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  		}  		// the last 1.5 bytes are always the disp  		outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  		bufferlength++;  		readBytes += lengths [readBytes];  	}  	bufferedBlocks++;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: if (bufferedBlocks == 8) {  	outstream.Write (outbuffer' 0' bufferlength);  	compressedLength += bufferlength;  	// reset the buffer  	outbuffer [0] = 0;  	bufferlength = 1;  	bufferedBlocks = 0;  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: if (lengths [readBytes] == 1) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	if (lengths [readBytes] > 0x110) {  		// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x10;  		outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  	} else if (lengths [readBytes] > 0x10) {  		// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x00;  		outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  	} else {  		// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  	}  	// the last 1.5 bytes are always the disp  	outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  	bufferlength++;  	readBytes += lengths [readBytes];  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: if (lengths [readBytes] == 1) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	if (lengths [readBytes] > 0x110) {  		// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x10;  		outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  	} else if (lengths [readBytes] > 0x10) {  		// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x00;  		outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  	} else {  		// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  	}  	// the last 1.5 bytes are always the disp  	outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  	bufferlength++;  	readBytes += lengths [readBytes];  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: if (lengths [readBytes] == 1) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	if (lengths [readBytes] > 0x110) {  		// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x10;  		outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  	} else if (lengths [readBytes] > 0x10) {  		// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x00;  		outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  	} else {  		// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  	}  	// the last 1.5 bytes are always the disp  	outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  	bufferlength++;  	readBytes += lengths [readBytes];  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: if (lengths [readBytes] == 1) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	if (lengths [readBytes] > 0x110) {  		// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x10;  		outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  	} else if (lengths [readBytes] > 0x10) {  		// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x00;  		outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  	} else {  		// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  	}  	// the last 1.5 bytes are always the disp  	outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  	bufferlength++;  	readBytes += lengths [readBytes];  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: if (lengths [readBytes] == 1) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	if (lengths [readBytes] > 0x110) {  		// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x10;  		outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  	} else if (lengths [readBytes] > 0x10) {  		// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x00;  		outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  	} else {  		// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  	}  	// the last 1.5 bytes are always the disp  	outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  	bufferlength++;  	readBytes += lengths [readBytes];  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: if (lengths [readBytes] == 1) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	if (lengths [readBytes] > 0x110) {  		// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x10;  		outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  	} else if (lengths [readBytes] > 0x10) {  		// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x00;  		outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  	} else {  		// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  	}  	// the last 1.5 bytes are always the disp  	outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  	bufferlength++;  	readBytes += lengths [readBytes];  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: if (lengths [readBytes] == 1) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	if (lengths [readBytes] > 0x110) {  		// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x10;  		outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  	} else if (lengths [readBytes] > 0x10) {  		// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x00;  		outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  	} else {  		// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  	}  	// the last 1.5 bytes are always the disp  	outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  	bufferlength++;  	readBytes += lengths [readBytes];  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: if (lengths [readBytes] == 1) {  	outbuffer [bufferlength++] = *(instart + (readBytes++));  } else {  	// mark the next block as compressed  	outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  	if (lengths [readBytes] > 0x110) {  		// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x10;  		outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  	} else if (lengths [readBytes] > 0x10) {  		// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = 0x00;  		outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  		bufferlength++;  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  	} else {  		// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  		outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  	}  	// the last 1.5 bytes are always the disp  	outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)((disps [readBytes] - 1) & 0xFF);  	bufferlength++;  	readBytes += lengths [readBytes];  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: outbuffer [0] |= (byte)(1 << (7 - bufferedBlocks));  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: if (lengths [readBytes] > 0x110) {  	// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x10;  	outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  } else if (lengths [readBytes] > 0x10) {  	// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x00;  	outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  } else {  	// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: if (lengths [readBytes] > 0x110) {  	// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x10;  	outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  } else if (lengths [readBytes] > 0x10) {  	// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x00;  	outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  } else {  	// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: if (lengths [readBytes] > 0x110) {  	// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x10;  	outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  } else if (lengths [readBytes] > 0x10) {  	// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x00;  	outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  } else {  	// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: if (lengths [readBytes] > 0x110) {  	// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x10;  	outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  } else if (lengths [readBytes] > 0x10) {  	// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x00;  	outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  } else {  	// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: if (lengths [readBytes] > 0x110) {  	// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x10;  	outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  } else if (lengths [readBytes] > 0x10) {  	// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x00;  	outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  } else {  	// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: if (lengths [readBytes] > 0x110) {  	// case 1: 1(B CD E)(F GH) + (0x111)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x10;  	outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  } else if (lengths [readBytes] > 0x10) {  	// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x00;  	outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  } else {  	// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 12) & 0x0F);  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) >> 4) & 0xFF);  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: if (lengths [readBytes] > 0x10) {  	// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x00;  	outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  } else {  	// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: if (lengths [readBytes] > 0x10) {  	// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x00;  	outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  } else {  	// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: if (lengths [readBytes] > 0x10) {  	// case 0; 0(B C)(D EF) + (0x11)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = 0x00;  	outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  	bufferlength++;  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  } else {  	// case > 1: (A)(B CD) + (0x1)(0x1) = (LEN)(DISP)  	outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: outbuffer [bufferlength] |= (byte)(((lengths [readBytes] - 0x111) >> 4) & 0x0F);  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 0x111) << 4) & 0xF0);  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: outbuffer [bufferlength] = (byte)(((lengths [readBytes] - 1) << 4) & 0xF0);  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,CompressWithLA,The following statement contains a magic number: outbuffer [bufferlength] |= (byte)(((disps [readBytes] - 1) >> 8) & 0x0F);  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,GetOptimalCompressionLengths,The following statement contains a magic number: for (int i = inLength - 1; i >= 0; i--) {  	// first get the compression length when the next byte is not compressed  	minLengths [i] = int.MaxValue;  	lengths [i] = 1;  	if (i + 1 >= inLength)  		minLengths [i] = 1;  	else  		minLengths [i] = 1 + minLengths [i + 1];  	// then the optimal compressed length  	int oldLength = Math.Min (0x1000' i);  	// get the appropriate disp while at it. Takes at most O(n) time if oldLength is considered O(n) and 0x10110 constant.  	// however since a lot of files will not be larger than 0x10110' this will often take ~O(n^2) time.  	// be sure to bound the input length with 0x10110' as that's the maximum length for LZ-11 compressed blocks.  	int maxLen = LZUtil.GetOccurrenceLength (indata + i' Math.Min (inLength - i' 0x10110)' indata + i - oldLength' oldLength' out disps [i]);  	if (disps [i] > i)  		throw new Exception (Main.Get_Traduction ("S02"));  	for (int j = 3; j <= maxLen; j++) {  		int blocklen;  		if (j > 0x110)  			blocklen = 4;  		else if (j > 0x10)  			blocklen = 3;  		else  			blocklen = 2;  		int newCompLen;  		if (i + j >= inLength)  			newCompLen = blocklen;  		else  			newCompLen = blocklen + minLengths [i + j];  		if (newCompLen < minLengths [i]) {  			lengths [i] = j;  			minLengths [i] = newCompLen;  		}  	}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,GetOptimalCompressionLengths,The following statement contains a magic number: for (int i = inLength - 1; i >= 0; i--) {  	// first get the compression length when the next byte is not compressed  	minLengths [i] = int.MaxValue;  	lengths [i] = 1;  	if (i + 1 >= inLength)  		minLengths [i] = 1;  	else  		minLengths [i] = 1 + minLengths [i + 1];  	// then the optimal compressed length  	int oldLength = Math.Min (0x1000' i);  	// get the appropriate disp while at it. Takes at most O(n) time if oldLength is considered O(n) and 0x10110 constant.  	// however since a lot of files will not be larger than 0x10110' this will often take ~O(n^2) time.  	// be sure to bound the input length with 0x10110' as that's the maximum length for LZ-11 compressed blocks.  	int maxLen = LZUtil.GetOccurrenceLength (indata + i' Math.Min (inLength - i' 0x10110)' indata + i - oldLength' oldLength' out disps [i]);  	if (disps [i] > i)  		throw new Exception (Main.Get_Traduction ("S02"));  	for (int j = 3; j <= maxLen; j++) {  		int blocklen;  		if (j > 0x110)  			blocklen = 4;  		else if (j > 0x10)  			blocklen = 3;  		else  			blocklen = 2;  		int newCompLen;  		if (i + j >= inLength)  			newCompLen = blocklen;  		else  			newCompLen = blocklen + minLengths [i + j];  		if (newCompLen < minLengths [i]) {  			lengths [i] = j;  			minLengths [i] = newCompLen;  		}  	}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,GetOptimalCompressionLengths,The following statement contains a magic number: for (int i = inLength - 1; i >= 0; i--) {  	// first get the compression length when the next byte is not compressed  	minLengths [i] = int.MaxValue;  	lengths [i] = 1;  	if (i + 1 >= inLength)  		minLengths [i] = 1;  	else  		minLengths [i] = 1 + minLengths [i + 1];  	// then the optimal compressed length  	int oldLength = Math.Min (0x1000' i);  	// get the appropriate disp while at it. Takes at most O(n) time if oldLength is considered O(n) and 0x10110 constant.  	// however since a lot of files will not be larger than 0x10110' this will often take ~O(n^2) time.  	// be sure to bound the input length with 0x10110' as that's the maximum length for LZ-11 compressed blocks.  	int maxLen = LZUtil.GetOccurrenceLength (indata + i' Math.Min (inLength - i' 0x10110)' indata + i - oldLength' oldLength' out disps [i]);  	if (disps [i] > i)  		throw new Exception (Main.Get_Traduction ("S02"));  	for (int j = 3; j <= maxLen; j++) {  		int blocklen;  		if (j > 0x110)  			blocklen = 4;  		else if (j > 0x10)  			blocklen = 3;  		else  			blocklen = 2;  		int newCompLen;  		if (i + j >= inLength)  			newCompLen = blocklen;  		else  			newCompLen = blocklen + minLengths [i + j];  		if (newCompLen < minLengths [i]) {  			lengths [i] = j;  			minLengths [i] = newCompLen;  		}  	}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,GetOptimalCompressionLengths,The following statement contains a magic number: for (int i = inLength - 1; i >= 0; i--) {  	// first get the compression length when the next byte is not compressed  	minLengths [i] = int.MaxValue;  	lengths [i] = 1;  	if (i + 1 >= inLength)  		minLengths [i] = 1;  	else  		minLengths [i] = 1 + minLengths [i + 1];  	// then the optimal compressed length  	int oldLength = Math.Min (0x1000' i);  	// get the appropriate disp while at it. Takes at most O(n) time if oldLength is considered O(n) and 0x10110 constant.  	// however since a lot of files will not be larger than 0x10110' this will often take ~O(n^2) time.  	// be sure to bound the input length with 0x10110' as that's the maximum length for LZ-11 compressed blocks.  	int maxLen = LZUtil.GetOccurrenceLength (indata + i' Math.Min (inLength - i' 0x10110)' indata + i - oldLength' oldLength' out disps [i]);  	if (disps [i] > i)  		throw new Exception (Main.Get_Traduction ("S02"));  	for (int j = 3; j <= maxLen; j++) {  		int blocklen;  		if (j > 0x110)  			blocklen = 4;  		else if (j > 0x10)  			blocklen = 3;  		else  			blocklen = 2;  		int newCompLen;  		if (i + j >= inLength)  			newCompLen = blocklen;  		else  			newCompLen = blocklen + minLengths [i + j];  		if (newCompLen < minLengths [i]) {  			lengths [i] = j;  			minLengths [i] = newCompLen;  		}  	}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,GetOptimalCompressionLengths,The following statement contains a magic number: for (int j = 3; j <= maxLen; j++) {  	int blocklen;  	if (j > 0x110)  		blocklen = 4;  	else if (j > 0x10)  		blocklen = 3;  	else  		blocklen = 2;  	int newCompLen;  	if (i + j >= inLength)  		newCompLen = blocklen;  	else  		newCompLen = blocklen + minLengths [i + j];  	if (newCompLen < minLengths [i]) {  		lengths [i] = j;  		minLengths [i] = newCompLen;  	}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,GetOptimalCompressionLengths,The following statement contains a magic number: for (int j = 3; j <= maxLen; j++) {  	int blocklen;  	if (j > 0x110)  		blocklen = 4;  	else if (j > 0x10)  		blocklen = 3;  	else  		blocklen = 2;  	int newCompLen;  	if (i + j >= inLength)  		newCompLen = blocklen;  	else  		newCompLen = blocklen + minLengths [i + j];  	if (newCompLen < minLengths [i]) {  		lengths [i] = j;  		minLengths [i] = newCompLen;  	}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,GetOptimalCompressionLengths,The following statement contains a magic number: for (int j = 3; j <= maxLen; j++) {  	int blocklen;  	if (j > 0x110)  		blocklen = 4;  	else if (j > 0x10)  		blocklen = 3;  	else  		blocklen = 2;  	int newCompLen;  	if (i + j >= inLength)  		newCompLen = blocklen;  	else  		newCompLen = blocklen + minLengths [i + j];  	if (newCompLen < minLengths [i]) {  		lengths [i] = j;  		minLengths [i] = newCompLen;  	}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,GetOptimalCompressionLengths,The following statement contains a magic number: for (int j = 3; j <= maxLen; j++) {  	int blocklen;  	if (j > 0x110)  		blocklen = 4;  	else if (j > 0x10)  		blocklen = 3;  	else  		blocklen = 2;  	int newCompLen;  	if (i + j >= inLength)  		newCompLen = blocklen;  	else  		newCompLen = blocklen + minLengths [i + j];  	if (newCompLen < minLengths [i]) {  		lengths [i] = j;  		minLengths [i] = newCompLen;  	}  }  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,GetOptimalCompressionLengths,The following statement contains a magic number: if (j > 0x110)  	blocklen = 4;  else if (j > 0x10)  	blocklen = 3;  else  	blocklen = 2;  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,GetOptimalCompressionLengths,The following statement contains a magic number: if (j > 0x110)  	blocklen = 4;  else if (j > 0x10)  	blocklen = 3;  else  	blocklen = 2;  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,GetOptimalCompressionLengths,The following statement contains a magic number: if (j > 0x110)  	blocklen = 4;  else if (j > 0x10)  	blocklen = 3;  else  	blocklen = 2;  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,GetOptimalCompressionLengths,The following statement contains a magic number: blocklen = 4;  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,GetOptimalCompressionLengths,The following statement contains a magic number: if (j > 0x10)  	blocklen = 3;  else  	blocklen = 2;  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,GetOptimalCompressionLengths,The following statement contains a magic number: if (j > 0x10)  	blocklen = 3;  else  	blocklen = 2;  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,GetOptimalCompressionLengths,The following statement contains a magic number: blocklen = 3;  
Magic Number,DSDecmp.Formats.Nitro,LZ11,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\LZ11.cs,GetOptimalCompressionLengths,The following statement contains a magic number: blocklen = 2;  
Magic Number,DSDecmp.Formats.Nitro,NitroCFormat,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\NitroCFormat.cs,Supports,The following statement contains a magic number: try {  	int firstByte = stream.ReadByte ();  	if (firstByte != this.magicByte)  		return false;  	// no need to read the size info as well if it's used anyway.  	if (!SkipLargePlaintexts)  		return true;  	byte[] sizeBytes = new byte[3];  	stream.Read (sizeBytes' 0' 3);  	int outSize = IOUtils.ToNDSu24 (sizeBytes' 0);  	if (outSize == 0) {  		sizeBytes = new byte[4];  		stream.Read (sizeBytes' 0' 4);  		outSize = (int)IOUtils.ToNDSu32 (sizeBytes' 0);  	}  	return outSize <= MaxPlaintextSize;  } finally {  	stream.Position = startPosition;  }  
Magic Number,DSDecmp.Formats.Nitro,NitroCFormat,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\NitroCFormat.cs,Supports,The following statement contains a magic number: try {  	int firstByte = stream.ReadByte ();  	if (firstByte != this.magicByte)  		return false;  	// no need to read the size info as well if it's used anyway.  	if (!SkipLargePlaintexts)  		return true;  	byte[] sizeBytes = new byte[3];  	stream.Read (sizeBytes' 0' 3);  	int outSize = IOUtils.ToNDSu24 (sizeBytes' 0);  	if (outSize == 0) {  		sizeBytes = new byte[4];  		stream.Read (sizeBytes' 0' 4);  		outSize = (int)IOUtils.ToNDSu32 (sizeBytes' 0);  	}  	return outSize <= MaxPlaintextSize;  } finally {  	stream.Position = startPosition;  }  
Magic Number,DSDecmp.Formats.Nitro,NitroCFormat,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\NitroCFormat.cs,Supports,The following statement contains a magic number: try {  	int firstByte = stream.ReadByte ();  	if (firstByte != this.magicByte)  		return false;  	// no need to read the size info as well if it's used anyway.  	if (!SkipLargePlaintexts)  		return true;  	byte[] sizeBytes = new byte[3];  	stream.Read (sizeBytes' 0' 3);  	int outSize = IOUtils.ToNDSu24 (sizeBytes' 0);  	if (outSize == 0) {  		sizeBytes = new byte[4];  		stream.Read (sizeBytes' 0' 4);  		outSize = (int)IOUtils.ToNDSu32 (sizeBytes' 0);  	}  	return outSize <= MaxPlaintextSize;  } finally {  	stream.Position = startPosition;  }  
Magic Number,DSDecmp.Formats.Nitro,NitroCFormat,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\NitroCFormat.cs,Supports,The following statement contains a magic number: try {  	int firstByte = stream.ReadByte ();  	if (firstByte != this.magicByte)  		return false;  	// no need to read the size info as well if it's used anyway.  	if (!SkipLargePlaintexts)  		return true;  	byte[] sizeBytes = new byte[3];  	stream.Read (sizeBytes' 0' 3);  	int outSize = IOUtils.ToNDSu24 (sizeBytes' 0);  	if (outSize == 0) {  		sizeBytes = new byte[4];  		stream.Read (sizeBytes' 0' 4);  		outSize = (int)IOUtils.ToNDSu32 (sizeBytes' 0);  	}  	return outSize <= MaxPlaintextSize;  } finally {  	stream.Position = startPosition;  }  
Magic Number,DSDecmp.Formats.Nitro,NitroCFormat,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\NitroCFormat.cs,Supports,The following statement contains a magic number: stream.Read (sizeBytes' 0' 3);  
Magic Number,DSDecmp.Formats.Nitro,NitroCFormat,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\NitroCFormat.cs,Supports,The following statement contains a magic number: if (outSize == 0) {  	sizeBytes = new byte[4];  	stream.Read (sizeBytes' 0' 4);  	outSize = (int)IOUtils.ToNDSu32 (sizeBytes' 0);  }  
Magic Number,DSDecmp.Formats.Nitro,NitroCFormat,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\NitroCFormat.cs,Supports,The following statement contains a magic number: if (outSize == 0) {  	sizeBytes = new byte[4];  	stream.Read (sizeBytes' 0' 4);  	outSize = (int)IOUtils.ToNDSu32 (sizeBytes' 0);  }  
Magic Number,DSDecmp.Formats.Nitro,NitroCFormat,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\NitroCFormat.cs,Supports,The following statement contains a magic number: sizeBytes = new byte[4];  
Magic Number,DSDecmp.Formats.Nitro,NitroCFormat,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\NitroCFormat.cs,Supports,The following statement contains a magic number: stream.Read (sizeBytes' 0' 4);  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Decompress,The following statement contains a magic number: instream.Read (sizeBytes' 0' 3);  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Decompress,The following statement contains a magic number: readBytes += 4;  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Decompress,The following statement contains a magic number: if (decompressedSize == 0) {  	sizeBytes = new byte[4];  	instream.Read (sizeBytes' 0' 4);  	decompressedSize = IOUtils.ToNDSs32 (sizeBytes' 0);  	readBytes += 4;  }  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Decompress,The following statement contains a magic number: if (decompressedSize == 0) {  	sizeBytes = new byte[4];  	instream.Read (sizeBytes' 0' 4);  	decompressedSize = IOUtils.ToNDSs32 (sizeBytes' 0);  	readBytes += 4;  }  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Decompress,The following statement contains a magic number: if (decompressedSize == 0) {  	sizeBytes = new byte[4];  	instream.Read (sizeBytes' 0' 4);  	decompressedSize = IOUtils.ToNDSs32 (sizeBytes' 0);  	readBytes += 4;  }  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Decompress,The following statement contains a magic number: sizeBytes = new byte[4];  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Decompress,The following statement contains a magic number: instream.Read (sizeBytes' 0' 4);  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Decompress,The following statement contains a magic number: readBytes += 4;  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Decompress,The following statement contains a magic number: while (currentOutSize < decompressedSize) {  	#region (try to) get the flag byte with the length data and compressed flag  	if (readBytes >= inLength)  		throw new NotEnoughDataException (currentOutSize' decompressedSize);  	int flag = instream.ReadByte ();  	readBytes++;  	if (flag < 0)  		throw new StreamTooShortException ();  	bool compressed = (flag & 0x80) > 0;  	int length = flag & 0x7F;  	if (compressed)  		length += 3;  	else  		length += 1;  	#endregion  	if (compressed) {  		#region compressed: write the next byte (length) times.  		if (readBytes >= inLength)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		int data = instream.ReadByte ();  		readBytes++;  		if (data < 0)  			throw new StreamTooShortException ();  		if (currentOutSize + length > decompressedSize)  			throw new InvalidDataException (Main.Get_Traduction ("S0C"));  		byte bdata = (byte)data;  		for (int i = 0; i < length; i++) {  			// Stream.Write(byte[]' offset' len) may also work' but only if it is a circular buffer  			outstream.WriteByte (bdata);  			currentOutSize++;  		}  		#endregion  	} else {  		#region uncompressed: copy the next (length) bytes.  		int tryReadLength = length;  		// limit the amount of bytes read by the indicated number of bytes available  		if (readBytes + length > inLength)  			tryReadLength = (int)(inLength - readBytes);  		byte[] data = new byte[length];  		int readLength = instream.Read (data' 0' (int)tryReadLength);  		readBytes += readLength;  		outstream.Write (data' 0' readLength);  		currentOutSize += readLength;  		// if the attempted number of bytes read is less than the desired number' the given input  		// length is too small (or there is not enough data in the stream)  		if (tryReadLength < length)  			throw new NotEnoughDataException (currentOutSize' decompressedSize);  		// if the actual number of read bytes is even less' it means that the end of the stream has  		// bee reached' thus the given input length is larger than the actual length of the input  		if (readLength < length)  			throw new StreamTooShortException ();  		#endregion  	}  }  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Decompress,The following statement contains a magic number: if (compressed)  	length += 3;  else  	length += 1;  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Decompress,The following statement contains a magic number: length += 3;  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Decompress,The following statement contains a magic number: if (readBytes < inLength) {  	// the input may be 4-byte aligned.  	if ((readBytes ^ (readBytes & 3)) + 4 < inLength)  		throw new TooMuchInputException (readBytes' inLength);  }  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Decompress,The following statement contains a magic number: if (readBytes < inLength) {  	// the input may be 4-byte aligned.  	if ((readBytes ^ (readBytes & 3)) + 4 < inLength)  		throw new TooMuchInputException (readBytes' inLength);  }  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Decompress,The following statement contains a magic number: if ((readBytes ^ (readBytes & 3)) + 4 < inLength)  	throw new TooMuchInputException (readBytes' inLength);  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Decompress,The following statement contains a magic number: if ((readBytes ^ (readBytes & 3)) + 4 < inLength)  	throw new TooMuchInputException (readBytes' inLength);  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Compress,The following statement contains a magic number: while (readLength < inLength) {  	bool foundRepetition = false;  	while (currentBlockLength < dataBlock.Length && readLength < inLength) {  		nextByte = instream.ReadByte ();  		if (nextByte < 0)  			throw new StreamTooShortException ();  		readLength++;  		dataBlock [currentBlockLength++] = (byte)nextByte;  		if (currentBlockLength > 1) {  			if (nextByte == dataBlock [currentBlockLength - 2])  				repCount++;  			else  				repCount = 1;  		}  		foundRepetition = repCount > 2;  		if (foundRepetition)  			break;  	}  	int numUncompToCopy = 0;  	if (foundRepetition) {  		// if a repetition was found' copy block size - 3 bytes as compressed data  		numUncompToCopy = currentBlockLength - 3;  	} else {  		// if no repetition was found' copy min(block size' max block size - 2) bytes as uncompressed data.  		numUncompToCopy = Math.Min (currentBlockLength' dataBlock.Length - 2);  	}  	#region insert uncompressed block  	if (numUncompToCopy > 0) {  		byte flag = (byte)(numUncompToCopy - 1);  		compressedData.Add (flag);  		for (int i = 0; i < numUncompToCopy; i++)  			compressedData.Add (dataBlock [i]);  		// shift some possibly remaining bytes to the start  		for (int i = numUncompToCopy; i < currentBlockLength; i++)  			dataBlock [i - numUncompToCopy] = dataBlock [i];  		currentBlockLength -= numUncompToCopy;  	}  	#endregion  	if (foundRepetition) {  		// if a repetition was found' continue until the first different byte  		// (or until the buffer is full)  		while (currentBlockLength < dataBlock.Length && readLength < inLength) {  			nextByte = instream.ReadByte ();  			if (nextByte < 0)  				throw new StreamTooShortException ();  			readLength++;  			dataBlock [currentBlockLength++] = (byte)nextByte;  			if (nextByte != dataBlock [0])  				break;  			else  				repCount++;  		}  		// the next repCount bytes are the same.  		#region insert compressed block  		byte flag = (byte)(0x80 | (repCount - 3));  		compressedData.Add (flag);  		compressedData.Add (dataBlock [0]);  		// make sure to shift the possible extra byte to the start  		if (repCount != currentBlockLength)  			dataBlock [0] = dataBlock [currentBlockLength - 1];  		currentBlockLength -= repCount;  		#endregion  	}  }  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Compress,The following statement contains a magic number: while (readLength < inLength) {  	bool foundRepetition = false;  	while (currentBlockLength < dataBlock.Length && readLength < inLength) {  		nextByte = instream.ReadByte ();  		if (nextByte < 0)  			throw new StreamTooShortException ();  		readLength++;  		dataBlock [currentBlockLength++] = (byte)nextByte;  		if (currentBlockLength > 1) {  			if (nextByte == dataBlock [currentBlockLength - 2])  				repCount++;  			else  				repCount = 1;  		}  		foundRepetition = repCount > 2;  		if (foundRepetition)  			break;  	}  	int numUncompToCopy = 0;  	if (foundRepetition) {  		// if a repetition was found' copy block size - 3 bytes as compressed data  		numUncompToCopy = currentBlockLength - 3;  	} else {  		// if no repetition was found' copy min(block size' max block size - 2) bytes as uncompressed data.  		numUncompToCopy = Math.Min (currentBlockLength' dataBlock.Length - 2);  	}  	#region insert uncompressed block  	if (numUncompToCopy > 0) {  		byte flag = (byte)(numUncompToCopy - 1);  		compressedData.Add (flag);  		for (int i = 0; i < numUncompToCopy; i++)  			compressedData.Add (dataBlock [i]);  		// shift some possibly remaining bytes to the start  		for (int i = numUncompToCopy; i < currentBlockLength; i++)  			dataBlock [i - numUncompToCopy] = dataBlock [i];  		currentBlockLength -= numUncompToCopy;  	}  	#endregion  	if (foundRepetition) {  		// if a repetition was found' continue until the first different byte  		// (or until the buffer is full)  		while (currentBlockLength < dataBlock.Length && readLength < inLength) {  			nextByte = instream.ReadByte ();  			if (nextByte < 0)  				throw new StreamTooShortException ();  			readLength++;  			dataBlock [currentBlockLength++] = (byte)nextByte;  			if (nextByte != dataBlock [0])  				break;  			else  				repCount++;  		}  		// the next repCount bytes are the same.  		#region insert compressed block  		byte flag = (byte)(0x80 | (repCount - 3));  		compressedData.Add (flag);  		compressedData.Add (dataBlock [0]);  		// make sure to shift the possible extra byte to the start  		if (repCount != currentBlockLength)  			dataBlock [0] = dataBlock [currentBlockLength - 1];  		currentBlockLength -= repCount;  		#endregion  	}  }  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Compress,The following statement contains a magic number: while (readLength < inLength) {  	bool foundRepetition = false;  	while (currentBlockLength < dataBlock.Length && readLength < inLength) {  		nextByte = instream.ReadByte ();  		if (nextByte < 0)  			throw new StreamTooShortException ();  		readLength++;  		dataBlock [currentBlockLength++] = (byte)nextByte;  		if (currentBlockLength > 1) {  			if (nextByte == dataBlock [currentBlockLength - 2])  				repCount++;  			else  				repCount = 1;  		}  		foundRepetition = repCount > 2;  		if (foundRepetition)  			break;  	}  	int numUncompToCopy = 0;  	if (foundRepetition) {  		// if a repetition was found' copy block size - 3 bytes as compressed data  		numUncompToCopy = currentBlockLength - 3;  	} else {  		// if no repetition was found' copy min(block size' max block size - 2) bytes as uncompressed data.  		numUncompToCopy = Math.Min (currentBlockLength' dataBlock.Length - 2);  	}  	#region insert uncompressed block  	if (numUncompToCopy > 0) {  		byte flag = (byte)(numUncompToCopy - 1);  		compressedData.Add (flag);  		for (int i = 0; i < numUncompToCopy; i++)  			compressedData.Add (dataBlock [i]);  		// shift some possibly remaining bytes to the start  		for (int i = numUncompToCopy; i < currentBlockLength; i++)  			dataBlock [i - numUncompToCopy] = dataBlock [i];  		currentBlockLength -= numUncompToCopy;  	}  	#endregion  	if (foundRepetition) {  		// if a repetition was found' continue until the first different byte  		// (or until the buffer is full)  		while (currentBlockLength < dataBlock.Length && readLength < inLength) {  			nextByte = instream.ReadByte ();  			if (nextByte < 0)  				throw new StreamTooShortException ();  			readLength++;  			dataBlock [currentBlockLength++] = (byte)nextByte;  			if (nextByte != dataBlock [0])  				break;  			else  				repCount++;  		}  		// the next repCount bytes are the same.  		#region insert compressed block  		byte flag = (byte)(0x80 | (repCount - 3));  		compressedData.Add (flag);  		compressedData.Add (dataBlock [0]);  		// make sure to shift the possible extra byte to the start  		if (repCount != currentBlockLength)  			dataBlock [0] = dataBlock [currentBlockLength - 1];  		currentBlockLength -= repCount;  		#endregion  	}  }  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Compress,The following statement contains a magic number: while (readLength < inLength) {  	bool foundRepetition = false;  	while (currentBlockLength < dataBlock.Length && readLength < inLength) {  		nextByte = instream.ReadByte ();  		if (nextByte < 0)  			throw new StreamTooShortException ();  		readLength++;  		dataBlock [currentBlockLength++] = (byte)nextByte;  		if (currentBlockLength > 1) {  			if (nextByte == dataBlock [currentBlockLength - 2])  				repCount++;  			else  				repCount = 1;  		}  		foundRepetition = repCount > 2;  		if (foundRepetition)  			break;  	}  	int numUncompToCopy = 0;  	if (foundRepetition) {  		// if a repetition was found' copy block size - 3 bytes as compressed data  		numUncompToCopy = currentBlockLength - 3;  	} else {  		// if no repetition was found' copy min(block size' max block size - 2) bytes as uncompressed data.  		numUncompToCopy = Math.Min (currentBlockLength' dataBlock.Length - 2);  	}  	#region insert uncompressed block  	if (numUncompToCopy > 0) {  		byte flag = (byte)(numUncompToCopy - 1);  		compressedData.Add (flag);  		for (int i = 0; i < numUncompToCopy; i++)  			compressedData.Add (dataBlock [i]);  		// shift some possibly remaining bytes to the start  		for (int i = numUncompToCopy; i < currentBlockLength; i++)  			dataBlock [i - numUncompToCopy] = dataBlock [i];  		currentBlockLength -= numUncompToCopy;  	}  	#endregion  	if (foundRepetition) {  		// if a repetition was found' continue until the first different byte  		// (or until the buffer is full)  		while (currentBlockLength < dataBlock.Length && readLength < inLength) {  			nextByte = instream.ReadByte ();  			if (nextByte < 0)  				throw new StreamTooShortException ();  			readLength++;  			dataBlock [currentBlockLength++] = (byte)nextByte;  			if (nextByte != dataBlock [0])  				break;  			else  				repCount++;  		}  		// the next repCount bytes are the same.  		#region insert compressed block  		byte flag = (byte)(0x80 | (repCount - 3));  		compressedData.Add (flag);  		compressedData.Add (dataBlock [0]);  		// make sure to shift the possible extra byte to the start  		if (repCount != currentBlockLength)  			dataBlock [0] = dataBlock [currentBlockLength - 1];  		currentBlockLength -= repCount;  		#endregion  	}  }  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Compress,The following statement contains a magic number: while (readLength < inLength) {  	bool foundRepetition = false;  	while (currentBlockLength < dataBlock.Length && readLength < inLength) {  		nextByte = instream.ReadByte ();  		if (nextByte < 0)  			throw new StreamTooShortException ();  		readLength++;  		dataBlock [currentBlockLength++] = (byte)nextByte;  		if (currentBlockLength > 1) {  			if (nextByte == dataBlock [currentBlockLength - 2])  				repCount++;  			else  				repCount = 1;  		}  		foundRepetition = repCount > 2;  		if (foundRepetition)  			break;  	}  	int numUncompToCopy = 0;  	if (foundRepetition) {  		// if a repetition was found' copy block size - 3 bytes as compressed data  		numUncompToCopy = currentBlockLength - 3;  	} else {  		// if no repetition was found' copy min(block size' max block size - 2) bytes as uncompressed data.  		numUncompToCopy = Math.Min (currentBlockLength' dataBlock.Length - 2);  	}  	#region insert uncompressed block  	if (numUncompToCopy > 0) {  		byte flag = (byte)(numUncompToCopy - 1);  		compressedData.Add (flag);  		for (int i = 0; i < numUncompToCopy; i++)  			compressedData.Add (dataBlock [i]);  		// shift some possibly remaining bytes to the start  		for (int i = numUncompToCopy; i < currentBlockLength; i++)  			dataBlock [i - numUncompToCopy] = dataBlock [i];  		currentBlockLength -= numUncompToCopy;  	}  	#endregion  	if (foundRepetition) {  		// if a repetition was found' continue until the first different byte  		// (or until the buffer is full)  		while (currentBlockLength < dataBlock.Length && readLength < inLength) {  			nextByte = instream.ReadByte ();  			if (nextByte < 0)  				throw new StreamTooShortException ();  			readLength++;  			dataBlock [currentBlockLength++] = (byte)nextByte;  			if (nextByte != dataBlock [0])  				break;  			else  				repCount++;  		}  		// the next repCount bytes are the same.  		#region insert compressed block  		byte flag = (byte)(0x80 | (repCount - 3));  		compressedData.Add (flag);  		compressedData.Add (dataBlock [0]);  		// make sure to shift the possible extra byte to the start  		if (repCount != currentBlockLength)  			dataBlock [0] = dataBlock [currentBlockLength - 1];  		currentBlockLength -= repCount;  		#endregion  	}  }  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Compress,The following statement contains a magic number: while (currentBlockLength < dataBlock.Length && readLength < inLength) {  	nextByte = instream.ReadByte ();  	if (nextByte < 0)  		throw new StreamTooShortException ();  	readLength++;  	dataBlock [currentBlockLength++] = (byte)nextByte;  	if (currentBlockLength > 1) {  		if (nextByte == dataBlock [currentBlockLength - 2])  			repCount++;  		else  			repCount = 1;  	}  	foundRepetition = repCount > 2;  	if (foundRepetition)  		break;  }  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Compress,The following statement contains a magic number: while (currentBlockLength < dataBlock.Length && readLength < inLength) {  	nextByte = instream.ReadByte ();  	if (nextByte < 0)  		throw new StreamTooShortException ();  	readLength++;  	dataBlock [currentBlockLength++] = (byte)nextByte;  	if (currentBlockLength > 1) {  		if (nextByte == dataBlock [currentBlockLength - 2])  			repCount++;  		else  			repCount = 1;  	}  	foundRepetition = repCount > 2;  	if (foundRepetition)  		break;  }  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Compress,The following statement contains a magic number: if (currentBlockLength > 1) {  	if (nextByte == dataBlock [currentBlockLength - 2])  		repCount++;  	else  		repCount = 1;  }  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Compress,The following statement contains a magic number: if (nextByte == dataBlock [currentBlockLength - 2])  	repCount++;  else  	repCount = 1;  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Compress,The following statement contains a magic number: foundRepetition = repCount > 2;  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Compress,The following statement contains a magic number: if (foundRepetition) {  	// if a repetition was found' copy block size - 3 bytes as compressed data  	numUncompToCopy = currentBlockLength - 3;  } else {  	// if no repetition was found' copy min(block size' max block size - 2) bytes as uncompressed data.  	numUncompToCopy = Math.Min (currentBlockLength' dataBlock.Length - 2);  }  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Compress,The following statement contains a magic number: if (foundRepetition) {  	// if a repetition was found' copy block size - 3 bytes as compressed data  	numUncompToCopy = currentBlockLength - 3;  } else {  	// if no repetition was found' copy min(block size' max block size - 2) bytes as uncompressed data.  	numUncompToCopy = Math.Min (currentBlockLength' dataBlock.Length - 2);  }  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Compress,The following statement contains a magic number: numUncompToCopy = currentBlockLength - 3;  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Compress,The following statement contains a magic number: numUncompToCopy = Math.Min (currentBlockLength' dataBlock.Length - 2);  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Compress,The following statement contains a magic number: if (foundRepetition) {  	// if a repetition was found' continue until the first different byte  	// (or until the buffer is full)  	while (currentBlockLength < dataBlock.Length && readLength < inLength) {  		nextByte = instream.ReadByte ();  		if (nextByte < 0)  			throw new StreamTooShortException ();  		readLength++;  		dataBlock [currentBlockLength++] = (byte)nextByte;  		if (nextByte != dataBlock [0])  			break;  		else  			repCount++;  	}  	// the next repCount bytes are the same.  	#region insert compressed block  	byte flag = (byte)(0x80 | (repCount - 3));  	compressedData.Add (flag);  	compressedData.Add (dataBlock [0]);  	// make sure to shift the possible extra byte to the start  	if (repCount != currentBlockLength)  		dataBlock [0] = dataBlock [currentBlockLength - 1];  	currentBlockLength -= repCount;  	#endregion  }  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Compress,The following statement contains a magic number: outstream.WriteByte ((byte)((inLength >> 8) & 0xFF));  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Compress,The following statement contains a magic number: outstream.WriteByte ((byte)((inLength >> 16) & 0xFF));  
Magic Number,DSDecmp.Formats.Nitro,RLE,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Formats\Nitro\RLE.cs,Compress,The following statement contains a magic number: return compLen + 4;  
Missing Default,DSDecmp,CompressionControl,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\CompressionControl.cs,checkLookAhead_CheckedChanged,The following switch statement is missing a default case: switch (format) {  case FormatCompress.LZOVL:  	Formats.LZOvl.LookAhead = checkLookAhead.Checked;  	break;  case FormatCompress.LZ10:  	Formats.Nitro.LZ10.LookAhead = checkLookAhead.Checked;  	break;  case FormatCompress.LZ11:  	Formats.Nitro.LZ11.LookAhead = checkLookAhead.Checked;  	break;  }  
Missing Default,DSDecmp,Main,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Main.cs,Get_Format,The following switch statement is missing a default case: switch (f) {  //case FormatCompress.LZOVL: fmt = new LZOvl(); break;  case FormatCompress.LZ10:  	fmt = new LZ10 ();  	break;  case FormatCompress.LZ11:  	fmt = new LZ11 ();  	break;  case FormatCompress.RLE:  	fmt = new RLE ();  	break;  case FormatCompress.HUFF:  	fmt = new Huffman ();  	break;  }  
Missing Default,DSDecmp,Main,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Main.cs,Get_Format,The following switch statement is missing a default case: switch (f) {  //case FormatCompress.LZOVL: fmt = new LZOvl(); break;  case FormatCompress.LZ10:  	fmt = new LZ10 ();  	break;  case FormatCompress.LZ11:  	fmt = new LZ11 ();  	break;  case FormatCompress.RLE:  	fmt = new RLE ();  	break;  case FormatCompress.HUFF:  	fmt = new Huffman ();  	break;  }  
Missing Default,DSDecmp,Main,D:\newReposJune17\pleonex_tinke\Plugins\DSDecmp\DSDecmp\Main.cs,CompressBest,The following switch statement is missing a default case: switch (format) {  case FormatCompress.HUFF4:  	Huffman.CompressBlockSize = Huffman.BlockSize.FOURBIT;  	realFormat = new Huffman ();  	break;  case FormatCompress.HUFF8:  	Huffman.CompressBlockSize = Huffman.BlockSize.EIGHTBIT;  	realFormat = new Huffman ();  	break;  case FormatCompress.LZ10:  	realFormat = new LZ10 ();  	break;  case FormatCompress.LZ11:  	realFormat = new LZ11 ();  	break;  case FormatCompress.LZOVL:  	realFormat = new LZOvl ();  	break;  case FormatCompress.RLE:  	realFormat = new RLE ();  	break;  }  
