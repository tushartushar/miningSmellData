Implementation smell,Namespace,Class,File,Method,Description
Long Method,MimeKit.Cryptography,OpenPgpContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\OpenPgpContext.cs,GetDecryptedStream,The method has 108 lines of code.
Long Method,MimeKit.Encodings,YDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\YDecoder.cs,ScanYBeginMarker,The method has 192 lines of code.
Long Method,MimeKit.Tnef,RtfCompressedToRtf,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\RtfCompressedToRtf.cs,Filter,The method has 120 lines of code.
Long Method,MimeKit.Tnef,TnefPart,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPart.cs,ExtractAttachments,The method has 143 lines of code.
Long Method,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TokenizePhrase,The method has 106 lines of code.
Long Method,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,FoldTokens,The method has 101 lines of code.
Long Method,MimeKit,InternetAddress,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\InternetAddress.cs,TryParse,The method has 105 lines of code.
Long Method,MimeKit,MimeParser,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeParser.cs,StepHeaders,The method has 141 lines of code.
Long Method,MimeKit,MimeTypes,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeTypes.cs,MimeTypes,The method has 555 lines of code.
Long Method,MimeKit,ParameterList,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\ParameterList.cs,TryParse,The method has 101 lines of code.
Complex Method,MimeKit.Cryptography,DefaultSecureMimeContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\DefaultSecureMimeContext.cs,Import,Cyclomatic complexity of the method is 9
Complex Method,MimeKit.Cryptography,MultipartEncrypted,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\MultipartEncrypted.cs,Decrypt,Cyclomatic complexity of the method is 9
Complex Method,MimeKit.Cryptography,OpenPgpContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\OpenPgpContext.cs,GetPublicKey,Cyclomatic complexity of the method is 8
Complex Method,MimeKit.Cryptography,OpenPgpContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\OpenPgpContext.cs,GetSigningKey,Cyclomatic complexity of the method is 9
Complex Method,MimeKit.Cryptography,OpenPgpContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\OpenPgpContext.cs,SignAndEncrypt,Cyclomatic complexity of the method is 8
Complex Method,MimeKit.Cryptography,SecureMimeContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SecureMimeContext.cs,TryGetEncryptionAlgorithm,Cyclomatic complexity of the method is 14
Complex Method,MimeKit.Cryptography,SecureMimeContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SecureMimeContext.cs,GetDigitalSignatures,Cyclomatic complexity of the method is 11
Complex Method,MimeKit.Cryptography,SqlCertificateDatabase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SqlCertificateDatabase.cs,GetSelectCommand,Cyclomatic complexity of the method is 14
Complex Method,MimeKit.Cryptography,X509CertificateDatabase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\X509CertificateDatabase.cs,GetColumnNames,Cyclomatic complexity of the method is 8
Complex Method,MimeKit.Cryptography,X509CertificateExtensions,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\X509CertificateExtensions.cs,GetKeyUsageFlags,Cyclomatic complexity of the method is 11
Complex Method,MimeKit.Cryptography,X509CertificateStore,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\X509CertificateStore.cs,Import,Cyclomatic complexity of the method is 8
Complex Method,MimeKit.Cryptography,X509CertificateStore,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\X509CertificateStore.cs,Export,Cyclomatic complexity of the method is 8
Complex Method,MimeKit.Encodings,Base64Decoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\Base64Decoder.cs,Decode,Cyclomatic complexity of the method is 9
Complex Method,MimeKit.Encodings,UUDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUDecoder.cs,ScanBeginMarker,Cyclomatic complexity of the method is 27
Complex Method,MimeKit.Encodings,UUDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUDecoder.cs,Decode,Cyclomatic complexity of the method is 12
Complex Method,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,Cyclomatic complexity of the method is 8
Complex Method,MimeKit.Encodings,YDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\YDecoder.cs,ScanYBeginMarker,Cyclomatic complexity of the method is 58
Complex Method,MimeKit.Encodings,YDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\YDecoder.cs,Decode,Cyclomatic complexity of the method is 9
Complex Method,MimeKit.IO,ChainedStream,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\ChainedStream.cs,Seek,Cyclomatic complexity of the method is 8
Complex Method,MimeKit.IO.Filters,ArmoredFromFilter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\ArmoredFromFilter.cs,Filter,Cyclomatic complexity of the method is 12
Complex Method,MimeKit.IO.Filters,BestEncodingFilter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\BestEncodingFilter.cs,Scan,Cyclomatic complexity of the method is 8
Complex Method,MimeKit.Tnef,RtfCompressedToRtf,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\RtfCompressedToRtf.cs,Filter,Cyclomatic complexity of the method is 12
Complex Method,MimeKit.Tnef,TnefPropertyReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyReader.cs,ReadTextValue,Cyclomatic complexity of the method is 8
Complex Method,MimeKit.Utils,ByteExtensions,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\ByteExtensions.cs,ByteExtensions,Cyclomatic complexity of the method is 8
Complex Method,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,Cyclomatic complexity of the method is 9
Complex Method,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryParseStandardDateFormat,Cyclomatic complexity of the method is 11
Complex Method,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryParseUnknownDateFormat,Cyclomatic complexity of the method is 21
Complex Method,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TryGetEncodedWordToken,Cyclomatic complexity of the method is 12
Complex Method,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TokenizePhrase,Cyclomatic complexity of the method is 13
Complex Method,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TokenizeText,Cyclomatic complexity of the method is 13
Complex Method,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,FoldTokens,Cyclomatic complexity of the method is 9
Complex Method,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,Merge,Cyclomatic complexity of the method is 9
Complex Method,MimeKit.Utils,StringBuilderExtensions,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\StringBuilderExtensions.cs,AppendFolded,Cyclomatic complexity of the method is 9
Complex Method,MimeKit,BodyBuilder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\BodyBuilder.cs,ToMessageBody,Cyclomatic complexity of the method is 10
Complex Method,MimeKit,ContentDisposition,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\ContentDisposition.cs,TryParse,Cyclomatic complexity of the method is 11
Complex Method,MimeKit,ContentType,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\ContentType.cs,ContentType,Cyclomatic complexity of the method is 9
Complex Method,MimeKit,ContentType,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\ContentType.cs,TryParse,Cyclomatic complexity of the method is 17
Complex Method,MimeKit,GroupAddress,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\GroupAddress.cs,Encode,Cyclomatic complexity of the method is 8
Complex Method,MimeKit,Header,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Header.cs,Header,Cyclomatic complexity of the method is 8
Complex Method,MimeKit,Header,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Header.cs,EncodeReceivedHeader,Cyclomatic complexity of the method is 14
Complex Method,MimeKit,Header,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Header.cs,Fold,Cyclomatic complexity of the method is 10
Complex Method,MimeKit,InternetAddress,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\InternetAddress.cs,CompareTo,Cyclomatic complexity of the method is 8
Complex Method,MimeKit,InternetAddress,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\InternetAddress.cs,TryParseAddrspec,Cyclomatic complexity of the method is 11
Complex Method,MimeKit,InternetAddress,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\InternetAddress.cs,TryParseMailbox,Cyclomatic complexity of the method is 14
Complex Method,MimeKit,InternetAddress,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\InternetAddress.cs,TryParse,Cyclomatic complexity of the method is 23
Complex Method,MimeKit,InternetAddress,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\InternetAddress.cs,TryParse,Cyclomatic complexity of the method is 8
Complex Method,MimeKit,InternetAddressList,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\InternetAddressList.cs,TryParse,Cyclomatic complexity of the method is 8
Complex Method,MimeKit,MailboxAddress,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MailboxAddress.cs,Encode,Cyclomatic complexity of the method is 9
Complex Method,MimeKit,MimeIterator,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeIterator.cs,MoveNext,Cyclomatic complexity of the method is 10
Complex Method,MimeKit,MimeMessage,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeMessage.cs,MimeMessage,Cyclomatic complexity of the method is 17
Complex Method,MimeKit,MimeMessage,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeMessage.cs,TryGetMessageBody,Cyclomatic complexity of the method is 8
Complex Method,MimeKit,MimeMessage,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeMessage.cs,EnumerateMimeParts,Cyclomatic complexity of the method is 8
Complex Method,MimeKit,MimeMessage,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeMessage.cs,CreateFromMailMessage,Cyclomatic complexity of the method is 25
Complex Method,MimeKit,MimeParser,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeParser.cs,ParseMessage,Cyclomatic complexity of the method is 12
Complex Method,MimeKit,MimePart,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimePart.cs,MimePart,Cyclomatic complexity of the method is 9
Complex Method,MimeKit,Multipart,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Multipart.cs,FoldPreambleOrEpilogue,Cyclomatic complexity of the method is 9
Complex Method,MimeKit,Multipart,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Multipart.cs,WriteTo,Cyclomatic complexity of the method is 8
Complex Method,MimeKit,Parameter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Parameter.cs,GetEncodeMethod,Cyclomatic complexity of the method is 8
Complex Method,MimeKit,ParameterList,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\ParameterList.cs,TryParseNameValuePair,Cyclomatic complexity of the method is 27
Complex Method,MimeKit,ParserOptions,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\ParserOptions.cs,CreateEntity,Cyclomatic complexity of the method is 12
Complex Method,MimeKit,TextPart,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\TextPart.cs,TextPart,Cyclomatic complexity of the method is 9
Long Parameter List,MimeKit.Cryptography,ApplicationPkcs7Mime,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\ApplicationPkcs7Mime.cs,SignAndEncrypt,The method has 5 parameters. Parameters: ctx' signer' digestAlgo' recipients' entity
Long Parameter List,MimeKit.Cryptography,MultipartEncrypted,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\MultipartEncrypted.cs,Create,The method has 5 parameters. Parameters: ctx' signer' digestAlgo' recipients' entity
Long Parameter List,MimeKit.Cryptography,MultipartEncrypted,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\MultipartEncrypted.cs,Create,The method has 6 parameters. Parameters: ctx' signer' digestAlgo' cipherAlgo' recipients' entity
Long Parameter List,MimeKit.Cryptography,MultipartEncrypted,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\MultipartEncrypted.cs,Create,The method has 5 parameters. Parameters: ctx' signer' digestAlgo' recipients' entity
Long Parameter List,MimeKit.Cryptography,MultipartEncrypted,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\MultipartEncrypted.cs,Create,The method has 5 parameters. Parameters: signer' digestAlgo' cipherAlgo' recipients' entity
Long Parameter List,MimeKit.Cryptography,OpenPgpContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\OpenPgpContext.cs,SignAndEncrypt,The method has 5 parameters. Parameters: signer' digestAlgo' cipherAlgo' recipients' content
Long Parameter List,MimeKit.Cryptography,SecureMailboxAddress,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SecureMailboxAddress.cs,SecureMailboxAddress,The method has 5 parameters. Parameters: encoding' name' route' address' fingerprint
Long Parameter List,MimeKit.Cryptography,SecureMimeContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SecureMimeContext.cs,BuildCertPath,The method has 5 parameters. Parameters: anchors' certificates' crls' certificate' signingTime
Long Parameter List,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The method has 5 parameters. Parameters: input' length' outbuf' output' uuptr
Long Parameter List,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Flush,The method has 5 parameters. Parameters: input' length' outbuf' output' uuptr
Long Parameter List,MimeKit.IO.Filters,ArmoredFromFilter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\ArmoredFromFilter.cs,Filter,The method has 6 parameters. Parameters: input' startIndex' length' outputIndex' outputLength' flush
Long Parameter List,MimeKit.IO.Filters,BestEncodingFilter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\BestEncodingFilter.cs,Filter,The method has 5 parameters. Parameters: input' startIndex' length' outputIndex' outputLength
Long Parameter List,MimeKit.IO.Filters,BestEncodingFilter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\BestEncodingFilter.cs,Flush,The method has 5 parameters. Parameters: input' startIndex' length' outputIndex' outputLength
Long Parameter List,MimeKit.IO.Filters,CharsetFilter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\CharsetFilter.cs,Filter,The method has 6 parameters. Parameters: input' startIndex' length' outputIndex' outputLength' flush
Long Parameter List,MimeKit.IO.Filters,DecoderFilter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\DecoderFilter.cs,Filter,The method has 6 parameters. Parameters: input' startIndex' length' outputIndex' outputLength' flush
Long Parameter List,MimeKit.IO.Filters,Dos2UnixFilter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\Dos2UnixFilter.cs,Filter,The method has 6 parameters. Parameters: input' startIndex' length' outputIndex' outputLength' flush
Long Parameter List,MimeKit.IO.Filters,EncoderFilter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\EncoderFilter.cs,Filter,The method has 6 parameters. Parameters: input' startIndex' length' outputIndex' outputLength' flush
Long Parameter List,MimeKit.IO.Filters,IMimeFilter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\IMimeFilter.cs,Filter,The method has 5 parameters. Parameters: input' startIndex' length' outputIndex' outputLength
Long Parameter List,MimeKit.IO.Filters,IMimeFilter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\IMimeFilter.cs,Flush,The method has 5 parameters. Parameters: input' startIndex' length' outputIndex' outputLength
Long Parameter List,MimeKit.IO.Filters,MimeFilterBase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\MimeFilterBase.cs,Filter,The method has 6 parameters. Parameters: input' startIndex' length' outputIndex' outputLength' flush
Long Parameter List,MimeKit.IO.Filters,MimeFilterBase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\MimeFilterBase.cs,Filter,The method has 5 parameters. Parameters: input' startIndex' length' outputIndex' outputLength
Long Parameter List,MimeKit.IO.Filters,MimeFilterBase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\MimeFilterBase.cs,Flush,The method has 5 parameters. Parameters: input' startIndex' length' outputIndex' outputLength
Long Parameter List,MimeKit.IO.Filters,PassThroughFilter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\PassThroughFilter.cs,Filter,The method has 5 parameters. Parameters: input' startIndex' length' outputIndex' outputLength
Long Parameter List,MimeKit.IO.Filters,PassThroughFilter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\PassThroughFilter.cs,Flush,The method has 5 parameters. Parameters: input' startIndex' length' outputIndex' outputLength
Long Parameter List,MimeKit.IO.Filters,TrailingWhitespaceFilter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\TrailingWhitespaceFilter.cs,Filter,The method has 6 parameters. Parameters: input' startIndex' length' outputIndex' outputLength' flush
Long Parameter List,MimeKit.IO.Filters,Unix2DosFilter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\Unix2DosFilter.cs,Filter,The method has 6 parameters. Parameters: input' startIndex' length' outputIndex' outputLength' flush
Long Parameter List,MimeKit.Tnef,RtfCompressedToRtf,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\RtfCompressedToRtf.cs,Filter,The method has 6 parameters. Parameters: input' startIndex' length' outputIndex' outputLength' flush
Long Parameter List,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ConvertToUnicode,The method has 5 parameters. Parameters: options' input' startIndex' length' charCount
Long Parameter List,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ConvertToUnicode,The method has 5 parameters. Parameters: encoding' input' startIndex' length' charCount
Long Parameter List,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ConvertToUnicode,The method has 6 parameters. Parameters: options' codepage' input' startIndex' length' charCount
Long Parameter List,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryGetTimeOfDay,The method has 5 parameters. Parameters: token' text' hour' minute' second
Long Parameter List,MimeKit.Utils,ParseUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\ParseUtils.cs,TryParseDotAtom,The method has 7 parameters. Parameters: text' index' endIndex' sentinels' throwOnError' tokenType' dotatom
Long Parameter List,MimeKit.Utils,ParseUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\ParseUtils.cs,TryParseDomainLiteral,The method has 5 parameters. Parameters: text' index' endIndex' throwOnError' domain
Long Parameter List,MimeKit.Utils,ParseUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\ParseUtils.cs,TryParseDomain,The method has 6 parameters. Parameters: text' index' endIndex' sentinels' throwOnError' domain
Long Parameter List,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,DecodeTokens,The method has 5 parameters. Parameters: options' tokens' input' inbuf' length
Long Parameter List,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,DecodePhrase,The method has 5 parameters. Parameters: options' phrase' startIndex' count' codepage
Long Parameter List,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,AppendEncodedWord,The method has 6 parameters. Parameters: str' charset' text' startIndex' length' mode
Long Parameter List,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,ShouldMergeWords,The method has 5 parameters. Parameters: options' charset' words' word' i
Long Parameter List,MimeKit.Utils,Token,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,Token,The method has 5 parameters. Parameters: charset' culture' encoding' startIndex' length
Long Parameter List,MimeKit,ContentDisposition,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\ContentDisposition.cs,TryParse,The method has 6 parameters. Parameters: options' text' index' endIndex' throwOnError' disposition
Long Parameter List,MimeKit,ContentDisposition,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\ContentDisposition.cs,TryParse,The method has 5 parameters. Parameters: options' buffer' startIndex' length' disposition
Long Parameter List,MimeKit,ContentType,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\ContentType.cs,TryParse,The method has 6 parameters. Parameters: options' text' index' endIndex' throwOnError' contentType
Long Parameter List,MimeKit,ContentType,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\ContentType.cs,TryParse,The method has 5 parameters. Parameters: options' buffer' startIndex' length' type
Long Parameter List,MimeKit,DomainList,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\DomainList.cs,TryParse,The method has 5 parameters. Parameters: text' index' endIndex' throwOnError' route
Long Parameter List,MimeKit,GroupAddress,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\GroupAddress.cs,TryParse,The method has 5 parameters. Parameters: options' buffer' startIndex' length' group
Long Parameter List,MimeKit,Header,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Header.cs,Header,The method has 5 parameters. Parameters: options' id' name' field' value
Long Parameter List,MimeKit,Header,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Header.cs,EncodeAddressHeader,The method has 5 parameters. Parameters: options' format' charset' field' value
Long Parameter List,MimeKit,Header,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Header.cs,EncodeMessageIdHeader,The method has 5 parameters. Parameters: options' format' charset' field' value
Long Parameter List,MimeKit,Header,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Header.cs,EncodeReceivedHeader,The method has 5 parameters. Parameters: options' format' charset' field' value
Long Parameter List,MimeKit,Header,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Header.cs,EncodeReferencesHeader,The method has 5 parameters. Parameters: options' format' charset' field' value
Long Parameter List,MimeKit,Header,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Header.cs,EncodeContentDisposition,The method has 5 parameters. Parameters: options' format' charset' field' value
Long Parameter List,MimeKit,Header,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Header.cs,EncodeContentType,The method has 5 parameters. Parameters: options' format' charset' field' value
Long Parameter List,MimeKit,Header,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Header.cs,EncodeUnstructuredHeader,The method has 5 parameters. Parameters: options' format' charset' field' value
Long Parameter List,MimeKit,Header,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Header.cs,TryParse,The method has 5 parameters. Parameters: options' input' length' strict' header
Long Parameter List,MimeKit,Header,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Header.cs,TryParse,The method has 5 parameters. Parameters: options' buffer' startIndex' length' header
Long Parameter List,MimeKit,InternetAddress,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\InternetAddress.cs,TryParseLocalPart,The method has 5 parameters. Parameters: text' index' endIndex' throwOnError' localpart
Long Parameter List,MimeKit,InternetAddress,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\InternetAddress.cs,TryParseAddrspec,The method has 6 parameters. Parameters: text' index' endIndex' sentinel' throwOnError' addrspec
Long Parameter List,MimeKit,InternetAddress,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\InternetAddress.cs,TryParseMailbox,The method has 9 parameters. Parameters: options' text' startIndex' index' endIndex' name' codepage' throwOnError' address
Long Parameter List,MimeKit,InternetAddress,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\InternetAddress.cs,TryParseGroup,The method has 9 parameters. Parameters: options' text' startIndex' index' endIndex' name' codepage' throwOnError' address
Long Parameter List,MimeKit,InternetAddress,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\InternetAddress.cs,TryParse,The method has 6 parameters. Parameters: options' text' index' endIndex' throwOnError' address
Long Parameter List,MimeKit,InternetAddress,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\InternetAddress.cs,TryParse,The method has 5 parameters. Parameters: options' buffer' startIndex' length' address
Long Parameter List,MimeKit,InternetAddressList,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\InternetAddressList.cs,TryParse,The method has 7 parameters. Parameters: options' text' index' endIndex' isGroup' throwOnError' addresses
Long Parameter List,MimeKit,InternetAddressList,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\InternetAddressList.cs,TryParse,The method has 5 parameters. Parameters: options' buffer' startIndex' length' addresses
Long Parameter List,MimeKit,MailboxAddress,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MailboxAddress.cs,TryParse,The method has 5 parameters. Parameters: options' buffer' startIndex' length' mailbox
Long Parameter List,MimeKit,Parameter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Parameter.cs,GetNextValue,The method has 10 parameters. Parameters: options' charset' encoder' hex' chars' index' bytes' encoded' maxLength' value
Long Parameter List,MimeKit,ParameterList,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\ParameterList.cs,TryParseNameValuePair,The method has 6 parameters. Parameters: options' text' index' endIndex' throwOnError' pair
Long Parameter List,MimeKit,ParameterList,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\ParameterList.cs,DecodeRfc2184,The method has 6 parameters. Parameters: decoder' hex' text' startIndex' count' flush
Long Parameter List,MimeKit,ParameterList,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\ParameterList.cs,TryParse,The method has 6 parameters. Parameters: options' text' index' endIndex' throwOnError' paramList
Long Identifier,MimeKit.Cryptography,SecureMimeContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SecureMimeContext.cs,,The length of the parameter DefaultEncryptionAlgorithmRank is 30.
Long Identifier,MimeKit.Cryptography,SqliteCertificateDatabase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SqliteCertificateDatabase.cs,,The length of the parameter sqliteConnectionStringBuilderClass is 34.
Long Identifier,MimeKit.Tnef,TnefPropertyTag,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyTag.cs,,The length of the parameter ContentConfidentialityAlgorithmId is 33.
Long Identifier,MimeKit.Tnef,TnefPropertyTag,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyTag.cs,,The length of the parameter NonReceiptNotificationRequested is 31.
Long Identifier,MimeKit.Tnef,TnefPropertyTag,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyTag.cs,,The length of the parameter OriginallyIntendedRecipAddrtypeA is 32.
Long Identifier,MimeKit.Tnef,TnefPropertyTag,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyTag.cs,,The length of the parameter OriginallyIntendedRecipAddrtypeW is 32.
Long Identifier,MimeKit.Tnef,TnefPropertyTag,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyTag.cs,,The length of the parameter OriginallyIntendedRecipEmailAddressA is 36.
Long Identifier,MimeKit.Tnef,TnefPropertyTag,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyTag.cs,,The length of the parameter OriginallyIntendedRecipEmailAddressW is 36.
Long Identifier,MimeKit.Tnef,TnefPropertyTag,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyTag.cs,,The length of the parameter OriginallyIntendedRecipEntryId is 30.
Long Identifier,MimeKit.Tnef,TnefPropertyTag,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyTag.cs,,The length of the parameter OriginallyIntendedRecipientName is 31.
Long Identifier,MimeKit.Tnef,TnefPropertyTag,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyTag.cs,,The length of the parameter OriginalSentRepresentingAddrtypeA is 33.
Long Identifier,MimeKit.Tnef,TnefPropertyTag,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyTag.cs,,The length of the parameter OriginalSentRepresentingAddrtypeW is 33.
Long Identifier,MimeKit.Tnef,TnefPropertyTag,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyTag.cs,,The length of the parameter OriginalSentRepresentingEmailAddressA is 37.
Long Identifier,MimeKit.Tnef,TnefPropertyTag,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyTag.cs,,The length of the parameter OriginalSentRepresentingEmailAddressW is 37.
Long Identifier,MimeKit.Tnef,TnefPropertyTag,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyTag.cs,,The length of the parameter OriginalSentRepresentingEntryId is 31.
Long Identifier,MimeKit.Tnef,TnefPropertyTag,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyTag.cs,,The length of the parameter OriginalSentRepresentingSearchKey is 33.
Long Identifier,MimeKit.Tnef,TnefPropertyTag,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyTag.cs,,The length of the parameter OriginatorAndDlExpansionHistory is 31.
Long Identifier,MimeKit.Tnef,TnefPropertyTag,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyTag.cs,,The length of the parameter OriginatorDeliveryReportRequested is 33.
Long Identifier,MimeKit.Tnef,TnefPropertyTag,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyTag.cs,,The length of the parameter OriginatorNonDeliveryReportRequested is 36.
Long Identifier,MimeKit.Tnef,TnefPropertyTag,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyTag.cs,,The length of the parameter OriginatorRequestedAlternateRecipient is 37.
Long Identifier,MimeKit.Tnef,TnefPropertyTag,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyTag.cs,,The length of the parameter PhysicalDeliveryBureauFaxDelivery is 33.
Long Identifier,MimeKit.Tnef,TnefPropertyTag,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyTag.cs,,The length of the parameter PhysicalForwardingAddressRequested is 34.
Long Identifier,MimeKit.Tnef,TnefPropertyTag,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyTag.cs,,The length of the parameter RecipientReassignmentProhibited is 31.
Long Statement,MimeKit.Cryptography,CryptographyContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\CryptographyContext.cs,Create,The length of the statement  "						throw new NotSupportedException ("You need to subclass MimeKit.Cryptography.SecureMimeContext and then register it with MimeKit.Cryptography.CryptographyContext.Register()."); " is 175.
Long Statement,MimeKit.Cryptography,CryptographyContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\CryptographyContext.cs,Create,The length of the statement  "					throw new NotSupportedException ("You need to subclass MimeKit.Cryptography.GnuPGContext and then register it with MimeKit.Cryptography.CryptographyContext.Register()."); " is 170.
Long Statement,MimeKit.Cryptography,DefaultSecureMimeContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\DefaultSecureMimeContext.cs,GetCmsSigner,The length of the statement  "				if (record.KeyUsage != X509KeyUsageFlags.None && (record.KeyUsage & SecureMimeContext.DigitalSignatureKeyUsageFlags) == 0) " is 122.
Long Statement,MimeKit.Cryptography,SqlCertificateDatabase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SqlCertificateDatabase.cs,CreateIndex,The length of the statement  "			var query = string.Format ("CREATE INDEX IF NOT EXISTS {0} ON {1}({2})"' indexName' tableName' string.Join ("' "' columnNames)); " is 128.
Long Statement,MimeKit.Cryptography,SqlCertificateDatabase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SqlCertificateDatabase.cs,GetSelectCommand,The length of the statement  "			command.CommandText = query + "WHERE ISSUERNAME = @ISSUERNAME AND SERIALNUMBER = @SERIALNUMBER AND FINGERPRINT = @FINGERPRINT LIMIT 1"; " is 135.
Long Statement,MimeKit.Cryptography,SqliteCertificateDatabase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SqliteCertificateDatabase.cs,CreateConnection,The length of the statement  "			var connectionString = (string) sqliteConnectionStringBuilderClass.GetProperty ("ConnectionString").GetValue (builder' null); " is 125.
Long Statement,MimeKit.Cryptography,WindowsSecureMimeContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\WindowsSecureMimeContext.cs,GetCmsSignerCertificate,The length of the statement  "					if (usage != null && (usage.KeyUsages & (RealX509KeyUsageFlags.DigitalSignature | RealX509KeyUsageFlags.NonRepudiation)) == 0) " is 126.
Long Statement,MimeKit.Cryptography,X509CertificateDatabase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\X509CertificateDatabase.cs,Find,The length of the statement  "			using (var command = GetSelectCommand (selector' trustedOnly' false' fields | X509CertificateRecordFields.Certificate)) { " is 121.
Long Statement,MimeKit.IO.Filters,CharsetFilter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\CharsetFilter.cs,Filter,The length of the statement  "					decoder.Convert (input' inputIndex' inputLeft' chars' charIndex' charsLeft' flush' out nread' out nwritten' out decoded); " is 121.
Long Statement,MimeKit.IO.Filters,CharsetFilter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\CharsetFilter.cs,Filter,The length of the statement  "					encoder.Convert (chars' charIndex' charsLeft' OutputBuffer' outputOffset' outputLeft' flush' out nread' out nwritten' out encoded); " is 131.
Long Statement,MimeKit.Utils,ParseUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\ParseUtils.cs,SkipQuoted,The length of the statement  "					throw new ParseException (string.Format ("Incomplete quoted-string token at offset {0}"' startIndex)' startIndex' index); " is 121.
Long Statement,MimeKit.Utils,ParseUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\ParseUtils.cs,TryParseDomainLiteral,The length of the statement  "						throw new ParseException (string.Format ("Incomplete domain literal token at offset {0}"' startIndex)' startIndex' index); " is 122.
Long Statement,MimeKit,InternetAddress,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\InternetAddress.cs,TryParse,The length of the statement  "				return TryParseGroup (options' text' startIndex' ref index' endIndex' MimeUtils.Unquote (name)' codepage' throwOnError' out address); " is 133.
Long Statement,MimeKit,InternetAddress,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\InternetAddress.cs,TryParse,The length of the statement  "				return TryParseMailbox (options' text' startIndex' ref index' endIndex' MimeUtils.Unquote (name)' codepage' throwOnError' out address); " is 135.
Long Statement,MimeKit,MessageIdList,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MessageIdList.cs,ValidateMessageId,The length of the statement  "			if (!InternetAddress.TryParse (ParserOptions.Default' buffer' ref index' buffer.Length' false' out addr) || !(addr is MailboxAddress)) " is 134.
Long Statement,MimeKit,MimeParser,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeParser.cs,IsMboxMarker,The length of the statement  "			return *inptr++ == (byte) 'F' && *inptr++ == (byte) 'r' && *inptr++ == (byte) 'o' && *inptr++ == (byte) 'm' && *inptr == (byte) ' '; " is 132.
Long Statement,MimeKit,MimeParser,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeParser.cs,ParseAndAppendHeader,The length of the statement  "					Debug.WriteLine (string.Format ("Invalid header at offset {0}: {1}"' headerOffset' ConvertToCString (headerBuffer' 0' headerIndex))); " is 133.
Long Statement,MimeKit,ParserOptions,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\ParserOptions.cs,RegisterMimeType,The length of the statement  "				throw new ArgumentException ("The specified type must have a constructor that takes a MimeEntityConstructorInfo argument."' "type"); " is 132.
Complex Conditional,MimeKit.Encodings,YEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\YEncoder.cs,Encode,The conditional expression  "c == 0 || c == (byte) '\t' || c == (byte) '\r' || c == (byte) '\n' || c == (byte) '=' || c == (byte) '.'"  is complex.
Complex Conditional,MimeKit.IO,BoundStream,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\BoundStream.cs,Seek,The conditional expression  "(EndBoundary != -1 && real < EndBoundary) || (eos && real < StartBoundary + position)"  is complex.
Complex Conditional,MimeKit.Utils,ByteExtensions,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\ByteExtensions.cs,ByteExtensions,The conditional expression  "(i >= 33 && i <= 60) || (i >= 62 && i <= 126) || i == 32"  is complex.
Complex Conditional,MimeKit.Utils,ByteExtensions,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\ByteExtensions.cs,ByteExtensions,The conditional expression  "(i >= '0' && i <= '9') || (i >= 'a' && i <= 'z') || (i >= 'A' && i <= 'Z')"  is complex.
Complex Conditional,MimeKit.Utils,ByteExtensions,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\ByteExtensions.cs,ByteExtensions,The conditional expression  "(i >= '0' && i <= '9') || (i >= 'a' && i <= 'f') || (i >= 'A' && i <= 'F')"  is complex.
Complex Conditional,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ParseIsoCodePage,The conditional expression  "codepage <= 0 || (codepage > 9 && codepage < 13) || codepage > 15"  is complex.
Complex Conditional,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TryGetEncodedWordToken,The conditional expression  "*inptr++ != '=' || *inptr++ != '?' || *inend++ != '?' || *inend++ != '='"  is complex.
Complex Conditional,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TokenizePhrase,The conditional expression  "inptr + 3 >= inend || *inptr != '?' || !IsBbQq (*(inptr + 1)) || *(inptr + 2) != '?'"  is complex.
Complex Conditional,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TokenizeText,The conditional expression  "inptr + 3 >= inend || *inptr != '?' || !IsBbQq (*(inptr + 1)) || *(inptr + 2) != '?'"  is complex.
Complex Conditional,MimeKit,InternetAddressList,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\InternetAddressList.cs,TryParse,The conditional expression  "index < endIndex && text[index] != (byte) ''' && (!isGroup || text[index] != (byte) ';')"  is complex.
Complex Conditional,MimeKit,ParameterList,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\ParameterList.cs,TryParseNameValuePair,The conditional expression  "index < endIndex && text[index] != (byte) ';' && text[index] != (byte) '\r' && text[index] != (byte) '\n'"  is complex.
Empty Catch Block,MimeKit.Cryptography,NpgsqlCertificateDatabase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\NpgsqlCertificateDatabase.cs,NpgsqlCertificateDatabase,The method has an empty catch block.
Empty Catch Block,MimeKit.Cryptography,NpgsqlCertificateDatabase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\NpgsqlCertificateDatabase.cs,NpgsqlCertificateDatabase,The method has an empty catch block.
Empty Catch Block,MimeKit.Cryptography,NpgsqlCertificateDatabase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\NpgsqlCertificateDatabase.cs,NpgsqlCertificateDatabase,The method has an empty catch block.
Empty Catch Block,MimeKit.Cryptography,SqliteCertificateDatabase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SqliteCertificateDatabase.cs,SqliteCertificateDatabase,The method has an empty catch block.
Empty Catch Block,MimeKit.Cryptography,SqliteCertificateDatabase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SqliteCertificateDatabase.cs,SqliteCertificateDatabase,The method has an empty catch block.
Empty Catch Block,MimeKit.Cryptography,SqliteCertificateDatabase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SqliteCertificateDatabase.cs,SqliteCertificateDatabase,The method has an empty catch block.
Empty Catch Block,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ConvertToUnicode,The method has an empty catch block.
Empty Catch Block,MimeKit,ContentObject,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\ContentObject.cs,WriteTo,The method has an empty catch block.
Empty Catch Block,MimeKit,MimeMessage,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeMessage.cs,ToString,The method has an empty catch block.
Magic Number,MimeKit.Cryptography,DefaultSecureMimeContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\DefaultSecureMimeContext.cs,GetTrustedAnchors,The following statement contains a magic number: var keyUsage = new bool[9];
Magic Number,MimeKit.Cryptography,MultipartEncrypted,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\MultipartEncrypted.cs,Decrypt,The following statement contains a magic number: if (Count < 2)  				throw new FormatException ();
Magic Number,MimeKit.Cryptography,MultipartEncrypted,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\MultipartEncrypted.cs,Decrypt,The following statement contains a magic number: if (Count < 2)  				throw new FormatException ();
Magic Number,MimeKit.Cryptography,MultipartSigned,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\MultipartSigned.cs,PrepareEntityForSigning,The following statement contains a magic number: if (entity is Multipart) {  				// Note: we do not want to modify multipart/signed parts  				if (entity is MultipartSigned)  					return;    				var multipart = (Multipart) entity;    				foreach (var subpart in multipart)  					PrepareEntityForSigning (subpart);  			} else if (entity is MessagePart) {  				var mpart = (MessagePart) entity;    				if (mpart.Message != null && mpart.Message.Body != null)  					PrepareEntityForSigning (mpart.Message.Body);  			} else {  				var part = (MimePart) entity;    				switch (part.ContentTransferEncoding) {  				case ContentEncoding.SevenBit:  					// need to make sure that "From "-lines are properly armored and wrapped at 78 bytes  					part.ContentTransferEncoding = part.GetBestEncoding (EncodingConstraint.SevenBit' 78);  					break;  				case ContentEncoding.EightBit:  					part.ContentTransferEncoding = ContentEncoding.QuotedPrintable;  					break;  				case ContentEncoding.Binary:  					part.ContentTransferEncoding = ContentEncoding.Base64;  					break;  				}  			}
Magic Number,MimeKit.Cryptography,MultipartSigned,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\MultipartSigned.cs,Verify,The following statement contains a magic number: if (Count < 2)  				throw new FormatException ("The multipart/signed part did not contain the expected children.");
Magic Number,MimeKit.Cryptography,OpenPgpContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\OpenPgpContext.cs,Supports,The following statement contains a magic number: if (type.Length != 2 || type[0] != "application")  				return false;
Magic Number,MimeKit.Cryptography,OpenPgpContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\OpenPgpContext.cs,Supports,The following statement contains a magic number: if (type[1].StartsWith ("x-"' StringComparison.Ordinal))  				type[1] = type[1].Substring (2);
Magic Number,MimeKit.Cryptography,OpenPgpContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\OpenPgpContext.cs,GetFingerprint,The following statement contains a magic number: if (length < 16)  				return ((int) keyId).ToString ("X2");
Magic Number,MimeKit.Cryptography,OpenPgpContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\OpenPgpContext.cs,GetPrivateKey,The following statement contains a magic number: do {  				if ((password = GetPasswordForKey (key)) == null)  					throw new OperationCanceledException ();    				try {  					var privateKey = key.ExtractPrivateKey (password.ToCharArray ());    					// Note: the private key will be null if the private key is empty.  					if (privateKey == null)  						break;    					return privateKey;  				} catch (Exception ex) {  #if DEBUG  					Debug.WriteLine (string.Format ("Failed to extract secret key: {0}"' ex));  #endif  				}    				attempts++;  			} while (attempts < 3);
Magic Number,MimeKit.Cryptography,OpenPgpContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\OpenPgpContext.cs,Sign,The following statement contains a magic number: using (var armored = new ArmoredOutputStream (memory)) {  				var compresser = new PgpCompressedDataGenerator (CompressionAlgorithmTag.ZLib);  				using (var compressed = compresser.Open (armored)) {  					var signatureGenerator = new PgpSignatureGenerator (signer.PublicKey.Algorithm' hashAlgorithm);  					var buf = new byte[4096];  					int nread;    					signatureGenerator.InitSign (PgpSignature.CanonicalTextDocument' GetPrivateKey (signer));    					while ((nread = content.Read (buf' 0' buf.Length)) > 0)  						signatureGenerator.Update (buf' 0' nread);    					var signature = signatureGenerator.Generate ();    					signature.Encode (compressed);  					compressed.Flush ();  				}    				armored.Flush ();  			}
Magic Number,MimeKit.Cryptography,OpenPgpContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\OpenPgpContext.cs,GetDigitalSignatures,The following statement contains a magic number: var buf = new byte[4096];
Magic Number,MimeKit.Cryptography,OpenPgpContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\OpenPgpContext.cs,Compress,The following statement contains a magic number: using (var compressed = compresser.Open (memory)) {  				var literalGenerator = new PgpLiteralDataGenerator ();    				using (var literal = literalGenerator.Open (compressed' 't'' "mime.txt"' content.Length' DateTime.Now)) {  					content.CopyTo (literal' 4096);  					literal.Flush ();  				}    				compressed.Flush ();  			}
Magic Number,MimeKit.Cryptography,OpenPgpContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\OpenPgpContext.cs,Encrypt,The following statement contains a magic number: using (var armored = new ArmoredOutputStream (memory)) {  				using (var compressed = Compress (content)) {  					using (var encrypted = encrypter.Open (armored' compressed.Length)) {  						compressed.CopyTo (encrypted' 4096);  						encrypted.Flush ();  					}  				}    				armored.Flush ();  			}
Magic Number,MimeKit.Cryptography,OpenPgpContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\OpenPgpContext.cs,SignAndEncrypt,The following statement contains a magic number: using (var compressed = new MemoryBlockStream ()) {  				using (var signed = compresser.Open (compressed)) {  					var signatureGenerator = new PgpSignatureGenerator (signer.PublicKey.Algorithm' hashAlgorithm);  					signatureGenerator.InitSign (PgpSignature.CanonicalTextDocument' GetPrivateKey (signer));  					var subpacket = new PgpSignatureSubpacketGenerator ();    					foreach (string userId in signer.PublicKey.GetUserIds ()) {  						subpacket.SetSignerUserId (false' userId);  						break;  					}    					signatureGenerator.SetHashedSubpackets (subpacket.Generate ());    					var onepass = signatureGenerator.GenerateOnePassVersion (false);  					onepass.Encode (signed);    					var literalGenerator = new PgpLiteralDataGenerator ();  					using (var literal = literalGenerator.Open (signed' 't'' "mime.txt"' content.Length' DateTime.Now)) {  						var buf = new byte[4096];  						int nread;    						while ((nread = content.Read (buf' 0' buf.Length)) > 0) {  							signatureGenerator.Update (buf' 0' nread);  							literal.Write (buf' 0' nread);  						}    						literal.Flush ();  					}    					var signature = signatureGenerator.Generate ();  					signature.Encode (signed);    					signed.Flush ();  				}    				compressed.Position = 0;    				var memory = new MemoryBlockStream ();  				using (var armored = new ArmoredOutputStream (memory)) {  					using (var encrypted = encrypter.Open (armored' compressed.Length)) {  						compressed.CopyTo (encrypted' 4096);  						encrypted.Flush ();  					}    					armored.Flush ();  				}    				memory.Position = 0;    				return new MimePart ("application"' "octet-stream") {  					ContentDisposition = new ContentDisposition ("attachment")'  					ContentObject = new ContentObject (memory)  				};  			}
Magic Number,MimeKit.Cryptography,OpenPgpContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\OpenPgpContext.cs,SignAndEncrypt,The following statement contains a magic number: using (var compressed = new MemoryBlockStream ()) {  				using (var signed = compresser.Open (compressed)) {  					var signatureGenerator = new PgpSignatureGenerator (signer.PublicKey.Algorithm' hashAlgorithm);  					signatureGenerator.InitSign (PgpSignature.CanonicalTextDocument' GetPrivateKey (signer));  					var subpacket = new PgpSignatureSubpacketGenerator ();    					foreach (string userId in signer.PublicKey.GetUserIds ()) {  						subpacket.SetSignerUserId (false' userId);  						break;  					}    					signatureGenerator.SetHashedSubpackets (subpacket.Generate ());    					var onepass = signatureGenerator.GenerateOnePassVersion (false);  					onepass.Encode (signed);    					var literalGenerator = new PgpLiteralDataGenerator ();  					using (var literal = literalGenerator.Open (signed' 't'' "mime.txt"' content.Length' DateTime.Now)) {  						var buf = new byte[4096];  						int nread;    						while ((nread = content.Read (buf' 0' buf.Length)) > 0) {  							signatureGenerator.Update (buf' 0' nread);  							literal.Write (buf' 0' nread);  						}    						literal.Flush ();  					}    					var signature = signatureGenerator.Generate ();  					signature.Encode (signed);    					signed.Flush ();  				}    				compressed.Position = 0;    				var memory = new MemoryBlockStream ();  				using (var armored = new ArmoredOutputStream (memory)) {  					using (var encrypted = encrypter.Open (armored' compressed.Length)) {  						compressed.CopyTo (encrypted' 4096);  						encrypted.Flush ();  					}    					armored.Flush ();  				}    				memory.Position = 0;    				return new MimePart ("application"' "octet-stream") {  					ContentDisposition = new ContentDisposition ("attachment")'  					ContentObject = new ContentObject (memory)  				};  			}
Magic Number,MimeKit.Cryptography,OpenPgpContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\OpenPgpContext.cs,GetDecryptedStream,The following statement contains a magic number: using (var armored = new ArmoredInputStream (encryptedData)) {  				var factory = new PgpObjectFactory (armored);  				var obj = factory.NextPgpObject ();  				var list = obj as PgpEncryptedDataList;    				if (list == null) {  					// probably a PgpMarker...  					obj = factory.NextPgpObject ();    					list = obj as PgpEncryptedDataList;    					if (list == null)  						throw new PgpException ("Unexpected OpenPGP packet.");  				}    				PgpPublicKeyEncryptedData encrypted = null;  				PrivateKeyNotFoundException pkex = null;  				bool hasEncryptedPackets = false;  				PgpSecretKey secret = null;    				foreach (PgpEncryptedData data in list.GetEncryptedDataObjects ()) {  					if ((encrypted = data as PgpPublicKeyEncryptedData) == null)  						continue;    					hasEncryptedPackets = true;    					try {  						secret = GetSecretKey (encrypted.KeyId);  						break;  					} catch (PrivateKeyNotFoundException ex) {  						pkex = ex;  					}  				}    				if (!hasEncryptedPackets)  					throw new PgpException ("No encrypted packets found.");    				if (secret == null)  					throw pkex;    				factory = new PgpObjectFactory (encrypted.GetDataStream (GetPrivateKey (secret)));  				List<IDigitalSignature> onepassList = null;  				PgpSignatureList signatureList = null;  				PgpCompressedData compressed = null;  				var memory = new MemoryBlockStream ();    				obj = factory.NextPgpObject ();  				while (obj != null) {  					if (obj is PgpCompressedData) {  						if (compressed != null)  							throw new PgpException ("Recursive compression packets are not supported.");    						compressed = (PgpCompressedData) obj;  						factory = new PgpObjectFactory (compressed.GetDataStream ());  					} else if (obj is PgpOnePassSignatureList) {  						if (memory.Length == 0) {  							var onepasses = (PgpOnePassSignatureList) obj;    							onepassList = new List<IDigitalSignature> ();    							for (int i = 0; i < onepasses.Count; i++) {  								var onepass = onepasses[i];  								var pubkey = PublicKeyRingBundle.GetPublicKey (onepass.KeyId);    								if (pubkey == null) {  									// too messy' pretend we never found a one-pass signature list  									onepassList = null;  									break;  								}    								onepass.InitVerify (pubkey);    								var signature = new OpenPgpDigitalSignature (pubkey' onepass) {  									PublicKeyAlgorithm = GetPublicKeyAlgorithm (onepass.KeyAlgorithm)'  									DigestAlgorithm = GetDigestAlgorithm (onepass.HashAlgorithm)'  								};    								onepassList.Add (signature);  							}  						}  					} else if (obj is PgpSignatureList) {  						signatureList = (PgpSignatureList) obj;  					} else if (obj is PgpLiteralData) {  						var literal = (PgpLiteralData) obj;    						using (var stream = literal.GetDataStream ()) {  							var buffer = new byte[4096];  							int nread;    							while ((nread = stream.Read (buffer' 0' buffer.Length)) > 0) {  								if (onepassList != null) {  									// update our one-pass signatures...  									for (int index = 0; index < nread; index++) {  										byte c = buffer[index];    										for (int i = 0; i < onepassList.Count; i++) {  											var pgp = (OpenPgpDigitalSignature) onepassList[i];  											pgp.OnePassSignature.Update (c);  										}  									}  								}    								memory.Write (buffer' 0' nread);  							}  						}  					}    					obj = factory.NextPgpObject ();  				}    				memory.Position = 0;    				if (signatureList != null) {  					if (onepassList != null && signatureList.Count == onepassList.Count) {  						for (int i = 0; i < onepassList.Count; i++) {  							var pgp = (OpenPgpDigitalSignature) onepassList[i];  							pgp.CreationDate = signatureList[i].CreationTime;  							pgp.Signature = signatureList[i];  						}    						signatures = new DigitalSignatureCollection (onepassList);  					} else {  						signatures = GetDigitalSignatures (signatureList' memory);  						memory.Position = 0;  					}  				} else {  					signatures = null;  				}    				return memory;  			}
Magic Number,MimeKit.Cryptography,SecureMailboxAddress,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SecureMailboxAddress.cs,ValidateFingerprint,The following statement contains a magic number: for (int i = 0; i < fingerprint.Length; i++) {  				if (fingerprint[i] > 128 || !((byte) fingerprint[i]).IsXDigit ())  					throw new ArgumentException ("The fingerprint should be a hex-encoded string."' "fingerprint");  			}
Magic Number,MimeKit.Cryptography,SecureMimeContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SecureMimeContext.cs,Supports,The following statement contains a magic number: if (type.Length != 2 || type[0] != "application")  				return false;
Magic Number,MimeKit.Cryptography,SecureMimeContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SecureMimeContext.cs,Supports,The following statement contains a magic number: if (type[1].StartsWith ("x-"' StringComparison.Ordinal))  				type[1] = type[1].Substring (2);
Magic Number,MimeKit.Cryptography,SecureMimeContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SecureMimeContext.cs,AddSecureMimeCapabilities,The following statement contains a magic number: foreach (var algorithm in EncryptionAlgorithmRank) {  				if (!IsEnabled (algorithm))  					continue;    				switch (algorithm) {  				case EncryptionAlgorithm.Camellia256:  					capabilities.AddCapability (NttObjectIdentifiers.IdCamellia256Cbc);  					break;  				case EncryptionAlgorithm.Camellia192:  					capabilities.AddCapability (NttObjectIdentifiers.IdCamellia192Cbc);  					break;  				case EncryptionAlgorithm.Camellia128:  					capabilities.AddCapability (NttObjectIdentifiers.IdCamellia128Cbc);  					break;  				case EncryptionAlgorithm.Aes256:  					capabilities.AddCapability (SmimeCapabilities.Aes256Cbc);  					break;  				case EncryptionAlgorithm.Aes192:  					capabilities.AddCapability (SmimeCapabilities.Aes192Cbc);  					break;  				case EncryptionAlgorithm.Aes128:  					capabilities.AddCapability (SmimeCapabilities.Aes128Cbc);  					break;  				case EncryptionAlgorithm.Idea:  					capabilities.AddCapability (SmimeCapabilities.IdeaCbc);  					break;  				case EncryptionAlgorithm.Cast5:  					capabilities.AddCapability (SmimeCapabilities.Cast5Cbc);  					break;  				case EncryptionAlgorithm.TripleDes:  					capabilities.AddCapability (SmimeCapabilities.DesEde3Cbc);  					break;  				case EncryptionAlgorithm.RC2128:  					capabilities.AddCapability (SmimeCapabilities.RC2Cbc' 128);  					break;  				case EncryptionAlgorithm.RC264:  					capabilities.AddCapability (SmimeCapabilities.RC2Cbc' 64);  					break;  				case EncryptionAlgorithm.RC240:  					capabilities.AddCapability (SmimeCapabilities.RC2Cbc' 40);  					break;  				case EncryptionAlgorithm.Des:  					capabilities.AddCapability (SmimeCapabilities.DesCbc);  					break;  				}  			}
Magic Number,MimeKit.Cryptography,SecureMimeContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SecureMimeContext.cs,AddSecureMimeCapabilities,The following statement contains a magic number: foreach (var algorithm in EncryptionAlgorithmRank) {  				if (!IsEnabled (algorithm))  					continue;    				switch (algorithm) {  				case EncryptionAlgorithm.Camellia256:  					capabilities.AddCapability (NttObjectIdentifiers.IdCamellia256Cbc);  					break;  				case EncryptionAlgorithm.Camellia192:  					capabilities.AddCapability (NttObjectIdentifiers.IdCamellia192Cbc);  					break;  				case EncryptionAlgorithm.Camellia128:  					capabilities.AddCapability (NttObjectIdentifiers.IdCamellia128Cbc);  					break;  				case EncryptionAlgorithm.Aes256:  					capabilities.AddCapability (SmimeCapabilities.Aes256Cbc);  					break;  				case EncryptionAlgorithm.Aes192:  					capabilities.AddCapability (SmimeCapabilities.Aes192Cbc);  					break;  				case EncryptionAlgorithm.Aes128:  					capabilities.AddCapability (SmimeCapabilities.Aes128Cbc);  					break;  				case EncryptionAlgorithm.Idea:  					capabilities.AddCapability (SmimeCapabilities.IdeaCbc);  					break;  				case EncryptionAlgorithm.Cast5:  					capabilities.AddCapability (SmimeCapabilities.Cast5Cbc);  					break;  				case EncryptionAlgorithm.TripleDes:  					capabilities.AddCapability (SmimeCapabilities.DesEde3Cbc);  					break;  				case EncryptionAlgorithm.RC2128:  					capabilities.AddCapability (SmimeCapabilities.RC2Cbc' 128);  					break;  				case EncryptionAlgorithm.RC264:  					capabilities.AddCapability (SmimeCapabilities.RC2Cbc' 64);  					break;  				case EncryptionAlgorithm.RC240:  					capabilities.AddCapability (SmimeCapabilities.RC2Cbc' 40);  					break;  				case EncryptionAlgorithm.Des:  					capabilities.AddCapability (SmimeCapabilities.DesCbc);  					break;  				}  			}
Magic Number,MimeKit.Cryptography,SecureMimeContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SecureMimeContext.cs,AddSecureMimeCapabilities,The following statement contains a magic number: foreach (var algorithm in EncryptionAlgorithmRank) {  				if (!IsEnabled (algorithm))  					continue;    				switch (algorithm) {  				case EncryptionAlgorithm.Camellia256:  					capabilities.AddCapability (NttObjectIdentifiers.IdCamellia256Cbc);  					break;  				case EncryptionAlgorithm.Camellia192:  					capabilities.AddCapability (NttObjectIdentifiers.IdCamellia192Cbc);  					break;  				case EncryptionAlgorithm.Camellia128:  					capabilities.AddCapability (NttObjectIdentifiers.IdCamellia128Cbc);  					break;  				case EncryptionAlgorithm.Aes256:  					capabilities.AddCapability (SmimeCapabilities.Aes256Cbc);  					break;  				case EncryptionAlgorithm.Aes192:  					capabilities.AddCapability (SmimeCapabilities.Aes192Cbc);  					break;  				case EncryptionAlgorithm.Aes128:  					capabilities.AddCapability (SmimeCapabilities.Aes128Cbc);  					break;  				case EncryptionAlgorithm.Idea:  					capabilities.AddCapability (SmimeCapabilities.IdeaCbc);  					break;  				case EncryptionAlgorithm.Cast5:  					capabilities.AddCapability (SmimeCapabilities.Cast5Cbc);  					break;  				case EncryptionAlgorithm.TripleDes:  					capabilities.AddCapability (SmimeCapabilities.DesEde3Cbc);  					break;  				case EncryptionAlgorithm.RC2128:  					capabilities.AddCapability (SmimeCapabilities.RC2Cbc' 128);  					break;  				case EncryptionAlgorithm.RC264:  					capabilities.AddCapability (SmimeCapabilities.RC2Cbc' 64);  					break;  				case EncryptionAlgorithm.RC240:  					capabilities.AddCapability (SmimeCapabilities.RC2Cbc' 40);  					break;  				case EncryptionAlgorithm.Des:  					capabilities.AddCapability (SmimeCapabilities.DesCbc);  					break;  				}  			}
Magic Number,MimeKit.Cryptography,SecureMimeContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SecureMimeContext.cs,Sign,The following statement contains a magic number: using (var stream = signedData.Open (memory' encapsulate))  				content.CopyTo (stream' 4096);
Magic Number,MimeKit.Cryptography,SecureMimeContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SecureMimeContext.cs,TryGetEncryptionAlgorithm,The following statement contains a magic number: if (identifier.ObjectID.Id == CmsEnvelopedGenerator.RC2Cbc) {  				var param = (DerInteger) identifier.Parameters;  				int bits = param.Value.IntValue;    				switch (bits) {  				case 128: algorithm = EncryptionAlgorithm.RC2128; return true;  				case 64: algorithm = EncryptionAlgorithm.RC264; return true;  				case 40: algorithm = EncryptionAlgorithm.RC240; return true;  				}  			}
Magic Number,MimeKit.Cryptography,SecureMimeContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SecureMimeContext.cs,TryGetEncryptionAlgorithm,The following statement contains a magic number: if (identifier.ObjectID.Id == CmsEnvelopedGenerator.RC2Cbc) {  				var param = (DerInteger) identifier.Parameters;  				int bits = param.Value.IntValue;    				switch (bits) {  				case 128: algorithm = EncryptionAlgorithm.RC2128; return true;  				case 64: algorithm = EncryptionAlgorithm.RC264; return true;  				case 40: algorithm = EncryptionAlgorithm.RC240; return true;  				}  			}
Magic Number,MimeKit.Cryptography,SecureMimeContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SecureMimeContext.cs,TryGetEncryptionAlgorithm,The following statement contains a magic number: if (identifier.ObjectID.Id == CmsEnvelopedGenerator.RC2Cbc) {  				var param = (DerInteger) identifier.Parameters;  				int bits = param.Value.IntValue;    				switch (bits) {  				case 128: algorithm = EncryptionAlgorithm.RC2128; return true;  				case 64: algorithm = EncryptionAlgorithm.RC264; return true;  				case 40: algorithm = EncryptionAlgorithm.RC240; return true;  				}  			}
Magic Number,MimeKit.Cryptography,SecureMimeContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SecureMimeContext.cs,Envelope,The following statement contains a magic number: switch (GetPreferredEncryptionAlgorithm (recipients)) {  			case EncryptionAlgorithm.Camellia256:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.Camellia256Cbc);  				break;  			case EncryptionAlgorithm.Camellia192:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.Camellia192Cbc);  				break;  			case EncryptionAlgorithm.Camellia128:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.Camellia128Cbc);  				break;  			case EncryptionAlgorithm.Aes256:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.Aes256Cbc);  				break;  			case EncryptionAlgorithm.Aes192:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.Aes192Cbc);  				break;  			case EncryptionAlgorithm.Aes128:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.Aes128Cbc);  				break;  			case EncryptionAlgorithm.Cast5:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.Cast5Cbc);  				break;  			case EncryptionAlgorithm.Idea:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.IdeaCbc);  				break;  			case EncryptionAlgorithm.RC2128:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.RC2Cbc' 128);  				break;  			case EncryptionAlgorithm.RC264:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.RC2Cbc' 64);  				break;  			case EncryptionAlgorithm.RC240:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.RC2Cbc' 40);  				break;  			default:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.DesEde3Cbc);  				break;  			}
Magic Number,MimeKit.Cryptography,SecureMimeContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SecureMimeContext.cs,Envelope,The following statement contains a magic number: switch (GetPreferredEncryptionAlgorithm (recipients)) {  			case EncryptionAlgorithm.Camellia256:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.Camellia256Cbc);  				break;  			case EncryptionAlgorithm.Camellia192:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.Camellia192Cbc);  				break;  			case EncryptionAlgorithm.Camellia128:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.Camellia128Cbc);  				break;  			case EncryptionAlgorithm.Aes256:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.Aes256Cbc);  				break;  			case EncryptionAlgorithm.Aes192:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.Aes192Cbc);  				break;  			case EncryptionAlgorithm.Aes128:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.Aes128Cbc);  				break;  			case EncryptionAlgorithm.Cast5:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.Cast5Cbc);  				break;  			case EncryptionAlgorithm.Idea:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.IdeaCbc);  				break;  			case EncryptionAlgorithm.RC2128:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.RC2Cbc' 128);  				break;  			case EncryptionAlgorithm.RC264:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.RC2Cbc' 64);  				break;  			case EncryptionAlgorithm.RC240:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.RC2Cbc' 40);  				break;  			default:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.DesEde3Cbc);  				break;  			}
Magic Number,MimeKit.Cryptography,SecureMimeContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SecureMimeContext.cs,Envelope,The following statement contains a magic number: switch (GetPreferredEncryptionAlgorithm (recipients)) {  			case EncryptionAlgorithm.Camellia256:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.Camellia256Cbc);  				break;  			case EncryptionAlgorithm.Camellia192:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.Camellia192Cbc);  				break;  			case EncryptionAlgorithm.Camellia128:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.Camellia128Cbc);  				break;  			case EncryptionAlgorithm.Aes256:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.Aes256Cbc);  				break;  			case EncryptionAlgorithm.Aes192:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.Aes192Cbc);  				break;  			case EncryptionAlgorithm.Aes128:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.Aes128Cbc);  				break;  			case EncryptionAlgorithm.Cast5:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.Cast5Cbc);  				break;  			case EncryptionAlgorithm.Idea:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.IdeaCbc);  				break;  			case EncryptionAlgorithm.RC2128:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.RC2Cbc' 128);  				break;  			case EncryptionAlgorithm.RC264:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.RC2Cbc' 64);  				break;  			case EncryptionAlgorithm.RC240:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.RC2Cbc' 40);  				break;  			default:  				envelopedData = cms.Generate (input' CmsEnvelopedGenerator.DesEde3Cbc);  				break;  			}
Magic Number,MimeKit.Cryptography,SqlCertificateDatabase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SqlCertificateDatabase.cs,GetSelectCommand,The following statement contains a magic number: if (secure != null && !string.IsNullOrEmpty (secure.Fingerprint)) {  				if (secure.Fingerprint.Length < 40) {  					constraints += "AND FINGERPRINT LIKE @FINGERPRINT ";  					command.AddParameterWithValue ("@FINGERPRINT"' secure.Fingerprint.ToLowerInvariant () + "%");  				} else {  					constraints += "AND FINGERPRINT = @FINGERPRINT ";  					command.AddParameterWithValue ("@FINGERPRINT"' secure.Fingerprint.ToLowerInvariant ());  				}  			} else {  				constraints += "AND SUBJECTEMAIL = @SUBJECTEMAIL ";  				command.AddParameterWithValue ("@SUBJECTEMAIL"' mailbox.Address.ToLowerInvariant ());  			}
Magic Number,MimeKit.Cryptography,SqliteCertificateDatabase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SqliteCertificateDatabase.cs,SqliteCertificateDatabase,The following statement contains a magic number: try {  				// Mono.Data.Sqlite will only work on Unix-based platforms and 32-bit Windows platforms.  				if (platform == PlatformID.Unix || platform == PlatformID.MacOSX || IntPtr.Size == 4) {  					sqliteAssembly = Assembly.Load ("Mono.Data.Sqlite");  					if (sqliteAssembly != null) {  						sqliteConnectionClass = sqliteAssembly.GetType ("Mono.Data.Sqlite.SqliteConnection");  						sqliteConnectionStringBuilderClass = sqliteAssembly.GetType ("Mono.Data.Sqlite.SqliteConnectionStringBuilder");    						// Make sure that the runtime can load the native sqlite3 library  						var builder = Activator.CreateInstance (sqliteConnectionStringBuilderClass);  						sqliteConnectionStringBuilderClass.GetProperty ("DateTimeFormat").SetValue (builder' 0' null);    						IsAvailable = true;  					}  				}    				// System.Data.Sqlite is only available for Windows-based platforms.  				if (!IsAvailable && platform != PlatformID.Unix && platform != PlatformID.MacOSX) {  					sqliteAssembly = Assembly.Load ("System.Data.SQLite");  					if (sqliteAssembly != null) {  						sqliteConnectionClass = sqliteAssembly.GetType ("System.Data.SQLite.SQLiteConnection");  						sqliteConnectionStringBuilderClass = sqliteAssembly.GetType ("System.Data.SQLite.SQLiteConnectionStringBuilder");    						// Make sure that the runtime can load the native sqlite3 library  						var builder = Activator.CreateInstance (sqliteConnectionStringBuilderClass);  						sqliteConnectionStringBuilderClass.GetProperty ("DateTimeFormat").SetValue (builder' 0' null);    						IsAvailable = true;  					}  				}  			} catch (FileNotFoundException) {  			} catch (FileLoadException) {  			} catch (BadImageFormatException) {  			}
Magic Number,MimeKit.Cryptography,WindowsSecureMimeContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\WindowsSecureMimeContext.cs,ReadAllBytes,The following statement contains a magic number: using (var memory = new MemoryBlockStream ()) {  				stream.CopyTo (memory' 4096);  				return memory.ToArray ();  			}
Magic Number,MimeKit.Cryptography,X509CertificateDatabase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\X509CertificateDatabase.cs,Find,The following statement contains a magic number: using (var command = GetSelectCommand (certificate' fields)) {  				var reader = command.ExecuteReader ();    				try {  					if (reader.Read ()) {  						var parser = new X509CertificateParser ();  						var buffer = new byte[4096];    						return LoadCertificateRecord (reader' parser' ref buffer);  					}  				} finally {  					reader.Close ();  				}  			}
Magic Number,MimeKit.Cryptography,X509CertificateDatabase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\X509CertificateDatabase.cs,FindCertificates,The following statement contains a magic number: using (var command = GetSelectCommand (selector' false' false' X509CertificateRecordFields.Certificate)) {  				var reader = command.ExecuteReader ();    				try {  					var parser = new X509CertificateParser ();  					var buffer = new byte[4096];    					while (reader.Read ()) {  						var record = LoadCertificateRecord (reader' parser' ref buffer);  						if (selector == null || selector.Match (record.Certificate))  							yield return record.Certificate;  					}  				} finally {  					reader.Close ();  				}  			}
Magic Number,MimeKit.Cryptography,X509CertificateDatabase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\X509CertificateDatabase.cs,FindPrivateKeys,The following statement contains a magic number: using (var command = GetSelectCommand (selector' false' true' PrivateKeyFields)) {  				var reader = command.ExecuteReader ();    				try {  					var parser = new X509CertificateParser ();  					var buffer = new byte[4096];    					while (reader.Read ()) {  						var record = LoadCertificateRecord (reader' parser' ref buffer);    						if (selector == null || selector.Match (record.Certificate))  							yield return record.PrivateKey;  					}  				} finally {  					reader.Close ();  				}  			}
Magic Number,MimeKit.Cryptography,X509CertificateDatabase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\X509CertificateDatabase.cs,Find,The following statement contains a magic number: using (var command = GetSelectCommand (mailbox' now' requirePrivateKey' fields)) {  				var reader = command.ExecuteReader ();    				try {  					var parser = new X509CertificateParser ();  					var buffer = new byte[4096];    					while (reader.Read ()) {  						yield return LoadCertificateRecord (reader' parser' ref buffer);  					}  				} finally {  					reader.Close ();  				}  			}
Magic Number,MimeKit.Cryptography,X509CertificateDatabase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\X509CertificateDatabase.cs,Find,The following statement contains a magic number: using (var command = GetSelectCommand (selector' trustedOnly' false' fields | X509CertificateRecordFields.Certificate)) {  				var reader = command.ExecuteReader ();    				try {  					var parser = new X509CertificateParser ();  					var buffer = new byte[4096];    					while (reader.Read ()) {  						var record = LoadCertificateRecord (reader' parser' ref buffer);    						if (selector == null || selector.Match (record.Certificate))  							yield return record;  					}  				} finally {  					reader.Close ();  				}  			}
Magic Number,MimeKit.Cryptography,X509CertificateDatabase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\X509CertificateDatabase.cs,Find,The following statement contains a magic number: using (var command = GetSelectCommand (issuer' fields)) {  				var reader = command.ExecuteReader ();    				try {  					var parser = new X509CrlParser ();  					var buffer = new byte[4096];    					while (reader.Read ()) {  						yield return LoadCrlRecord (reader' parser' ref buffer);  					}  				} finally {  					reader.Close ();  				}  			}
Magic Number,MimeKit.Cryptography,X509CertificateDatabase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\X509CertificateDatabase.cs,Find,The following statement contains a magic number: using (var command = GetSelectCommand (crl' fields)) {  				var reader = command.ExecuteReader ();    				try {  					if (reader.Read ()) {  						var parser = new X509CrlParser ();  						var buffer = new byte[4096];    						return LoadCrlRecord (reader' parser' ref buffer);  					}  				} finally {  					reader.Close ();  				}  			}
Magic Number,MimeKit.Cryptography,X509CertificateDatabase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\X509CertificateDatabase.cs,GetCrlStore,The following statement contains a magic number: using (var command = GetSelectAllCrlsCommand ()) {  				var reader = command.ExecuteReader ();    				try {  					var parser = new X509CrlParser ();  					var buffer = new byte[4096];    					while (reader.Read ()) {  						var record = LoadCrlRecord (reader' parser' ref buffer);  						crls.Add (record.Crl);  					}  				} finally {  					reader.Close ();  				}  			}
Magic Number,MimeKit.Cryptography,X509CertificateExtensions,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\X509CertificateExtensions.cs,GetFingerprint,The following statement contains a magic number: var data = new byte[20];
Magic Number,MimeKit.Encodings,Base64Decoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\Base64Decoder.cs,EstimateOutputLength,The following statement contains a magic number: return inputLength + 3;
Magic Number,MimeKit.Encodings,Base64Decoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\Base64Decoder.cs,Decode,The following statement contains a magic number: while (inptr < inend) {  				byte c = base64_rank[*inptr++];  				if (c != 0xFF) {  					saved = (saved << 6) | c;  					bytes++;    					if (bytes == 4) {  						*outptr++ = (byte) ((saved >> 16) & 0xFF);  						*outptr++ = (byte) ((saved >> 8) & 0xFF);  						*outptr++ = (byte) (saved & 0xFF);  						saved = 0;  						bytes = 0;    						if (npad > 0) {  							outptr -= npad;  							npad = 0;  						}  					}  				}  			}
Magic Number,MimeKit.Encodings,Base64Decoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\Base64Decoder.cs,Decode,The following statement contains a magic number: while (inptr < inend) {  				byte c = base64_rank[*inptr++];  				if (c != 0xFF) {  					saved = (saved << 6) | c;  					bytes++;    					if (bytes == 4) {  						*outptr++ = (byte) ((saved >> 16) & 0xFF);  						*outptr++ = (byte) ((saved >> 8) & 0xFF);  						*outptr++ = (byte) (saved & 0xFF);  						saved = 0;  						bytes = 0;    						if (npad > 0) {  							outptr -= npad;  							npad = 0;  						}  					}  				}  			}
Magic Number,MimeKit.Encodings,Base64Decoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\Base64Decoder.cs,Decode,The following statement contains a magic number: while (inptr < inend) {  				byte c = base64_rank[*inptr++];  				if (c != 0xFF) {  					saved = (saved << 6) | c;  					bytes++;    					if (bytes == 4) {  						*outptr++ = (byte) ((saved >> 16) & 0xFF);  						*outptr++ = (byte) ((saved >> 8) & 0xFF);  						*outptr++ = (byte) (saved & 0xFF);  						saved = 0;  						bytes = 0;    						if (npad > 0) {  							outptr -= npad;  							npad = 0;  						}  					}  				}  			}
Magic Number,MimeKit.Encodings,Base64Decoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\Base64Decoder.cs,Decode,The following statement contains a magic number: while (inptr < inend) {  				byte c = base64_rank[*inptr++];  				if (c != 0xFF) {  					saved = (saved << 6) | c;  					bytes++;    					if (bytes == 4) {  						*outptr++ = (byte) ((saved >> 16) & 0xFF);  						*outptr++ = (byte) ((saved >> 8) & 0xFF);  						*outptr++ = (byte) (saved & 0xFF);  						saved = 0;  						bytes = 0;    						if (npad > 0) {  							outptr -= npad;  							npad = 0;  						}  					}  				}  			}
Magic Number,MimeKit.Encodings,Base64Decoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\Base64Decoder.cs,Decode,The following statement contains a magic number: for (int eq = 0; inptr > input && eq < 2; ) {  				inptr--;    				if (base64_rank[*inptr] != 0xFF) {  					if (*inptr == '=' && outptr > output) {  						if (bytes == 0) {  							// we've got a full quartet' so it's safe to drop an output character.  							outptr--;  						} else if (npad < 2) {  							// keep a record of the # of '='s at the end of the input (up to 2)  							npad++;  						}    						eq++;  					} else {  						break;  					}  				}  			}
Magic Number,MimeKit.Encodings,Base64Decoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\Base64Decoder.cs,Decode,The following statement contains a magic number: for (int eq = 0; inptr > input && eq < 2; ) {  				inptr--;    				if (base64_rank[*inptr] != 0xFF) {  					if (*inptr == '=' && outptr > output) {  						if (bytes == 0) {  							// we've got a full quartet' so it's safe to drop an output character.  							outptr--;  						} else if (npad < 2) {  							// keep a record of the # of '='s at the end of the input (up to 2)  							npad++;  						}    						eq++;  					} else {  						break;  					}  				}  			}
Magic Number,MimeKit.Encodings,Base64Encoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\Base64Encoder.cs,EstimateOutputLength,The following statement contains a magic number: if (rfc2047)  				return ((inputLength + 2) / 3) * 4;
Magic Number,MimeKit.Encodings,Base64Encoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\Base64Encoder.cs,EstimateOutputLength,The following statement contains a magic number: if (rfc2047)  				return ((inputLength + 2) / 3) * 4;
Magic Number,MimeKit.Encodings,Base64Encoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\Base64Encoder.cs,EstimateOutputLength,The following statement contains a magic number: if (rfc2047)  				return ((inputLength + 2) / 3) * 4;
Magic Number,MimeKit.Encodings,Base64Encoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\Base64Encoder.cs,EstimateOutputLength,The following statement contains a magic number: return (((inputLength + 2) / MaxInputPerLine) * MaxLineLength) + MaxLineLength;
Magic Number,MimeKit.Encodings,Base64Encoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\Base64Encoder.cs,Encode,The following statement contains a magic number: if (length + saved > 2) {  				byte* inend = inptr + length - 2;  				int c1' c2' c3;    				c1 = saved < 1 ? *inptr++ : saved1;  				c2 = saved < 2 ? *inptr++ : saved2;  				c3 = *inptr++;    				do {  					// encode our triplet into a quartet  					*outptr++ = base64_alphabet[c1 >> 2];  					*outptr++ = base64_alphabet[(c2 >> 4) | ((c1 & 0x3) << 4)];  					*outptr++ = base64_alphabet[((c2 & 0x0f) << 2) | (c3 >> 6)];  					*outptr++ = base64_alphabet[c3 & 0x3f];    					// encode 18 quartets per line  					if (!rfc2047 && (++quartets) >= QuartetsPerLine) {  						*outptr++ = (byte) '\n';  						quartets = 0;  					}    					if (inptr >= inend)  						break;    					c1 = *inptr++;  					c2 = *inptr++;  					c3 = *inptr++;  				} while (true);    				remaining = 2 - (int) (inptr - inend);  				saved = 0;  			}
Magic Number,MimeKit.Encodings,Base64Encoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\Base64Encoder.cs,Encode,The following statement contains a magic number: if (length + saved > 2) {  				byte* inend = inptr + length - 2;  				int c1' c2' c3;    				c1 = saved < 1 ? *inptr++ : saved1;  				c2 = saved < 2 ? *inptr++ : saved2;  				c3 = *inptr++;    				do {  					// encode our triplet into a quartet  					*outptr++ = base64_alphabet[c1 >> 2];  					*outptr++ = base64_alphabet[(c2 >> 4) | ((c1 & 0x3) << 4)];  					*outptr++ = base64_alphabet[((c2 & 0x0f) << 2) | (c3 >> 6)];  					*outptr++ = base64_alphabet[c3 & 0x3f];    					// encode 18 quartets per line  					if (!rfc2047 && (++quartets) >= QuartetsPerLine) {  						*outptr++ = (byte) '\n';  						quartets = 0;  					}    					if (inptr >= inend)  						break;    					c1 = *inptr++;  					c2 = *inptr++;  					c3 = *inptr++;  				} while (true);    				remaining = 2 - (int) (inptr - inend);  				saved = 0;  			}
Magic Number,MimeKit.Encodings,Base64Encoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\Base64Encoder.cs,Encode,The following statement contains a magic number: if (length + saved > 2) {  				byte* inend = inptr + length - 2;  				int c1' c2' c3;    				c1 = saved < 1 ? *inptr++ : saved1;  				c2 = saved < 2 ? *inptr++ : saved2;  				c3 = *inptr++;    				do {  					// encode our triplet into a quartet  					*outptr++ = base64_alphabet[c1 >> 2];  					*outptr++ = base64_alphabet[(c2 >> 4) | ((c1 & 0x3) << 4)];  					*outptr++ = base64_alphabet[((c2 & 0x0f) << 2) | (c3 >> 6)];  					*outptr++ = base64_alphabet[c3 & 0x3f];    					// encode 18 quartets per line  					if (!rfc2047 && (++quartets) >= QuartetsPerLine) {  						*outptr++ = (byte) '\n';  						quartets = 0;  					}    					if (inptr >= inend)  						break;    					c1 = *inptr++;  					c2 = *inptr++;  					c3 = *inptr++;  				} while (true);    				remaining = 2 - (int) (inptr - inend);  				saved = 0;  			}
Magic Number,MimeKit.Encodings,Base64Encoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\Base64Encoder.cs,Encode,The following statement contains a magic number: if (length + saved > 2) {  				byte* inend = inptr + length - 2;  				int c1' c2' c3;    				c1 = saved < 1 ? *inptr++ : saved1;  				c2 = saved < 2 ? *inptr++ : saved2;  				c3 = *inptr++;    				do {  					// encode our triplet into a quartet  					*outptr++ = base64_alphabet[c1 >> 2];  					*outptr++ = base64_alphabet[(c2 >> 4) | ((c1 & 0x3) << 4)];  					*outptr++ = base64_alphabet[((c2 & 0x0f) << 2) | (c3 >> 6)];  					*outptr++ = base64_alphabet[c3 & 0x3f];    					// encode 18 quartets per line  					if (!rfc2047 && (++quartets) >= QuartetsPerLine) {  						*outptr++ = (byte) '\n';  						quartets = 0;  					}    					if (inptr >= inend)  						break;    					c1 = *inptr++;  					c2 = *inptr++;  					c3 = *inptr++;  				} while (true);    				remaining = 2 - (int) (inptr - inend);  				saved = 0;  			}
Magic Number,MimeKit.Encodings,Base64Encoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\Base64Encoder.cs,Encode,The following statement contains a magic number: if (length + saved > 2) {  				byte* inend = inptr + length - 2;  				int c1' c2' c3;    				c1 = saved < 1 ? *inptr++ : saved1;  				c2 = saved < 2 ? *inptr++ : saved2;  				c3 = *inptr++;    				do {  					// encode our triplet into a quartet  					*outptr++ = base64_alphabet[c1 >> 2];  					*outptr++ = base64_alphabet[(c2 >> 4) | ((c1 & 0x3) << 4)];  					*outptr++ = base64_alphabet[((c2 & 0x0f) << 2) | (c3 >> 6)];  					*outptr++ = base64_alphabet[c3 & 0x3f];    					// encode 18 quartets per line  					if (!rfc2047 && (++quartets) >= QuartetsPerLine) {  						*outptr++ = (byte) '\n';  						quartets = 0;  					}    					if (inptr >= inend)  						break;    					c1 = *inptr++;  					c2 = *inptr++;  					c3 = *inptr++;  				} while (true);    				remaining = 2 - (int) (inptr - inend);  				saved = 0;  			}
Magic Number,MimeKit.Encodings,Base64Encoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\Base64Encoder.cs,Encode,The following statement contains a magic number: if (length + saved > 2) {  				byte* inend = inptr + length - 2;  				int c1' c2' c3;    				c1 = saved < 1 ? *inptr++ : saved1;  				c2 = saved < 2 ? *inptr++ : saved2;  				c3 = *inptr++;    				do {  					// encode our triplet into a quartet  					*outptr++ = base64_alphabet[c1 >> 2];  					*outptr++ = base64_alphabet[(c2 >> 4) | ((c1 & 0x3) << 4)];  					*outptr++ = base64_alphabet[((c2 & 0x0f) << 2) | (c3 >> 6)];  					*outptr++ = base64_alphabet[c3 & 0x3f];    					// encode 18 quartets per line  					if (!rfc2047 && (++quartets) >= QuartetsPerLine) {  						*outptr++ = (byte) '\n';  						quartets = 0;  					}    					if (inptr >= inend)  						break;    					c1 = *inptr++;  					c2 = *inptr++;  					c3 = *inptr++;  				} while (true);    				remaining = 2 - (int) (inptr - inend);  				saved = 0;  			}
Magic Number,MimeKit.Encodings,Base64Encoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\Base64Encoder.cs,Encode,The following statement contains a magic number: if (length + saved > 2) {  				byte* inend = inptr + length - 2;  				int c1' c2' c3;    				c1 = saved < 1 ? *inptr++ : saved1;  				c2 = saved < 2 ? *inptr++ : saved2;  				c3 = *inptr++;    				do {  					// encode our triplet into a quartet  					*outptr++ = base64_alphabet[c1 >> 2];  					*outptr++ = base64_alphabet[(c2 >> 4) | ((c1 & 0x3) << 4)];  					*outptr++ = base64_alphabet[((c2 & 0x0f) << 2) | (c3 >> 6)];  					*outptr++ = base64_alphabet[c3 & 0x3f];    					// encode 18 quartets per line  					if (!rfc2047 && (++quartets) >= QuartetsPerLine) {  						*outptr++ = (byte) '\n';  						quartets = 0;  					}    					if (inptr >= inend)  						break;    					c1 = *inptr++;  					c2 = *inptr++;  					c3 = *inptr++;  				} while (true);    				remaining = 2 - (int) (inptr - inend);  				saved = 0;  			}
Magic Number,MimeKit.Encodings,Base64Encoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\Base64Encoder.cs,Encode,The following statement contains a magic number: if (length + saved > 2) {  				byte* inend = inptr + length - 2;  				int c1' c2' c3;    				c1 = saved < 1 ? *inptr++ : saved1;  				c2 = saved < 2 ? *inptr++ : saved2;  				c3 = *inptr++;    				do {  					// encode our triplet into a quartet  					*outptr++ = base64_alphabet[c1 >> 2];  					*outptr++ = base64_alphabet[(c2 >> 4) | ((c1 & 0x3) << 4)];  					*outptr++ = base64_alphabet[((c2 & 0x0f) << 2) | (c3 >> 6)];  					*outptr++ = base64_alphabet[c3 & 0x3f];    					// encode 18 quartets per line  					if (!rfc2047 && (++quartets) >= QuartetsPerLine) {  						*outptr++ = (byte) '\n';  						quartets = 0;  					}    					if (inptr >= inend)  						break;    					c1 = *inptr++;  					c2 = *inptr++;  					c3 = *inptr++;  				} while (true);    				remaining = 2 - (int) (inptr - inend);  				saved = 0;  			}
Magic Number,MimeKit.Encodings,Base64Encoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\Base64Encoder.cs,Encode,The following statement contains a magic number: if (length + saved > 2) {  				byte* inend = inptr + length - 2;  				int c1' c2' c3;    				c1 = saved < 1 ? *inptr++ : saved1;  				c2 = saved < 2 ? *inptr++ : saved2;  				c3 = *inptr++;    				do {  					// encode our triplet into a quartet  					*outptr++ = base64_alphabet[c1 >> 2];  					*outptr++ = base64_alphabet[(c2 >> 4) | ((c1 & 0x3) << 4)];  					*outptr++ = base64_alphabet[((c2 & 0x0f) << 2) | (c3 >> 6)];  					*outptr++ = base64_alphabet[c3 & 0x3f];    					// encode 18 quartets per line  					if (!rfc2047 && (++quartets) >= QuartetsPerLine) {  						*outptr++ = (byte) '\n';  						quartets = 0;  					}    					if (inptr >= inend)  						break;    					c1 = *inptr++;  					c2 = *inptr++;  					c3 = *inptr++;  				} while (true);    				remaining = 2 - (int) (inptr - inend);  				saved = 0;  			}
Magic Number,MimeKit.Encodings,Base64Encoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\Base64Encoder.cs,Encode,The following statement contains a magic number: if (remaining > 0) {  				// At this point' saved can only be 0 or 1.  				if (saved == 0) {  					// We can have up to 2 remaining input bytes.  					saved = (byte) remaining;  					saved1 = *inptr++;  					if (remaining == 2)  						saved2 = *inptr;  					else  						saved2 = 0;  				} else {  					// We have 1 remaining input byte.  					saved2 = *inptr++;  					saved = 2;  				}  				  			}
Magic Number,MimeKit.Encodings,Base64Encoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\Base64Encoder.cs,Encode,The following statement contains a magic number: if (remaining > 0) {  				// At this point' saved can only be 0 or 1.  				if (saved == 0) {  					// We can have up to 2 remaining input bytes.  					saved = (byte) remaining;  					saved1 = *inptr++;  					if (remaining == 2)  						saved2 = *inptr;  					else  						saved2 = 0;  				} else {  					// We have 1 remaining input byte.  					saved2 = *inptr++;  					saved = 2;  				}  				  			}
Magic Number,MimeKit.Encodings,Base64Encoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\Base64Encoder.cs,Flush,The following statement contains a magic number: if (saved >= 1) {  				int c1 = saved1;  				int c2 = saved2;    				*outptr++ = base64_alphabet[c1 >> 2];  				*outptr++ = base64_alphabet[c2 >> 4 | ((c1 & 0x3) << 4)];  				if (saved == 2)  					*outptr++ = base64_alphabet[(c2 & 0x0f) << 2];  				else  					*outptr++ = (byte) '=';  				*outptr++ = (byte) '=';  			}
Magic Number,MimeKit.Encodings,Base64Encoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\Base64Encoder.cs,Flush,The following statement contains a magic number: if (saved >= 1) {  				int c1 = saved1;  				int c2 = saved2;    				*outptr++ = base64_alphabet[c1 >> 2];  				*outptr++ = base64_alphabet[c2 >> 4 | ((c1 & 0x3) << 4)];  				if (saved == 2)  					*outptr++ = base64_alphabet[(c2 & 0x0f) << 2];  				else  					*outptr++ = (byte) '=';  				*outptr++ = (byte) '=';  			}
Magic Number,MimeKit.Encodings,Base64Encoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\Base64Encoder.cs,Flush,The following statement contains a magic number: if (saved >= 1) {  				int c1 = saved1;  				int c2 = saved2;    				*outptr++ = base64_alphabet[c1 >> 2];  				*outptr++ = base64_alphabet[c2 >> 4 | ((c1 & 0x3) << 4)];  				if (saved == 2)  					*outptr++ = base64_alphabet[(c2 & 0x0f) << 2];  				else  					*outptr++ = (byte) '=';  				*outptr++ = (byte) '=';  			}
Magic Number,MimeKit.Encodings,Base64Encoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\Base64Encoder.cs,Flush,The following statement contains a magic number: if (saved >= 1) {  				int c1 = saved1;  				int c2 = saved2;    				*outptr++ = base64_alphabet[c1 >> 2];  				*outptr++ = base64_alphabet[c2 >> 4 | ((c1 & 0x3) << 4)];  				if (saved == 2)  					*outptr++ = base64_alphabet[(c2 & 0x0f) << 2];  				else  					*outptr++ = (byte) '=';  				*outptr++ = (byte) '=';  			}
Magic Number,MimeKit.Encodings,Base64Encoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\Base64Encoder.cs,Flush,The following statement contains a magic number: if (saved >= 1) {  				int c1 = saved1;  				int c2 = saved2;    				*outptr++ = base64_alphabet[c1 >> 2];  				*outptr++ = base64_alphabet[c2 >> 4 | ((c1 & 0x3) << 4)];  				if (saved == 2)  					*outptr++ = base64_alphabet[(c2 & 0x0f) << 2];  				else  					*outptr++ = (byte) '=';  				*outptr++ = (byte) '=';  			}
Magic Number,MimeKit.Encodings,HexDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\HexDecoder.cs,EstimateOutputLength,The following statement contains a magic number: return inputLength + 3;
Magic Number,MimeKit.Encodings,HexDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\HexDecoder.cs,Decode,The following statement contains a magic number: while (inptr < inend) {  				switch (state) {  				case HexDecoderState.PassThrough:  					while (inptr < inend) {  						c = *inptr++;    						if (c == '%') {  							state = HexDecoderState.Percent;  							break;  						}    						*outptr++ = c;  					}  					break;  				case HexDecoderState.Percent:  					c = *inptr++;  					state = HexDecoderState.DecodeByte;  					saved = c;  					break;  				case HexDecoderState.DecodeByte:  					c = *inptr++;  					if (c.IsXDigit () && saved.IsXDigit ()) {  						saved = saved.ToXDigit ();  						c = c.ToXDigit ();    						*outptr++ = (byte) ((saved << 4) | c);  					} else {  						// invalid encoded sequence - pass it through undecoded  						*outptr++ = (byte) '%';  						*outptr++ = saved;  						*outptr++ = c;  					}    					state = HexDecoderState.PassThrough;  					break;  				}  			}
Magic Number,MimeKit.Encodings,HexEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\HexEncoder.cs,EstimateOutputLength,The following statement contains a magic number: return inputLength * 3;
Magic Number,MimeKit.Encodings,HexEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\HexEncoder.cs,Encode,The following statement contains a magic number: while (inptr < inend) {  				byte c = *inptr++;    				if (c.IsAttr ()) {  					*outptr++ = c;  				} else {  					*outptr++ = (byte) '%';  					*outptr++ = hex_alphabet[(c >> 4) & 0x0f];  					*outptr++ = hex_alphabet[c & 0x0f];  				}  			}
Magic Number,MimeKit.Encodings,QEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\QEncoder.cs,EstimateOutputLength,The following statement contains a magic number: return inputLength * 3;
Magic Number,MimeKit.Encodings,QEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\QEncoder.cs,Encode,The following statement contains a magic number: while (inptr < inend) {  				byte c = *inptr++;    				if (c == ' ') {  					*outptr++ = (byte) '_';  				} else if (c != '_' && c.IsType (mask)) {  					*outptr++ = c;  				} else {  					*outptr++ = (byte) '=';  					*outptr++ = hex_alphabet[(c >> 4) & 0x0f];  					*outptr++ = hex_alphabet[c & 0x0f];  				}  			}
Magic Number,MimeKit.Encodings,QuotedPrintableDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\QuotedPrintableDecoder.cs,EstimateOutputLength,The following statement contains a magic number: return inputLength + 3;
Magic Number,MimeKit.Encodings,QuotedPrintableDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\QuotedPrintableDecoder.cs,Decode,The following statement contains a magic number: while (inptr < inend) {  				switch (state) {  				case QpDecoderState.PassThrough:  					while (inptr < inend) {  						c = *inptr++;    						if (c == '=') {  							state = QpDecoderState.EqualSign;  							break;  						} else if (rfc2047 && c == '_') {  							*outptr++ = (byte) ' ';  						} else {  							*outptr++ = c;  						}  					}  					break;  				case QpDecoderState.EqualSign:  					c = *inptr++;  					if (c == '\n') {  						// this is a soft break ("=\n")  						state = QpDecoderState.PassThrough;  					} else {  						state = QpDecoderState.DecodeByte;  						saved = c;  					}  					break;  				case QpDecoderState.DecodeByte:  					c = *inptr++;  					if (c.IsXDigit () && saved.IsXDigit ()) {  						saved = saved.ToXDigit ();  						c = c.ToXDigit ();    						*outptr++ = (byte) ((saved << 4) | c);  					} else if (saved == '\r' && c == '\n') {  						// end-of-line  					} else {  						// invalid encoded sequence - pass it through undecoded  						*outptr++ = (byte) '=';  						*outptr++ = saved;  						*outptr++ = c;  					}    					state = QpDecoderState.PassThrough;  					break;  				}  			}
Magic Number,MimeKit.Encodings,QuotedPrintableEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\QuotedPrintableEncoder.cs,Encode,The following statement contains a magic number: while (inptr < inend) {  				byte c = *inptr++;    				if (c == (byte) '\r') {  					if (saved != -1) {  						*outptr++ = (byte) '=';  						*outptr++ = hex_alphabet[(saved >> 4) & 0x0f];  						*outptr++ = hex_alphabet[saved & 0x0f];  						currentLineLength += 3;  					}    					saved = c;  				} else if (c == (byte) '\n') {  					if (saved != -1 && saved != '\r') {  						*outptr++ = (byte) '=';  						*outptr++ = hex_alphabet[(saved >> 4) & 0x0f];  						*outptr++ = hex_alphabet[saved & 0x0f];  					}    					*outptr++ = (byte) '\n';  					currentLineLength = 0;  					saved = -1;  				} else {  					if (saved != -1) {  						byte b = (byte) saved;    						if (b.IsQpSafe ()) {  							*outptr++ = b;  							currentLineLength++;  						} else {  							*outptr++ = (byte) '=';  							*outptr++ = hex_alphabet[(saved >> 4) & 0x0f];  							*outptr++ = hex_alphabet[saved & 0x0f];  						}  					}    					if (currentLineLength > DesiredLineLength) {  						*outptr++ = (byte) '=';  						*outptr++ = (byte) '\n';  						currentLineLength = 0;  					}    					if (c.IsQpSafe ()) {  						// delay output of whitespace character  						if (c.IsBlank ()) {  							saved = c;  						} else {  							*outptr++ = c;  							currentLineLength++;  							saved = -1;  						}  					} else {  						*outptr++ = (byte) '=';  						*outptr++ = hex_alphabet[(c >> 4) & 0x0f];  						*outptr++ = hex_alphabet[c & 0x0f];  						currentLineLength += 3;  						saved = -1;  					}  				}  			}
Magic Number,MimeKit.Encodings,QuotedPrintableEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\QuotedPrintableEncoder.cs,Encode,The following statement contains a magic number: while (inptr < inend) {  				byte c = *inptr++;    				if (c == (byte) '\r') {  					if (saved != -1) {  						*outptr++ = (byte) '=';  						*outptr++ = hex_alphabet[(saved >> 4) & 0x0f];  						*outptr++ = hex_alphabet[saved & 0x0f];  						currentLineLength += 3;  					}    					saved = c;  				} else if (c == (byte) '\n') {  					if (saved != -1 && saved != '\r') {  						*outptr++ = (byte) '=';  						*outptr++ = hex_alphabet[(saved >> 4) & 0x0f];  						*outptr++ = hex_alphabet[saved & 0x0f];  					}    					*outptr++ = (byte) '\n';  					currentLineLength = 0;  					saved = -1;  				} else {  					if (saved != -1) {  						byte b = (byte) saved;    						if (b.IsQpSafe ()) {  							*outptr++ = b;  							currentLineLength++;  						} else {  							*outptr++ = (byte) '=';  							*outptr++ = hex_alphabet[(saved >> 4) & 0x0f];  							*outptr++ = hex_alphabet[saved & 0x0f];  						}  					}    					if (currentLineLength > DesiredLineLength) {  						*outptr++ = (byte) '=';  						*outptr++ = (byte) '\n';  						currentLineLength = 0;  					}    					if (c.IsQpSafe ()) {  						// delay output of whitespace character  						if (c.IsBlank ()) {  							saved = c;  						} else {  							*outptr++ = c;  							currentLineLength++;  							saved = -1;  						}  					} else {  						*outptr++ = (byte) '=';  						*outptr++ = hex_alphabet[(c >> 4) & 0x0f];  						*outptr++ = hex_alphabet[c & 0x0f];  						currentLineLength += 3;  						saved = -1;  					}  				}  			}
Magic Number,MimeKit.Encodings,QuotedPrintableEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\QuotedPrintableEncoder.cs,Encode,The following statement contains a magic number: while (inptr < inend) {  				byte c = *inptr++;    				if (c == (byte) '\r') {  					if (saved != -1) {  						*outptr++ = (byte) '=';  						*outptr++ = hex_alphabet[(saved >> 4) & 0x0f];  						*outptr++ = hex_alphabet[saved & 0x0f];  						currentLineLength += 3;  					}    					saved = c;  				} else if (c == (byte) '\n') {  					if (saved != -1 && saved != '\r') {  						*outptr++ = (byte) '=';  						*outptr++ = hex_alphabet[(saved >> 4) & 0x0f];  						*outptr++ = hex_alphabet[saved & 0x0f];  					}    					*outptr++ = (byte) '\n';  					currentLineLength = 0;  					saved = -1;  				} else {  					if (saved != -1) {  						byte b = (byte) saved;    						if (b.IsQpSafe ()) {  							*outptr++ = b;  							currentLineLength++;  						} else {  							*outptr++ = (byte) '=';  							*outptr++ = hex_alphabet[(saved >> 4) & 0x0f];  							*outptr++ = hex_alphabet[saved & 0x0f];  						}  					}    					if (currentLineLength > DesiredLineLength) {  						*outptr++ = (byte) '=';  						*outptr++ = (byte) '\n';  						currentLineLength = 0;  					}    					if (c.IsQpSafe ()) {  						// delay output of whitespace character  						if (c.IsBlank ()) {  							saved = c;  						} else {  							*outptr++ = c;  							currentLineLength++;  							saved = -1;  						}  					} else {  						*outptr++ = (byte) '=';  						*outptr++ = hex_alphabet[(c >> 4) & 0x0f];  						*outptr++ = hex_alphabet[c & 0x0f];  						currentLineLength += 3;  						saved = -1;  					}  				}  			}
Magic Number,MimeKit.Encodings,QuotedPrintableEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\QuotedPrintableEncoder.cs,Encode,The following statement contains a magic number: while (inptr < inend) {  				byte c = *inptr++;    				if (c == (byte) '\r') {  					if (saved != -1) {  						*outptr++ = (byte) '=';  						*outptr++ = hex_alphabet[(saved >> 4) & 0x0f];  						*outptr++ = hex_alphabet[saved & 0x0f];  						currentLineLength += 3;  					}    					saved = c;  				} else if (c == (byte) '\n') {  					if (saved != -1 && saved != '\r') {  						*outptr++ = (byte) '=';  						*outptr++ = hex_alphabet[(saved >> 4) & 0x0f];  						*outptr++ = hex_alphabet[saved & 0x0f];  					}    					*outptr++ = (byte) '\n';  					currentLineLength = 0;  					saved = -1;  				} else {  					if (saved != -1) {  						byte b = (byte) saved;    						if (b.IsQpSafe ()) {  							*outptr++ = b;  							currentLineLength++;  						} else {  							*outptr++ = (byte) '=';  							*outptr++ = hex_alphabet[(saved >> 4) & 0x0f];  							*outptr++ = hex_alphabet[saved & 0x0f];  						}  					}    					if (currentLineLength > DesiredLineLength) {  						*outptr++ = (byte) '=';  						*outptr++ = (byte) '\n';  						currentLineLength = 0;  					}    					if (c.IsQpSafe ()) {  						// delay output of whitespace character  						if (c.IsBlank ()) {  							saved = c;  						} else {  							*outptr++ = c;  							currentLineLength++;  							saved = -1;  						}  					} else {  						*outptr++ = (byte) '=';  						*outptr++ = hex_alphabet[(c >> 4) & 0x0f];  						*outptr++ = hex_alphabet[c & 0x0f];  						currentLineLength += 3;  						saved = -1;  					}  				}  			}
Magic Number,MimeKit.Encodings,QuotedPrintableEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\QuotedPrintableEncoder.cs,Encode,The following statement contains a magic number: while (inptr < inend) {  				byte c = *inptr++;    				if (c == (byte) '\r') {  					if (saved != -1) {  						*outptr++ = (byte) '=';  						*outptr++ = hex_alphabet[(saved >> 4) & 0x0f];  						*outptr++ = hex_alphabet[saved & 0x0f];  						currentLineLength += 3;  					}    					saved = c;  				} else if (c == (byte) '\n') {  					if (saved != -1 && saved != '\r') {  						*outptr++ = (byte) '=';  						*outptr++ = hex_alphabet[(saved >> 4) & 0x0f];  						*outptr++ = hex_alphabet[saved & 0x0f];  					}    					*outptr++ = (byte) '\n';  					currentLineLength = 0;  					saved = -1;  				} else {  					if (saved != -1) {  						byte b = (byte) saved;    						if (b.IsQpSafe ()) {  							*outptr++ = b;  							currentLineLength++;  						} else {  							*outptr++ = (byte) '=';  							*outptr++ = hex_alphabet[(saved >> 4) & 0x0f];  							*outptr++ = hex_alphabet[saved & 0x0f];  						}  					}    					if (currentLineLength > DesiredLineLength) {  						*outptr++ = (byte) '=';  						*outptr++ = (byte) '\n';  						currentLineLength = 0;  					}    					if (c.IsQpSafe ()) {  						// delay output of whitespace character  						if (c.IsBlank ()) {  							saved = c;  						} else {  							*outptr++ = c;  							currentLineLength++;  							saved = -1;  						}  					} else {  						*outptr++ = (byte) '=';  						*outptr++ = hex_alphabet[(c >> 4) & 0x0f];  						*outptr++ = hex_alphabet[c & 0x0f];  						currentLineLength += 3;  						saved = -1;  					}  				}  			}
Magic Number,MimeKit.Encodings,QuotedPrintableEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\QuotedPrintableEncoder.cs,Encode,The following statement contains a magic number: while (inptr < inend) {  				byte c = *inptr++;    				if (c == (byte) '\r') {  					if (saved != -1) {  						*outptr++ = (byte) '=';  						*outptr++ = hex_alphabet[(saved >> 4) & 0x0f];  						*outptr++ = hex_alphabet[saved & 0x0f];  						currentLineLength += 3;  					}    					saved = c;  				} else if (c == (byte) '\n') {  					if (saved != -1 && saved != '\r') {  						*outptr++ = (byte) '=';  						*outptr++ = hex_alphabet[(saved >> 4) & 0x0f];  						*outptr++ = hex_alphabet[saved & 0x0f];  					}    					*outptr++ = (byte) '\n';  					currentLineLength = 0;  					saved = -1;  				} else {  					if (saved != -1) {  						byte b = (byte) saved;    						if (b.IsQpSafe ()) {  							*outptr++ = b;  							currentLineLength++;  						} else {  							*outptr++ = (byte) '=';  							*outptr++ = hex_alphabet[(saved >> 4) & 0x0f];  							*outptr++ = hex_alphabet[saved & 0x0f];  						}  					}    					if (currentLineLength > DesiredLineLength) {  						*outptr++ = (byte) '=';  						*outptr++ = (byte) '\n';  						currentLineLength = 0;  					}    					if (c.IsQpSafe ()) {  						// delay output of whitespace character  						if (c.IsBlank ()) {  							saved = c;  						} else {  							*outptr++ = c;  							currentLineLength++;  							saved = -1;  						}  					} else {  						*outptr++ = (byte) '=';  						*outptr++ = hex_alphabet[(c >> 4) & 0x0f];  						*outptr++ = hex_alphabet[c & 0x0f];  						currentLineLength += 3;  						saved = -1;  					}  				}  			}
Magic Number,MimeKit.Encodings,QuotedPrintableEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\QuotedPrintableEncoder.cs,Flush,The following statement contains a magic number: if (saved != -1) {  				// spaces and tabs must be encoded if they the last character on the line  				byte c = (byte) saved;    				if (c.IsBlank () || !c.IsQpSafe ()) {  					*outptr++ = (byte) '=';  					*outptr++ = hex_alphabet[(saved >> 4) & 0xf];  					*outptr++ = hex_alphabet[saved & 0xf];  				} else {  					*outptr++ = c;  				}  			}
Magic Number,MimeKit.Encodings,UUDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUDecoder.cs,EstimateOutputLength,The following statement contains a magic number: return inputLength + 3;
Magic Number,MimeKit.Encodings,UUDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUDecoder.cs,Decode,The following statement contains a magic number: while (inptr < inend) {  				if (*inptr == (byte) '\r') {  					inptr++;  					continue;  				}    				if (*inptr == (byte) '\n') {  					last_was_eoln = true;  					inptr++;  					continue;  				}    				if (uulen == 0 || last_was_eoln) {  					// first octet on a line is the uulen octet  					uulen = uudecode_rank[*inptr];  					last_was_eoln = false;  					if (uulen == 0) {  						state = UUDecoderState.Ended;  						break;  					}    					inptr++;  					continue;  				}    				c = *inptr++;    				if (uulen > 0) {  					// save the byte  					saved = (saved << 8) | c;  					nsaved++;    					if (nsaved == 4) {  						byte b0 = (byte) ((saved >> 24) & 0xFF);  						byte b1 = (byte) ((saved >> 16) & 0xFF);  						byte b2 = (byte) ((saved >> 8) & 0xFF);  						byte b3 = (byte) (saved & 0xFF);    						if (uulen >= 3) {  							*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  							*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  							*outptr++ = (byte) (uudecode_rank[b2] << 6 | uudecode_rank[b3]);  							uulen -= 3;  						} else {  							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  								uulen--;  							}    							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  								uulen--;  							}  						}    						nsaved = 0;  						saved = 0;  					}  				} else {  					break;  				}  			}
Magic Number,MimeKit.Encodings,UUDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUDecoder.cs,Decode,The following statement contains a magic number: while (inptr < inend) {  				if (*inptr == (byte) '\r') {  					inptr++;  					continue;  				}    				if (*inptr == (byte) '\n') {  					last_was_eoln = true;  					inptr++;  					continue;  				}    				if (uulen == 0 || last_was_eoln) {  					// first octet on a line is the uulen octet  					uulen = uudecode_rank[*inptr];  					last_was_eoln = false;  					if (uulen == 0) {  						state = UUDecoderState.Ended;  						break;  					}    					inptr++;  					continue;  				}    				c = *inptr++;    				if (uulen > 0) {  					// save the byte  					saved = (saved << 8) | c;  					nsaved++;    					if (nsaved == 4) {  						byte b0 = (byte) ((saved >> 24) & 0xFF);  						byte b1 = (byte) ((saved >> 16) & 0xFF);  						byte b2 = (byte) ((saved >> 8) & 0xFF);  						byte b3 = (byte) (saved & 0xFF);    						if (uulen >= 3) {  							*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  							*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  							*outptr++ = (byte) (uudecode_rank[b2] << 6 | uudecode_rank[b3]);  							uulen -= 3;  						} else {  							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  								uulen--;  							}    							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  								uulen--;  							}  						}    						nsaved = 0;  						saved = 0;  					}  				} else {  					break;  				}  			}
Magic Number,MimeKit.Encodings,UUDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUDecoder.cs,Decode,The following statement contains a magic number: while (inptr < inend) {  				if (*inptr == (byte) '\r') {  					inptr++;  					continue;  				}    				if (*inptr == (byte) '\n') {  					last_was_eoln = true;  					inptr++;  					continue;  				}    				if (uulen == 0 || last_was_eoln) {  					// first octet on a line is the uulen octet  					uulen = uudecode_rank[*inptr];  					last_was_eoln = false;  					if (uulen == 0) {  						state = UUDecoderState.Ended;  						break;  					}    					inptr++;  					continue;  				}    				c = *inptr++;    				if (uulen > 0) {  					// save the byte  					saved = (saved << 8) | c;  					nsaved++;    					if (nsaved == 4) {  						byte b0 = (byte) ((saved >> 24) & 0xFF);  						byte b1 = (byte) ((saved >> 16) & 0xFF);  						byte b2 = (byte) ((saved >> 8) & 0xFF);  						byte b3 = (byte) (saved & 0xFF);    						if (uulen >= 3) {  							*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  							*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  							*outptr++ = (byte) (uudecode_rank[b2] << 6 | uudecode_rank[b3]);  							uulen -= 3;  						} else {  							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  								uulen--;  							}    							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  								uulen--;  							}  						}    						nsaved = 0;  						saved = 0;  					}  				} else {  					break;  				}  			}
Magic Number,MimeKit.Encodings,UUDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUDecoder.cs,Decode,The following statement contains a magic number: while (inptr < inend) {  				if (*inptr == (byte) '\r') {  					inptr++;  					continue;  				}    				if (*inptr == (byte) '\n') {  					last_was_eoln = true;  					inptr++;  					continue;  				}    				if (uulen == 0 || last_was_eoln) {  					// first octet on a line is the uulen octet  					uulen = uudecode_rank[*inptr];  					last_was_eoln = false;  					if (uulen == 0) {  						state = UUDecoderState.Ended;  						break;  					}    					inptr++;  					continue;  				}    				c = *inptr++;    				if (uulen > 0) {  					// save the byte  					saved = (saved << 8) | c;  					nsaved++;    					if (nsaved == 4) {  						byte b0 = (byte) ((saved >> 24) & 0xFF);  						byte b1 = (byte) ((saved >> 16) & 0xFF);  						byte b2 = (byte) ((saved >> 8) & 0xFF);  						byte b3 = (byte) (saved & 0xFF);    						if (uulen >= 3) {  							*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  							*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  							*outptr++ = (byte) (uudecode_rank[b2] << 6 | uudecode_rank[b3]);  							uulen -= 3;  						} else {  							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  								uulen--;  							}    							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  								uulen--;  							}  						}    						nsaved = 0;  						saved = 0;  					}  				} else {  					break;  				}  			}
Magic Number,MimeKit.Encodings,UUDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUDecoder.cs,Decode,The following statement contains a magic number: while (inptr < inend) {  				if (*inptr == (byte) '\r') {  					inptr++;  					continue;  				}    				if (*inptr == (byte) '\n') {  					last_was_eoln = true;  					inptr++;  					continue;  				}    				if (uulen == 0 || last_was_eoln) {  					// first octet on a line is the uulen octet  					uulen = uudecode_rank[*inptr];  					last_was_eoln = false;  					if (uulen == 0) {  						state = UUDecoderState.Ended;  						break;  					}    					inptr++;  					continue;  				}    				c = *inptr++;    				if (uulen > 0) {  					// save the byte  					saved = (saved << 8) | c;  					nsaved++;    					if (nsaved == 4) {  						byte b0 = (byte) ((saved >> 24) & 0xFF);  						byte b1 = (byte) ((saved >> 16) & 0xFF);  						byte b2 = (byte) ((saved >> 8) & 0xFF);  						byte b3 = (byte) (saved & 0xFF);    						if (uulen >= 3) {  							*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  							*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  							*outptr++ = (byte) (uudecode_rank[b2] << 6 | uudecode_rank[b3]);  							uulen -= 3;  						} else {  							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  								uulen--;  							}    							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  								uulen--;  							}  						}    						nsaved = 0;  						saved = 0;  					}  				} else {  					break;  				}  			}
Magic Number,MimeKit.Encodings,UUDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUDecoder.cs,Decode,The following statement contains a magic number: while (inptr < inend) {  				if (*inptr == (byte) '\r') {  					inptr++;  					continue;  				}    				if (*inptr == (byte) '\n') {  					last_was_eoln = true;  					inptr++;  					continue;  				}    				if (uulen == 0 || last_was_eoln) {  					// first octet on a line is the uulen octet  					uulen = uudecode_rank[*inptr];  					last_was_eoln = false;  					if (uulen == 0) {  						state = UUDecoderState.Ended;  						break;  					}    					inptr++;  					continue;  				}    				c = *inptr++;    				if (uulen > 0) {  					// save the byte  					saved = (saved << 8) | c;  					nsaved++;    					if (nsaved == 4) {  						byte b0 = (byte) ((saved >> 24) & 0xFF);  						byte b1 = (byte) ((saved >> 16) & 0xFF);  						byte b2 = (byte) ((saved >> 8) & 0xFF);  						byte b3 = (byte) (saved & 0xFF);    						if (uulen >= 3) {  							*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  							*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  							*outptr++ = (byte) (uudecode_rank[b2] << 6 | uudecode_rank[b3]);  							uulen -= 3;  						} else {  							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  								uulen--;  							}    							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  								uulen--;  							}  						}    						nsaved = 0;  						saved = 0;  					}  				} else {  					break;  				}  			}
Magic Number,MimeKit.Encodings,UUDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUDecoder.cs,Decode,The following statement contains a magic number: while (inptr < inend) {  				if (*inptr == (byte) '\r') {  					inptr++;  					continue;  				}    				if (*inptr == (byte) '\n') {  					last_was_eoln = true;  					inptr++;  					continue;  				}    				if (uulen == 0 || last_was_eoln) {  					// first octet on a line is the uulen octet  					uulen = uudecode_rank[*inptr];  					last_was_eoln = false;  					if (uulen == 0) {  						state = UUDecoderState.Ended;  						break;  					}    					inptr++;  					continue;  				}    				c = *inptr++;    				if (uulen > 0) {  					// save the byte  					saved = (saved << 8) | c;  					nsaved++;    					if (nsaved == 4) {  						byte b0 = (byte) ((saved >> 24) & 0xFF);  						byte b1 = (byte) ((saved >> 16) & 0xFF);  						byte b2 = (byte) ((saved >> 8) & 0xFF);  						byte b3 = (byte) (saved & 0xFF);    						if (uulen >= 3) {  							*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  							*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  							*outptr++ = (byte) (uudecode_rank[b2] << 6 | uudecode_rank[b3]);  							uulen -= 3;  						} else {  							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  								uulen--;  							}    							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  								uulen--;  							}  						}    						nsaved = 0;  						saved = 0;  					}  				} else {  					break;  				}  			}
Magic Number,MimeKit.Encodings,UUDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUDecoder.cs,Decode,The following statement contains a magic number: while (inptr < inend) {  				if (*inptr == (byte) '\r') {  					inptr++;  					continue;  				}    				if (*inptr == (byte) '\n') {  					last_was_eoln = true;  					inptr++;  					continue;  				}    				if (uulen == 0 || last_was_eoln) {  					// first octet on a line is the uulen octet  					uulen = uudecode_rank[*inptr];  					last_was_eoln = false;  					if (uulen == 0) {  						state = UUDecoderState.Ended;  						break;  					}    					inptr++;  					continue;  				}    				c = *inptr++;    				if (uulen > 0) {  					// save the byte  					saved = (saved << 8) | c;  					nsaved++;    					if (nsaved == 4) {  						byte b0 = (byte) ((saved >> 24) & 0xFF);  						byte b1 = (byte) ((saved >> 16) & 0xFF);  						byte b2 = (byte) ((saved >> 8) & 0xFF);  						byte b3 = (byte) (saved & 0xFF);    						if (uulen >= 3) {  							*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  							*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  							*outptr++ = (byte) (uudecode_rank[b2] << 6 | uudecode_rank[b3]);  							uulen -= 3;  						} else {  							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  								uulen--;  							}    							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  								uulen--;  							}  						}    						nsaved = 0;  						saved = 0;  					}  				} else {  					break;  				}  			}
Magic Number,MimeKit.Encodings,UUDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUDecoder.cs,Decode,The following statement contains a magic number: while (inptr < inend) {  				if (*inptr == (byte) '\r') {  					inptr++;  					continue;  				}    				if (*inptr == (byte) '\n') {  					last_was_eoln = true;  					inptr++;  					continue;  				}    				if (uulen == 0 || last_was_eoln) {  					// first octet on a line is the uulen octet  					uulen = uudecode_rank[*inptr];  					last_was_eoln = false;  					if (uulen == 0) {  						state = UUDecoderState.Ended;  						break;  					}    					inptr++;  					continue;  				}    				c = *inptr++;    				if (uulen > 0) {  					// save the byte  					saved = (saved << 8) | c;  					nsaved++;    					if (nsaved == 4) {  						byte b0 = (byte) ((saved >> 24) & 0xFF);  						byte b1 = (byte) ((saved >> 16) & 0xFF);  						byte b2 = (byte) ((saved >> 8) & 0xFF);  						byte b3 = (byte) (saved & 0xFF);    						if (uulen >= 3) {  							*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  							*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  							*outptr++ = (byte) (uudecode_rank[b2] << 6 | uudecode_rank[b3]);  							uulen -= 3;  						} else {  							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  								uulen--;  							}    							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  								uulen--;  							}  						}    						nsaved = 0;  						saved = 0;  					}  				} else {  					break;  				}  			}
Magic Number,MimeKit.Encodings,UUDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUDecoder.cs,Decode,The following statement contains a magic number: while (inptr < inend) {  				if (*inptr == (byte) '\r') {  					inptr++;  					continue;  				}    				if (*inptr == (byte) '\n') {  					last_was_eoln = true;  					inptr++;  					continue;  				}    				if (uulen == 0 || last_was_eoln) {  					// first octet on a line is the uulen octet  					uulen = uudecode_rank[*inptr];  					last_was_eoln = false;  					if (uulen == 0) {  						state = UUDecoderState.Ended;  						break;  					}    					inptr++;  					continue;  				}    				c = *inptr++;    				if (uulen > 0) {  					// save the byte  					saved = (saved << 8) | c;  					nsaved++;    					if (nsaved == 4) {  						byte b0 = (byte) ((saved >> 24) & 0xFF);  						byte b1 = (byte) ((saved >> 16) & 0xFF);  						byte b2 = (byte) ((saved >> 8) & 0xFF);  						byte b3 = (byte) (saved & 0xFF);    						if (uulen >= 3) {  							*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  							*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  							*outptr++ = (byte) (uudecode_rank[b2] << 6 | uudecode_rank[b3]);  							uulen -= 3;  						} else {  							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  								uulen--;  							}    							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  								uulen--;  							}  						}    						nsaved = 0;  						saved = 0;  					}  				} else {  					break;  				}  			}
Magic Number,MimeKit.Encodings,UUDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUDecoder.cs,Decode,The following statement contains a magic number: while (inptr < inend) {  				if (*inptr == (byte) '\r') {  					inptr++;  					continue;  				}    				if (*inptr == (byte) '\n') {  					last_was_eoln = true;  					inptr++;  					continue;  				}    				if (uulen == 0 || last_was_eoln) {  					// first octet on a line is the uulen octet  					uulen = uudecode_rank[*inptr];  					last_was_eoln = false;  					if (uulen == 0) {  						state = UUDecoderState.Ended;  						break;  					}    					inptr++;  					continue;  				}    				c = *inptr++;    				if (uulen > 0) {  					// save the byte  					saved = (saved << 8) | c;  					nsaved++;    					if (nsaved == 4) {  						byte b0 = (byte) ((saved >> 24) & 0xFF);  						byte b1 = (byte) ((saved >> 16) & 0xFF);  						byte b2 = (byte) ((saved >> 8) & 0xFF);  						byte b3 = (byte) (saved & 0xFF);    						if (uulen >= 3) {  							*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  							*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  							*outptr++ = (byte) (uudecode_rank[b2] << 6 | uudecode_rank[b3]);  							uulen -= 3;  						} else {  							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  								uulen--;  							}    							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  								uulen--;  							}  						}    						nsaved = 0;  						saved = 0;  					}  				} else {  					break;  				}  			}
Magic Number,MimeKit.Encodings,UUDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUDecoder.cs,Decode,The following statement contains a magic number: while (inptr < inend) {  				if (*inptr == (byte) '\r') {  					inptr++;  					continue;  				}    				if (*inptr == (byte) '\n') {  					last_was_eoln = true;  					inptr++;  					continue;  				}    				if (uulen == 0 || last_was_eoln) {  					// first octet on a line is the uulen octet  					uulen = uudecode_rank[*inptr];  					last_was_eoln = false;  					if (uulen == 0) {  						state = UUDecoderState.Ended;  						break;  					}    					inptr++;  					continue;  				}    				c = *inptr++;    				if (uulen > 0) {  					// save the byte  					saved = (saved << 8) | c;  					nsaved++;    					if (nsaved == 4) {  						byte b0 = (byte) ((saved >> 24) & 0xFF);  						byte b1 = (byte) ((saved >> 16) & 0xFF);  						byte b2 = (byte) ((saved >> 8) & 0xFF);  						byte b3 = (byte) (saved & 0xFF);    						if (uulen >= 3) {  							*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  							*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  							*outptr++ = (byte) (uudecode_rank[b2] << 6 | uudecode_rank[b3]);  							uulen -= 3;  						} else {  							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  								uulen--;  							}    							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  								uulen--;  							}  						}    						nsaved = 0;  						saved = 0;  					}  				} else {  					break;  				}  			}
Magic Number,MimeKit.Encodings,UUDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUDecoder.cs,Decode,The following statement contains a magic number: while (inptr < inend) {  				if (*inptr == (byte) '\r') {  					inptr++;  					continue;  				}    				if (*inptr == (byte) '\n') {  					last_was_eoln = true;  					inptr++;  					continue;  				}    				if (uulen == 0 || last_was_eoln) {  					// first octet on a line is the uulen octet  					uulen = uudecode_rank[*inptr];  					last_was_eoln = false;  					if (uulen == 0) {  						state = UUDecoderState.Ended;  						break;  					}    					inptr++;  					continue;  				}    				c = *inptr++;    				if (uulen > 0) {  					// save the byte  					saved = (saved << 8) | c;  					nsaved++;    					if (nsaved == 4) {  						byte b0 = (byte) ((saved >> 24) & 0xFF);  						byte b1 = (byte) ((saved >> 16) & 0xFF);  						byte b2 = (byte) ((saved >> 8) & 0xFF);  						byte b3 = (byte) (saved & 0xFF);    						if (uulen >= 3) {  							*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  							*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  							*outptr++ = (byte) (uudecode_rank[b2] << 6 | uudecode_rank[b3]);  							uulen -= 3;  						} else {  							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  								uulen--;  							}    							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  								uulen--;  							}  						}    						nsaved = 0;  						saved = 0;  					}  				} else {  					break;  				}  			}
Magic Number,MimeKit.Encodings,UUDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUDecoder.cs,Decode,The following statement contains a magic number: while (inptr < inend) {  				if (*inptr == (byte) '\r') {  					inptr++;  					continue;  				}    				if (*inptr == (byte) '\n') {  					last_was_eoln = true;  					inptr++;  					continue;  				}    				if (uulen == 0 || last_was_eoln) {  					// first octet on a line is the uulen octet  					uulen = uudecode_rank[*inptr];  					last_was_eoln = false;  					if (uulen == 0) {  						state = UUDecoderState.Ended;  						break;  					}    					inptr++;  					continue;  				}    				c = *inptr++;    				if (uulen > 0) {  					// save the byte  					saved = (saved << 8) | c;  					nsaved++;    					if (nsaved == 4) {  						byte b0 = (byte) ((saved >> 24) & 0xFF);  						byte b1 = (byte) ((saved >> 16) & 0xFF);  						byte b2 = (byte) ((saved >> 8) & 0xFF);  						byte b3 = (byte) (saved & 0xFF);    						if (uulen >= 3) {  							*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  							*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  							*outptr++ = (byte) (uudecode_rank[b2] << 6 | uudecode_rank[b3]);  							uulen -= 3;  						} else {  							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  								uulen--;  							}    							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  								uulen--;  							}  						}    						nsaved = 0;  						saved = 0;  					}  				} else {  					break;  				}  			}
Magic Number,MimeKit.Encodings,UUDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUDecoder.cs,Decode,The following statement contains a magic number: while (inptr < inend) {  				if (*inptr == (byte) '\r') {  					inptr++;  					continue;  				}    				if (*inptr == (byte) '\n') {  					last_was_eoln = true;  					inptr++;  					continue;  				}    				if (uulen == 0 || last_was_eoln) {  					// first octet on a line is the uulen octet  					uulen = uudecode_rank[*inptr];  					last_was_eoln = false;  					if (uulen == 0) {  						state = UUDecoderState.Ended;  						break;  					}    					inptr++;  					continue;  				}    				c = *inptr++;    				if (uulen > 0) {  					// save the byte  					saved = (saved << 8) | c;  					nsaved++;    					if (nsaved == 4) {  						byte b0 = (byte) ((saved >> 24) & 0xFF);  						byte b1 = (byte) ((saved >> 16) & 0xFF);  						byte b2 = (byte) ((saved >> 8) & 0xFF);  						byte b3 = (byte) (saved & 0xFF);    						if (uulen >= 3) {  							*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  							*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  							*outptr++ = (byte) (uudecode_rank[b2] << 6 | uudecode_rank[b3]);  							uulen -= 3;  						} else {  							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  								uulen--;  							}    							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  								uulen--;  							}  						}    						nsaved = 0;  						saved = 0;  					}  				} else {  					break;  				}  			}
Magic Number,MimeKit.Encodings,UUDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUDecoder.cs,Decode,The following statement contains a magic number: while (inptr < inend) {  				if (*inptr == (byte) '\r') {  					inptr++;  					continue;  				}    				if (*inptr == (byte) '\n') {  					last_was_eoln = true;  					inptr++;  					continue;  				}    				if (uulen == 0 || last_was_eoln) {  					// first octet on a line is the uulen octet  					uulen = uudecode_rank[*inptr];  					last_was_eoln = false;  					if (uulen == 0) {  						state = UUDecoderState.Ended;  						break;  					}    					inptr++;  					continue;  				}    				c = *inptr++;    				if (uulen > 0) {  					// save the byte  					saved = (saved << 8) | c;  					nsaved++;    					if (nsaved == 4) {  						byte b0 = (byte) ((saved >> 24) & 0xFF);  						byte b1 = (byte) ((saved >> 16) & 0xFF);  						byte b2 = (byte) ((saved >> 8) & 0xFF);  						byte b3 = (byte) (saved & 0xFF);    						if (uulen >= 3) {  							*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  							*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  							*outptr++ = (byte) (uudecode_rank[b2] << 6 | uudecode_rank[b3]);  							uulen -= 3;  						} else {  							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b0] << 2 | uudecode_rank[b1] >> 4);  								uulen--;  							}    							if (uulen >= 1) {  								*outptr++ = (byte) (uudecode_rank[b1] << 4 | uudecode_rank[b2] >> 2);  								uulen--;  							}  						}    						nsaved = 0;  						saved = 0;  					}  				} else {  					break;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,EstimateOutputLength,The following statement contains a magic number: return (((inputLength + 2) / MaxInputPerLine) * MaxOutputPerLine) + MaxOutputPerLine + 2;
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,EstimateOutputLength,The following statement contains a magic number: return (((inputLength + 2) / MaxInputPerLine) * MaxOutputPerLine) + MaxOutputPerLine + 2;
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: if ((length + uulen) < 45) {  				// not enough input to write a full uuencoded line  				bufptr = uuptr + ((uulen / 3) * 4);  			} else {  				bufptr = outptr + 1;  				  				if (uulen > 0) {  					// copy the previous call's uubuf to output  					int n = (uulen / 3) * 4;    					Buffer.BlockCopy (uubuf' 0' outbuf' (int) (bufptr - output)' n);  					bufptr += n;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: if ((length + uulen) < 45) {  				// not enough input to write a full uuencoded line  				bufptr = uuptr + ((uulen / 3) * 4);  			} else {  				bufptr = outptr + 1;  				  				if (uulen > 0) {  					// copy the previous call's uubuf to output  					int n = (uulen / 3) * 4;    					Buffer.BlockCopy (uubuf' 0' outbuf' (int) (bufptr - output)' n);  					bufptr += n;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: if ((length + uulen) < 45) {  				// not enough input to write a full uuencoded line  				bufptr = uuptr + ((uulen / 3) * 4);  			} else {  				bufptr = outptr + 1;  				  				if (uulen > 0) {  					// copy the previous call's uubuf to output  					int n = (uulen / 3) * 4;    					Buffer.BlockCopy (uubuf' 0' outbuf' (int) (bufptr - output)' n);  					bufptr += n;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: if ((length + uulen) < 45) {  				// not enough input to write a full uuencoded line  				bufptr = uuptr + ((uulen / 3) * 4);  			} else {  				bufptr = outptr + 1;  				  				if (uulen > 0) {  					// copy the previous call's uubuf to output  					int n = (uulen / 3) * 4;    					Buffer.BlockCopy (uubuf' 0' outbuf' (int) (bufptr - output)' n);  					bufptr += n;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: if ((length + uulen) < 45) {  				// not enough input to write a full uuencoded line  				bufptr = uuptr + ((uulen / 3) * 4);  			} else {  				bufptr = outptr + 1;  				  				if (uulen > 0) {  					// copy the previous call's uubuf to output  					int n = (uulen / 3) * 4;    					Buffer.BlockCopy (uubuf' 0' outbuf' (int) (bufptr - output)' n);  					bufptr += n;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: if (nsaved == 2) {  				b0 = (byte) ((saved >> 8) & 0xFF);  				b1 = (byte) (saved & 0xFF);  				b2 = *inptr++;  				nsaved = 0;  				saved = 0;    				// convert 3 input bytes into 4 uuencoded bytes  				*bufptr++ = Encode ((b0 >> 2) & 0x3F);  				*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  				*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  				*bufptr++ = Encode (b2 & 0x3F);    				uulen += 3;  			} else if (nsaved == 1) {  				if ((inptr + 2) < inend) {  					b0 = (byte) (saved & 0xFF);  					b1 = *inptr++;  					b2 = *inptr++;  					nsaved = 0;  					saved = 0;    					// convert 3 input bytes into 4 uuencoded bytes  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);    					uulen += 3;  				} else {  					while (inptr < inend) {  						saved = (saved << 8) | *inptr++;  						nsaved++;  					}  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: if (nsaved == 2) {  				b0 = (byte) ((saved >> 8) & 0xFF);  				b1 = (byte) (saved & 0xFF);  				b2 = *inptr++;  				nsaved = 0;  				saved = 0;    				// convert 3 input bytes into 4 uuencoded bytes  				*bufptr++ = Encode ((b0 >> 2) & 0x3F);  				*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  				*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  				*bufptr++ = Encode (b2 & 0x3F);    				uulen += 3;  			} else if (nsaved == 1) {  				if ((inptr + 2) < inend) {  					b0 = (byte) (saved & 0xFF);  					b1 = *inptr++;  					b2 = *inptr++;  					nsaved = 0;  					saved = 0;    					// convert 3 input bytes into 4 uuencoded bytes  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);    					uulen += 3;  				} else {  					while (inptr < inend) {  						saved = (saved << 8) | *inptr++;  						nsaved++;  					}  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: if (nsaved == 2) {  				b0 = (byte) ((saved >> 8) & 0xFF);  				b1 = (byte) (saved & 0xFF);  				b2 = *inptr++;  				nsaved = 0;  				saved = 0;    				// convert 3 input bytes into 4 uuencoded bytes  				*bufptr++ = Encode ((b0 >> 2) & 0x3F);  				*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  				*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  				*bufptr++ = Encode (b2 & 0x3F);    				uulen += 3;  			} else if (nsaved == 1) {  				if ((inptr + 2) < inend) {  					b0 = (byte) (saved & 0xFF);  					b1 = *inptr++;  					b2 = *inptr++;  					nsaved = 0;  					saved = 0;    					// convert 3 input bytes into 4 uuencoded bytes  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);    					uulen += 3;  				} else {  					while (inptr < inend) {  						saved = (saved << 8) | *inptr++;  						nsaved++;  					}  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: if (nsaved == 2) {  				b0 = (byte) ((saved >> 8) & 0xFF);  				b1 = (byte) (saved & 0xFF);  				b2 = *inptr++;  				nsaved = 0;  				saved = 0;    				// convert 3 input bytes into 4 uuencoded bytes  				*bufptr++ = Encode ((b0 >> 2) & 0x3F);  				*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  				*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  				*bufptr++ = Encode (b2 & 0x3F);    				uulen += 3;  			} else if (nsaved == 1) {  				if ((inptr + 2) < inend) {  					b0 = (byte) (saved & 0xFF);  					b1 = *inptr++;  					b2 = *inptr++;  					nsaved = 0;  					saved = 0;    					// convert 3 input bytes into 4 uuencoded bytes  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);    					uulen += 3;  				} else {  					while (inptr < inend) {  						saved = (saved << 8) | *inptr++;  						nsaved++;  					}  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: if (nsaved == 2) {  				b0 = (byte) ((saved >> 8) & 0xFF);  				b1 = (byte) (saved & 0xFF);  				b2 = *inptr++;  				nsaved = 0;  				saved = 0;    				// convert 3 input bytes into 4 uuencoded bytes  				*bufptr++ = Encode ((b0 >> 2) & 0x3F);  				*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  				*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  				*bufptr++ = Encode (b2 & 0x3F);    				uulen += 3;  			} else if (nsaved == 1) {  				if ((inptr + 2) < inend) {  					b0 = (byte) (saved & 0xFF);  					b1 = *inptr++;  					b2 = *inptr++;  					nsaved = 0;  					saved = 0;    					// convert 3 input bytes into 4 uuencoded bytes  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);    					uulen += 3;  				} else {  					while (inptr < inend) {  						saved = (saved << 8) | *inptr++;  						nsaved++;  					}  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: if (nsaved == 2) {  				b0 = (byte) ((saved >> 8) & 0xFF);  				b1 = (byte) (saved & 0xFF);  				b2 = *inptr++;  				nsaved = 0;  				saved = 0;    				// convert 3 input bytes into 4 uuencoded bytes  				*bufptr++ = Encode ((b0 >> 2) & 0x3F);  				*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  				*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  				*bufptr++ = Encode (b2 & 0x3F);    				uulen += 3;  			} else if (nsaved == 1) {  				if ((inptr + 2) < inend) {  					b0 = (byte) (saved & 0xFF);  					b1 = *inptr++;  					b2 = *inptr++;  					nsaved = 0;  					saved = 0;    					// convert 3 input bytes into 4 uuencoded bytes  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);    					uulen += 3;  				} else {  					while (inptr < inend) {  						saved = (saved << 8) | *inptr++;  						nsaved++;  					}  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: if (nsaved == 2) {  				b0 = (byte) ((saved >> 8) & 0xFF);  				b1 = (byte) (saved & 0xFF);  				b2 = *inptr++;  				nsaved = 0;  				saved = 0;    				// convert 3 input bytes into 4 uuencoded bytes  				*bufptr++ = Encode ((b0 >> 2) & 0x3F);  				*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  				*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  				*bufptr++ = Encode (b2 & 0x3F);    				uulen += 3;  			} else if (nsaved == 1) {  				if ((inptr + 2) < inend) {  					b0 = (byte) (saved & 0xFF);  					b1 = *inptr++;  					b2 = *inptr++;  					nsaved = 0;  					saved = 0;    					// convert 3 input bytes into 4 uuencoded bytes  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);    					uulen += 3;  				} else {  					while (inptr < inend) {  						saved = (saved << 8) | *inptr++;  						nsaved++;  					}  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: if (nsaved == 2) {  				b0 = (byte) ((saved >> 8) & 0xFF);  				b1 = (byte) (saved & 0xFF);  				b2 = *inptr++;  				nsaved = 0;  				saved = 0;    				// convert 3 input bytes into 4 uuencoded bytes  				*bufptr++ = Encode ((b0 >> 2) & 0x3F);  				*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  				*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  				*bufptr++ = Encode (b2 & 0x3F);    				uulen += 3;  			} else if (nsaved == 1) {  				if ((inptr + 2) < inend) {  					b0 = (byte) (saved & 0xFF);  					b1 = *inptr++;  					b2 = *inptr++;  					nsaved = 0;  					saved = 0;    					// convert 3 input bytes into 4 uuencoded bytes  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);    					uulen += 3;  				} else {  					while (inptr < inend) {  						saved = (saved << 8) | *inptr++;  						nsaved++;  					}  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: if (nsaved == 2) {  				b0 = (byte) ((saved >> 8) & 0xFF);  				b1 = (byte) (saved & 0xFF);  				b2 = *inptr++;  				nsaved = 0;  				saved = 0;    				// convert 3 input bytes into 4 uuencoded bytes  				*bufptr++ = Encode ((b0 >> 2) & 0x3F);  				*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  				*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  				*bufptr++ = Encode (b2 & 0x3F);    				uulen += 3;  			} else if (nsaved == 1) {  				if ((inptr + 2) < inend) {  					b0 = (byte) (saved & 0xFF);  					b1 = *inptr++;  					b2 = *inptr++;  					nsaved = 0;  					saved = 0;    					// convert 3 input bytes into 4 uuencoded bytes  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);    					uulen += 3;  				} else {  					while (inptr < inend) {  						saved = (saved << 8) | *inptr++;  						nsaved++;  					}  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: if (nsaved == 2) {  				b0 = (byte) ((saved >> 8) & 0xFF);  				b1 = (byte) (saved & 0xFF);  				b2 = *inptr++;  				nsaved = 0;  				saved = 0;    				// convert 3 input bytes into 4 uuencoded bytes  				*bufptr++ = Encode ((b0 >> 2) & 0x3F);  				*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  				*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  				*bufptr++ = Encode (b2 & 0x3F);    				uulen += 3;  			} else if (nsaved == 1) {  				if ((inptr + 2) < inend) {  					b0 = (byte) (saved & 0xFF);  					b1 = *inptr++;  					b2 = *inptr++;  					nsaved = 0;  					saved = 0;    					// convert 3 input bytes into 4 uuencoded bytes  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);    					uulen += 3;  				} else {  					while (inptr < inend) {  						saved = (saved << 8) | *inptr++;  						nsaved++;  					}  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: if (nsaved == 2) {  				b0 = (byte) ((saved >> 8) & 0xFF);  				b1 = (byte) (saved & 0xFF);  				b2 = *inptr++;  				nsaved = 0;  				saved = 0;    				// convert 3 input bytes into 4 uuencoded bytes  				*bufptr++ = Encode ((b0 >> 2) & 0x3F);  				*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  				*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  				*bufptr++ = Encode (b2 & 0x3F);    				uulen += 3;  			} else if (nsaved == 1) {  				if ((inptr + 2) < inend) {  					b0 = (byte) (saved & 0xFF);  					b1 = *inptr++;  					b2 = *inptr++;  					nsaved = 0;  					saved = 0;    					// convert 3 input bytes into 4 uuencoded bytes  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);    					uulen += 3;  				} else {  					while (inptr < inend) {  						saved = (saved << 8) | *inptr++;  						nsaved++;  					}  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: if (nsaved == 2) {  				b0 = (byte) ((saved >> 8) & 0xFF);  				b1 = (byte) (saved & 0xFF);  				b2 = *inptr++;  				nsaved = 0;  				saved = 0;    				// convert 3 input bytes into 4 uuencoded bytes  				*bufptr++ = Encode ((b0 >> 2) & 0x3F);  				*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  				*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  				*bufptr++ = Encode (b2 & 0x3F);    				uulen += 3;  			} else if (nsaved == 1) {  				if ((inptr + 2) < inend) {  					b0 = (byte) (saved & 0xFF);  					b1 = *inptr++;  					b2 = *inptr++;  					nsaved = 0;  					saved = 0;    					// convert 3 input bytes into 4 uuencoded bytes  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);    					uulen += 3;  				} else {  					while (inptr < inend) {  						saved = (saved << 8) | *inptr++;  						nsaved++;  					}  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: if (nsaved == 2) {  				b0 = (byte) ((saved >> 8) & 0xFF);  				b1 = (byte) (saved & 0xFF);  				b2 = *inptr++;  				nsaved = 0;  				saved = 0;    				// convert 3 input bytes into 4 uuencoded bytes  				*bufptr++ = Encode ((b0 >> 2) & 0x3F);  				*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  				*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  				*bufptr++ = Encode (b2 & 0x3F);    				uulen += 3;  			} else if (nsaved == 1) {  				if ((inptr + 2) < inend) {  					b0 = (byte) (saved & 0xFF);  					b1 = *inptr++;  					b2 = *inptr++;  					nsaved = 0;  					saved = 0;    					// convert 3 input bytes into 4 uuencoded bytes  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);    					uulen += 3;  				} else {  					while (inptr < inend) {  						saved = (saved << 8) | *inptr++;  						nsaved++;  					}  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: if (nsaved == 2) {  				b0 = (byte) ((saved >> 8) & 0xFF);  				b1 = (byte) (saved & 0xFF);  				b2 = *inptr++;  				nsaved = 0;  				saved = 0;    				// convert 3 input bytes into 4 uuencoded bytes  				*bufptr++ = Encode ((b0 >> 2) & 0x3F);  				*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  				*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  				*bufptr++ = Encode (b2 & 0x3F);    				uulen += 3;  			} else if (nsaved == 1) {  				if ((inptr + 2) < inend) {  					b0 = (byte) (saved & 0xFF);  					b1 = *inptr++;  					b2 = *inptr++;  					nsaved = 0;  					saved = 0;    					// convert 3 input bytes into 4 uuencoded bytes  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);    					uulen += 3;  				} else {  					while (inptr < inend) {  						saved = (saved << 8) | *inptr++;  						nsaved++;  					}  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: if (nsaved == 2) {  				b0 = (byte) ((saved >> 8) & 0xFF);  				b1 = (byte) (saved & 0xFF);  				b2 = *inptr++;  				nsaved = 0;  				saved = 0;    				// convert 3 input bytes into 4 uuencoded bytes  				*bufptr++ = Encode ((b0 >> 2) & 0x3F);  				*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  				*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  				*bufptr++ = Encode (b2 & 0x3F);    				uulen += 3;  			} else if (nsaved == 1) {  				if ((inptr + 2) < inend) {  					b0 = (byte) (saved & 0xFF);  					b1 = *inptr++;  					b2 = *inptr++;  					nsaved = 0;  					saved = 0;    					// convert 3 input bytes into 4 uuencoded bytes  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);    					uulen += 3;  				} else {  					while (inptr < inend) {  						saved = (saved << 8) | *inptr++;  						nsaved++;  					}  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: if (nsaved == 2) {  				b0 = (byte) ((saved >> 8) & 0xFF);  				b1 = (byte) (saved & 0xFF);  				b2 = *inptr++;  				nsaved = 0;  				saved = 0;    				// convert 3 input bytes into 4 uuencoded bytes  				*bufptr++ = Encode ((b0 >> 2) & 0x3F);  				*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  				*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  				*bufptr++ = Encode (b2 & 0x3F);    				uulen += 3;  			} else if (nsaved == 1) {  				if ((inptr + 2) < inend) {  					b0 = (byte) (saved & 0xFF);  					b1 = *inptr++;  					b2 = *inptr++;  					nsaved = 0;  					saved = 0;    					// convert 3 input bytes into 4 uuencoded bytes  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);    					uulen += 3;  				} else {  					while (inptr < inend) {  						saved = (saved << 8) | *inptr++;  						nsaved++;  					}  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: while (inptr < inend) {  				while (uulen < 45 && (inptr + 3) <= inend) {  					b0 = *inptr++;  					b1 = *inptr++;  					b2 = *inptr++;    					// convert 3 input bytes into 4 uuencoded bytes  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);    					uulen += 3;  				}    				if (uulen >= 45) {  					// output the uu line length  					*outptr = Encode (uulen);  					outptr += ((uulen / 3) * 4) + 1;  					*outptr++ = (byte) '\n';  					uulen = 0;    					if ((inptr + 45) <= inend) {  						// we have enough input to output another full line  						bufptr = outptr + 1;  					} else {  						bufptr = uuptr;  					}  				} else {  					// not enough input to continue...  					for (nsaved = 0' saved = 0; inptr < inend; nsaved++)  						saved = (saved << 8) | *inptr++;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: while (inptr < inend) {  				while (uulen < 45 && (inptr + 3) <= inend) {  					b0 = *inptr++;  					b1 = *inptr++;  					b2 = *inptr++;    					// convert 3 input bytes into 4 uuencoded bytes  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);    					uulen += 3;  				}    				if (uulen >= 45) {  					// output the uu line length  					*outptr = Encode (uulen);  					outptr += ((uulen / 3) * 4) + 1;  					*outptr++ = (byte) '\n';  					uulen = 0;    					if ((inptr + 45) <= inend) {  						// we have enough input to output another full line  						bufptr = outptr + 1;  					} else {  						bufptr = uuptr;  					}  				} else {  					// not enough input to continue...  					for (nsaved = 0' saved = 0; inptr < inend; nsaved++)  						saved = (saved << 8) | *inptr++;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: while (inptr < inend) {  				while (uulen < 45 && (inptr + 3) <= inend) {  					b0 = *inptr++;  					b1 = *inptr++;  					b2 = *inptr++;    					// convert 3 input bytes into 4 uuencoded bytes  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);    					uulen += 3;  				}    				if (uulen >= 45) {  					// output the uu line length  					*outptr = Encode (uulen);  					outptr += ((uulen / 3) * 4) + 1;  					*outptr++ = (byte) '\n';  					uulen = 0;    					if ((inptr + 45) <= inend) {  						// we have enough input to output another full line  						bufptr = outptr + 1;  					} else {  						bufptr = uuptr;  					}  				} else {  					// not enough input to continue...  					for (nsaved = 0' saved = 0; inptr < inend; nsaved++)  						saved = (saved << 8) | *inptr++;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: while (inptr < inend) {  				while (uulen < 45 && (inptr + 3) <= inend) {  					b0 = *inptr++;  					b1 = *inptr++;  					b2 = *inptr++;    					// convert 3 input bytes into 4 uuencoded bytes  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);    					uulen += 3;  				}    				if (uulen >= 45) {  					// output the uu line length  					*outptr = Encode (uulen);  					outptr += ((uulen / 3) * 4) + 1;  					*outptr++ = (byte) '\n';  					uulen = 0;    					if ((inptr + 45) <= inend) {  						// we have enough input to output another full line  						bufptr = outptr + 1;  					} else {  						bufptr = uuptr;  					}  				} else {  					// not enough input to continue...  					for (nsaved = 0' saved = 0; inptr < inend; nsaved++)  						saved = (saved << 8) | *inptr++;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: while (inptr < inend) {  				while (uulen < 45 && (inptr + 3) <= inend) {  					b0 = *inptr++;  					b1 = *inptr++;  					b2 = *inptr++;    					// convert 3 input bytes into 4 uuencoded bytes  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);    					uulen += 3;  				}    				if (uulen >= 45) {  					// output the uu line length  					*outptr = Encode (uulen);  					outptr += ((uulen / 3) * 4) + 1;  					*outptr++ = (byte) '\n';  					uulen = 0;    					if ((inptr + 45) <= inend) {  						// we have enough input to output another full line  						bufptr = outptr + 1;  					} else {  						bufptr = uuptr;  					}  				} else {  					// not enough input to continue...  					for (nsaved = 0' saved = 0; inptr < inend; nsaved++)  						saved = (saved << 8) | *inptr++;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: while (inptr < inend) {  				while (uulen < 45 && (inptr + 3) <= inend) {  					b0 = *inptr++;  					b1 = *inptr++;  					b2 = *inptr++;    					// convert 3 input bytes into 4 uuencoded bytes  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);    					uulen += 3;  				}    				if (uulen >= 45) {  					// output the uu line length  					*outptr = Encode (uulen);  					outptr += ((uulen / 3) * 4) + 1;  					*outptr++ = (byte) '\n';  					uulen = 0;    					if ((inptr + 45) <= inend) {  						// we have enough input to output another full line  						bufptr = outptr + 1;  					} else {  						bufptr = uuptr;  					}  				} else {  					// not enough input to continue...  					for (nsaved = 0' saved = 0; inptr < inend; nsaved++)  						saved = (saved << 8) | *inptr++;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: while (inptr < inend) {  				while (uulen < 45 && (inptr + 3) <= inend) {  					b0 = *inptr++;  					b1 = *inptr++;  					b2 = *inptr++;    					// convert 3 input bytes into 4 uuencoded bytes  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);    					uulen += 3;  				}    				if (uulen >= 45) {  					// output the uu line length  					*outptr = Encode (uulen);  					outptr += ((uulen / 3) * 4) + 1;  					*outptr++ = (byte) '\n';  					uulen = 0;    					if ((inptr + 45) <= inend) {  						// we have enough input to output another full line  						bufptr = outptr + 1;  					} else {  						bufptr = uuptr;  					}  				} else {  					// not enough input to continue...  					for (nsaved = 0' saved = 0; inptr < inend; nsaved++)  						saved = (saved << 8) | *inptr++;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: while (inptr < inend) {  				while (uulen < 45 && (inptr + 3) <= inend) {  					b0 = *inptr++;  					b1 = *inptr++;  					b2 = *inptr++;    					// convert 3 input bytes into 4 uuencoded bytes  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);    					uulen += 3;  				}    				if (uulen >= 45) {  					// output the uu line length  					*outptr = Encode (uulen);  					outptr += ((uulen / 3) * 4) + 1;  					*outptr++ = (byte) '\n';  					uulen = 0;    					if ((inptr + 45) <= inend) {  						// we have enough input to output another full line  						bufptr = outptr + 1;  					} else {  						bufptr = uuptr;  					}  				} else {  					// not enough input to continue...  					for (nsaved = 0' saved = 0; inptr < inend; nsaved++)  						saved = (saved << 8) | *inptr++;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: while (inptr < inend) {  				while (uulen < 45 && (inptr + 3) <= inend) {  					b0 = *inptr++;  					b1 = *inptr++;  					b2 = *inptr++;    					// convert 3 input bytes into 4 uuencoded bytes  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);    					uulen += 3;  				}    				if (uulen >= 45) {  					// output the uu line length  					*outptr = Encode (uulen);  					outptr += ((uulen / 3) * 4) + 1;  					*outptr++ = (byte) '\n';  					uulen = 0;    					if ((inptr + 45) <= inend) {  						// we have enough input to output another full line  						bufptr = outptr + 1;  					} else {  						bufptr = uuptr;  					}  				} else {  					// not enough input to continue...  					for (nsaved = 0' saved = 0; inptr < inend; nsaved++)  						saved = (saved << 8) | *inptr++;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: while (inptr < inend) {  				while (uulen < 45 && (inptr + 3) <= inend) {  					b0 = *inptr++;  					b1 = *inptr++;  					b2 = *inptr++;    					// convert 3 input bytes into 4 uuencoded bytes  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);    					uulen += 3;  				}    				if (uulen >= 45) {  					// output the uu line length  					*outptr = Encode (uulen);  					outptr += ((uulen / 3) * 4) + 1;  					*outptr++ = (byte) '\n';  					uulen = 0;    					if ((inptr + 45) <= inend) {  						// we have enough input to output another full line  						bufptr = outptr + 1;  					} else {  						bufptr = uuptr;  					}  				} else {  					// not enough input to continue...  					for (nsaved = 0' saved = 0; inptr < inend; nsaved++)  						saved = (saved << 8) | *inptr++;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: while (inptr < inend) {  				while (uulen < 45 && (inptr + 3) <= inend) {  					b0 = *inptr++;  					b1 = *inptr++;  					b2 = *inptr++;    					// convert 3 input bytes into 4 uuencoded bytes  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);    					uulen += 3;  				}    				if (uulen >= 45) {  					// output the uu line length  					*outptr = Encode (uulen);  					outptr += ((uulen / 3) * 4) + 1;  					*outptr++ = (byte) '\n';  					uulen = 0;    					if ((inptr + 45) <= inend) {  						// we have enough input to output another full line  						bufptr = outptr + 1;  					} else {  						bufptr = uuptr;  					}  				} else {  					// not enough input to continue...  					for (nsaved = 0' saved = 0; inptr < inend; nsaved++)  						saved = (saved << 8) | *inptr++;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: while (inptr < inend) {  				while (uulen < 45 && (inptr + 3) <= inend) {  					b0 = *inptr++;  					b1 = *inptr++;  					b2 = *inptr++;    					// convert 3 input bytes into 4 uuencoded bytes  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);    					uulen += 3;  				}    				if (uulen >= 45) {  					// output the uu line length  					*outptr = Encode (uulen);  					outptr += ((uulen / 3) * 4) + 1;  					*outptr++ = (byte) '\n';  					uulen = 0;    					if ((inptr + 45) <= inend) {  						// we have enough input to output another full line  						bufptr = outptr + 1;  					} else {  						bufptr = uuptr;  					}  				} else {  					// not enough input to continue...  					for (nsaved = 0' saved = 0; inptr < inend; nsaved++)  						saved = (saved << 8) | *inptr++;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Encode,The following statement contains a magic number: while (inptr < inend) {  				while (uulen < 45 && (inptr + 3) <= inend) {  					b0 = *inptr++;  					b1 = *inptr++;  					b2 = *inptr++;    					// convert 3 input bytes into 4 uuencoded bytes  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);    					uulen += 3;  				}    				if (uulen >= 45) {  					// output the uu line length  					*outptr = Encode (uulen);  					outptr += ((uulen / 3) * 4) + 1;  					*outptr++ = (byte) '\n';  					uulen = 0;    					if ((inptr + 45) <= inend) {  						// we have enough input to output another full line  						bufptr = outptr + 1;  					} else {  						bufptr = uuptr;  					}  				} else {  					// not enough input to continue...  					for (nsaved = 0' saved = 0; inptr < inend; nsaved++)  						saved = (saved << 8) | *inptr++;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Flush,The following statement contains a magic number: byte* bufptr = uuptr + ((uulen / 3) * 4);
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Flush,The following statement contains a magic number: byte* bufptr = uuptr + ((uulen / 3) * 4);
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Flush,The following statement contains a magic number: if (nsaved > 0) {  				while (nsaved < 3) {  					saved <<= 8;  					uufill++;  					nsaved++;  				}  				  				if (nsaved == 3) {  					// convert 3 input bytes into 4 uuencoded bytes  					byte b0' b1' b2;  					  					b0 = (byte) ((saved >> 16) & 0xFF);  					b1 = (byte) ((saved >> 8) & 0xFF);  					b2 = (byte) (saved & 0xFF);  					  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);  					  					uulen += 3;  					nsaved = 0;  					saved = 0;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Flush,The following statement contains a magic number: if (nsaved > 0) {  				while (nsaved < 3) {  					saved <<= 8;  					uufill++;  					nsaved++;  				}  				  				if (nsaved == 3) {  					// convert 3 input bytes into 4 uuencoded bytes  					byte b0' b1' b2;  					  					b0 = (byte) ((saved >> 16) & 0xFF);  					b1 = (byte) ((saved >> 8) & 0xFF);  					b2 = (byte) (saved & 0xFF);  					  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);  					  					uulen += 3;  					nsaved = 0;  					saved = 0;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Flush,The following statement contains a magic number: if (nsaved > 0) {  				while (nsaved < 3) {  					saved <<= 8;  					uufill++;  					nsaved++;  				}  				  				if (nsaved == 3) {  					// convert 3 input bytes into 4 uuencoded bytes  					byte b0' b1' b2;  					  					b0 = (byte) ((saved >> 16) & 0xFF);  					b1 = (byte) ((saved >> 8) & 0xFF);  					b2 = (byte) (saved & 0xFF);  					  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);  					  					uulen += 3;  					nsaved = 0;  					saved = 0;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Flush,The following statement contains a magic number: if (nsaved > 0) {  				while (nsaved < 3) {  					saved <<= 8;  					uufill++;  					nsaved++;  				}  				  				if (nsaved == 3) {  					// convert 3 input bytes into 4 uuencoded bytes  					byte b0' b1' b2;  					  					b0 = (byte) ((saved >> 16) & 0xFF);  					b1 = (byte) ((saved >> 8) & 0xFF);  					b2 = (byte) (saved & 0xFF);  					  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);  					  					uulen += 3;  					nsaved = 0;  					saved = 0;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Flush,The following statement contains a magic number: if (nsaved > 0) {  				while (nsaved < 3) {  					saved <<= 8;  					uufill++;  					nsaved++;  				}  				  				if (nsaved == 3) {  					// convert 3 input bytes into 4 uuencoded bytes  					byte b0' b1' b2;  					  					b0 = (byte) ((saved >> 16) & 0xFF);  					b1 = (byte) ((saved >> 8) & 0xFF);  					b2 = (byte) (saved & 0xFF);  					  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);  					  					uulen += 3;  					nsaved = 0;  					saved = 0;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Flush,The following statement contains a magic number: if (nsaved > 0) {  				while (nsaved < 3) {  					saved <<= 8;  					uufill++;  					nsaved++;  				}  				  				if (nsaved == 3) {  					// convert 3 input bytes into 4 uuencoded bytes  					byte b0' b1' b2;  					  					b0 = (byte) ((saved >> 16) & 0xFF);  					b1 = (byte) ((saved >> 8) & 0xFF);  					b2 = (byte) (saved & 0xFF);  					  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);  					  					uulen += 3;  					nsaved = 0;  					saved = 0;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Flush,The following statement contains a magic number: if (nsaved > 0) {  				while (nsaved < 3) {  					saved <<= 8;  					uufill++;  					nsaved++;  				}  				  				if (nsaved == 3) {  					// convert 3 input bytes into 4 uuencoded bytes  					byte b0' b1' b2;  					  					b0 = (byte) ((saved >> 16) & 0xFF);  					b1 = (byte) ((saved >> 8) & 0xFF);  					b2 = (byte) (saved & 0xFF);  					  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);  					  					uulen += 3;  					nsaved = 0;  					saved = 0;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Flush,The following statement contains a magic number: if (nsaved > 0) {  				while (nsaved < 3) {  					saved <<= 8;  					uufill++;  					nsaved++;  				}  				  				if (nsaved == 3) {  					// convert 3 input bytes into 4 uuencoded bytes  					byte b0' b1' b2;  					  					b0 = (byte) ((saved >> 16) & 0xFF);  					b1 = (byte) ((saved >> 8) & 0xFF);  					b2 = (byte) (saved & 0xFF);  					  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);  					  					uulen += 3;  					nsaved = 0;  					saved = 0;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Flush,The following statement contains a magic number: if (nsaved > 0) {  				while (nsaved < 3) {  					saved <<= 8;  					uufill++;  					nsaved++;  				}  				  				if (nsaved == 3) {  					// convert 3 input bytes into 4 uuencoded bytes  					byte b0' b1' b2;  					  					b0 = (byte) ((saved >> 16) & 0xFF);  					b1 = (byte) ((saved >> 8) & 0xFF);  					b2 = (byte) (saved & 0xFF);  					  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);  					  					uulen += 3;  					nsaved = 0;  					saved = 0;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Flush,The following statement contains a magic number: if (nsaved > 0) {  				while (nsaved < 3) {  					saved <<= 8;  					uufill++;  					nsaved++;  				}  				  				if (nsaved == 3) {  					// convert 3 input bytes into 4 uuencoded bytes  					byte b0' b1' b2;  					  					b0 = (byte) ((saved >> 16) & 0xFF);  					b1 = (byte) ((saved >> 8) & 0xFF);  					b2 = (byte) (saved & 0xFF);  					  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);  					  					uulen += 3;  					nsaved = 0;  					saved = 0;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Flush,The following statement contains a magic number: if (nsaved > 0) {  				while (nsaved < 3) {  					saved <<= 8;  					uufill++;  					nsaved++;  				}  				  				if (nsaved == 3) {  					// convert 3 input bytes into 4 uuencoded bytes  					byte b0' b1' b2;  					  					b0 = (byte) ((saved >> 16) & 0xFF);  					b1 = (byte) ((saved >> 8) & 0xFF);  					b2 = (byte) (saved & 0xFF);  					  					*bufptr++ = Encode ((b0 >> 2) & 0x3F);  					*bufptr++ = Encode (((b0 << 4) | ((b1 >> 4) & 0x0F)) & 0x3F);  					*bufptr++ = Encode (((b1 << 2) | ((b2 >> 6) & 0x03)) & 0x3F);  					*bufptr++ = Encode (b2 & 0x3F);  					  					uulen += 3;  					nsaved = 0;  					saved = 0;  				}  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Flush,The following statement contains a magic number: if (uulen > 0) {  				int n = (uulen / 3) * 4;  				  				*outptr++ = Encode ((uulen - uufill) & 0xFF);  				Buffer.BlockCopy (uubuf' 0' outbuf' (int) (outptr - output)' n);  				outptr += n;    				*outptr++ = (byte) '\n';  				uulen = 0;  			}
Magic Number,MimeKit.Encodings,UUEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\UUEncoder.cs,Flush,The following statement contains a magic number: if (uulen > 0) {  				int n = (uulen / 3) * 4;  				  				*outptr++ = Encode ((uulen - uufill) & 0xFF);  				Buffer.BlockCopy (uubuf' 0' outbuf' (int) (outptr - output)' n);  				outptr += n;    				*outptr++ = (byte) '\n';  				uulen = 0;  			}
Magic Number,MimeKit.Encodings,YDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\YDecoder.cs,Decode,The following statement contains a magic number: while (inptr < inend) {  				octet = *inptr++;    				if (octet == (byte) '\r') {  					escaped = false;  					continue;  				}    				if (octet == (byte) '\n') {  					escaped = false;  					eoln = true;  					continue;  				}    				if (escaped) {  					if (eoln && octet == (byte) 'y') {  						// this can only be =yend  						state = YDecoderState.Ended;  						break;  					}    					escaped = false;  					eoln = false;  					octet -= 64;  				} else if (octet == (byte) '=') {  					escaped = true;  					continue;  				} else {  					eoln = false;  				}    				octet -= 42;    				crc.Update (octet);  				*outptr++ = octet;  			}
Magic Number,MimeKit.Encodings,YDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\YDecoder.cs,Decode,The following statement contains a magic number: while (inptr < inend) {  				octet = *inptr++;    				if (octet == (byte) '\r') {  					escaped = false;  					continue;  				}    				if (octet == (byte) '\n') {  					escaped = false;  					eoln = true;  					continue;  				}    				if (escaped) {  					if (eoln && octet == (byte) 'y') {  						// this can only be =yend  						state = YDecoderState.Ended;  						break;  					}    					escaped = false;  					eoln = false;  					octet -= 64;  				} else if (octet == (byte) '=') {  					escaped = true;  					continue;  				} else {  					eoln = false;  				}    				octet -= 42;    				crc.Update (octet);  				*outptr++ = octet;  			}
Magic Number,MimeKit.Encodings,YEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\YEncoder.cs,YEncoder,The following statement contains a magic number: if (maxLineLength < 0 || maxLineLength > 254)  				throw new ArgumentOutOfRangeException ("maxLineLength");
Magic Number,MimeKit.Encodings,YEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\YEncoder.cs,EstimateOutputLength,The following statement contains a magic number: return (inputLength * 2) + (inputLength / lineLength) + 1;
Magic Number,MimeKit.Encodings,YEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\YEncoder.cs,Encode,The following statement contains a magic number: while (inptr < inend) {  				byte c = *inptr++;    				crc.Update (c);    				c += (byte) 42;    				if (c == 0 || c == (byte) '\t' || c == (byte) '\r' || c == (byte) '\n' || c == (byte) '=' || c == (byte) '.') {  					*outptr++ = (byte) '=';  					*outptr++ = (byte) (c + 64);  					octets += 2;  				} else {  					*outptr++ = c;  					octets++;  				}    				if (octets >= lineLength) {  					*outptr++ = (byte) '\n';  					octets = 0;  				}  			}
Magic Number,MimeKit.Encodings,YEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\YEncoder.cs,Encode,The following statement contains a magic number: while (inptr < inend) {  				byte c = *inptr++;    				crc.Update (c);    				c += (byte) 42;    				if (c == 0 || c == (byte) '\t' || c == (byte) '\r' || c == (byte) '\n' || c == (byte) '=' || c == (byte) '.') {  					*outptr++ = (byte) '=';  					*outptr++ = (byte) (c + 64);  					octets += 2;  				} else {  					*outptr++ = c;  					octets++;  				}    				if (octets >= lineLength) {  					*outptr++ = (byte) '\n';  					octets = 0;  				}  			}
Magic Number,MimeKit.Encodings,YEncoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\YEncoder.cs,Encode,The following statement contains a magic number: while (inptr < inend) {  				byte c = *inptr++;    				crc.Update (c);    				c += (byte) 42;    				if (c == 0 || c == (byte) '\t' || c == (byte) '\r' || c == (byte) '\n' || c == (byte) '=' || c == (byte) '.') {  					*outptr++ = (byte) '=';  					*outptr++ = (byte) (c + 64);  					octets += 2;  				} else {  					*outptr++ = c;  					octets++;  				}    				if (octets >= lineLength) {  					*outptr++ = (byte) '\n';  					octets = 0;  				}  			}
Magic Number,MimeKit.IO.Filters,ArmoredFromFilter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\ArmoredFromFilter.cs,Filter,The following statement contains a magic number: while (index < endIndex) {  				byte c = 0;    				if (midline) {  					while (index < endIndex) {  						c = input[index++];  						if (c == (byte) '\n')  							break;  					}  				}    				if (c == (byte) '\n' || !midline) {  					if ((left = endIndex - index) > 0) {  						midline = true;    						if (left < 5) {  							if (StartsWithFrom (input' index' endIndex)) {  								SaveRemainingInput (input' index' left);  								endIndex = index;  								midline = false;  								break;  							}  						} else {  							if (StartsWithFrom (input' index' endIndex)) {  								fromOffsets.Add (index);  								index += 5;  							}  						}  					} else {  						midline = false;  					}  				}  			}
Magic Number,MimeKit.IO.Filters,ArmoredFromFilter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\ArmoredFromFilter.cs,Filter,The following statement contains a magic number: while (index < endIndex) {  				byte c = 0;    				if (midline) {  					while (index < endIndex) {  						c = input[index++];  						if (c == (byte) '\n')  							break;  					}  				}    				if (c == (byte) '\n' || !midline) {  					if ((left = endIndex - index) > 0) {  						midline = true;    						if (left < 5) {  							if (StartsWithFrom (input' index' endIndex)) {  								SaveRemainingInput (input' index' left);  								endIndex = index;  								midline = false;  								break;  							}  						} else {  							if (StartsWithFrom (input' index' endIndex)) {  								fromOffsets.Add (index);  								index += 5;  							}  						}  					} else {  						midline = false;  					}  				}  			}
Magic Number,MimeKit.IO.Filters,ArmoredFromFilter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\ArmoredFromFilter.cs,Filter,The following statement contains a magic number: if (fromOffsets.Count > 0) {  				int need = (endIndex - startIndex) + fromOffsets.Count * 2;    				EnsureOutputSize (need' false);  				outputLength = 0;  				outputIndex = 0;    				index = startIndex;  				foreach (var offset in fromOffsets) {  					if (index < offset) {  						Buffer.BlockCopy (input' index' OutputBuffer' outputLength' offset - index);  						outputLength += offset - index;  						index = offset;  					}    					// encode the F using quoted-printable  					OutputBuffer[outputLength++] = (byte) '=';  					OutputBuffer[outputLength++] = (byte) '4';  					OutputBuffer[outputLength++] = (byte) '6';  					index++;  				}    				Buffer.BlockCopy (input' index' OutputBuffer' outputLength' endIndex - index);  				outputLength += endIndex - index;    				return OutputBuffer;  			}
Magic Number,MimeKit.IO.Filters,BestEncodingFilter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\BestEncodingFilter.cs,GetBestEncoding,The following statement contains a magic number: if (maxLineLength < 72 || maxLineLength > 998)  				throw new ArgumentOutOfRangeException ("maxLineLength");
Magic Number,MimeKit.IO.Filters,BestEncodingFilter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\BestEncodingFilter.cs,GetBestEncoding,The following statement contains a magic number: if (maxLineLength < 72 || maxLineLength > 998)  				throw new ArgumentOutOfRangeException ("maxLineLength");
Magic Number,MimeKit.IO.Filters,BestEncodingFilter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\BestEncodingFilter.cs,GetBestEncoding,The following statement contains a magic number: switch (constraint) {  			case EncodingConstraint.SevenBit:  				if (count0 > 0)  					return ContentEncoding.Base64;    				if (count8 > 0) {  					if (count8 >= (int) (total * (17.0 / 100.0)))  						return ContentEncoding.Base64;    					return ContentEncoding.QuotedPrintable;  				}    				if (maxline > maxLineLength)  					return ContentEncoding.QuotedPrintable;    				break;  			case EncodingConstraint.EightBit:  				if (count0 > 0)  					return ContentEncoding.Base64;    				if (maxline > maxLineLength)  					return ContentEncoding.QuotedPrintable;    				if (count8 > 0)  					return ContentEncoding.EightBit;    				break;  			case EncodingConstraint.None:  				if (count0 > 0)  					return ContentEncoding.Binary;    				if (maxline > maxLineLength)  					return ContentEncoding.QuotedPrintable;    				if (count8 > 0)  					return ContentEncoding.EightBit;    				break;  			default:  				throw new ArgumentOutOfRangeException ("constraint");  			}
Magic Number,MimeKit.IO.Filters,BestEncodingFilter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\BestEncodingFilter.cs,GetBestEncoding,The following statement contains a magic number: switch (constraint) {  			case EncodingConstraint.SevenBit:  				if (count0 > 0)  					return ContentEncoding.Base64;    				if (count8 > 0) {  					if (count8 >= (int) (total * (17.0 / 100.0)))  						return ContentEncoding.Base64;    					return ContentEncoding.QuotedPrintable;  				}    				if (maxline > maxLineLength)  					return ContentEncoding.QuotedPrintable;    				break;  			case EncodingConstraint.EightBit:  				if (count0 > 0)  					return ContentEncoding.Base64;    				if (maxline > maxLineLength)  					return ContentEncoding.QuotedPrintable;    				if (count8 > 0)  					return ContentEncoding.EightBit;    				break;  			case EncodingConstraint.None:  				if (count0 > 0)  					return ContentEncoding.Binary;    				if (maxline > maxLineLength)  					return ContentEncoding.QuotedPrintable;    				if (count8 > 0)  					return ContentEncoding.EightBit;    				break;  			default:  				throw new ArgumentOutOfRangeException ("constraint");  			}
Magic Number,MimeKit.IO.Filters,BestEncodingFilter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\BestEncodingFilter.cs,IsMboxMarker,The following statement contains a magic number: fixed (byte* buf = marker) {  				uint* word = (uint*) buf;    				if ((*word & FromMask) != From)  					return false;    				return *(buf + 4) == (byte) ' ';  			}
Magic Number,MimeKit.IO.Filters,BestEncodingFilter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\BestEncodingFilter.cs,Scan,The following statement contains a magic number: while (inptr < inend) {  				if (midline) {  					byte c = 0;    					while (inptr < inend && (c = *inptr++) != (byte) '\n') {  						if (c == 0)  							count0++;  						else if ((c & 0x80) != 0)  							count8++;    						if (!hasMarker && markerLength > 0 && markerLength < 5)  							marker[markerLength++] = c;    						linelen++;  					}    					if (c == (byte) '\n') {  						maxline = Math.Max (maxline' linelen);  						midline = false;  						linelen = 0;  					}  				}    				// check our from-save buffer for "From "  				if (!hasMarker && markerLength == 5 && IsMboxMarker (marker))  					hasMarker = true;    				markerLength = 0;  				midline = true;  			}
Magic Number,MimeKit.IO.Filters,BestEncodingFilter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\BestEncodingFilter.cs,Scan,The following statement contains a magic number: while (inptr < inend) {  				if (midline) {  					byte c = 0;    					while (inptr < inend && (c = *inptr++) != (byte) '\n') {  						if (c == 0)  							count0++;  						else if ((c & 0x80) != 0)  							count8++;    						if (!hasMarker && markerLength > 0 && markerLength < 5)  							marker[markerLength++] = c;    						linelen++;  					}    					if (c == (byte) '\n') {  						maxline = Math.Max (maxline' linelen);  						midline = false;  						linelen = 0;  					}  				}    				// check our from-save buffer for "From "  				if (!hasMarker && markerLength == 5 && IsMboxMarker (marker))  					hasMarker = true;    				markerLength = 0;  				midline = true;  			}
Magic Number,MimeKit.IO.Filters,CharsetFilter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\CharsetFilter.cs,Filter,The following statement contains a magic number: do {  				charsLeft = chars.Length;  				charIndex = 0;    				if (!decoded) {  					decoder.Convert (input' inputIndex' inputLeft' chars' charIndex' charsLeft' flush' out nread' out nwritten' out decoded);  					if (nwritten > 0)  						encoded = false;  					charIndex += nwritten;  					inputIndex += nread;  					inputLeft -= nread;  				}  				  				charsLeft = charIndex;  				charIndex = 0;  				  				// encode *all* input chars into the output buffer  				while (!encoded) {  					EnsureOutputSize (outputOffset + TargetEncoding.GetMaxByteCount (charsLeft) + 4' true);  					outputLeft = OutputBuffer.Length - outputOffset;  					  					encoder.Convert (chars' charIndex' charsLeft' OutputBuffer' outputOffset' outputLeft' flush' out nread' out nwritten' out encoded);  					outputOffset += nwritten;  					charIndex += nread;  					charsLeft -= nread;  				}  			} while (!decoded);
Magic Number,MimeKit.IO.Filters,MimeFilterBase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\MimeFilterBase.cs,GetIdealBufferSize,The following statement contains a magic number: return (need + 63) & ~63;
Magic Number,MimeKit.IO.Filters,MimeFilterBase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\MimeFilterBase.cs,GetIdealBufferSize,The following statement contains a magic number: return (need + 63) & ~63;
Magic Number,MimeKit.IO.Filters,Unix2DosFilter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\IO\Filters\Unix2DosFilter.cs,Filter,The following statement contains a magic number: EnsureOutputSize (length * 2' false);
Magic Number,MimeKit.Tnef,RtfCompressedToRtf,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\RtfCompressedToRtf.cs,TryReadInt32,The following statement contains a magic number: int nread = (saved >> 24) & 0xFF;
Magic Number,MimeKit.Tnef,RtfCompressedToRtf,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\RtfCompressedToRtf.cs,TryReadInt32,The following statement contains a magic number: switch (nread) {  			case 0:  				saved = buffer[index++];  				nread++;    				if (index == endIndex)  					break;    				goto case 1;  			case 1:  				saved |= (buffer[index++] << 8);  				nread++;    				if (index == endIndex)  					break;    				goto case 2;  			case 2:  				saved |= (buffer[index++] << 16);  				nread++;    				if (index == endIndex)  					break;    				goto case 3;  			case 3:  				saved |= (buffer[index++] << 24);  				nread++;  				break;  			}
Magic Number,MimeKit.Tnef,RtfCompressedToRtf,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\RtfCompressedToRtf.cs,TryReadInt32,The following statement contains a magic number: switch (nread) {  			case 0:  				saved = buffer[index++];  				nread++;    				if (index == endIndex)  					break;    				goto case 1;  			case 1:  				saved |= (buffer[index++] << 8);  				nread++;    				if (index == endIndex)  					break;    				goto case 2;  			case 2:  				saved |= (buffer[index++] << 16);  				nread++;    				if (index == endIndex)  					break;    				goto case 3;  			case 3:  				saved |= (buffer[index++] << 24);  				nread++;  				break;  			}
Magic Number,MimeKit.Tnef,RtfCompressedToRtf,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\RtfCompressedToRtf.cs,TryReadInt32,The following statement contains a magic number: switch (nread) {  			case 0:  				saved = buffer[index++];  				nread++;    				if (index == endIndex)  					break;    				goto case 1;  			case 1:  				saved |= (buffer[index++] << 8);  				nread++;    				if (index == endIndex)  					break;    				goto case 2;  			case 2:  				saved |= (buffer[index++] << 16);  				nread++;    				if (index == endIndex)  					break;    				goto case 3;  			case 3:  				saved |= (buffer[index++] << 24);  				nread++;  				break;  			}
Magic Number,MimeKit.Tnef,RtfCompressedToRtf,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\RtfCompressedToRtf.cs,TryReadInt32,The following statement contains a magic number: switch (nread) {  			case 0:  				saved = buffer[index++];  				nread++;    				if (index == endIndex)  					break;    				goto case 1;  			case 1:  				saved |= (buffer[index++] << 8);  				nread++;    				if (index == endIndex)  					break;    				goto case 2;  			case 2:  				saved |= (buffer[index++] << 16);  				nread++;    				if (index == endIndex)  					break;    				goto case 3;  			case 3:  				saved |= (buffer[index++] << 24);  				nread++;  				break;  			}
Magic Number,MimeKit.Tnef,RtfCompressedToRtf,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\RtfCompressedToRtf.cs,TryReadInt32,The following statement contains a magic number: switch (nread) {  			case 0:  				saved = buffer[index++];  				nread++;    				if (index == endIndex)  					break;    				goto case 1;  			case 1:  				saved |= (buffer[index++] << 8);  				nread++;    				if (index == endIndex)  					break;    				goto case 2;  			case 2:  				saved |= (buffer[index++] << 16);  				nread++;    				if (index == endIndex)  					break;    				goto case 3;  			case 3:  				saved |= (buffer[index++] << 24);  				nread++;  				break;  			}
Magic Number,MimeKit.Tnef,RtfCompressedToRtf,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\RtfCompressedToRtf.cs,TryReadInt32,The following statement contains a magic number: switch (nread) {  			case 0:  				saved = buffer[index++];  				nread++;    				if (index == endIndex)  					break;    				goto case 1;  			case 1:  				saved |= (buffer[index++] << 8);  				nread++;    				if (index == endIndex)  					break;    				goto case 2;  			case 2:  				saved |= (buffer[index++] << 16);  				nread++;    				if (index == endIndex)  					break;    				goto case 3;  			case 3:  				saved |= (buffer[index++] << 24);  				nread++;  				break;  			}
Magic Number,MimeKit.Tnef,RtfCompressedToRtf,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\RtfCompressedToRtf.cs,TryReadInt32,The following statement contains a magic number: switch (nread) {  			case 0:  				saved = buffer[index++];  				nread++;    				if (index == endIndex)  					break;    				goto case 1;  			case 1:  				saved |= (buffer[index++] << 8);  				nread++;    				if (index == endIndex)  					break;    				goto case 2;  			case 2:  				saved |= (buffer[index++] << 16);  				nread++;    				if (index == endIndex)  					break;    				goto case 3;  			case 3:  				saved |= (buffer[index++] << 24);  				nread++;  				break;  			}
Magic Number,MimeKit.Tnef,RtfCompressedToRtf,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\RtfCompressedToRtf.cs,TryReadInt32,The following statement contains a magic number: if (nread == 4) {  				saved = 0;  				return true;  			}
Magic Number,MimeKit.Tnef,RtfCompressedToRtf,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\RtfCompressedToRtf.cs,TryReadInt32,The following statement contains a magic number: saved |= nread << 24;
Magic Number,MimeKit.Tnef,RtfCompressedToRtf,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\RtfCompressedToRtf.cs,Filter,The following statement contains a magic number: if (state == FilterState.CompressedSize) {  				if (!TryReadInt32 (input' ref index' endIndex' out compressedSize)) {  					outputLength = 0;  					outputIndex = 0;  					return input;  				}    				state = FilterState.UncompressedSize;  				compressedSize -= 12;  			}
Magic Number,MimeKit.Tnef,RtfCompressedToRtf,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\RtfCompressedToRtf.cs,Filter,The following statement contains a magic number: EnsureOutputSize (Math.Max (estimatedSize' 4096)' false);
Magic Number,MimeKit.Tnef,RtfCompressedToRtf,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\RtfCompressedToRtf.cs,Filter,The following statement contains a magic number: while (index < endIndex) {  				byte value = input[index++];    				crc32.Update (value);  				size++;    				switch (state) {  				case FilterState.BeginControlRun:  					flags = value;  					flagCount = 1;    					if ((flags & 0x1) != 0)  						state = FilterState.ReadControlOffset;  					else  						state = FilterState.ReadLiteral;  					break;  				case FilterState.ReadLiteral:  					EnsureOutputSize (outputLength + 1' true);  					OutputBuffer[outputLength++] = value;  					dict[dictWriteOffset++] = value;    					dictEndOffset = Math.Max (dictWriteOffset' dictEndOffset);  					dictWriteOffset = (short) (dictWriteOffset % 4096);    					if ((flagCount++ % 8) != 0) {  						flags = (byte) (flags >> 1);    						if ((flags & 0x1) != 0)  							state = FilterState.ReadControlOffset;  						else  							state = FilterState.ReadLiteral;  					} else {  						state = FilterState.BeginControlRun;  					}  					break;  				case FilterState.ReadControlOffset:  					state = FilterState.ProcessControl;  					dictReadOffset = value;  					break;  				case FilterState.ProcessControl:  					dictReadOffset = (short) ((dictReadOffset << 4) | (value >> 4));  					int controlLength = (value & 0x0F) + 2;    					if (dictReadOffset == dictWriteOffset) {  						state = FilterState.Complete;  						break;  					}    					EnsureOutputSize (outputLength + controlLength' true);    					int controlEnd = dictReadOffset + controlLength;    					while (dictReadOffset < controlEnd) {  						value = dict[dictReadOffset++ % 4096];  						OutputBuffer[outputLength++] = value;  						dict[dictWriteOffset++] = value;    						dictEndOffset = Math.Max (dictWriteOffset' dictEndOffset);  						dictWriteOffset = (short) (dictWriteOffset % 4096);  					}    					if ((flagCount++ % 8) != 0) {  						flags = (byte) (flags >> 1);    						if ((flags & 0x1) != 0)  							state = FilterState.ReadControlOffset;  						else  							state = FilterState.ReadLiteral;  					} else {  						state = FilterState.BeginControlRun;  					}  					break;  				case FilterState.Complete:  					break;  				}  			}
Magic Number,MimeKit.Tnef,RtfCompressedToRtf,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\RtfCompressedToRtf.cs,Filter,The following statement contains a magic number: while (index < endIndex) {  				byte value = input[index++];    				crc32.Update (value);  				size++;    				switch (state) {  				case FilterState.BeginControlRun:  					flags = value;  					flagCount = 1;    					if ((flags & 0x1) != 0)  						state = FilterState.ReadControlOffset;  					else  						state = FilterState.ReadLiteral;  					break;  				case FilterState.ReadLiteral:  					EnsureOutputSize (outputLength + 1' true);  					OutputBuffer[outputLength++] = value;  					dict[dictWriteOffset++] = value;    					dictEndOffset = Math.Max (dictWriteOffset' dictEndOffset);  					dictWriteOffset = (short) (dictWriteOffset % 4096);    					if ((flagCount++ % 8) != 0) {  						flags = (byte) (flags >> 1);    						if ((flags & 0x1) != 0)  							state = FilterState.ReadControlOffset;  						else  							state = FilterState.ReadLiteral;  					} else {  						state = FilterState.BeginControlRun;  					}  					break;  				case FilterState.ReadControlOffset:  					state = FilterState.ProcessControl;  					dictReadOffset = value;  					break;  				case FilterState.ProcessControl:  					dictReadOffset = (short) ((dictReadOffset << 4) | (value >> 4));  					int controlLength = (value & 0x0F) + 2;    					if (dictReadOffset == dictWriteOffset) {  						state = FilterState.Complete;  						break;  					}    					EnsureOutputSize (outputLength + controlLength' true);    					int controlEnd = dictReadOffset + controlLength;    					while (dictReadOffset < controlEnd) {  						value = dict[dictReadOffset++ % 4096];  						OutputBuffer[outputLength++] = value;  						dict[dictWriteOffset++] = value;    						dictEndOffset = Math.Max (dictWriteOffset' dictEndOffset);  						dictWriteOffset = (short) (dictWriteOffset % 4096);  					}    					if ((flagCount++ % 8) != 0) {  						flags = (byte) (flags >> 1);    						if ((flags & 0x1) != 0)  							state = FilterState.ReadControlOffset;  						else  							state = FilterState.ReadLiteral;  					} else {  						state = FilterState.BeginControlRun;  					}  					break;  				case FilterState.Complete:  					break;  				}  			}
Magic Number,MimeKit.Tnef,RtfCompressedToRtf,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\RtfCompressedToRtf.cs,Filter,The following statement contains a magic number: while (index < endIndex) {  				byte value = input[index++];    				crc32.Update (value);  				size++;    				switch (state) {  				case FilterState.BeginControlRun:  					flags = value;  					flagCount = 1;    					if ((flags & 0x1) != 0)  						state = FilterState.ReadControlOffset;  					else  						state = FilterState.ReadLiteral;  					break;  				case FilterState.ReadLiteral:  					EnsureOutputSize (outputLength + 1' true);  					OutputBuffer[outputLength++] = value;  					dict[dictWriteOffset++] = value;    					dictEndOffset = Math.Max (dictWriteOffset' dictEndOffset);  					dictWriteOffset = (short) (dictWriteOffset % 4096);    					if ((flagCount++ % 8) != 0) {  						flags = (byte) (flags >> 1);    						if ((flags & 0x1) != 0)  							state = FilterState.ReadControlOffset;  						else  							state = FilterState.ReadLiteral;  					} else {  						state = FilterState.BeginControlRun;  					}  					break;  				case FilterState.ReadControlOffset:  					state = FilterState.ProcessControl;  					dictReadOffset = value;  					break;  				case FilterState.ProcessControl:  					dictReadOffset = (short) ((dictReadOffset << 4) | (value >> 4));  					int controlLength = (value & 0x0F) + 2;    					if (dictReadOffset == dictWriteOffset) {  						state = FilterState.Complete;  						break;  					}    					EnsureOutputSize (outputLength + controlLength' true);    					int controlEnd = dictReadOffset + controlLength;    					while (dictReadOffset < controlEnd) {  						value = dict[dictReadOffset++ % 4096];  						OutputBuffer[outputLength++] = value;  						dict[dictWriteOffset++] = value;    						dictEndOffset = Math.Max (dictWriteOffset' dictEndOffset);  						dictWriteOffset = (short) (dictWriteOffset % 4096);  					}    					if ((flagCount++ % 8) != 0) {  						flags = (byte) (flags >> 1);    						if ((flags & 0x1) != 0)  							state = FilterState.ReadControlOffset;  						else  							state = FilterState.ReadLiteral;  					} else {  						state = FilterState.BeginControlRun;  					}  					break;  				case FilterState.Complete:  					break;  				}  			}
Magic Number,MimeKit.Tnef,RtfCompressedToRtf,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\RtfCompressedToRtf.cs,Filter,The following statement contains a magic number: while (index < endIndex) {  				byte value = input[index++];    				crc32.Update (value);  				size++;    				switch (state) {  				case FilterState.BeginControlRun:  					flags = value;  					flagCount = 1;    					if ((flags & 0x1) != 0)  						state = FilterState.ReadControlOffset;  					else  						state = FilterState.ReadLiteral;  					break;  				case FilterState.ReadLiteral:  					EnsureOutputSize (outputLength + 1' true);  					OutputBuffer[outputLength++] = value;  					dict[dictWriteOffset++] = value;    					dictEndOffset = Math.Max (dictWriteOffset' dictEndOffset);  					dictWriteOffset = (short) (dictWriteOffset % 4096);    					if ((flagCount++ % 8) != 0) {  						flags = (byte) (flags >> 1);    						if ((flags & 0x1) != 0)  							state = FilterState.ReadControlOffset;  						else  							state = FilterState.ReadLiteral;  					} else {  						state = FilterState.BeginControlRun;  					}  					break;  				case FilterState.ReadControlOffset:  					state = FilterState.ProcessControl;  					dictReadOffset = value;  					break;  				case FilterState.ProcessControl:  					dictReadOffset = (short) ((dictReadOffset << 4) | (value >> 4));  					int controlLength = (value & 0x0F) + 2;    					if (dictReadOffset == dictWriteOffset) {  						state = FilterState.Complete;  						break;  					}    					EnsureOutputSize (outputLength + controlLength' true);    					int controlEnd = dictReadOffset + controlLength;    					while (dictReadOffset < controlEnd) {  						value = dict[dictReadOffset++ % 4096];  						OutputBuffer[outputLength++] = value;  						dict[dictWriteOffset++] = value;    						dictEndOffset = Math.Max (dictWriteOffset' dictEndOffset);  						dictWriteOffset = (short) (dictWriteOffset % 4096);  					}    					if ((flagCount++ % 8) != 0) {  						flags = (byte) (flags >> 1);    						if ((flags & 0x1) != 0)  							state = FilterState.ReadControlOffset;  						else  							state = FilterState.ReadLiteral;  					} else {  						state = FilterState.BeginControlRun;  					}  					break;  				case FilterState.Complete:  					break;  				}  			}
Magic Number,MimeKit.Tnef,RtfCompressedToRtf,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\RtfCompressedToRtf.cs,Filter,The following statement contains a magic number: while (index < endIndex) {  				byte value = input[index++];    				crc32.Update (value);  				size++;    				switch (state) {  				case FilterState.BeginControlRun:  					flags = value;  					flagCount = 1;    					if ((flags & 0x1) != 0)  						state = FilterState.ReadControlOffset;  					else  						state = FilterState.ReadLiteral;  					break;  				case FilterState.ReadLiteral:  					EnsureOutputSize (outputLength + 1' true);  					OutputBuffer[outputLength++] = value;  					dict[dictWriteOffset++] = value;    					dictEndOffset = Math.Max (dictWriteOffset' dictEndOffset);  					dictWriteOffset = (short) (dictWriteOffset % 4096);    					if ((flagCount++ % 8) != 0) {  						flags = (byte) (flags >> 1);    						if ((flags & 0x1) != 0)  							state = FilterState.ReadControlOffset;  						else  							state = FilterState.ReadLiteral;  					} else {  						state = FilterState.BeginControlRun;  					}  					break;  				case FilterState.ReadControlOffset:  					state = FilterState.ProcessControl;  					dictReadOffset = value;  					break;  				case FilterState.ProcessControl:  					dictReadOffset = (short) ((dictReadOffset << 4) | (value >> 4));  					int controlLength = (value & 0x0F) + 2;    					if (dictReadOffset == dictWriteOffset) {  						state = FilterState.Complete;  						break;  					}    					EnsureOutputSize (outputLength + controlLength' true);    					int controlEnd = dictReadOffset + controlLength;    					while (dictReadOffset < controlEnd) {  						value = dict[dictReadOffset++ % 4096];  						OutputBuffer[outputLength++] = value;  						dict[dictWriteOffset++] = value;    						dictEndOffset = Math.Max (dictWriteOffset' dictEndOffset);  						dictWriteOffset = (short) (dictWriteOffset % 4096);  					}    					if ((flagCount++ % 8) != 0) {  						flags = (byte) (flags >> 1);    						if ((flags & 0x1) != 0)  							state = FilterState.ReadControlOffset;  						else  							state = FilterState.ReadLiteral;  					} else {  						state = FilterState.BeginControlRun;  					}  					break;  				case FilterState.Complete:  					break;  				}  			}
Magic Number,MimeKit.Tnef,RtfCompressedToRtf,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\RtfCompressedToRtf.cs,Filter,The following statement contains a magic number: while (index < endIndex) {  				byte value = input[index++];    				crc32.Update (value);  				size++;    				switch (state) {  				case FilterState.BeginControlRun:  					flags = value;  					flagCount = 1;    					if ((flags & 0x1) != 0)  						state = FilterState.ReadControlOffset;  					else  						state = FilterState.ReadLiteral;  					break;  				case FilterState.ReadLiteral:  					EnsureOutputSize (outputLength + 1' true);  					OutputBuffer[outputLength++] = value;  					dict[dictWriteOffset++] = value;    					dictEndOffset = Math.Max (dictWriteOffset' dictEndOffset);  					dictWriteOffset = (short) (dictWriteOffset % 4096);    					if ((flagCount++ % 8) != 0) {  						flags = (byte) (flags >> 1);    						if ((flags & 0x1) != 0)  							state = FilterState.ReadControlOffset;  						else  							state = FilterState.ReadLiteral;  					} else {  						state = FilterState.BeginControlRun;  					}  					break;  				case FilterState.ReadControlOffset:  					state = FilterState.ProcessControl;  					dictReadOffset = value;  					break;  				case FilterState.ProcessControl:  					dictReadOffset = (short) ((dictReadOffset << 4) | (value >> 4));  					int controlLength = (value & 0x0F) + 2;    					if (dictReadOffset == dictWriteOffset) {  						state = FilterState.Complete;  						break;  					}    					EnsureOutputSize (outputLength + controlLength' true);    					int controlEnd = dictReadOffset + controlLength;    					while (dictReadOffset < controlEnd) {  						value = dict[dictReadOffset++ % 4096];  						OutputBuffer[outputLength++] = value;  						dict[dictWriteOffset++] = value;    						dictEndOffset = Math.Max (dictWriteOffset' dictEndOffset);  						dictWriteOffset = (short) (dictWriteOffset % 4096);  					}    					if ((flagCount++ % 8) != 0) {  						flags = (byte) (flags >> 1);    						if ((flags & 0x1) != 0)  							state = FilterState.ReadControlOffset;  						else  							state = FilterState.ReadLiteral;  					} else {  						state = FilterState.BeginControlRun;  					}  					break;  				case FilterState.Complete:  					break;  				}  			}
Magic Number,MimeKit.Tnef,RtfCompressedToRtf,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\RtfCompressedToRtf.cs,Filter,The following statement contains a magic number: while (index < endIndex) {  				byte value = input[index++];    				crc32.Update (value);  				size++;    				switch (state) {  				case FilterState.BeginControlRun:  					flags = value;  					flagCount = 1;    					if ((flags & 0x1) != 0)  						state = FilterState.ReadControlOffset;  					else  						state = FilterState.ReadLiteral;  					break;  				case FilterState.ReadLiteral:  					EnsureOutputSize (outputLength + 1' true);  					OutputBuffer[outputLength++] = value;  					dict[dictWriteOffset++] = value;    					dictEndOffset = Math.Max (dictWriteOffset' dictEndOffset);  					dictWriteOffset = (short) (dictWriteOffset % 4096);    					if ((flagCount++ % 8) != 0) {  						flags = (byte) (flags >> 1);    						if ((flags & 0x1) != 0)  							state = FilterState.ReadControlOffset;  						else  							state = FilterState.ReadLiteral;  					} else {  						state = FilterState.BeginControlRun;  					}  					break;  				case FilterState.ReadControlOffset:  					state = FilterState.ProcessControl;  					dictReadOffset = value;  					break;  				case FilterState.ProcessControl:  					dictReadOffset = (short) ((dictReadOffset << 4) | (value >> 4));  					int controlLength = (value & 0x0F) + 2;    					if (dictReadOffset == dictWriteOffset) {  						state = FilterState.Complete;  						break;  					}    					EnsureOutputSize (outputLength + controlLength' true);    					int controlEnd = dictReadOffset + controlLength;    					while (dictReadOffset < controlEnd) {  						value = dict[dictReadOffset++ % 4096];  						OutputBuffer[outputLength++] = value;  						dict[dictWriteOffset++] = value;    						dictEndOffset = Math.Max (dictWriteOffset' dictEndOffset);  						dictWriteOffset = (short) (dictWriteOffset % 4096);  					}    					if ((flagCount++ % 8) != 0) {  						flags = (byte) (flags >> 1);    						if ((flags & 0x1) != 0)  							state = FilterState.ReadControlOffset;  						else  							state = FilterState.ReadLiteral;  					} else {  						state = FilterState.BeginControlRun;  					}  					break;  				case FilterState.Complete:  					break;  				}  			}
Magic Number,MimeKit.Tnef,RtfCompressedToRtf,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\RtfCompressedToRtf.cs,Filter,The following statement contains a magic number: while (index < endIndex) {  				byte value = input[index++];    				crc32.Update (value);  				size++;    				switch (state) {  				case FilterState.BeginControlRun:  					flags = value;  					flagCount = 1;    					if ((flags & 0x1) != 0)  						state = FilterState.ReadControlOffset;  					else  						state = FilterState.ReadLiteral;  					break;  				case FilterState.ReadLiteral:  					EnsureOutputSize (outputLength + 1' true);  					OutputBuffer[outputLength++] = value;  					dict[dictWriteOffset++] = value;    					dictEndOffset = Math.Max (dictWriteOffset' dictEndOffset);  					dictWriteOffset = (short) (dictWriteOffset % 4096);    					if ((flagCount++ % 8) != 0) {  						flags = (byte) (flags >> 1);    						if ((flags & 0x1) != 0)  							state = FilterState.ReadControlOffset;  						else  							state = FilterState.ReadLiteral;  					} else {  						state = FilterState.BeginControlRun;  					}  					break;  				case FilterState.ReadControlOffset:  					state = FilterState.ProcessControl;  					dictReadOffset = value;  					break;  				case FilterState.ProcessControl:  					dictReadOffset = (short) ((dictReadOffset << 4) | (value >> 4));  					int controlLength = (value & 0x0F) + 2;    					if (dictReadOffset == dictWriteOffset) {  						state = FilterState.Complete;  						break;  					}    					EnsureOutputSize (outputLength + controlLength' true);    					int controlEnd = dictReadOffset + controlLength;    					while (dictReadOffset < controlEnd) {  						value = dict[dictReadOffset++ % 4096];  						OutputBuffer[outputLength++] = value;  						dict[dictWriteOffset++] = value;    						dictEndOffset = Math.Max (dictWriteOffset' dictEndOffset);  						dictWriteOffset = (short) (dictWriteOffset % 4096);  					}    					if ((flagCount++ % 8) != 0) {  						flags = (byte) (flags >> 1);    						if ((flags & 0x1) != 0)  							state = FilterState.ReadControlOffset;  						else  							state = FilterState.ReadLiteral;  					} else {  						state = FilterState.BeginControlRun;  					}  					break;  				case FilterState.Complete:  					break;  				}  			}
Magic Number,MimeKit.Tnef,TnefPart,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPart.cs,ExtractRecipientTable,The following statement contains a magic number: while (prop.ReadNextRow ()) {  				InternetAddressList list = null;  				string name = null' addr = null;    				while (prop.ReadNextProperty ()) {  					switch (prop.PropertyTag.Id) {  					case TnefPropertyId.RecipientType:  						int recipientType = prop.ReadValueAsInt32 ();  						switch (recipientType) {  						case 1: list = message.To; break;  						case 2: list = message.Cc; break;  						case 3: list = message.Bcc; break;  						}  						break;  					case TnefPropertyId.TransmitableDisplayName:  						if (string.IsNullOrEmpty (name))  							name = prop.ReadValueAsString ();  						break;  					case TnefPropertyId.DisplayName:  						name = prop.ReadValueAsString ();  						break;  					case TnefPropertyId.EmailAddress:  						if (string.IsNullOrEmpty (addr))  							addr = prop.ReadValueAsString ();  						break;  					case TnefPropertyId.SmtpAddress:  						// The SmtpAddress' if it exists' should take precedence over the EmailAddress  						// (since the SmtpAddress is meant to be used in the RCPT TO command).  						addr = prop.ReadValueAsString ();  						break;  					}  				}    				if (list != null && !string.IsNullOrEmpty (addr))  					list.Add (new MailboxAddress (name' addr));  			}
Magic Number,MimeKit.Tnef,TnefPart,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPart.cs,ExtractRecipientTable,The following statement contains a magic number: while (prop.ReadNextRow ()) {  				InternetAddressList list = null;  				string name = null' addr = null;    				while (prop.ReadNextProperty ()) {  					switch (prop.PropertyTag.Id) {  					case TnefPropertyId.RecipientType:  						int recipientType = prop.ReadValueAsInt32 ();  						switch (recipientType) {  						case 1: list = message.To; break;  						case 2: list = message.Cc; break;  						case 3: list = message.Bcc; break;  						}  						break;  					case TnefPropertyId.TransmitableDisplayName:  						if (string.IsNullOrEmpty (name))  							name = prop.ReadValueAsString ();  						break;  					case TnefPropertyId.DisplayName:  						name = prop.ReadValueAsString ();  						break;  					case TnefPropertyId.EmailAddress:  						if (string.IsNullOrEmpty (addr))  							addr = prop.ReadValueAsString ();  						break;  					case TnefPropertyId.SmtpAddress:  						// The SmtpAddress' if it exists' should take precedence over the EmailAddress  						// (since the SmtpAddress is meant to be used in the RCPT TO command).  						addr = prop.ReadValueAsString ();  						break;  					}  				}    				if (list != null && !string.IsNullOrEmpty (addr))  					list.Add (new MailboxAddress (name' addr));  			}
Magic Number,MimeKit.Tnef,TnefPart,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPart.cs,ExtractMapiProperties,The following statement contains a magic number: while (prop.ReadNextProperty ()) {  				switch (prop.PropertyTag.Id) {  				case TnefPropertyId.InternetMessageId:  					if (prop.PropertyTag.ValueTnefType == TnefPropertyType.String8 ||  						prop.PropertyTag.ValueTnefType == TnefPropertyType.Unicode) {  						message.MessageId = prop.ReadValueAsString ();  					}  					break;  				case TnefPropertyId.Subject:  					if (prop.PropertyTag.ValueTnefType == TnefPropertyType.String8 ||  						prop.PropertyTag.ValueTnefType == TnefPropertyType.Unicode) {  						message.Subject = prop.ReadValueAsString ();  					}  					break;  				case TnefPropertyId.RtfCompressed:  					if (prop.PropertyTag.ValueTnefType == TnefPropertyType.String8 ||  						prop.PropertyTag.ValueTnefType == TnefPropertyType.Unicode ||  						prop.PropertyTag.ValueTnefType == TnefPropertyType.Binary) {  						var rtf = new TextPart ("rtf");  						rtf.ContentType.Name = "body.rtf";    						var converter = new RtfCompressedToRtf ();  						var content = new MemoryBlockStream ();    						using (var filtered = new FilteredStream (content)) {  							filtered.Add (converter);    							using (var compressed = prop.GetRawValueReadStream ()) {  								compressed.CopyTo (filtered' 4096);  								filtered.Flush ();  							}  						}    						rtf.ContentObject = new ContentObject (content);  						content.Position = 0;    						builder.Attachments.Add (rtf);  					}  					break;  				case TnefPropertyId.BodyHtml:  					if (prop.PropertyTag.ValueTnefType == TnefPropertyType.String8 ||  						prop.PropertyTag.ValueTnefType == TnefPropertyType.Unicode ||  						prop.PropertyTag.ValueTnefType == TnefPropertyType.Binary) {  						var html = new TextPart ("html");  						html.ContentType.Name = "body.html";  						html.Text = prop.ReadValueAsString ();    						builder.Attachments.Add (html);  					}  					break;  				case TnefPropertyId.Body:  					if (prop.PropertyTag.ValueTnefType == TnefPropertyType.String8 ||  						prop.PropertyTag.ValueTnefType == TnefPropertyType.Unicode ||  						prop.PropertyTag.ValueTnefType == TnefPropertyType.Binary) {  						var plain = new TextPart ("plain");  						plain.ContentType.Name = "body.txt";  						plain.Text = prop.ReadValueAsString ();    						builder.Attachments.Add (plain);  					}  					break;  				}  			}
Magic Number,MimeKit.Tnef,TnefPart,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPart.cs,ExtractAttachments,The following statement contains a magic number: do {  				if (reader.AttributeLevel != TnefAttributeLevel.Attachment)  					break;    				switch (reader.AttributeTag) {  				case TnefAttributeTag.AttachRenderData:  					attachMethod = TnefAttachMethod.ByValue;  					attachment = new MimePart ();  					break;  				case TnefAttributeTag.Attachment:  					if (attachment == null)  						break;    					while (prop.ReadNextProperty ()) {  						switch (prop.PropertyTag.Id) {  						case TnefPropertyId.AttachLongFilename:  							attachment.FileName = prop.ReadValueAsString ();  							break;  						case TnefPropertyId.AttachFilename:  							if (attachment.FileName == null)  								attachment.FileName = prop.ReadValueAsString ();  							break;  						case TnefPropertyId.AttachContentLocation:  							text = prop.ReadValueAsString ();  							if (Uri.IsWellFormedUriString (text' UriKind.Absolute))  								attachment.ContentLocation = new Uri (text' UriKind.Absolute);  							else if (Uri.IsWellFormedUriString (text' UriKind.Relative))  								attachment.ContentLocation = new Uri (text' UriKind.Relative);  							break;  						case TnefPropertyId.AttachContentBase:  							text = prop.ReadValueAsString ();  							attachment.ContentBase = new Uri (text' UriKind.Absolute);  							break;  						case TnefPropertyId.AttachContentId:  							attachment.ContentId = prop.ReadValueAsString ();  							break;  						case TnefPropertyId.AttachDisposition:  							text = prop.ReadValueAsString ();  							if (attachment.ContentDisposition == null)  								attachment.ContentDisposition = new ContentDisposition (text);  							else  								attachment.ContentDisposition.Disposition = text;  							break;  						case TnefPropertyId.AttachData:  							var stream = prop.GetRawValueReadStream ();  							var content = new MemoryStream ();  							var guid = new byte[16];    							if (attachMethod == TnefAttachMethod.EmbeddedMessage) {  								var tnef = new TnefPart ();    								foreach (var param in attachment.ContentType.Parameters)  									tnef.ContentType.Parameters[param.Name] = param.Value;    								if (attachment.ContentDisposition != null)  									tnef.ContentDisposition = attachment.ContentDisposition;    								attachment = tnef;  							}    							// read the GUID  							stream.Read (guid' 0' 16);    							// the rest is content  							using (var filtered = new FilteredStream (content)) {  								filtered.Add (filter);  								stream.CopyTo (filtered' 4096);  								filtered.Flush ();  							}    							content.Position = 0;    							attachment.ContentTransferEncoding = filter.GetBestEncoding (EncodingConstraint.SevenBit);  							attachment.ContentObject = new ContentObject (content);  							filter.Reset ();    							builder.Attachments.Add (attachment);  							break;  						case TnefPropertyId.AttachMethod:  							attachMethod = (TnefAttachMethod) prop.ReadValueAsInt32 ();  							break;  						case TnefPropertyId.AttachMimeTag:  							mimeType = prop.ReadValueAsString ().Split ('/');  							if (mimeType.Length == 2) {  								attachment.ContentType.MediaType = mimeType[0].Trim ();  								attachment.ContentType.MediaSubtype = mimeType[1].Trim ();  							}  							break;  						case TnefPropertyId.AttachFlags:  							flags = (TnefAttachFlags) prop.ReadValueAsInt32 ();  							if ((flags & TnefAttachFlags.RenderedInBody) != 0) {  								if (attachment.ContentDisposition == null)  									attachment.ContentDisposition = new ContentDisposition (ContentDisposition.Inline);  								else  									attachment.ContentDisposition.Disposition = ContentDisposition.Inline;  							}  							break;  						case TnefPropertyId.AttachSize:  							if (attachment.ContentDisposition == null)  								attachment.ContentDisposition = new ContentDisposition ();    							attachment.ContentDisposition.Size = prop.ReadValueAsInt64 ();  							break;  						case TnefPropertyId.DisplayName:  							attachment.ContentType.Name = prop.ReadValueAsString ();  							break;  						}  					}  					break;  				case TnefAttributeTag.AttachCreateDate:  					if (attachment != null) {  						if (attachment.ContentDisposition == null)  							attachment.ContentDisposition = new ContentDisposition ();    						attachment.ContentDisposition.CreationDate = prop.ReadValueAsDateTime ();  					}  					break;  				case TnefAttributeTag.AttachModifyDate:  					if (attachment != null) {  						if (attachment.ContentDisposition == null)  							attachment.ContentDisposition = new ContentDisposition ();    						attachment.ContentDisposition.ModificationDate = prop.ReadValueAsDateTime ();  					}  					break;  				case TnefAttributeTag.AttachTitle:  					if (attachment != null && string.IsNullOrEmpty (attachment.FileName))  						attachment.FileName = prop.ReadValueAsString ();  					break;  				case TnefAttributeTag.AttachMetaFile:  					if (attachment == null)  						break;    					// TODO: what to do with the meta data?  					break;  				case TnefAttributeTag.AttachData:  					if (attachment == null || attachMethod != TnefAttachMethod.ByValue)  						break;    					attachData = prop.ReadValueAsBytes ();  					filter.Flush (attachData' 0' attachData.Length' out outIndex' out outLength);  					attachment.ContentTransferEncoding = filter.GetBestEncoding (EncodingConstraint.EightBit);  					attachment.ContentObject = new ContentObject (new MemoryStream (attachData' false));  					filter.Reset ();    					builder.Attachments.Add (attachment);  					break;  				}  			} while (reader.ReadNextAttribute ());
Magic Number,MimeKit.Tnef,TnefPart,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPart.cs,ExtractAttachments,The following statement contains a magic number: do {  				if (reader.AttributeLevel != TnefAttributeLevel.Attachment)  					break;    				switch (reader.AttributeTag) {  				case TnefAttributeTag.AttachRenderData:  					attachMethod = TnefAttachMethod.ByValue;  					attachment = new MimePart ();  					break;  				case TnefAttributeTag.Attachment:  					if (attachment == null)  						break;    					while (prop.ReadNextProperty ()) {  						switch (prop.PropertyTag.Id) {  						case TnefPropertyId.AttachLongFilename:  							attachment.FileName = prop.ReadValueAsString ();  							break;  						case TnefPropertyId.AttachFilename:  							if (attachment.FileName == null)  								attachment.FileName = prop.ReadValueAsString ();  							break;  						case TnefPropertyId.AttachContentLocation:  							text = prop.ReadValueAsString ();  							if (Uri.IsWellFormedUriString (text' UriKind.Absolute))  								attachment.ContentLocation = new Uri (text' UriKind.Absolute);  							else if (Uri.IsWellFormedUriString (text' UriKind.Relative))  								attachment.ContentLocation = new Uri (text' UriKind.Relative);  							break;  						case TnefPropertyId.AttachContentBase:  							text = prop.ReadValueAsString ();  							attachment.ContentBase = new Uri (text' UriKind.Absolute);  							break;  						case TnefPropertyId.AttachContentId:  							attachment.ContentId = prop.ReadValueAsString ();  							break;  						case TnefPropertyId.AttachDisposition:  							text = prop.ReadValueAsString ();  							if (attachment.ContentDisposition == null)  								attachment.ContentDisposition = new ContentDisposition (text);  							else  								attachment.ContentDisposition.Disposition = text;  							break;  						case TnefPropertyId.AttachData:  							var stream = prop.GetRawValueReadStream ();  							var content = new MemoryStream ();  							var guid = new byte[16];    							if (attachMethod == TnefAttachMethod.EmbeddedMessage) {  								var tnef = new TnefPart ();    								foreach (var param in attachment.ContentType.Parameters)  									tnef.ContentType.Parameters[param.Name] = param.Value;    								if (attachment.ContentDisposition != null)  									tnef.ContentDisposition = attachment.ContentDisposition;    								attachment = tnef;  							}    							// read the GUID  							stream.Read (guid' 0' 16);    							// the rest is content  							using (var filtered = new FilteredStream (content)) {  								filtered.Add (filter);  								stream.CopyTo (filtered' 4096);  								filtered.Flush ();  							}    							content.Position = 0;    							attachment.ContentTransferEncoding = filter.GetBestEncoding (EncodingConstraint.SevenBit);  							attachment.ContentObject = new ContentObject (content);  							filter.Reset ();    							builder.Attachments.Add (attachment);  							break;  						case TnefPropertyId.AttachMethod:  							attachMethod = (TnefAttachMethod) prop.ReadValueAsInt32 ();  							break;  						case TnefPropertyId.AttachMimeTag:  							mimeType = prop.ReadValueAsString ().Split ('/');  							if (mimeType.Length == 2) {  								attachment.ContentType.MediaType = mimeType[0].Trim ();  								attachment.ContentType.MediaSubtype = mimeType[1].Trim ();  							}  							break;  						case TnefPropertyId.AttachFlags:  							flags = (TnefAttachFlags) prop.ReadValueAsInt32 ();  							if ((flags & TnefAttachFlags.RenderedInBody) != 0) {  								if (attachment.ContentDisposition == null)  									attachment.ContentDisposition = new ContentDisposition (ContentDisposition.Inline);  								else  									attachment.ContentDisposition.Disposition = ContentDisposition.Inline;  							}  							break;  						case TnefPropertyId.AttachSize:  							if (attachment.ContentDisposition == null)  								attachment.ContentDisposition = new ContentDisposition ();    							attachment.ContentDisposition.Size = prop.ReadValueAsInt64 ();  							break;  						case TnefPropertyId.DisplayName:  							attachment.ContentType.Name = prop.ReadValueAsString ();  							break;  						}  					}  					break;  				case TnefAttributeTag.AttachCreateDate:  					if (attachment != null) {  						if (attachment.ContentDisposition == null)  							attachment.ContentDisposition = new ContentDisposition ();    						attachment.ContentDisposition.CreationDate = prop.ReadValueAsDateTime ();  					}  					break;  				case TnefAttributeTag.AttachModifyDate:  					if (attachment != null) {  						if (attachment.ContentDisposition == null)  							attachment.ContentDisposition = new ContentDisposition ();    						attachment.ContentDisposition.ModificationDate = prop.ReadValueAsDateTime ();  					}  					break;  				case TnefAttributeTag.AttachTitle:  					if (attachment != null && string.IsNullOrEmpty (attachment.FileName))  						attachment.FileName = prop.ReadValueAsString ();  					break;  				case TnefAttributeTag.AttachMetaFile:  					if (attachment == null)  						break;    					// TODO: what to do with the meta data?  					break;  				case TnefAttributeTag.AttachData:  					if (attachment == null || attachMethod != TnefAttachMethod.ByValue)  						break;    					attachData = prop.ReadValueAsBytes ();  					filter.Flush (attachData' 0' attachData.Length' out outIndex' out outLength);  					attachment.ContentTransferEncoding = filter.GetBestEncoding (EncodingConstraint.EightBit);  					attachment.ContentObject = new ContentObject (new MemoryStream (attachData' false));  					filter.Reset ();    					builder.Attachments.Add (attachment);  					break;  				}  			} while (reader.ReadNextAttribute ());
Magic Number,MimeKit.Tnef,TnefPart,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPart.cs,ExtractAttachments,The following statement contains a magic number: do {  				if (reader.AttributeLevel != TnefAttributeLevel.Attachment)  					break;    				switch (reader.AttributeTag) {  				case TnefAttributeTag.AttachRenderData:  					attachMethod = TnefAttachMethod.ByValue;  					attachment = new MimePart ();  					break;  				case TnefAttributeTag.Attachment:  					if (attachment == null)  						break;    					while (prop.ReadNextProperty ()) {  						switch (prop.PropertyTag.Id) {  						case TnefPropertyId.AttachLongFilename:  							attachment.FileName = prop.ReadValueAsString ();  							break;  						case TnefPropertyId.AttachFilename:  							if (attachment.FileName == null)  								attachment.FileName = prop.ReadValueAsString ();  							break;  						case TnefPropertyId.AttachContentLocation:  							text = prop.ReadValueAsString ();  							if (Uri.IsWellFormedUriString (text' UriKind.Absolute))  								attachment.ContentLocation = new Uri (text' UriKind.Absolute);  							else if (Uri.IsWellFormedUriString (text' UriKind.Relative))  								attachment.ContentLocation = new Uri (text' UriKind.Relative);  							break;  						case TnefPropertyId.AttachContentBase:  							text = prop.ReadValueAsString ();  							attachment.ContentBase = new Uri (text' UriKind.Absolute);  							break;  						case TnefPropertyId.AttachContentId:  							attachment.ContentId = prop.ReadValueAsString ();  							break;  						case TnefPropertyId.AttachDisposition:  							text = prop.ReadValueAsString ();  							if (attachment.ContentDisposition == null)  								attachment.ContentDisposition = new ContentDisposition (text);  							else  								attachment.ContentDisposition.Disposition = text;  							break;  						case TnefPropertyId.AttachData:  							var stream = prop.GetRawValueReadStream ();  							var content = new MemoryStream ();  							var guid = new byte[16];    							if (attachMethod == TnefAttachMethod.EmbeddedMessage) {  								var tnef = new TnefPart ();    								foreach (var param in attachment.ContentType.Parameters)  									tnef.ContentType.Parameters[param.Name] = param.Value;    								if (attachment.ContentDisposition != null)  									tnef.ContentDisposition = attachment.ContentDisposition;    								attachment = tnef;  							}    							// read the GUID  							stream.Read (guid' 0' 16);    							// the rest is content  							using (var filtered = new FilteredStream (content)) {  								filtered.Add (filter);  								stream.CopyTo (filtered' 4096);  								filtered.Flush ();  							}    							content.Position = 0;    							attachment.ContentTransferEncoding = filter.GetBestEncoding (EncodingConstraint.SevenBit);  							attachment.ContentObject = new ContentObject (content);  							filter.Reset ();    							builder.Attachments.Add (attachment);  							break;  						case TnefPropertyId.AttachMethod:  							attachMethod = (TnefAttachMethod) prop.ReadValueAsInt32 ();  							break;  						case TnefPropertyId.AttachMimeTag:  							mimeType = prop.ReadValueAsString ().Split ('/');  							if (mimeType.Length == 2) {  								attachment.ContentType.MediaType = mimeType[0].Trim ();  								attachment.ContentType.MediaSubtype = mimeType[1].Trim ();  							}  							break;  						case TnefPropertyId.AttachFlags:  							flags = (TnefAttachFlags) prop.ReadValueAsInt32 ();  							if ((flags & TnefAttachFlags.RenderedInBody) != 0) {  								if (attachment.ContentDisposition == null)  									attachment.ContentDisposition = new ContentDisposition (ContentDisposition.Inline);  								else  									attachment.ContentDisposition.Disposition = ContentDisposition.Inline;  							}  							break;  						case TnefPropertyId.AttachSize:  							if (attachment.ContentDisposition == null)  								attachment.ContentDisposition = new ContentDisposition ();    							attachment.ContentDisposition.Size = prop.ReadValueAsInt64 ();  							break;  						case TnefPropertyId.DisplayName:  							attachment.ContentType.Name = prop.ReadValueAsString ();  							break;  						}  					}  					break;  				case TnefAttributeTag.AttachCreateDate:  					if (attachment != null) {  						if (attachment.ContentDisposition == null)  							attachment.ContentDisposition = new ContentDisposition ();    						attachment.ContentDisposition.CreationDate = prop.ReadValueAsDateTime ();  					}  					break;  				case TnefAttributeTag.AttachModifyDate:  					if (attachment != null) {  						if (attachment.ContentDisposition == null)  							attachment.ContentDisposition = new ContentDisposition ();    						attachment.ContentDisposition.ModificationDate = prop.ReadValueAsDateTime ();  					}  					break;  				case TnefAttributeTag.AttachTitle:  					if (attachment != null && string.IsNullOrEmpty (attachment.FileName))  						attachment.FileName = prop.ReadValueAsString ();  					break;  				case TnefAttributeTag.AttachMetaFile:  					if (attachment == null)  						break;    					// TODO: what to do with the meta data?  					break;  				case TnefAttributeTag.AttachData:  					if (attachment == null || attachMethod != TnefAttachMethod.ByValue)  						break;    					attachData = prop.ReadValueAsBytes ();  					filter.Flush (attachData' 0' attachData.Length' out outIndex' out outLength);  					attachment.ContentTransferEncoding = filter.GetBestEncoding (EncodingConstraint.EightBit);  					attachment.ContentObject = new ContentObject (new MemoryStream (attachData' false));  					filter.Reset ();    					builder.Attachments.Add (attachment);  					break;  				}  			} while (reader.ReadNextAttribute ());
Magic Number,MimeKit.Tnef,TnefPart,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPart.cs,ExtractAttachments,The following statement contains a magic number: do {  				if (reader.AttributeLevel != TnefAttributeLevel.Attachment)  					break;    				switch (reader.AttributeTag) {  				case TnefAttributeTag.AttachRenderData:  					attachMethod = TnefAttachMethod.ByValue;  					attachment = new MimePart ();  					break;  				case TnefAttributeTag.Attachment:  					if (attachment == null)  						break;    					while (prop.ReadNextProperty ()) {  						switch (prop.PropertyTag.Id) {  						case TnefPropertyId.AttachLongFilename:  							attachment.FileName = prop.ReadValueAsString ();  							break;  						case TnefPropertyId.AttachFilename:  							if (attachment.FileName == null)  								attachment.FileName = prop.ReadValueAsString ();  							break;  						case TnefPropertyId.AttachContentLocation:  							text = prop.ReadValueAsString ();  							if (Uri.IsWellFormedUriString (text' UriKind.Absolute))  								attachment.ContentLocation = new Uri (text' UriKind.Absolute);  							else if (Uri.IsWellFormedUriString (text' UriKind.Relative))  								attachment.ContentLocation = new Uri (text' UriKind.Relative);  							break;  						case TnefPropertyId.AttachContentBase:  							text = prop.ReadValueAsString ();  							attachment.ContentBase = new Uri (text' UriKind.Absolute);  							break;  						case TnefPropertyId.AttachContentId:  							attachment.ContentId = prop.ReadValueAsString ();  							break;  						case TnefPropertyId.AttachDisposition:  							text = prop.ReadValueAsString ();  							if (attachment.ContentDisposition == null)  								attachment.ContentDisposition = new ContentDisposition (text);  							else  								attachment.ContentDisposition.Disposition = text;  							break;  						case TnefPropertyId.AttachData:  							var stream = prop.GetRawValueReadStream ();  							var content = new MemoryStream ();  							var guid = new byte[16];    							if (attachMethod == TnefAttachMethod.EmbeddedMessage) {  								var tnef = new TnefPart ();    								foreach (var param in attachment.ContentType.Parameters)  									tnef.ContentType.Parameters[param.Name] = param.Value;    								if (attachment.ContentDisposition != null)  									tnef.ContentDisposition = attachment.ContentDisposition;    								attachment = tnef;  							}    							// read the GUID  							stream.Read (guid' 0' 16);    							// the rest is content  							using (var filtered = new FilteredStream (content)) {  								filtered.Add (filter);  								stream.CopyTo (filtered' 4096);  								filtered.Flush ();  							}    							content.Position = 0;    							attachment.ContentTransferEncoding = filter.GetBestEncoding (EncodingConstraint.SevenBit);  							attachment.ContentObject = new ContentObject (content);  							filter.Reset ();    							builder.Attachments.Add (attachment);  							break;  						case TnefPropertyId.AttachMethod:  							attachMethod = (TnefAttachMethod) prop.ReadValueAsInt32 ();  							break;  						case TnefPropertyId.AttachMimeTag:  							mimeType = prop.ReadValueAsString ().Split ('/');  							if (mimeType.Length == 2) {  								attachment.ContentType.MediaType = mimeType[0].Trim ();  								attachment.ContentType.MediaSubtype = mimeType[1].Trim ();  							}  							break;  						case TnefPropertyId.AttachFlags:  							flags = (TnefAttachFlags) prop.ReadValueAsInt32 ();  							if ((flags & TnefAttachFlags.RenderedInBody) != 0) {  								if (attachment.ContentDisposition == null)  									attachment.ContentDisposition = new ContentDisposition (ContentDisposition.Inline);  								else  									attachment.ContentDisposition.Disposition = ContentDisposition.Inline;  							}  							break;  						case TnefPropertyId.AttachSize:  							if (attachment.ContentDisposition == null)  								attachment.ContentDisposition = new ContentDisposition ();    							attachment.ContentDisposition.Size = prop.ReadValueAsInt64 ();  							break;  						case TnefPropertyId.DisplayName:  							attachment.ContentType.Name = prop.ReadValueAsString ();  							break;  						}  					}  					break;  				case TnefAttributeTag.AttachCreateDate:  					if (attachment != null) {  						if (attachment.ContentDisposition == null)  							attachment.ContentDisposition = new ContentDisposition ();    						attachment.ContentDisposition.CreationDate = prop.ReadValueAsDateTime ();  					}  					break;  				case TnefAttributeTag.AttachModifyDate:  					if (attachment != null) {  						if (attachment.ContentDisposition == null)  							attachment.ContentDisposition = new ContentDisposition ();    						attachment.ContentDisposition.ModificationDate = prop.ReadValueAsDateTime ();  					}  					break;  				case TnefAttributeTag.AttachTitle:  					if (attachment != null && string.IsNullOrEmpty (attachment.FileName))  						attachment.FileName = prop.ReadValueAsString ();  					break;  				case TnefAttributeTag.AttachMetaFile:  					if (attachment == null)  						break;    					// TODO: what to do with the meta data?  					break;  				case TnefAttributeTag.AttachData:  					if (attachment == null || attachMethod != TnefAttachMethod.ByValue)  						break;    					attachData = prop.ReadValueAsBytes ();  					filter.Flush (attachData' 0' attachData.Length' out outIndex' out outLength);  					attachment.ContentTransferEncoding = filter.GetBestEncoding (EncodingConstraint.EightBit);  					attachment.ContentObject = new ContentObject (new MemoryStream (attachData' false));  					filter.Reset ();    					builder.Attachments.Add (attachment);  					break;  				}  			} while (reader.ReadNextAttribute ());
Magic Number,MimeKit.Tnef,TnefPropertyReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyReader.cs,GetEmbeddedMessageReader,The following statement contains a magic number: var guid = new byte[16];
Magic Number,MimeKit.Tnef,TnefPropertyReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyReader.cs,GetEmbeddedMessageReader,The following statement contains a magic number: stream.Read (guid' 0' 16);
Magic Number,MimeKit.Tnef,TnefPropertyReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyReader.cs,ReadDateTime,The following statement contains a magic number: var date = new DateTime (1601' 1' 1);
Magic Number,MimeKit.Tnef,TnefPropertyReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyReader.cs,ReadDateTime,The following statement contains a magic number: date = date.AddMilliseconds (fileTime /= 10000);
Magic Number,MimeKit.Tnef,TnefPropertyReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyReader.cs,GetPaddedLength,The following statement contains a magic number: return (length + 3) & ~3;
Magic Number,MimeKit.Tnef,TnefPropertyReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyReader.cs,GetPaddedLength,The following statement contains a magic number: return (length + 3) & ~3;
Magic Number,MimeKit.Tnef,TnefPropertyReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyReader.cs,ReadByteArray,The following statement contains a magic number: if ((length % 4) != 0) {  				// remaining bytes are padding  				int padding = 4 - (length % 4);    				reader.Seek (reader.StreamOffset + padding);  			}
Magic Number,MimeKit.Tnef,TnefPropertyReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyReader.cs,ReadByteArray,The following statement contains a magic number: if ((length % 4) != 0) {  				// remaining bytes are padding  				int padding = 4 - (length % 4);    				reader.Seek (reader.StreamOffset + padding);  			}
Magic Number,MimeKit.Tnef,TnefPropertyReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyReader.cs,ReadByteArray,The following statement contains a magic number: if ((length % 4) != 0) {  				// remaining bytes are padding  				int padding = 4 - (length % 4);    				reader.Seek (reader.StreamOffset + padding);  			}
Magic Number,MimeKit.Tnef,TnefPropertyReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyReader.cs,ReadUnicodeString,The following statement contains a magic number: while (length > 1 && bytes[length - 1] == 0 && bytes[length - 2] == 0)  				length -= 2;
Magic Number,MimeKit.Tnef,TnefPropertyReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyReader.cs,ReadUnicodeString,The following statement contains a magic number: while (length > 1 && bytes[length - 1] == 0 && bytes[length - 2] == 0)  				length -= 2;
Magic Number,MimeKit.Tnef,TnefPropertyReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyReader.cs,ReadUnicodeString,The following statement contains a magic number: if (length < 2)  				return string.Empty;
Magic Number,MimeKit.Tnef,TnefPropertyReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyReader.cs,GetMessageEncoding,The following statement contains a magic number: if (codepage != 0 && codepage != 1252) {  				try {  					return Encoding.GetEncoding (codepage' new EncoderExceptionFallback ()' new DecoderExceptionFallback ());  				} catch {  					return DefaultEncoding;  				}  			}
Magic Number,MimeKit.Tnef,TnefPropertyReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyReader.cs,LoadPropertyName,The following statement contains a magic number: var guid = new Guid (ReadBytes (16));
Magic Number,MimeKit.Tnef,TnefPropertyReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyReader.cs,TryGetPropertyValueLength,The following statement contains a magic number: switch (propertyTag.ValueTnefType) {  			case TnefPropertyType.Unspecified:  			case TnefPropertyType.Null:  				length = 0;  				break;  			case TnefPropertyType.Boolean:  			case TnefPropertyType.Error:  			case TnefPropertyType.Long:  			case TnefPropertyType.R4:  			case TnefPropertyType.I2:  				length = 4;  				break;  			case TnefPropertyType.Currency:  			case TnefPropertyType.Double:  			case TnefPropertyType.I8:  				length = 8;  				break;  			case TnefPropertyType.ClassId:  				length = 16;  				break;  			case TnefPropertyType.Unicode:  			case TnefPropertyType.String8:  			case TnefPropertyType.Binary:  			case TnefPropertyType.Object:  				length = 4 + GetPaddedLength (PeekInt32 ());  				break;  			case TnefPropertyType.AppTime:  			case TnefPropertyType.SysTime:  				length = 8;  				break;  			default:  				reader.SetComplianceError (TnefComplianceStatus.UnsupportedPropertyType);  				length = 0;    				return false;  			}
Magic Number,MimeKit.Tnef,TnefPropertyReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyReader.cs,TryGetPropertyValueLength,The following statement contains a magic number: switch (propertyTag.ValueTnefType) {  			case TnefPropertyType.Unspecified:  			case TnefPropertyType.Null:  				length = 0;  				break;  			case TnefPropertyType.Boolean:  			case TnefPropertyType.Error:  			case TnefPropertyType.Long:  			case TnefPropertyType.R4:  			case TnefPropertyType.I2:  				length = 4;  				break;  			case TnefPropertyType.Currency:  			case TnefPropertyType.Double:  			case TnefPropertyType.I8:  				length = 8;  				break;  			case TnefPropertyType.ClassId:  				length = 16;  				break;  			case TnefPropertyType.Unicode:  			case TnefPropertyType.String8:  			case TnefPropertyType.Binary:  			case TnefPropertyType.Object:  				length = 4 + GetPaddedLength (PeekInt32 ());  				break;  			case TnefPropertyType.AppTime:  			case TnefPropertyType.SysTime:  				length = 8;  				break;  			default:  				reader.SetComplianceError (TnefComplianceStatus.UnsupportedPropertyType);  				length = 0;    				return false;  			}
Magic Number,MimeKit.Tnef,TnefPropertyReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyReader.cs,TryGetPropertyValueLength,The following statement contains a magic number: switch (propertyTag.ValueTnefType) {  			case TnefPropertyType.Unspecified:  			case TnefPropertyType.Null:  				length = 0;  				break;  			case TnefPropertyType.Boolean:  			case TnefPropertyType.Error:  			case TnefPropertyType.Long:  			case TnefPropertyType.R4:  			case TnefPropertyType.I2:  				length = 4;  				break;  			case TnefPropertyType.Currency:  			case TnefPropertyType.Double:  			case TnefPropertyType.I8:  				length = 8;  				break;  			case TnefPropertyType.ClassId:  				length = 16;  				break;  			case TnefPropertyType.Unicode:  			case TnefPropertyType.String8:  			case TnefPropertyType.Binary:  			case TnefPropertyType.Object:  				length = 4 + GetPaddedLength (PeekInt32 ());  				break;  			case TnefPropertyType.AppTime:  			case TnefPropertyType.SysTime:  				length = 8;  				break;  			default:  				reader.SetComplianceError (TnefComplianceStatus.UnsupportedPropertyType);  				length = 0;    				return false;  			}
Magic Number,MimeKit.Tnef,TnefPropertyReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyReader.cs,TryGetPropertyValueLength,The following statement contains a magic number: switch (propertyTag.ValueTnefType) {  			case TnefPropertyType.Unspecified:  			case TnefPropertyType.Null:  				length = 0;  				break;  			case TnefPropertyType.Boolean:  			case TnefPropertyType.Error:  			case TnefPropertyType.Long:  			case TnefPropertyType.R4:  			case TnefPropertyType.I2:  				length = 4;  				break;  			case TnefPropertyType.Currency:  			case TnefPropertyType.Double:  			case TnefPropertyType.I8:  				length = 8;  				break;  			case TnefPropertyType.ClassId:  				length = 16;  				break;  			case TnefPropertyType.Unicode:  			case TnefPropertyType.String8:  			case TnefPropertyType.Binary:  			case TnefPropertyType.Object:  				length = 4 + GetPaddedLength (PeekInt32 ());  				break;  			case TnefPropertyType.AppTime:  			case TnefPropertyType.SysTime:  				length = 8;  				break;  			default:  				reader.SetComplianceError (TnefComplianceStatus.UnsupportedPropertyType);  				length = 0;    				return false;  			}
Magic Number,MimeKit.Tnef,TnefPropertyReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyReader.cs,TryGetPropertyValueLength,The following statement contains a magic number: switch (propertyTag.ValueTnefType) {  			case TnefPropertyType.Unspecified:  			case TnefPropertyType.Null:  				length = 0;  				break;  			case TnefPropertyType.Boolean:  			case TnefPropertyType.Error:  			case TnefPropertyType.Long:  			case TnefPropertyType.R4:  			case TnefPropertyType.I2:  				length = 4;  				break;  			case TnefPropertyType.Currency:  			case TnefPropertyType.Double:  			case TnefPropertyType.I8:  				length = 8;  				break;  			case TnefPropertyType.ClassId:  				length = 16;  				break;  			case TnefPropertyType.Unicode:  			case TnefPropertyType.String8:  			case TnefPropertyType.Binary:  			case TnefPropertyType.Object:  				length = 4 + GetPaddedLength (PeekInt32 ());  				break;  			case TnefPropertyType.AppTime:  			case TnefPropertyType.SysTime:  				length = 8;  				break;  			default:  				reader.SetComplianceError (TnefComplianceStatus.UnsupportedPropertyType);  				length = 0;    				return false;  			}
Magic Number,MimeKit.Tnef,TnefPropertyReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyReader.cs,ReadPropertyValue,The following statement contains a magic number: switch (propertyTag.ValueTnefType) {  			case TnefPropertyType.Null:  				value = null;  				break;  			case TnefPropertyType.I2:  				// 2 bytes for the short followed by 2 bytes of padding  				value = (short) (ReadInt32 () & 0xFFFF);  				break;  			case TnefPropertyType.Boolean:  				value = (ReadInt32 () & 0xFF) != 0;  				break;  			case TnefPropertyType.Currency:  			case TnefPropertyType.I8:  				value = ReadInt64 ();  				break;  			case TnefPropertyType.Error:  			case TnefPropertyType.Long:  				value = ReadInt32 ();  				break;  			case TnefPropertyType.Double:  				value = ReadDouble ();  				break;  			case TnefPropertyType.R4:  				value = ReadSingle ();  				break;  			case TnefPropertyType.AppTime:  			case TnefPropertyType.SysTime:  				value = ReadDateTime ();  				break;  			case TnefPropertyType.Unicode:  				value = ReadUnicodeString ();  				break;  			case TnefPropertyType.String8:  				value = ReadString ();  				break;  			case TnefPropertyType.Binary:  				value = ReadByteArray ();  				break;  			case TnefPropertyType.ClassId:  				value = new Guid (ReadBytes (16));  				break;  			case TnefPropertyType.Object:  				value = ReadByteArray ();  				break;  			default:  				reader.SetComplianceError (TnefComplianceStatus.UnsupportedPropertyType);  				value = null;  				break;  			}
Magic Number,MimeKit.Tnef,TnefPropertyReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyReader.cs,ReadValueAsBytes,The following statement contains a magic number: if (propertyCount > 0) {  				switch (propertyTag.ValueTnefType) {  				case TnefPropertyType.Unicode:  				case TnefPropertyType.String8:  				case TnefPropertyType.Binary:  				case TnefPropertyType.Object:  					bytes = ReadByteArray ();  					break;  				case TnefPropertyType.ClassId:  					bytes = ReadBytes (16);  					break;  				default:  					throw new InvalidOperationException ();  				}  			} else {  				switch (reader.AttributeType) {  				case TnefAttributeType.Triples:  				case TnefAttributeType.String:  				case TnefAttributeType.Text:  				case TnefAttributeType.Byte:  					bytes = ReadAttrBytes ();  					break;  				default:  					throw new ArgumentOutOfRangeException ();  				}  			}
Magic Number,MimeKit.Tnef,TnefPropertyReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyReader.cs,ReadValueAsGuid,The following statement contains a magic number: if (propertyCount > 0) {  				switch (propertyTag.ValueTnefType) {  				case TnefPropertyType.ClassId:  					guid = new Guid (ReadBytes (16));  					break;  				default:  					throw new InvalidOperationException ();  				}  			} else {  				throw new InvalidOperationException ();  			}
Magic Number,MimeKit.Tnef,TnefPropertyTag,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyTag.cs,TnefPropertyTag,The following statement contains a magic number: type = (TnefPropertyType) ((tag >> 16) & 0xFFFF);
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,TnefReader,The following statement contains a magic number: if (defaultMessageCodepage != 0) {  				// make sure that this codepage is valid...  				var encoding = Encoding.GetEncoding (defaultMessageCodepage);  				codepage = encoding.CodePage;  			} else {  				codepage = 1252;  			}
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,Load32BitValue,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				dest[0] = src[startIndex];  				dest[1] = src[startIndex + 1];  				dest[2] = src[startIndex + 2];  				dest[3] = src[startIndex + 3];  			} else {  				dest[0] = src[startIndex + 3];  				dest[1] = src[startIndex + 2];  				dest[2] = src[startIndex + 1];  				dest[3] = src[startIndex];  			}
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,Load32BitValue,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				dest[0] = src[startIndex];  				dest[1] = src[startIndex + 1];  				dest[2] = src[startIndex + 2];  				dest[3] = src[startIndex + 3];  			} else {  				dest[0] = src[startIndex + 3];  				dest[1] = src[startIndex + 2];  				dest[2] = src[startIndex + 1];  				dest[3] = src[startIndex];  			}
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,Load32BitValue,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				dest[0] = src[startIndex];  				dest[1] = src[startIndex + 1];  				dest[2] = src[startIndex + 2];  				dest[3] = src[startIndex + 3];  			} else {  				dest[0] = src[startIndex + 3];  				dest[1] = src[startIndex + 2];  				dest[2] = src[startIndex + 1];  				dest[3] = src[startIndex];  			}
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,Load32BitValue,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				dest[0] = src[startIndex];  				dest[1] = src[startIndex + 1];  				dest[2] = src[startIndex + 2];  				dest[3] = src[startIndex + 3];  			} else {  				dest[0] = src[startIndex + 3];  				dest[1] = src[startIndex + 2];  				dest[2] = src[startIndex + 1];  				dest[3] = src[startIndex];  			}
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,Load32BitValue,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				dest[0] = src[startIndex];  				dest[1] = src[startIndex + 1];  				dest[2] = src[startIndex + 2];  				dest[3] = src[startIndex + 3];  			} else {  				dest[0] = src[startIndex + 3];  				dest[1] = src[startIndex + 2];  				dest[2] = src[startIndex + 1];  				dest[3] = src[startIndex];  			}
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,Load32BitValue,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				dest[0] = src[startIndex];  				dest[1] = src[startIndex + 1];  				dest[2] = src[startIndex + 2];  				dest[3] = src[startIndex + 3];  			} else {  				dest[0] = src[startIndex + 3];  				dest[1] = src[startIndex + 2];  				dest[2] = src[startIndex + 1];  				dest[3] = src[startIndex];  			}
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,Load32BitValue,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				dest[0] = src[startIndex];  				dest[1] = src[startIndex + 1];  				dest[2] = src[startIndex + 2];  				dest[3] = src[startIndex + 3];  			} else {  				dest[0] = src[startIndex + 3];  				dest[1] = src[startIndex + 2];  				dest[2] = src[startIndex + 1];  				dest[3] = src[startIndex];  			}
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,Load32BitValue,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				dest[0] = src[startIndex];  				dest[1] = src[startIndex + 1];  				dest[2] = src[startIndex + 2];  				dest[3] = src[startIndex + 3];  			} else {  				dest[0] = src[startIndex + 3];  				dest[1] = src[startIndex + 2];  				dest[2] = src[startIndex + 1];  				dest[3] = src[startIndex];  			}
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,Load64BitValue,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				for (int i = 0; i < 8; i++)  					dest[i] = src[startIndex + i];  			} else {  				for (int i = 0; i < 8; i++)  					dest[i] = src[startIndex + (7 - i)];  			}
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,Load64BitValue,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				for (int i = 0; i < 8; i++)  					dest[i] = src[startIndex + i];  			} else {  				for (int i = 0; i < 8; i++)  					dest[i] = src[startIndex + (7 - i)];  			}
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,Load64BitValue,The following statement contains a magic number: if (BitConverter.IsLittleEndian) {  				for (int i = 0; i < 8; i++)  					dest[i] = src[startIndex + i];  			} else {  				for (int i = 0; i < 8; i++)  					dest[i] = src[startIndex + (7 - i)];  			}
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,ReadInt16,The following statement contains a magic number: if (ReadAhead (2) < 2)  				throw new EndOfStreamException ();
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,ReadInt16,The following statement contains a magic number: if (ReadAhead (2) < 2)  				throw new EndOfStreamException ();
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,ReadInt16,The following statement contains a magic number: UpdateChecksum (input' inputIndex' 2);
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,ReadInt16,The following statement contains a magic number: return (short) (input[inputIndex++] | (input[inputIndex++] << 8));
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,ReadInt32,The following statement contains a magic number: if (ReadAhead (4) < 4)  				throw new EndOfStreamException ();
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,ReadInt32,The following statement contains a magic number: if (ReadAhead (4) < 4)  				throw new EndOfStreamException ();
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,ReadInt32,The following statement contains a magic number: UpdateChecksum (input' inputIndex' 4);
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,ReadInt32,The following statement contains a magic number: return input[inputIndex++] | (input[inputIndex++] << 8) |  				(input[inputIndex++] << 16) | (input[inputIndex++] << 24);
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,ReadInt32,The following statement contains a magic number: return input[inputIndex++] | (input[inputIndex++] << 8) |  				(input[inputIndex++] << 16) | (input[inputIndex++] << 24);
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,ReadInt32,The following statement contains a magic number: return input[inputIndex++] | (input[inputIndex++] << 8) |  				(input[inputIndex++] << 16) | (input[inputIndex++] << 24);
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,PeekInt32,The following statement contains a magic number: if (ReadAhead (4) < 4)  				throw new EndOfStreamException ();
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,PeekInt32,The following statement contains a magic number: if (ReadAhead (4) < 4)  				throw new EndOfStreamException ();
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,PeekInt32,The following statement contains a magic number: return input[inputIndex] | (input[inputIndex + 1] << 8) |  				(input[inputIndex + 2] << 16) | (input[inputIndex + 3] << 24);
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,PeekInt32,The following statement contains a magic number: return input[inputIndex] | (input[inputIndex + 1] << 8) |  				(input[inputIndex + 2] << 16) | (input[inputIndex + 3] << 24);
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,PeekInt32,The following statement contains a magic number: return input[inputIndex] | (input[inputIndex + 1] << 8) |  				(input[inputIndex + 2] << 16) | (input[inputIndex + 3] << 24);
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,PeekInt32,The following statement contains a magic number: return input[inputIndex] | (input[inputIndex + 1] << 8) |  				(input[inputIndex + 2] << 16) | (input[inputIndex + 3] << 24);
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,PeekInt32,The following statement contains a magic number: return input[inputIndex] | (input[inputIndex + 1] << 8) |  				(input[inputIndex + 2] << 16) | (input[inputIndex + 3] << 24);
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,ReadInt64,The following statement contains a magic number: if (ReadAhead (8) < 8)  				throw new EndOfStreamException ();
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,ReadInt64,The following statement contains a magic number: if (ReadAhead (8) < 8)  				throw new EndOfStreamException ();
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,ReadInt64,The following statement contains a magic number: UpdateChecksum (input' inputIndex' 8);
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,ReadInt64,The following statement contains a magic number: inputIndex += 8;
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,ReadSingle,The following statement contains a magic number: if (ReadAhead (4) < 4)  				throw new EndOfStreamException ();
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,ReadSingle,The following statement contains a magic number: if (ReadAhead (4) < 4)  				throw new EndOfStreamException ();
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,ReadSingle,The following statement contains a magic number: UpdateChecksum (input' inputIndex' 4);
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,ReadSingle,The following statement contains a magic number: inputIndex += 4;
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,ReadDouble,The following statement contains a magic number: if (ReadAhead (8) < 8)  				throw new EndOfStreamException ();
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,ReadDouble,The following statement contains a magic number: if (ReadAhead (8) < 8)  				throw new EndOfStreamException ();
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,ReadDouble,The following statement contains a magic number: UpdateChecksum (input' inputIndex' 8);
Magic Number,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,ReadDouble,The following statement contains a magic number: inputIndex += 8;
Magic Number,MimeKit.Utils,ByteExtensions,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\ByteExtensions.cs,SetFlags,The following statement contains a magic number: if (remove) {  				for (i = 0; i < 128; i++)  					table[i] |= bit;    				for (i = 0; i < values.Length; i++)  					table[values[i]] &= ~bit;    				if (bitcopy != CharType.None) {  					for (i = 0; i < 256; i++) {  						if ((table[i] & bitcopy) != 0)  							table[i] &= ~bit;  					}  				}  			} else {  				for (i = 0; i < values.Length; i++)  					table[values[i]] |= bit;    				if (bitcopy != CharType.None) {  					for (i = 0; i < 256; i++) {  						if ((table[i] & bitcopy) != 0)  							table[i] |= bit;  					}  				}  			}
Magic Number,MimeKit.Utils,ByteExtensions,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\ByteExtensions.cs,SetFlags,The following statement contains a magic number: if (remove) {  				for (i = 0; i < 128; i++)  					table[i] |= bit;    				for (i = 0; i < values.Length; i++)  					table[values[i]] &= ~bit;    				if (bitcopy != CharType.None) {  					for (i = 0; i < 256; i++) {  						if ((table[i] & bitcopy) != 0)  							table[i] &= ~bit;  					}  				}  			} else {  				for (i = 0; i < values.Length; i++)  					table[values[i]] |= bit;    				if (bitcopy != CharType.None) {  					for (i = 0; i < 256; i++) {  						if ((table[i] & bitcopy) != 0)  							table[i] |= bit;  					}  				}  			}
Magic Number,MimeKit.Utils,ByteExtensions,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\ByteExtensions.cs,SetFlags,The following statement contains a magic number: if (remove) {  				for (i = 0; i < 128; i++)  					table[i] |= bit;    				for (i = 0; i < values.Length; i++)  					table[values[i]] &= ~bit;    				if (bitcopy != CharType.None) {  					for (i = 0; i < 256; i++) {  						if ((table[i] & bitcopy) != 0)  							table[i] &= ~bit;  					}  				}  			} else {  				for (i = 0; i < values.Length; i++)  					table[values[i]] |= bit;    				if (bitcopy != CharType.None) {  					for (i = 0; i < 256; i++) {  						if ((table[i] & bitcopy) != 0)  							table[i] |= bit;  					}  				}  			}
Magic Number,MimeKit.Utils,ByteExtensions,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\ByteExtensions.cs,ByteExtensions,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  				if (i < 127) {  					if (i < 32)  						table[i] |= CharType.IsControl;  					if (i > 32)  						table[i] |= CharType.IsAttrChar;  					if ((i >= 33 && i <= 60) || (i >= 62 && i <= 126) || i == 32)  						table[i] |= (CharType.IsQuotedPrintableSafe | CharType.IsEncodedWordSafe);  					if ((i >= '0' && i <= '9') || (i >= 'a' && i <= 'z') || (i >= 'A' && i <= 'Z'))  						table[i] |= CharType.IsEncodedPhraseSafe | CharType.IsAtom;  					if ((i >= '0' && i <= '9') || (i >= 'a' && i <= 'f') || (i >= 'A' && i <= 'F'))  						table[i] |= CharType.IsXDigit;    					table[i] |= CharType.IsAscii;  				} else {  					if (i == 127)  						table[i] |= CharType.IsAscii;  					else  						table[i] |= CharType.IsAtom;    					table[i] |= CharType.IsControl;  				}  			}
Magic Number,MimeKit.Utils,ByteExtensions,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\ByteExtensions.cs,ByteExtensions,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  				if (i < 127) {  					if (i < 32)  						table[i] |= CharType.IsControl;  					if (i > 32)  						table[i] |= CharType.IsAttrChar;  					if ((i >= 33 && i <= 60) || (i >= 62 && i <= 126) || i == 32)  						table[i] |= (CharType.IsQuotedPrintableSafe | CharType.IsEncodedWordSafe);  					if ((i >= '0' && i <= '9') || (i >= 'a' && i <= 'z') || (i >= 'A' && i <= 'Z'))  						table[i] |= CharType.IsEncodedPhraseSafe | CharType.IsAtom;  					if ((i >= '0' && i <= '9') || (i >= 'a' && i <= 'f') || (i >= 'A' && i <= 'F'))  						table[i] |= CharType.IsXDigit;    					table[i] |= CharType.IsAscii;  				} else {  					if (i == 127)  						table[i] |= CharType.IsAscii;  					else  						table[i] |= CharType.IsAtom;    					table[i] |= CharType.IsControl;  				}  			}
Magic Number,MimeKit.Utils,ByteExtensions,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\ByteExtensions.cs,ByteExtensions,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  				if (i < 127) {  					if (i < 32)  						table[i] |= CharType.IsControl;  					if (i > 32)  						table[i] |= CharType.IsAttrChar;  					if ((i >= 33 && i <= 60) || (i >= 62 && i <= 126) || i == 32)  						table[i] |= (CharType.IsQuotedPrintableSafe | CharType.IsEncodedWordSafe);  					if ((i >= '0' && i <= '9') || (i >= 'a' && i <= 'z') || (i >= 'A' && i <= 'Z'))  						table[i] |= CharType.IsEncodedPhraseSafe | CharType.IsAtom;  					if ((i >= '0' && i <= '9') || (i >= 'a' && i <= 'f') || (i >= 'A' && i <= 'F'))  						table[i] |= CharType.IsXDigit;    					table[i] |= CharType.IsAscii;  				} else {  					if (i == 127)  						table[i] |= CharType.IsAscii;  					else  						table[i] |= CharType.IsAtom;    					table[i] |= CharType.IsControl;  				}  			}
Magic Number,MimeKit.Utils,ByteExtensions,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\ByteExtensions.cs,ByteExtensions,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  				if (i < 127) {  					if (i < 32)  						table[i] |= CharType.IsControl;  					if (i > 32)  						table[i] |= CharType.IsAttrChar;  					if ((i >= 33 && i <= 60) || (i >= 62 && i <= 126) || i == 32)  						table[i] |= (CharType.IsQuotedPrintableSafe | CharType.IsEncodedWordSafe);  					if ((i >= '0' && i <= '9') || (i >= 'a' && i <= 'z') || (i >= 'A' && i <= 'Z'))  						table[i] |= CharType.IsEncodedPhraseSafe | CharType.IsAtom;  					if ((i >= '0' && i <= '9') || (i >= 'a' && i <= 'f') || (i >= 'A' && i <= 'F'))  						table[i] |= CharType.IsXDigit;    					table[i] |= CharType.IsAscii;  				} else {  					if (i == 127)  						table[i] |= CharType.IsAscii;  					else  						table[i] |= CharType.IsAtom;    					table[i] |= CharType.IsControl;  				}  			}
Magic Number,MimeKit.Utils,ByteExtensions,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\ByteExtensions.cs,ByteExtensions,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  				if (i < 127) {  					if (i < 32)  						table[i] |= CharType.IsControl;  					if (i > 32)  						table[i] |= CharType.IsAttrChar;  					if ((i >= 33 && i <= 60) || (i >= 62 && i <= 126) || i == 32)  						table[i] |= (CharType.IsQuotedPrintableSafe | CharType.IsEncodedWordSafe);  					if ((i >= '0' && i <= '9') || (i >= 'a' && i <= 'z') || (i >= 'A' && i <= 'Z'))  						table[i] |= CharType.IsEncodedPhraseSafe | CharType.IsAtom;  					if ((i >= '0' && i <= '9') || (i >= 'a' && i <= 'f') || (i >= 'A' && i <= 'F'))  						table[i] |= CharType.IsXDigit;    					table[i] |= CharType.IsAscii;  				} else {  					if (i == 127)  						table[i] |= CharType.IsAscii;  					else  						table[i] |= CharType.IsAtom;    					table[i] |= CharType.IsControl;  				}  			}
Magic Number,MimeKit.Utils,ByteExtensions,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\ByteExtensions.cs,ByteExtensions,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  				if (i < 127) {  					if (i < 32)  						table[i] |= CharType.IsControl;  					if (i > 32)  						table[i] |= CharType.IsAttrChar;  					if ((i >= 33 && i <= 60) || (i >= 62 && i <= 126) || i == 32)  						table[i] |= (CharType.IsQuotedPrintableSafe | CharType.IsEncodedWordSafe);  					if ((i >= '0' && i <= '9') || (i >= 'a' && i <= 'z') || (i >= 'A' && i <= 'Z'))  						table[i] |= CharType.IsEncodedPhraseSafe | CharType.IsAtom;  					if ((i >= '0' && i <= '9') || (i >= 'a' && i <= 'f') || (i >= 'A' && i <= 'F'))  						table[i] |= CharType.IsXDigit;    					table[i] |= CharType.IsAscii;  				} else {  					if (i == 127)  						table[i] |= CharType.IsAscii;  					else  						table[i] |= CharType.IsAtom;    					table[i] |= CharType.IsControl;  				}  			}
Magic Number,MimeKit.Utils,ByteExtensions,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\ByteExtensions.cs,ByteExtensions,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  				if (i < 127) {  					if (i < 32)  						table[i] |= CharType.IsControl;  					if (i > 32)  						table[i] |= CharType.IsAttrChar;  					if ((i >= 33 && i <= 60) || (i >= 62 && i <= 126) || i == 32)  						table[i] |= (CharType.IsQuotedPrintableSafe | CharType.IsEncodedWordSafe);  					if ((i >= '0' && i <= '9') || (i >= 'a' && i <= 'z') || (i >= 'A' && i <= 'Z'))  						table[i] |= CharType.IsEncodedPhraseSafe | CharType.IsAtom;  					if ((i >= '0' && i <= '9') || (i >= 'a' && i <= 'f') || (i >= 'A' && i <= 'F'))  						table[i] |= CharType.IsXDigit;    					table[i] |= CharType.IsAscii;  				} else {  					if (i == 127)  						table[i] |= CharType.IsAscii;  					else  						table[i] |= CharType.IsAtom;    					table[i] |= CharType.IsControl;  				}  			}
Magic Number,MimeKit.Utils,ByteExtensions,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\ByteExtensions.cs,ByteExtensions,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  				if (i < 127) {  					if (i < 32)  						table[i] |= CharType.IsControl;  					if (i > 32)  						table[i] |= CharType.IsAttrChar;  					if ((i >= 33 && i <= 60) || (i >= 62 && i <= 126) || i == 32)  						table[i] |= (CharType.IsQuotedPrintableSafe | CharType.IsEncodedWordSafe);  					if ((i >= '0' && i <= '9') || (i >= 'a' && i <= 'z') || (i >= 'A' && i <= 'Z'))  						table[i] |= CharType.IsEncodedPhraseSafe | CharType.IsAtom;  					if ((i >= '0' && i <= '9') || (i >= 'a' && i <= 'f') || (i >= 'A' && i <= 'F'))  						table[i] |= CharType.IsXDigit;    					table[i] |= CharType.IsAscii;  				} else {  					if (i == 127)  						table[i] |= CharType.IsAscii;  					else  						table[i] |= CharType.IsAtom;    					table[i] |= CharType.IsControl;  				}  			}
Magic Number,MimeKit.Utils,ByteExtensions,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\ByteExtensions.cs,ByteExtensions,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  				if (i < 127) {  					if (i < 32)  						table[i] |= CharType.IsControl;  					if (i > 32)  						table[i] |= CharType.IsAttrChar;  					if ((i >= 33 && i <= 60) || (i >= 62 && i <= 126) || i == 32)  						table[i] |= (CharType.IsQuotedPrintableSafe | CharType.IsEncodedWordSafe);  					if ((i >= '0' && i <= '9') || (i >= 'a' && i <= 'z') || (i >= 'A' && i <= 'Z'))  						table[i] |= CharType.IsEncodedPhraseSafe | CharType.IsAtom;  					if ((i >= '0' && i <= '9') || (i >= 'a' && i <= 'f') || (i >= 'A' && i <= 'F'))  						table[i] |= CharType.IsXDigit;    					table[i] |= CharType.IsAscii;  				} else {  					if (i == 127)  						table[i] |= CharType.IsAscii;  					else  						table[i] |= CharType.IsAtom;    					table[i] |= CharType.IsControl;  				}  			}
Magic Number,MimeKit.Utils,ByteExtensions,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\ByteExtensions.cs,ByteExtensions,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  				if (i < 127) {  					if (i < 32)  						table[i] |= CharType.IsControl;  					if (i > 32)  						table[i] |= CharType.IsAttrChar;  					if ((i >= 33 && i <= 60) || (i >= 62 && i <= 126) || i == 32)  						table[i] |= (CharType.IsQuotedPrintableSafe | CharType.IsEncodedWordSafe);  					if ((i >= '0' && i <= '9') || (i >= 'a' && i <= 'z') || (i >= 'A' && i <= 'Z'))  						table[i] |= CharType.IsEncodedPhraseSafe | CharType.IsAtom;  					if ((i >= '0' && i <= '9') || (i >= 'a' && i <= 'f') || (i >= 'A' && i <= 'F'))  						table[i] |= CharType.IsXDigit;    					table[i] |= CharType.IsAscii;  				} else {  					if (i == 127)  						table[i] |= CharType.IsAscii;  					else  						table[i] |= CharType.IsAtom;    					table[i] |= CharType.IsControl;  				}  			}
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,CharsetUtils,The following statement contains a magic number: AddAliases (65001' -1' "utf-8"' "utf8");
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,CharsetUtils,The following statement contains a magic number: AddAliases (20127' -1' "ansi_x3.4-1968");
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,CharsetUtils,The following statement contains a magic number: AddAliases (28591' -1' "ansi_x3.110-1983"' "latin1");
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,CharsetUtils,The following statement contains a magic number: AddAliases (10000' -1' "macintosh");
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,CharsetUtils,The following statement contains a magic number: AddAliases (10079' -1' "x-mac-icelandic");
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,CharsetUtils,The following statement contains a magic number: AddAliases (51949' -1'  				"ks_c_5601-1987"'  				"ksc-5601-1987"'  				"ksc-5601_1987"'  				"ksc-5601"'  				"5601"'  				"ks_c_5861-1992"'  				"ksc-5861-1992"'  				"ksc-5861_1992"'  				"euckr-0"'  				"euc-kr");
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,CharsetUtils,The following statement contains a magic number: AddAliases (950' -1' "big5"' "big5-0"' "big5-hkscs"' "big5.eten-0"' "big5hkscs-0");
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,CharsetUtils,The following statement contains a magic number: gb2312 = AddAliases (936' -1' "gb2312"' "gb-2312"' "gb2312-0"' "gb2312-80"' "gb2312.1980-0");
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,CharsetUtils,The following statement contains a magic number: AddAliases (51936' gb2312' "euc-cn"' "gbk-0"' "x-gbk"' "gbk");
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,CharsetUtils,The following statement contains a magic number: AddAliases (52936' gb2312' "hz-gb-2312"' "hz-gb2312");
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,CharsetUtils,The following statement contains a magic number: AddAliases (54936' -1' "gb18030-0"' "gb18030");
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,CharsetUtils,The following statement contains a magic number: AddAliases (51932' -1' "eucjp-0"' "euc-jp"' "ujis-0"' "ujis");
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,CharsetUtils,The following statement contains a magic number: AddAliases (932' -1' "jisx0208.1983-0"' "jisx0212.1990-0"' "pck");
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,GetMimeCharset,The following statement contains a magic number: switch (encoding.CodePage) {  			case 949: // ks_c_5601-1987  				return "euc-kr";  			default:  				return encoding.HeaderName.ToLowerInvariant ();  			}
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ParseIsoCodePage,The following statement contains a magic number: if (charset.Length < 6)  				return -1;
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ParseIsoCodePage,The following statement contains a magic number: if (iso == 10646)  				return 1201;
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ParseIsoCodePage,The following statement contains a magic number: if (iso == 10646)  				return 1201;
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ParseIsoCodePage,The following statement contains a magic number: if (dash + 2 > charset.Length)  				return -1;
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ParseIsoCodePage,The following statement contains a magic number: switch (iso) {  			case 8859:  				if (!int.TryParse (suffix' out codepage))  					return -1;    				if (codepage <= 0 || (codepage > 9 && codepage < 13) || codepage > 15)  					return -1;    				codepage += 28590;  				break;  			case 2022:  				switch (suffix.ToLowerInvariant ()) {  				case "jp":  					codepage = 50220;  					break;  				case "kr":  					codepage = 50225;  					break;  				default:  					return -1;  				}  				break;  			default:  				return -1;  			}
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ParseIsoCodePage,The following statement contains a magic number: switch (iso) {  			case 8859:  				if (!int.TryParse (suffix' out codepage))  					return -1;    				if (codepage <= 0 || (codepage > 9 && codepage < 13) || codepage > 15)  					return -1;    				codepage += 28590;  				break;  			case 2022:  				switch (suffix.ToLowerInvariant ()) {  				case "jp":  					codepage = 50220;  					break;  				case "kr":  					codepage = 50225;  					break;  				default:  					return -1;  				}  				break;  			default:  				return -1;  			}
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ParseIsoCodePage,The following statement contains a magic number: switch (iso) {  			case 8859:  				if (!int.TryParse (suffix' out codepage))  					return -1;    				if (codepage <= 0 || (codepage > 9 && codepage < 13) || codepage > 15)  					return -1;    				codepage += 28590;  				break;  			case 2022:  				switch (suffix.ToLowerInvariant ()) {  				case "jp":  					codepage = 50220;  					break;  				case "kr":  					codepage = 50225;  					break;  				default:  					return -1;  				}  				break;  			default:  				return -1;  			}
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ParseIsoCodePage,The following statement contains a magic number: switch (iso) {  			case 8859:  				if (!int.TryParse (suffix' out codepage))  					return -1;    				if (codepage <= 0 || (codepage > 9 && codepage < 13) || codepage > 15)  					return -1;    				codepage += 28590;  				break;  			case 2022:  				switch (suffix.ToLowerInvariant ()) {  				case "jp":  					codepage = 50220;  					break;  				case "kr":  					codepage = 50225;  					break;  				default:  					return -1;  				}  				break;  			default:  				return -1;  			}
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ParseIsoCodePage,The following statement contains a magic number: switch (iso) {  			case 8859:  				if (!int.TryParse (suffix' out codepage))  					return -1;    				if (codepage <= 0 || (codepage > 9 && codepage < 13) || codepage > 15)  					return -1;    				codepage += 28590;  				break;  			case 2022:  				switch (suffix.ToLowerInvariant ()) {  				case "jp":  					codepage = 50220;  					break;  				case "kr":  					codepage = 50225;  					break;  				default:  					return -1;  				}  				break;  			default:  				return -1;  			}
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ParseIsoCodePage,The following statement contains a magic number: switch (iso) {  			case 8859:  				if (!int.TryParse (suffix' out codepage))  					return -1;    				if (codepage <= 0 || (codepage > 9 && codepage < 13) || codepage > 15)  					return -1;    				codepage += 28590;  				break;  			case 2022:  				switch (suffix.ToLowerInvariant ()) {  				case "jp":  					codepage = 50220;  					break;  				case "kr":  					codepage = 50225;  					break;  				default:  					return -1;  				}  				break;  			default:  				return -1;  			}
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ParseIsoCodePage,The following statement contains a magic number: switch (iso) {  			case 8859:  				if (!int.TryParse (suffix' out codepage))  					return -1;    				if (codepage <= 0 || (codepage > 9 && codepage < 13) || codepage > 15)  					return -1;    				codepage += 28590;  				break;  			case 2022:  				switch (suffix.ToLowerInvariant ()) {  				case "jp":  					codepage = 50220;  					break;  				case "kr":  					codepage = 50225;  					break;  				default:  					return -1;  				}  				break;  			default:  				return -1;  			}
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ParseIsoCodePage,The following statement contains a magic number: switch (iso) {  			case 8859:  				if (!int.TryParse (suffix' out codepage))  					return -1;    				if (codepage <= 0 || (codepage > 9 && codepage < 13) || codepage > 15)  					return -1;    				codepage += 28590;  				break;  			case 2022:  				switch (suffix.ToLowerInvariant ()) {  				case "jp":  					codepage = 50220;  					break;  				case "kr":  					codepage = 50225;  					break;  				default:  					return -1;  				}  				break;  			default:  				return -1;  			}
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ParseCodePage,The following statement contains a magic number: if (charset.StartsWith ("windows"' StringComparison.OrdinalIgnoreCase)) {  				i = 7;    				if (i == charset.Length)  					return -1;    				if (charset[i] == '-' || charset[i] == '_') {  					if (i + 1 == charset.Length)  						return -1;    					i++;  				}    				if (i + 2 < charset.Length && charset[i] == 'c' && charset[i + 1] == 'p')  					i += 2;    				if (int.TryParse (charset.Substring (i)' out codepage))  					return codepage;  			} else if (charset.StartsWith ("ibm"' StringComparison.OrdinalIgnoreCase)) {  				i = 3;    				if (i == charset.Length)  					return -1;    				if (charset[i] == '-' || charset[i] == '_')  					i++;    				if (int.TryParse (charset.Substring (i)' out codepage))  					return codepage;  			} else if (charset.StartsWith ("iso"' StringComparison.OrdinalIgnoreCase)) {  				i = 3;    				if (i == charset.Length)  					return -1;    				if (charset[i] == '-' || charset[i] == '_')  					i++;    				if ((codepage = ParseIsoCodePage (charset.Substring (i))) != -1)  					return codepage;  			} else if (charset.StartsWith ("cp"' StringComparison.OrdinalIgnoreCase)) {  				i = 2;    				if (i == charset.Length)  					return -1;    				if (charset[i] == '-' || charset[i] == '_')  					i++;    				if (int.TryParse (charset.Substring (i)' out codepage))  					return codepage;  			} else if (charset == "latin1") {  				return 28591;  			}
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ParseCodePage,The following statement contains a magic number: if (charset.StartsWith ("windows"' StringComparison.OrdinalIgnoreCase)) {  				i = 7;    				if (i == charset.Length)  					return -1;    				if (charset[i] == '-' || charset[i] == '_') {  					if (i + 1 == charset.Length)  						return -1;    					i++;  				}    				if (i + 2 < charset.Length && charset[i] == 'c' && charset[i + 1] == 'p')  					i += 2;    				if (int.TryParse (charset.Substring (i)' out codepage))  					return codepage;  			} else if (charset.StartsWith ("ibm"' StringComparison.OrdinalIgnoreCase)) {  				i = 3;    				if (i == charset.Length)  					return -1;    				if (charset[i] == '-' || charset[i] == '_')  					i++;    				if (int.TryParse (charset.Substring (i)' out codepage))  					return codepage;  			} else if (charset.StartsWith ("iso"' StringComparison.OrdinalIgnoreCase)) {  				i = 3;    				if (i == charset.Length)  					return -1;    				if (charset[i] == '-' || charset[i] == '_')  					i++;    				if ((codepage = ParseIsoCodePage (charset.Substring (i))) != -1)  					return codepage;  			} else if (charset.StartsWith ("cp"' StringComparison.OrdinalIgnoreCase)) {  				i = 2;    				if (i == charset.Length)  					return -1;    				if (charset[i] == '-' || charset[i] == '_')  					i++;    				if (int.TryParse (charset.Substring (i)' out codepage))  					return codepage;  			} else if (charset == "latin1") {  				return 28591;  			}
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ParseCodePage,The following statement contains a magic number: if (charset.StartsWith ("windows"' StringComparison.OrdinalIgnoreCase)) {  				i = 7;    				if (i == charset.Length)  					return -1;    				if (charset[i] == '-' || charset[i] == '_') {  					if (i + 1 == charset.Length)  						return -1;    					i++;  				}    				if (i + 2 < charset.Length && charset[i] == 'c' && charset[i + 1] == 'p')  					i += 2;    				if (int.TryParse (charset.Substring (i)' out codepage))  					return codepage;  			} else if (charset.StartsWith ("ibm"' StringComparison.OrdinalIgnoreCase)) {  				i = 3;    				if (i == charset.Length)  					return -1;    				if (charset[i] == '-' || charset[i] == '_')  					i++;    				if (int.TryParse (charset.Substring (i)' out codepage))  					return codepage;  			} else if (charset.StartsWith ("iso"' StringComparison.OrdinalIgnoreCase)) {  				i = 3;    				if (i == charset.Length)  					return -1;    				if (charset[i] == '-' || charset[i] == '_')  					i++;    				if ((codepage = ParseIsoCodePage (charset.Substring (i))) != -1)  					return codepage;  			} else if (charset.StartsWith ("cp"' StringComparison.OrdinalIgnoreCase)) {  				i = 2;    				if (i == charset.Length)  					return -1;    				if (charset[i] == '-' || charset[i] == '_')  					i++;    				if (int.TryParse (charset.Substring (i)' out codepage))  					return codepage;  			} else if (charset == "latin1") {  				return 28591;  			}
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ParseCodePage,The following statement contains a magic number: if (charset.StartsWith ("windows"' StringComparison.OrdinalIgnoreCase)) {  				i = 7;    				if (i == charset.Length)  					return -1;    				if (charset[i] == '-' || charset[i] == '_') {  					if (i + 1 == charset.Length)  						return -1;    					i++;  				}    				if (i + 2 < charset.Length && charset[i] == 'c' && charset[i + 1] == 'p')  					i += 2;    				if (int.TryParse (charset.Substring (i)' out codepage))  					return codepage;  			} else if (charset.StartsWith ("ibm"' StringComparison.OrdinalIgnoreCase)) {  				i = 3;    				if (i == charset.Length)  					return -1;    				if (charset[i] == '-' || charset[i] == '_')  					i++;    				if (int.TryParse (charset.Substring (i)' out codepage))  					return codepage;  			} else if (charset.StartsWith ("iso"' StringComparison.OrdinalIgnoreCase)) {  				i = 3;    				if (i == charset.Length)  					return -1;    				if (charset[i] == '-' || charset[i] == '_')  					i++;    				if ((codepage = ParseIsoCodePage (charset.Substring (i))) != -1)  					return codepage;  			} else if (charset.StartsWith ("cp"' StringComparison.OrdinalIgnoreCase)) {  				i = 2;    				if (i == charset.Length)  					return -1;    				if (charset[i] == '-' || charset[i] == '_')  					i++;    				if (int.TryParse (charset.Substring (i)' out codepage))  					return codepage;  			} else if (charset == "latin1") {  				return 28591;  			}
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ParseCodePage,The following statement contains a magic number: if (charset.StartsWith ("windows"' StringComparison.OrdinalIgnoreCase)) {  				i = 7;    				if (i == charset.Length)  					return -1;    				if (charset[i] == '-' || charset[i] == '_') {  					if (i + 1 == charset.Length)  						return -1;    					i++;  				}    				if (i + 2 < charset.Length && charset[i] == 'c' && charset[i + 1] == 'p')  					i += 2;    				if (int.TryParse (charset.Substring (i)' out codepage))  					return codepage;  			} else if (charset.StartsWith ("ibm"' StringComparison.OrdinalIgnoreCase)) {  				i = 3;    				if (i == charset.Length)  					return -1;    				if (charset[i] == '-' || charset[i] == '_')  					i++;    				if (int.TryParse (charset.Substring (i)' out codepage))  					return codepage;  			} else if (charset.StartsWith ("iso"' StringComparison.OrdinalIgnoreCase)) {  				i = 3;    				if (i == charset.Length)  					return -1;    				if (charset[i] == '-' || charset[i] == '_')  					i++;    				if ((codepage = ParseIsoCodePage (charset.Substring (i))) != -1)  					return codepage;  			} else if (charset.StartsWith ("cp"' StringComparison.OrdinalIgnoreCase)) {  				i = 2;    				if (i == charset.Length)  					return -1;    				if (charset[i] == '-' || charset[i] == '_')  					i++;    				if (int.TryParse (charset.Substring (i)' out codepage))  					return codepage;  			} else if (charset == "latin1") {  				return 28591;  			}
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ParseCodePage,The following statement contains a magic number: if (charset.StartsWith ("windows"' StringComparison.OrdinalIgnoreCase)) {  				i = 7;    				if (i == charset.Length)  					return -1;    				if (charset[i] == '-' || charset[i] == '_') {  					if (i + 1 == charset.Length)  						return -1;    					i++;  				}    				if (i + 2 < charset.Length && charset[i] == 'c' && charset[i + 1] == 'p')  					i += 2;    				if (int.TryParse (charset.Substring (i)' out codepage))  					return codepage;  			} else if (charset.StartsWith ("ibm"' StringComparison.OrdinalIgnoreCase)) {  				i = 3;    				if (i == charset.Length)  					return -1;    				if (charset[i] == '-' || charset[i] == '_')  					i++;    				if (int.TryParse (charset.Substring (i)' out codepage))  					return codepage;  			} else if (charset.StartsWith ("iso"' StringComparison.OrdinalIgnoreCase)) {  				i = 3;    				if (i == charset.Length)  					return -1;    				if (charset[i] == '-' || charset[i] == '_')  					i++;    				if ((codepage = ParseIsoCodePage (charset.Substring (i))) != -1)  					return codepage;  			} else if (charset.StartsWith ("cp"' StringComparison.OrdinalIgnoreCase)) {  				i = 2;    				if (i == charset.Length)  					return -1;    				if (charset[i] == '-' || charset[i] == '_')  					i++;    				if (int.TryParse (charset.Substring (i)' out codepage))  					return codepage;  			} else if (charset == "latin1") {  				return 28591;  			}
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ParseCodePage,The following statement contains a magic number: if (charset.StartsWith ("windows"' StringComparison.OrdinalIgnoreCase)) {  				i = 7;    				if (i == charset.Length)  					return -1;    				if (charset[i] == '-' || charset[i] == '_') {  					if (i + 1 == charset.Length)  						return -1;    					i++;  				}    				if (i + 2 < charset.Length && charset[i] == 'c' && charset[i + 1] == 'p')  					i += 2;    				if (int.TryParse (charset.Substring (i)' out codepage))  					return codepage;  			} else if (charset.StartsWith ("ibm"' StringComparison.OrdinalIgnoreCase)) {  				i = 3;    				if (i == charset.Length)  					return -1;    				if (charset[i] == '-' || charset[i] == '_')  					i++;    				if (int.TryParse (charset.Substring (i)' out codepage))  					return codepage;  			} else if (charset.StartsWith ("iso"' StringComparison.OrdinalIgnoreCase)) {  				i = 3;    				if (i == charset.Length)  					return -1;    				if (charset[i] == '-' || charset[i] == '_')  					i++;    				if ((codepage = ParseIsoCodePage (charset.Substring (i))) != -1)  					return codepage;  			} else if (charset.StartsWith ("cp"' StringComparison.OrdinalIgnoreCase)) {  				i = 2;    				if (i == charset.Length)  					return -1;    				if (charset[i] == '-' || charset[i] == '_')  					i++;    				if (int.TryParse (charset.Substring (i)' out codepage))  					return codepage;  			} else if (charset == "latin1") {  				return 28591;  			}
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ConvertToUnicode,The following statement contains a magic number: if (userCharset != null && userCharset.CodePage != 65001 && userCharset.CodePage != 28591) {  				codepages = new [] { 65001' userCharset.CodePage' 28591 };  			} else {  				codepages = new [] { 65001' 28591 };  			}
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ConvertToUnicode,The following statement contains a magic number: if (userCharset != null && userCharset.CodePage != 65001 && userCharset.CodePage != 28591) {  				codepages = new [] { 65001' userCharset.CodePage' 28591 };  			} else {  				codepages = new [] { 65001' 28591 };  			}
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ConvertToUnicode,The following statement contains a magic number: if (userCharset != null && userCharset.CodePage != 65001 && userCharset.CodePage != 28591) {  				codepages = new [] { 65001' userCharset.CodePage' 28591 };  			} else {  				codepages = new [] { 65001' 28591 };  			}
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ConvertToUnicode,The following statement contains a magic number: if (userCharset != null && userCharset.CodePage != 65001 && userCharset.CodePage != 28591) {  				codepages = new [] { 65001' userCharset.CodePage' 28591 };  			} else {  				codepages = new [] { 65001' 28591 };  			}
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ConvertToUnicode,The following statement contains a magic number: if (userCharset != null && userCharset.CodePage != 65001 && userCharset.CodePage != 28591) {  				codepages = new [] { 65001' userCharset.CodePage' 28591 };  			} else {  				codepages = new [] { 65001' 28591 };  			}
Magic Number,MimeKit.Utils,CharsetUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\CharsetUtils.cs,ConvertToUnicode,The following statement contains a magic number: if (userCharset != null && userCharset.CodePage != 65001 && userCharset.CodePage != 28591) {  				codepages = new [] { 65001' userCharset.CodePage' 28591 };  			} else {  				codepages = new [] { 65001' 28591 };  			}
Magic Number,MimeKit.Utils,Crc32,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Crc32.cs,Update,The following statement contains a magic number: for (int i = offset; i < max; i++)  				crc = (int) Crc32Table[(crc ^ (int) buffer[i]) & 0xFF] ^ ((crc >> 8) & 0x00FFFFFF);
Magic Number,MimeKit.Utils,Crc32,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Crc32.cs,Update,The following statement contains a magic number: crc = (int) Crc32Table[(crc ^ (int) value) & 0xFF] ^ ((crc >> 8) & 0x00FFFFFF);
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: timezones = new Dictionary<string' int> {  				{ "UT"'       0 }' { "UTC"'      0 }' { "GMT"'      0 }'  				{ "EDT"'   -400 }' { "EST"'   -500 }'  				{ "CDT"'   -500 }' { "CST"'   -600 }'  				{ "MDT"'   -600 }' { "MST"'   -700 }'  				{ "PDT"'   -700 }' { "PST"'   -800 }'  				// Note: rfc822 got the signs backwards for the military  				// timezones so some sending clients may mistakenly use the  				// wrong values.  				{ "A"'      100 }' { "B"'      200 }' { "C"'      300 }'  				{ "D"'      400 }' { "E"'      500 }' { "F"'      600 }'  				{ "G"'      700 }' { "H"'      800 }' { "I"'      900 }'  				{ "K"'     1000 }' { "L"'     1100 }' { "M"'     1200 }'  				{ "N"'     -100 }' { "O"'     -200 }' { "P"'     -300 }'  				{ "Q"'     -400 }' { "R"'     -500 }' { "S"'     -600 }'  				{ "T"'     -700 }' { "U"'     -800 }' { "V"'     -900 }'  				{ "W"'    -1000 }' { "X"'    -1100 }' { "Y"'    -1200 }'  				{ "Z"'        0 }'  			};
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: datetok = new DateTokenFlags[256];
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: var any = new char[2];
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,DateUtils,The following statement contains a magic number: for (int c = 0; c < 256; c++) {  				if (c >= 0x41 && c <= 0x5a) {  					any[1] = (char) (c + 0x20);  					any[0] = (char) c;  				} else if (c >= 0x61 && c <= 0x7a) {  					any[0] = (char) (c - 0x20);  					any[1] = (char) c;  				}    				if (NumericZoneCharacters.IndexOf ((char) c) == -1)  					datetok[c] |= DateTokenFlags.NonNumericZone;  				if (AlphaZoneCharacters.IndexOf ((char) c) == -1)  					datetok[c] |= DateTokenFlags.NonAlphaZone;  				if (WeekdayCharacters.IndexOfAny (any) == -1)  					datetok[c] |= DateTokenFlags.NonWeekday;  				if (NumericCharacters.IndexOf ((char) c) == -1)  					datetok[c] |= DateTokenFlags.NonNumeric;  				if (MonthCharacters.IndexOfAny (any) == -1)  					datetok[c] |= DateTokenFlags.NonMonth;  				if (TimeCharacters.IndexOf ((char) c) == -1)  					datetok[c] |= DateTokenFlags.NonTime;  			}
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryGetWeekday,The following statement contains a magic number: if (!token.IsWeekday || token.Length < 3)  				return false;
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryGetWeekday,The following statement contains a magic number: if (name.Length > 3)  				name = name.Substring (0' 3);
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryGetWeekday,The following statement contains a magic number: if (name.Length > 3)  				name = name.Substring (0' 3);
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryGetDayOfMonth,The following statement contains a magic number: if (day <= 0 || day > 31)  				return false;
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryGetMonth,The following statement contains a magic number: if (!token.IsMonth || token.Length < 3)  				return false;
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryGetMonth,The following statement contains a magic number: if (name.Length > 3)  				name = name.Substring (0' 3);
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryGetMonth,The following statement contains a magic number: if (name.Length > 3)  				name = name.Substring (0' 3);
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryGetYear,The following statement contains a magic number: if (year < 100)  				year += (year < 70) ? 2000 : 1900;
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryGetYear,The following statement contains a magic number: if (year < 100)  				year += (year < 70) ? 2000 : 1900;
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryGetYear,The following statement contains a magic number: if (year < 100)  				year += (year < 70) ? 2000 : 1900;
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryGetYear,The following statement contains a magic number: if (year < 100)  				year += (year < 70) ? 2000 : 1900;
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryGetYear,The following statement contains a magic number: return year >= 1969;
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryGetTimeOfDay,The following statement contains a magic number: if (!ParseUtils.TryParseInt32 (text' ref index' endIndex' out hour) || hour > 23)  				return false;
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryGetTimeOfDay,The following statement contains a magic number: if (!ParseUtils.TryParseInt32 (text' ref index' endIndex' out minute) || minute > 59)  				return false;
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryGetTimeOfDay,The following statement contains a magic number: if (!ParseUtils.TryParseInt32 (text' ref index' endIndex' out second) || second > 59)  				return false;
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryGetTimeZone,The following statement contains a magic number: if (token.IsNumericZone) {  				if ((token.Flags & DateTokenFlags.HasSign) == 0)  					return false;    				int endIndex = token.StartIndex + token.Length;  				int index = token.StartIndex;  				int sign;    				if (text[index] == (byte) '-')  					sign = -1;  				else if (text[index] == (byte) '+')  					sign = 1;  				else  					return false;    				index++;    				if (!ParseUtils.TryParseInt32 (text' ref index' endIndex' out tzone) || index != endIndex)  					return false;    				tzone *= sign;  			} else if (token.IsAlphaZone) {  				if (token.Length > 3)  					return false;    				var name = Encoding.ASCII.GetString (text' token.StartIndex' token.Length);    				if (!timezones.TryGetValue (name' out tzone))  					return false;  			} else {  				return false;  			}
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryParseStandardDateFormat,The following statement contains a magic number: if (tokens.Count < 5)  				return false;
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryParseStandardDateFormat,The following statement contains a magic number: if (TryGetWeekday (tokens[n]' text' out weekday)) {  				if (tokens.Count < 6)  					return false;    				//haveWeekday = true;  				n++;  			}
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryParseStandardDateFormat,The following statement contains a magic number: while (tzone < -1400)  				tzone += 2400;
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryParseStandardDateFormat,The following statement contains a magic number: while (tzone < -1400)  				tzone += 2400;
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryParseStandardDateFormat,The following statement contains a magic number: while (tzone > 1400)  				tzone -= 2400;
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryParseStandardDateFormat,The following statement contains a magic number: while (tzone > 1400)  				tzone -= 2400;
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryParseStandardDateFormat,The following statement contains a magic number: int minutes = tzone % 100;
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryParseStandardDateFormat,The following statement contains a magic number: int hours = tzone / 100;
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryParseUnknownDateFormat,The following statement contains a magic number: for (int i = 0; i < tokens.Count; i++) {  				int value;    				if (!haveWeekday && tokens[i].IsWeekday) {  					if (TryGetWeekday (tokens[i]' text' out weekday)) {  						haveWeekday = true;  						continue;  					}  				}    				if ((month == null || numericMonth) && tokens[i].IsMonth) {  					if (TryGetMonth (tokens[i]' text' out value)) {  						if (numericMonth) {  							numericMonth = false;  							day = month;  						}    						month = value;  						continue;  					}  				}    				if (!haveTime && tokens[i].IsTimeOfDay) {  					if (TryGetTimeOfDay (tokens[i]' text' out hour' out minute' out second)) {  						haveTime = true;  						continue;  					}  				}    				if (tzone == null && tokens[i].IsTimeZone) {  					if (TryGetTimeZone (tokens[i]' text' out value)) {  						tzone = value;  						continue;  					}  				}    				if (tokens[i].IsNumeric) {  					if (tokens[i].Length == 4) {  						if (year == null && TryGetYear (tokens[i]' text' out value))  							year = value;    						continue;  					}    					if (tokens[i].Length > 2)  						continue;    					// Note: we likely have either YYYY[-/]MM[-/]DD or MM[-/]DD[-/]YY  					int endIndex = tokens[i].StartIndex + tokens[i].Length;  					int index = tokens[i].StartIndex;    					ParseUtils.TryParseInt32 (text' ref index' endIndex' out value);    					if (month == null && value > 0 && value <= 12) {  						numericMonth = true;  						month = value;  						continue;  					}    					if (day == null && value > 0 && value <= 31) {  						day = value;  						continue;  					}    					if (year == null && value >= 69) {  						year = 1900 + value;  						continue;  					}  				}    				// WTF is this??  			}
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryParseUnknownDateFormat,The following statement contains a magic number: for (int i = 0; i < tokens.Count; i++) {  				int value;    				if (!haveWeekday && tokens[i].IsWeekday) {  					if (TryGetWeekday (tokens[i]' text' out weekday)) {  						haveWeekday = true;  						continue;  					}  				}    				if ((month == null || numericMonth) && tokens[i].IsMonth) {  					if (TryGetMonth (tokens[i]' text' out value)) {  						if (numericMonth) {  							numericMonth = false;  							day = month;  						}    						month = value;  						continue;  					}  				}    				if (!haveTime && tokens[i].IsTimeOfDay) {  					if (TryGetTimeOfDay (tokens[i]' text' out hour' out minute' out second)) {  						haveTime = true;  						continue;  					}  				}    				if (tzone == null && tokens[i].IsTimeZone) {  					if (TryGetTimeZone (tokens[i]' text' out value)) {  						tzone = value;  						continue;  					}  				}    				if (tokens[i].IsNumeric) {  					if (tokens[i].Length == 4) {  						if (year == null && TryGetYear (tokens[i]' text' out value))  							year = value;    						continue;  					}    					if (tokens[i].Length > 2)  						continue;    					// Note: we likely have either YYYY[-/]MM[-/]DD or MM[-/]DD[-/]YY  					int endIndex = tokens[i].StartIndex + tokens[i].Length;  					int index = tokens[i].StartIndex;    					ParseUtils.TryParseInt32 (text' ref index' endIndex' out value);    					if (month == null && value > 0 && value <= 12) {  						numericMonth = true;  						month = value;  						continue;  					}    					if (day == null && value > 0 && value <= 31) {  						day = value;  						continue;  					}    					if (year == null && value >= 69) {  						year = 1900 + value;  						continue;  					}  				}    				// WTF is this??  			}
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryParseUnknownDateFormat,The following statement contains a magic number: for (int i = 0; i < tokens.Count; i++) {  				int value;    				if (!haveWeekday && tokens[i].IsWeekday) {  					if (TryGetWeekday (tokens[i]' text' out weekday)) {  						haveWeekday = true;  						continue;  					}  				}    				if ((month == null || numericMonth) && tokens[i].IsMonth) {  					if (TryGetMonth (tokens[i]' text' out value)) {  						if (numericMonth) {  							numericMonth = false;  							day = month;  						}    						month = value;  						continue;  					}  				}    				if (!haveTime && tokens[i].IsTimeOfDay) {  					if (TryGetTimeOfDay (tokens[i]' text' out hour' out minute' out second)) {  						haveTime = true;  						continue;  					}  				}    				if (tzone == null && tokens[i].IsTimeZone) {  					if (TryGetTimeZone (tokens[i]' text' out value)) {  						tzone = value;  						continue;  					}  				}    				if (tokens[i].IsNumeric) {  					if (tokens[i].Length == 4) {  						if (year == null && TryGetYear (tokens[i]' text' out value))  							year = value;    						continue;  					}    					if (tokens[i].Length > 2)  						continue;    					// Note: we likely have either YYYY[-/]MM[-/]DD or MM[-/]DD[-/]YY  					int endIndex = tokens[i].StartIndex + tokens[i].Length;  					int index = tokens[i].StartIndex;    					ParseUtils.TryParseInt32 (text' ref index' endIndex' out value);    					if (month == null && value > 0 && value <= 12) {  						numericMonth = true;  						month = value;  						continue;  					}    					if (day == null && value > 0 && value <= 31) {  						day = value;  						continue;  					}    					if (year == null && value >= 69) {  						year = 1900 + value;  						continue;  					}  				}    				// WTF is this??  			}
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryParseUnknownDateFormat,The following statement contains a magic number: for (int i = 0; i < tokens.Count; i++) {  				int value;    				if (!haveWeekday && tokens[i].IsWeekday) {  					if (TryGetWeekday (tokens[i]' text' out weekday)) {  						haveWeekday = true;  						continue;  					}  				}    				if ((month == null || numericMonth) && tokens[i].IsMonth) {  					if (TryGetMonth (tokens[i]' text' out value)) {  						if (numericMonth) {  							numericMonth = false;  							day = month;  						}    						month = value;  						continue;  					}  				}    				if (!haveTime && tokens[i].IsTimeOfDay) {  					if (TryGetTimeOfDay (tokens[i]' text' out hour' out minute' out second)) {  						haveTime = true;  						continue;  					}  				}    				if (tzone == null && tokens[i].IsTimeZone) {  					if (TryGetTimeZone (tokens[i]' text' out value)) {  						tzone = value;  						continue;  					}  				}    				if (tokens[i].IsNumeric) {  					if (tokens[i].Length == 4) {  						if (year == null && TryGetYear (tokens[i]' text' out value))  							year = value;    						continue;  					}    					if (tokens[i].Length > 2)  						continue;    					// Note: we likely have either YYYY[-/]MM[-/]DD or MM[-/]DD[-/]YY  					int endIndex = tokens[i].StartIndex + tokens[i].Length;  					int index = tokens[i].StartIndex;    					ParseUtils.TryParseInt32 (text' ref index' endIndex' out value);    					if (month == null && value > 0 && value <= 12) {  						numericMonth = true;  						month = value;  						continue;  					}    					if (day == null && value > 0 && value <= 31) {  						day = value;  						continue;  					}    					if (year == null && value >= 69) {  						year = 1900 + value;  						continue;  					}  				}    				// WTF is this??  			}
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryParseUnknownDateFormat,The following statement contains a magic number: for (int i = 0; i < tokens.Count; i++) {  				int value;    				if (!haveWeekday && tokens[i].IsWeekday) {  					if (TryGetWeekday (tokens[i]' text' out weekday)) {  						haveWeekday = true;  						continue;  					}  				}    				if ((month == null || numericMonth) && tokens[i].IsMonth) {  					if (TryGetMonth (tokens[i]' text' out value)) {  						if (numericMonth) {  							numericMonth = false;  							day = month;  						}    						month = value;  						continue;  					}  				}    				if (!haveTime && tokens[i].IsTimeOfDay) {  					if (TryGetTimeOfDay (tokens[i]' text' out hour' out minute' out second)) {  						haveTime = true;  						continue;  					}  				}    				if (tzone == null && tokens[i].IsTimeZone) {  					if (TryGetTimeZone (tokens[i]' text' out value)) {  						tzone = value;  						continue;  					}  				}    				if (tokens[i].IsNumeric) {  					if (tokens[i].Length == 4) {  						if (year == null && TryGetYear (tokens[i]' text' out value))  							year = value;    						continue;  					}    					if (tokens[i].Length > 2)  						continue;    					// Note: we likely have either YYYY[-/]MM[-/]DD or MM[-/]DD[-/]YY  					int endIndex = tokens[i].StartIndex + tokens[i].Length;  					int index = tokens[i].StartIndex;    					ParseUtils.TryParseInt32 (text' ref index' endIndex' out value);    					if (month == null && value > 0 && value <= 12) {  						numericMonth = true;  						month = value;  						continue;  					}    					if (day == null && value > 0 && value <= 31) {  						day = value;  						continue;  					}    					if (year == null && value >= 69) {  						year = 1900 + value;  						continue;  					}  				}    				// WTF is this??  			}
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryParseUnknownDateFormat,The following statement contains a magic number: for (int i = 0; i < tokens.Count; i++) {  				int value;    				if (!haveWeekday && tokens[i].IsWeekday) {  					if (TryGetWeekday (tokens[i]' text' out weekday)) {  						haveWeekday = true;  						continue;  					}  				}    				if ((month == null || numericMonth) && tokens[i].IsMonth) {  					if (TryGetMonth (tokens[i]' text' out value)) {  						if (numericMonth) {  							numericMonth = false;  							day = month;  						}    						month = value;  						continue;  					}  				}    				if (!haveTime && tokens[i].IsTimeOfDay) {  					if (TryGetTimeOfDay (tokens[i]' text' out hour' out minute' out second)) {  						haveTime = true;  						continue;  					}  				}    				if (tzone == null && tokens[i].IsTimeZone) {  					if (TryGetTimeZone (tokens[i]' text' out value)) {  						tzone = value;  						continue;  					}  				}    				if (tokens[i].IsNumeric) {  					if (tokens[i].Length == 4) {  						if (year == null && TryGetYear (tokens[i]' text' out value))  							year = value;    						continue;  					}    					if (tokens[i].Length > 2)  						continue;    					// Note: we likely have either YYYY[-/]MM[-/]DD or MM[-/]DD[-/]YY  					int endIndex = tokens[i].StartIndex + tokens[i].Length;  					int index = tokens[i].StartIndex;    					ParseUtils.TryParseInt32 (text' ref index' endIndex' out value);    					if (month == null && value > 0 && value <= 12) {  						numericMonth = true;  						month = value;  						continue;  					}    					if (day == null && value > 0 && value <= 31) {  						day = value;  						continue;  					}    					if (year == null && value >= 69) {  						year = 1900 + value;  						continue;  					}  				}    				// WTF is this??  			}
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryParseUnknownDateFormat,The following statement contains a magic number: if (tzone != null) {  				int minutes = tzone.Value % 100;  				int hours = tzone.Value / 100;    				offset = new TimeSpan (hours' minutes' 0);  			} else {  				offset = new TimeSpan (0);  			}
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,TryParseUnknownDateFormat,The following statement contains a magic number: if (tzone != null) {  				int minutes = tzone.Value % 100;  				int hours = tzone.Value / 100;    				offset = new TimeSpan (hours' minutes' 0);  			} else {  				offset = new TimeSpan (0);  			}
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,Parse,The following statement contains a magic number: while (i < text.Length && i < format.Length && format[i] != 'z') {  				if (text[i] < '0' || text[i] > '9')  					throw new FormatException ();    				int digit = text[i] - '0';    				switch (format[i]) {  				case 'y': year = (year * 10) + digit; break;  				case 'M': month = (month * 10) + digit; break;  				case 'd': day = (day * 10) + digit; break;  				case 'H': hour = (hour * 10) + digit; break;  				case 'm': minute = (minute * 10) + digit; break;  				case 's': second = (second * 10) + digit; break;  				}    				i++;  			}
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,Parse,The following statement contains a magic number: while (i < text.Length && i < format.Length && format[i] != 'z') {  				if (text[i] < '0' || text[i] > '9')  					throw new FormatException ();    				int digit = text[i] - '0';    				switch (format[i]) {  				case 'y': year = (year * 10) + digit; break;  				case 'M': month = (month * 10) + digit; break;  				case 'd': day = (day * 10) + digit; break;  				case 'H': hour = (hour * 10) + digit; break;  				case 'm': minute = (minute * 10) + digit; break;  				case 's': second = (second * 10) + digit; break;  				}    				i++;  			}
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,Parse,The following statement contains a magic number: while (i < text.Length && i < format.Length && format[i] != 'z') {  				if (text[i] < '0' || text[i] > '9')  					throw new FormatException ();    				int digit = text[i] - '0';    				switch (format[i]) {  				case 'y': year = (year * 10) + digit; break;  				case 'M': month = (month * 10) + digit; break;  				case 'd': day = (day * 10) + digit; break;  				case 'H': hour = (hour * 10) + digit; break;  				case 'm': minute = (minute * 10) + digit; break;  				case 's': second = (second * 10) + digit; break;  				}    				i++;  			}
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,Parse,The following statement contains a magic number: while (i < text.Length && i < format.Length && format[i] != 'z') {  				if (text[i] < '0' || text[i] > '9')  					throw new FormatException ();    				int digit = text[i] - '0';    				switch (format[i]) {  				case 'y': year = (year * 10) + digit; break;  				case 'M': month = (month * 10) + digit; break;  				case 'd': day = (day * 10) + digit; break;  				case 'H': hour = (hour * 10) + digit; break;  				case 'm': minute = (minute * 10) + digit; break;  				case 's': second = (second * 10) + digit; break;  				}    				i++;  			}
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,Parse,The following statement contains a magic number: while (i < text.Length && i < format.Length && format[i] != 'z') {  				if (text[i] < '0' || text[i] > '9')  					throw new FormatException ();    				int digit = text[i] - '0';    				switch (format[i]) {  				case 'y': year = (year * 10) + digit; break;  				case 'M': month = (month * 10) + digit; break;  				case 'd': day = (day * 10) + digit; break;  				case 'H': hour = (hour * 10) + digit; break;  				case 'm': minute = (minute * 10) + digit; break;  				case 's': second = (second * 10) + digit; break;  				}    				i++;  			}
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,Parse,The following statement contains a magic number: while (i < text.Length && i < format.Length && format[i] != 'z') {  				if (text[i] < '0' || text[i] > '9')  					throw new FormatException ();    				int digit = text[i] - '0';    				switch (format[i]) {  				case 'y': year = (year * 10) + digit; break;  				case 'M': month = (month * 10) + digit; break;  				case 'd': day = (day * 10) + digit; break;  				case 'H': hour = (hour * 10) + digit; break;  				case 'm': minute = (minute * 10) + digit; break;  				case 's': second = (second * 10) + digit; break;  				}    				i++;  			}
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,Parse,The following statement contains a magic number: minute += second / 60;
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,Parse,The following statement contains a magic number: second = second % 60;
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,Parse,The following statement contains a magic number: hour += minute / 60;
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,Parse,The following statement contains a magic number: minute = minute % 60;
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,Parse,The following statement contains a magic number: offset = new TimeSpan (timezone / 100' timezone % 100' 0);
Magic Number,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,Parse,The following statement contains a magic number: offset = new TimeSpan (timezone / 100' timezone % 100' 0);
Magic Number,MimeKit.Utils,MimeUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\MimeUtils.cs,GenerateMessageId,The following statement contains a magic number: var block = new byte[8];
Magic Number,MimeKit.Utils,MimeUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\MimeUtils.cs,GenerateMessageId,The following statement contains a magic number: do {  				id.Append (base36[(int) (value % 36)]);  				value /= 36;  			} while (value != 0);
Magic Number,MimeKit.Utils,MimeUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\MimeUtils.cs,GenerateMessageId,The following statement contains a magic number: do {  				id.Append (base36[(int) (value % 36)]);  				value /= 36;  			} while (value != 0);
Magic Number,MimeKit.Utils,MimeUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\MimeUtils.cs,GenerateMessageId,The following statement contains a magic number: for (int i = 0; i < 8; i++)  				value = (value << 8) | (ulong) block[i];
Magic Number,MimeKit.Utils,MimeUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\MimeUtils.cs,GenerateMessageId,The following statement contains a magic number: for (int i = 0; i < 8; i++)  				value = (value << 8) | (ulong) block[i];
Magic Number,MimeKit.Utils,MimeUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\MimeUtils.cs,GenerateMessageId,The following statement contains a magic number: do {  				id.Append (base36[(int) (value % 36)]);  				value /= 36;  			} while (value != 0);
Magic Number,MimeKit.Utils,MimeUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\MimeUtils.cs,GenerateMessageId,The following statement contains a magic number: do {  				id.Append (base36[(int) (value % 36)]);  				value /= 36;  			} while (value != 0);
Magic Number,MimeKit.Utils,MimeUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\MimeUtils.cs,TryParse,The following statement contains a magic number: switch (values.Count) {  			case 4: version = new Version (values[0]' values[1]' values[2]' values[3]); break;  			case 3: version = new Version (values[0]' values[1]' values[2]); break;  			case 2: version = new Version (values[0]' values[1]); break;  			default: return false;  			}
Magic Number,MimeKit.Utils,MimeUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\MimeUtils.cs,TryParse,The following statement contains a magic number: switch (values.Count) {  			case 4: version = new Version (values[0]' values[1]' values[2]' values[3]); break;  			case 3: version = new Version (values[0]' values[1]' values[2]); break;  			case 2: version = new Version (values[0]' values[1]); break;  			default: return false;  			}
Magic Number,MimeKit.Utils,MimeUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\MimeUtils.cs,TryParse,The following statement contains a magic number: switch (values.Count) {  			case 4: version = new Version (values[0]' values[1]' values[2]' values[3]); break;  			case 3: version = new Version (values[0]' values[1]' values[2]); break;  			case 2: version = new Version (values[0]' values[1]); break;  			default: return false;  			}
Magic Number,MimeKit.Utils,MimeUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\MimeUtils.cs,TryParse,The following statement contains a magic number: switch (values.Count) {  			case 4: version = new Version (values[0]' values[1]' values[2]' values[3]); break;  			case 3: version = new Version (values[0]' values[1]' values[2]); break;  			case 2: version = new Version (values[0]' values[1]); break;  			default: return false;  			}
Magic Number,MimeKit.Utils,MimeUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\MimeUtils.cs,TryParse,The following statement contains a magic number: switch (values.Count) {  			case 4: version = new Version (values[0]' values[1]' values[2]' values[3]); break;  			case 3: version = new Version (values[0]' values[1]' values[2]); break;  			case 2: version = new Version (values[0]' values[1]); break;  			default: return false;  			}
Magic Number,MimeKit.Utils,MimeUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\MimeUtils.cs,TryParse,The following statement contains a magic number: switch (values.Count) {  			case 4: version = new Version (values[0]' values[1]' values[2]' values[3]); break;  			case 3: version = new Version (values[0]' values[1]' values[2]); break;  			case 2: version = new Version (values[0]' values[1]); break;  			default: return false;  			}
Magic Number,MimeKit.Utils,MimeUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\MimeUtils.cs,Quote,The following statement contains a magic number: var quoted = new StringBuilder (text.Length + 2' (text.Length * 2) + 2);
Magic Number,MimeKit.Utils,MimeUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\MimeUtils.cs,Quote,The following statement contains a magic number: var quoted = new StringBuilder (text.Length + 2' (text.Length * 2) + 2);
Magic Number,MimeKit.Utils,MimeUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\MimeUtils.cs,Quote,The following statement contains a magic number: var quoted = new StringBuilder (text.Length + 2' (text.Length * 2) + 2);
Magic Number,MimeKit.Utils,PackedByteArray,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\PackedByteArray.cs,EnsureBufferSize,The following statement contains a magic number: int ideal = (size + 63) & ~63;
Magic Number,MimeKit.Utils,PackedByteArray,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\PackedByteArray.cs,EnsureBufferSize,The following statement contains a magic number: int ideal = (size + 63) & ~63;
Magic Number,MimeKit.Utils,PackedByteArray,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\PackedByteArray.cs,Add,The following statement contains a magic number: if (cursor < 0 || item != (byte) (buffer[cursor] & 0xFF) || (buffer[cursor] & 0xFF00) == 0xFF00) {  				EnsureBufferSize (cursor + 2);  				buffer[++cursor] = (ushort) ((1 << 8) | item);  			} else {  				buffer[cursor] += (1 << 8);  			}
Magic Number,MimeKit.Utils,PackedByteArray,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\PackedByteArray.cs,Add,The following statement contains a magic number: if (cursor < 0 || item != (byte) (buffer[cursor] & 0xFF) || (buffer[cursor] & 0xFF00) == 0xFF00) {  				EnsureBufferSize (cursor + 2);  				buffer[++cursor] = (ushort) ((1 << 8) | item);  			} else {  				buffer[cursor] += (1 << 8);  			}
Magic Number,MimeKit.Utils,PackedByteArray,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\PackedByteArray.cs,Add,The following statement contains a magic number: if (cursor < 0 || item != (byte) (buffer[cursor] & 0xFF) || (buffer[cursor] & 0xFF00) == 0xFF00) {  				EnsureBufferSize (cursor + 2);  				buffer[++cursor] = (ushort) ((1 << 8) | item);  			} else {  				buffer[cursor] += (1 << 8);  			}
Magic Number,MimeKit.Utils,PackedByteArray,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\PackedByteArray.cs,CopyTo,The following statement contains a magic number: for (int i = 0; i <= cursor; i++) {  				count = (buffer[i] >> 8) & 0xFF;  				c = (byte) (buffer[i] & 0xFF);    				for (int n = 0; n < count; n++)  					array[index++] = c;  			}
Magic Number,MimeKit.Utils,PackedByteArray,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\PackedByteArray.cs,Remove,The following statement contains a magic number: for (i = 0; i <= cursor; i++) {  				if (item == (byte) (buffer[i] & 0xFF)) {  					count = ((buffer[i] >> 8) & 0xFF);  					break;  				}  			}
Magic Number,MimeKit.Utils,PackedByteArray,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\PackedByteArray.cs,Remove,The following statement contains a magic number: if (count > 1) {  				// this byte was repeated more than once' so just decrement the count  				buffer[i] = (ushort) (((count - 1) << 8) | item);  			} else if (i < cursor) {  				// to remove the element at position i' we need to shift the  				// remaining data one item to the left  				Array.Copy (buffer' i + 1' buffer' i' cursor - i);  				cursor--;  			} else {  				// removing the last byte added  				cursor--;  			}
Magic Number,MimeKit.Utils,PackedByteArray,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\PackedByteArray.cs,IndexOf,The following statement contains a magic number: for (int i = 0; i <= cursor; i++) {  				if (item == (byte) (buffer[i] & 0xFF))  					return offset;    				offset += ((buffer[i] >> 8) & 0xFF);  			}
Magic Number,MimeKit.Utils,PackedByteArray,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\PackedByteArray.cs,RemoveAt,The following statement contains a magic number: for (i = 0; i <= cursor; i++) {  				count = ((buffer[i] >> 8) & 0xFF);  				if (offset + count > index)  					break;    				offset += count;  			}
Magic Number,MimeKit.Utils,PackedByteArray,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\PackedByteArray.cs,RemoveAt,The following statement contains a magic number: if (count > 1) {  				// this byte was repeated more than once' so just decrement the count  				byte c = (byte) (buffer[i] & 0xFF);  				buffer[i] = (ushort) (((count - 1) << 8) | c);  			} else if (i < cursor) {  				// to remove the element at position i' we need to shift the  				// remaining data one item to the left  				Array.Copy (buffer' i + 1' buffer' i' cursor - i);  				cursor--;  			} else {  				// removing the last byte added  				cursor--;  			}
Magic Number,MimeKit.Utils,PackedByteArray,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\PackedByteArray.cs,GetEnumerator,The following statement contains a magic number: for (int i = 0; i <= cursor; i++) {  				count = (buffer[i] >> 8) & 0xFF;  				c = (byte) (buffer[i] & 0xFF);  				  				for (int n = 0; n < count; n++)  					yield return c;  			}
Magic Number,MimeKit.Utils,ParseUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\ParseUtils.cs,TryParseInt32,The following statement contains a magic number: while (index < endIndex && text[index] >= (byte) '0' && text[index] <= (byte) '9') {  				int digit = text[index] - (byte) '0';    				if (value > int.MaxValue / 10) {  					// integer overflow  					return false;  				}    				if (value == int.MaxValue / 10 && digit > int.MaxValue % 10) {  					// integer overflow  					return false;  				}    				value = (value * 10) + digit;  				index++;  			}
Magic Number,MimeKit.Utils,ParseUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\ParseUtils.cs,TryParseInt32,The following statement contains a magic number: while (index < endIndex && text[index] >= (byte) '0' && text[index] <= (byte) '9') {  				int digit = text[index] - (byte) '0';    				if (value > int.MaxValue / 10) {  					// integer overflow  					return false;  				}    				if (value == int.MaxValue / 10 && digit > int.MaxValue % 10) {  					// integer overflow  					return false;  				}    				value = (value * 10) + digit;  				index++;  			}
Magic Number,MimeKit.Utils,ParseUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\ParseUtils.cs,TryParseInt32,The following statement contains a magic number: while (index < endIndex && text[index] >= (byte) '0' && text[index] <= (byte) '9') {  				int digit = text[index] - (byte) '0';    				if (value > int.MaxValue / 10) {  					// integer overflow  					return false;  				}    				if (value == int.MaxValue / 10 && digit > int.MaxValue % 10) {  					// integer overflow  					return false;  				}    				value = (value * 10) + digit;  				index++;  			}
Magic Number,MimeKit.Utils,ParseUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\ParseUtils.cs,TryParseInt32,The following statement contains a magic number: while (index < endIndex && text[index] >= (byte) '0' && text[index] <= (byte) '9') {  				int digit = text[index] - (byte) '0';    				if (value > int.MaxValue / 10) {  					// integer overflow  					return false;  				}    				if (value == int.MaxValue / 10 && digit > int.MaxValue % 10) {  					// integer overflow  					return false;  				}    				value = (value * 10) + digit;  				index++;  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,IsAscii,The following statement contains a magic number: return c < 128;
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TryGetEncodedWordToken,The following statement contains a magic number: if (length < 7)  				return false;
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TryGetEncodedWordToken,The following statement contains a magic number: byte* inend = word + length - 2;
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TryGetEncodedWordToken,The following statement contains a magic number: inend -= 2;
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TokenizePhrase,The following statement contains a magic number: while (inptr < inend) {  				text = inptr;  				while (inptr < inend && IsLwsp (*inptr))  					inptr++;    				if (inptr > text)  					lwsp = new Token ((int) (text - inbuf)' (int) (inptr - text));  				else  					lwsp = null;    				word = inptr;  				ascii = true;  				if (inptr < inend && IsAsciiAtom (*inptr)) {  					if (options.Rfc2047ComplianceMode == RfcComplianceMode.Loose) {  						// Make an extra effort to detect and separate encoded-word  						// tokens that have been merged with other words.  						bool is_rfc2047 = false;    						if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?') {  							inptr += 2;    							// skip past the charset (if one is even declared' sigh)  							while (inptr < inend && *inptr != '?') {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							// sanity check encoding type  							if (inptr + 3 >= inend || *inptr != '?' || !IsBbQq (*(inptr + 1)) || *(inptr + 2) != '?') {  								ascii = true;  								goto non_rfc2047;  							}    							inptr += 3;    							// find the end of the rfc2047 encoded word token  							while (inptr + 2 < inend && !(*inptr == '?' && *(inptr + 1) == '=')) {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							if (inptr + 2 > inend || *inptr != '?' || *(inptr + 1) != '=') {  								// didn't find an end marker...  								inptr = word + 2;  								ascii = true;    								goto non_rfc2047;  							}    							is_rfc2047 = true;  							inptr += 2;  						}    					non_rfc2047:  						if (!is_rfc2047) {  							// stop if we encounter a possible rfc2047 encoded  							// token even if it's inside another word' sigh.  							while (inptr < inend && IsAtom (*inptr)) {  								if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?')  									break;  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}  						}  					} else {  						// encoded-word tokens are atoms  						while (inptr < inend && IsAsciiAtom (*inptr)) {  							//ascii = ascii && IsAscii (*inptr);  							inptr++;  						}  					}    					n = (int) (inptr - word);  					if (TryGetEncodedWordToken (inbuf' word' n' out token)) {  						// rfc2047 states that you must ignore all whitespace between  						// encoded-word tokens  						if (!encoded && lwsp != null) {  							// previous token was not encoded' so preserve whitespace  							tokens.Add (lwsp);  						}    						tokens.Add (token);  						encoded = true;  					} else {  						// append the lwsp and atom tokens  						if (lwsp != null)  							tokens.Add (lwsp);    						token = new Token ((int) (word - inbuf)' n);  						token.Is8bit = !ascii;  						tokens.Add (token);    						encoded = false;  					}  				} else {  					// append the lwsp token  					if (lwsp != null)  						tokens.Add (lwsp);    					// append the non-ascii atom token  					ascii = true;  					while (inptr < inend && !IsLwsp (*inptr) && !IsAsciiAtom (*inptr)) {  						ascii = ascii && IsAscii (*inptr);  						inptr++;  					}    					token = new Token ((int) (word - inbuf)' (int) (inptr - word));  					token.Is8bit = !ascii;  					tokens.Add (token);    					encoded = false;  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TokenizePhrase,The following statement contains a magic number: while (inptr < inend) {  				text = inptr;  				while (inptr < inend && IsLwsp (*inptr))  					inptr++;    				if (inptr > text)  					lwsp = new Token ((int) (text - inbuf)' (int) (inptr - text));  				else  					lwsp = null;    				word = inptr;  				ascii = true;  				if (inptr < inend && IsAsciiAtom (*inptr)) {  					if (options.Rfc2047ComplianceMode == RfcComplianceMode.Loose) {  						// Make an extra effort to detect and separate encoded-word  						// tokens that have been merged with other words.  						bool is_rfc2047 = false;    						if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?') {  							inptr += 2;    							// skip past the charset (if one is even declared' sigh)  							while (inptr < inend && *inptr != '?') {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							// sanity check encoding type  							if (inptr + 3 >= inend || *inptr != '?' || !IsBbQq (*(inptr + 1)) || *(inptr + 2) != '?') {  								ascii = true;  								goto non_rfc2047;  							}    							inptr += 3;    							// find the end of the rfc2047 encoded word token  							while (inptr + 2 < inend && !(*inptr == '?' && *(inptr + 1) == '=')) {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							if (inptr + 2 > inend || *inptr != '?' || *(inptr + 1) != '=') {  								// didn't find an end marker...  								inptr = word + 2;  								ascii = true;    								goto non_rfc2047;  							}    							is_rfc2047 = true;  							inptr += 2;  						}    					non_rfc2047:  						if (!is_rfc2047) {  							// stop if we encounter a possible rfc2047 encoded  							// token even if it's inside another word' sigh.  							while (inptr < inend && IsAtom (*inptr)) {  								if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?')  									break;  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}  						}  					} else {  						// encoded-word tokens are atoms  						while (inptr < inend && IsAsciiAtom (*inptr)) {  							//ascii = ascii && IsAscii (*inptr);  							inptr++;  						}  					}    					n = (int) (inptr - word);  					if (TryGetEncodedWordToken (inbuf' word' n' out token)) {  						// rfc2047 states that you must ignore all whitespace between  						// encoded-word tokens  						if (!encoded && lwsp != null) {  							// previous token was not encoded' so preserve whitespace  							tokens.Add (lwsp);  						}    						tokens.Add (token);  						encoded = true;  					} else {  						// append the lwsp and atom tokens  						if (lwsp != null)  							tokens.Add (lwsp);    						token = new Token ((int) (word - inbuf)' n);  						token.Is8bit = !ascii;  						tokens.Add (token);    						encoded = false;  					}  				} else {  					// append the lwsp token  					if (lwsp != null)  						tokens.Add (lwsp);    					// append the non-ascii atom token  					ascii = true;  					while (inptr < inend && !IsLwsp (*inptr) && !IsAsciiAtom (*inptr)) {  						ascii = ascii && IsAscii (*inptr);  						inptr++;  					}    					token = new Token ((int) (word - inbuf)' (int) (inptr - word));  					token.Is8bit = !ascii;  					tokens.Add (token);    					encoded = false;  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TokenizePhrase,The following statement contains a magic number: while (inptr < inend) {  				text = inptr;  				while (inptr < inend && IsLwsp (*inptr))  					inptr++;    				if (inptr > text)  					lwsp = new Token ((int) (text - inbuf)' (int) (inptr - text));  				else  					lwsp = null;    				word = inptr;  				ascii = true;  				if (inptr < inend && IsAsciiAtom (*inptr)) {  					if (options.Rfc2047ComplianceMode == RfcComplianceMode.Loose) {  						// Make an extra effort to detect and separate encoded-word  						// tokens that have been merged with other words.  						bool is_rfc2047 = false;    						if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?') {  							inptr += 2;    							// skip past the charset (if one is even declared' sigh)  							while (inptr < inend && *inptr != '?') {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							// sanity check encoding type  							if (inptr + 3 >= inend || *inptr != '?' || !IsBbQq (*(inptr + 1)) || *(inptr + 2) != '?') {  								ascii = true;  								goto non_rfc2047;  							}    							inptr += 3;    							// find the end of the rfc2047 encoded word token  							while (inptr + 2 < inend && !(*inptr == '?' && *(inptr + 1) == '=')) {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							if (inptr + 2 > inend || *inptr != '?' || *(inptr + 1) != '=') {  								// didn't find an end marker...  								inptr = word + 2;  								ascii = true;    								goto non_rfc2047;  							}    							is_rfc2047 = true;  							inptr += 2;  						}    					non_rfc2047:  						if (!is_rfc2047) {  							// stop if we encounter a possible rfc2047 encoded  							// token even if it's inside another word' sigh.  							while (inptr < inend && IsAtom (*inptr)) {  								if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?')  									break;  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}  						}  					} else {  						// encoded-word tokens are atoms  						while (inptr < inend && IsAsciiAtom (*inptr)) {  							//ascii = ascii && IsAscii (*inptr);  							inptr++;  						}  					}    					n = (int) (inptr - word);  					if (TryGetEncodedWordToken (inbuf' word' n' out token)) {  						// rfc2047 states that you must ignore all whitespace between  						// encoded-word tokens  						if (!encoded && lwsp != null) {  							// previous token was not encoded' so preserve whitespace  							tokens.Add (lwsp);  						}    						tokens.Add (token);  						encoded = true;  					} else {  						// append the lwsp and atom tokens  						if (lwsp != null)  							tokens.Add (lwsp);    						token = new Token ((int) (word - inbuf)' n);  						token.Is8bit = !ascii;  						tokens.Add (token);    						encoded = false;  					}  				} else {  					// append the lwsp token  					if (lwsp != null)  						tokens.Add (lwsp);    					// append the non-ascii atom token  					ascii = true;  					while (inptr < inend && !IsLwsp (*inptr) && !IsAsciiAtom (*inptr)) {  						ascii = ascii && IsAscii (*inptr);  						inptr++;  					}    					token = new Token ((int) (word - inbuf)' (int) (inptr - word));  					token.Is8bit = !ascii;  					tokens.Add (token);    					encoded = false;  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TokenizePhrase,The following statement contains a magic number: while (inptr < inend) {  				text = inptr;  				while (inptr < inend && IsLwsp (*inptr))  					inptr++;    				if (inptr > text)  					lwsp = new Token ((int) (text - inbuf)' (int) (inptr - text));  				else  					lwsp = null;    				word = inptr;  				ascii = true;  				if (inptr < inend && IsAsciiAtom (*inptr)) {  					if (options.Rfc2047ComplianceMode == RfcComplianceMode.Loose) {  						// Make an extra effort to detect and separate encoded-word  						// tokens that have been merged with other words.  						bool is_rfc2047 = false;    						if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?') {  							inptr += 2;    							// skip past the charset (if one is even declared' sigh)  							while (inptr < inend && *inptr != '?') {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							// sanity check encoding type  							if (inptr + 3 >= inend || *inptr != '?' || !IsBbQq (*(inptr + 1)) || *(inptr + 2) != '?') {  								ascii = true;  								goto non_rfc2047;  							}    							inptr += 3;    							// find the end of the rfc2047 encoded word token  							while (inptr + 2 < inend && !(*inptr == '?' && *(inptr + 1) == '=')) {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							if (inptr + 2 > inend || *inptr != '?' || *(inptr + 1) != '=') {  								// didn't find an end marker...  								inptr = word + 2;  								ascii = true;    								goto non_rfc2047;  							}    							is_rfc2047 = true;  							inptr += 2;  						}    					non_rfc2047:  						if (!is_rfc2047) {  							// stop if we encounter a possible rfc2047 encoded  							// token even if it's inside another word' sigh.  							while (inptr < inend && IsAtom (*inptr)) {  								if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?')  									break;  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}  						}  					} else {  						// encoded-word tokens are atoms  						while (inptr < inend && IsAsciiAtom (*inptr)) {  							//ascii = ascii && IsAscii (*inptr);  							inptr++;  						}  					}    					n = (int) (inptr - word);  					if (TryGetEncodedWordToken (inbuf' word' n' out token)) {  						// rfc2047 states that you must ignore all whitespace between  						// encoded-word tokens  						if (!encoded && lwsp != null) {  							// previous token was not encoded' so preserve whitespace  							tokens.Add (lwsp);  						}    						tokens.Add (token);  						encoded = true;  					} else {  						// append the lwsp and atom tokens  						if (lwsp != null)  							tokens.Add (lwsp);    						token = new Token ((int) (word - inbuf)' n);  						token.Is8bit = !ascii;  						tokens.Add (token);    						encoded = false;  					}  				} else {  					// append the lwsp token  					if (lwsp != null)  						tokens.Add (lwsp);    					// append the non-ascii atom token  					ascii = true;  					while (inptr < inend && !IsLwsp (*inptr) && !IsAsciiAtom (*inptr)) {  						ascii = ascii && IsAscii (*inptr);  						inptr++;  					}    					token = new Token ((int) (word - inbuf)' (int) (inptr - word));  					token.Is8bit = !ascii;  					tokens.Add (token);    					encoded = false;  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TokenizePhrase,The following statement contains a magic number: while (inptr < inend) {  				text = inptr;  				while (inptr < inend && IsLwsp (*inptr))  					inptr++;    				if (inptr > text)  					lwsp = new Token ((int) (text - inbuf)' (int) (inptr - text));  				else  					lwsp = null;    				word = inptr;  				ascii = true;  				if (inptr < inend && IsAsciiAtom (*inptr)) {  					if (options.Rfc2047ComplianceMode == RfcComplianceMode.Loose) {  						// Make an extra effort to detect and separate encoded-word  						// tokens that have been merged with other words.  						bool is_rfc2047 = false;    						if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?') {  							inptr += 2;    							// skip past the charset (if one is even declared' sigh)  							while (inptr < inend && *inptr != '?') {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							// sanity check encoding type  							if (inptr + 3 >= inend || *inptr != '?' || !IsBbQq (*(inptr + 1)) || *(inptr + 2) != '?') {  								ascii = true;  								goto non_rfc2047;  							}    							inptr += 3;    							// find the end of the rfc2047 encoded word token  							while (inptr + 2 < inend && !(*inptr == '?' && *(inptr + 1) == '=')) {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							if (inptr + 2 > inend || *inptr != '?' || *(inptr + 1) != '=') {  								// didn't find an end marker...  								inptr = word + 2;  								ascii = true;    								goto non_rfc2047;  							}    							is_rfc2047 = true;  							inptr += 2;  						}    					non_rfc2047:  						if (!is_rfc2047) {  							// stop if we encounter a possible rfc2047 encoded  							// token even if it's inside another word' sigh.  							while (inptr < inend && IsAtom (*inptr)) {  								if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?')  									break;  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}  						}  					} else {  						// encoded-word tokens are atoms  						while (inptr < inend && IsAsciiAtom (*inptr)) {  							//ascii = ascii && IsAscii (*inptr);  							inptr++;  						}  					}    					n = (int) (inptr - word);  					if (TryGetEncodedWordToken (inbuf' word' n' out token)) {  						// rfc2047 states that you must ignore all whitespace between  						// encoded-word tokens  						if (!encoded && lwsp != null) {  							// previous token was not encoded' so preserve whitespace  							tokens.Add (lwsp);  						}    						tokens.Add (token);  						encoded = true;  					} else {  						// append the lwsp and atom tokens  						if (lwsp != null)  							tokens.Add (lwsp);    						token = new Token ((int) (word - inbuf)' n);  						token.Is8bit = !ascii;  						tokens.Add (token);    						encoded = false;  					}  				} else {  					// append the lwsp token  					if (lwsp != null)  						tokens.Add (lwsp);    					// append the non-ascii atom token  					ascii = true;  					while (inptr < inend && !IsLwsp (*inptr) && !IsAsciiAtom (*inptr)) {  						ascii = ascii && IsAscii (*inptr);  						inptr++;  					}    					token = new Token ((int) (word - inbuf)' (int) (inptr - word));  					token.Is8bit = !ascii;  					tokens.Add (token);    					encoded = false;  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TokenizePhrase,The following statement contains a magic number: while (inptr < inend) {  				text = inptr;  				while (inptr < inend && IsLwsp (*inptr))  					inptr++;    				if (inptr > text)  					lwsp = new Token ((int) (text - inbuf)' (int) (inptr - text));  				else  					lwsp = null;    				word = inptr;  				ascii = true;  				if (inptr < inend && IsAsciiAtom (*inptr)) {  					if (options.Rfc2047ComplianceMode == RfcComplianceMode.Loose) {  						// Make an extra effort to detect and separate encoded-word  						// tokens that have been merged with other words.  						bool is_rfc2047 = false;    						if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?') {  							inptr += 2;    							// skip past the charset (if one is even declared' sigh)  							while (inptr < inend && *inptr != '?') {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							// sanity check encoding type  							if (inptr + 3 >= inend || *inptr != '?' || !IsBbQq (*(inptr + 1)) || *(inptr + 2) != '?') {  								ascii = true;  								goto non_rfc2047;  							}    							inptr += 3;    							// find the end of the rfc2047 encoded word token  							while (inptr + 2 < inend && !(*inptr == '?' && *(inptr + 1) == '=')) {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							if (inptr + 2 > inend || *inptr != '?' || *(inptr + 1) != '=') {  								// didn't find an end marker...  								inptr = word + 2;  								ascii = true;    								goto non_rfc2047;  							}    							is_rfc2047 = true;  							inptr += 2;  						}    					non_rfc2047:  						if (!is_rfc2047) {  							// stop if we encounter a possible rfc2047 encoded  							// token even if it's inside another word' sigh.  							while (inptr < inend && IsAtom (*inptr)) {  								if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?')  									break;  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}  						}  					} else {  						// encoded-word tokens are atoms  						while (inptr < inend && IsAsciiAtom (*inptr)) {  							//ascii = ascii && IsAscii (*inptr);  							inptr++;  						}  					}    					n = (int) (inptr - word);  					if (TryGetEncodedWordToken (inbuf' word' n' out token)) {  						// rfc2047 states that you must ignore all whitespace between  						// encoded-word tokens  						if (!encoded && lwsp != null) {  							// previous token was not encoded' so preserve whitespace  							tokens.Add (lwsp);  						}    						tokens.Add (token);  						encoded = true;  					} else {  						// append the lwsp and atom tokens  						if (lwsp != null)  							tokens.Add (lwsp);    						token = new Token ((int) (word - inbuf)' n);  						token.Is8bit = !ascii;  						tokens.Add (token);    						encoded = false;  					}  				} else {  					// append the lwsp token  					if (lwsp != null)  						tokens.Add (lwsp);    					// append the non-ascii atom token  					ascii = true;  					while (inptr < inend && !IsLwsp (*inptr) && !IsAsciiAtom (*inptr)) {  						ascii = ascii && IsAscii (*inptr);  						inptr++;  					}    					token = new Token ((int) (word - inbuf)' (int) (inptr - word));  					token.Is8bit = !ascii;  					tokens.Add (token);    					encoded = false;  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TokenizePhrase,The following statement contains a magic number: while (inptr < inend) {  				text = inptr;  				while (inptr < inend && IsLwsp (*inptr))  					inptr++;    				if (inptr > text)  					lwsp = new Token ((int) (text - inbuf)' (int) (inptr - text));  				else  					lwsp = null;    				word = inptr;  				ascii = true;  				if (inptr < inend && IsAsciiAtom (*inptr)) {  					if (options.Rfc2047ComplianceMode == RfcComplianceMode.Loose) {  						// Make an extra effort to detect and separate encoded-word  						// tokens that have been merged with other words.  						bool is_rfc2047 = false;    						if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?') {  							inptr += 2;    							// skip past the charset (if one is even declared' sigh)  							while (inptr < inend && *inptr != '?') {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							// sanity check encoding type  							if (inptr + 3 >= inend || *inptr != '?' || !IsBbQq (*(inptr + 1)) || *(inptr + 2) != '?') {  								ascii = true;  								goto non_rfc2047;  							}    							inptr += 3;    							// find the end of the rfc2047 encoded word token  							while (inptr + 2 < inend && !(*inptr == '?' && *(inptr + 1) == '=')) {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							if (inptr + 2 > inend || *inptr != '?' || *(inptr + 1) != '=') {  								// didn't find an end marker...  								inptr = word + 2;  								ascii = true;    								goto non_rfc2047;  							}    							is_rfc2047 = true;  							inptr += 2;  						}    					non_rfc2047:  						if (!is_rfc2047) {  							// stop if we encounter a possible rfc2047 encoded  							// token even if it's inside another word' sigh.  							while (inptr < inend && IsAtom (*inptr)) {  								if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?')  									break;  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}  						}  					} else {  						// encoded-word tokens are atoms  						while (inptr < inend && IsAsciiAtom (*inptr)) {  							//ascii = ascii && IsAscii (*inptr);  							inptr++;  						}  					}    					n = (int) (inptr - word);  					if (TryGetEncodedWordToken (inbuf' word' n' out token)) {  						// rfc2047 states that you must ignore all whitespace between  						// encoded-word tokens  						if (!encoded && lwsp != null) {  							// previous token was not encoded' so preserve whitespace  							tokens.Add (lwsp);  						}    						tokens.Add (token);  						encoded = true;  					} else {  						// append the lwsp and atom tokens  						if (lwsp != null)  							tokens.Add (lwsp);    						token = new Token ((int) (word - inbuf)' n);  						token.Is8bit = !ascii;  						tokens.Add (token);    						encoded = false;  					}  				} else {  					// append the lwsp token  					if (lwsp != null)  						tokens.Add (lwsp);    					// append the non-ascii atom token  					ascii = true;  					while (inptr < inend && !IsLwsp (*inptr) && !IsAsciiAtom (*inptr)) {  						ascii = ascii && IsAscii (*inptr);  						inptr++;  					}    					token = new Token ((int) (word - inbuf)' (int) (inptr - word));  					token.Is8bit = !ascii;  					tokens.Add (token);    					encoded = false;  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TokenizePhrase,The following statement contains a magic number: while (inptr < inend) {  				text = inptr;  				while (inptr < inend && IsLwsp (*inptr))  					inptr++;    				if (inptr > text)  					lwsp = new Token ((int) (text - inbuf)' (int) (inptr - text));  				else  					lwsp = null;    				word = inptr;  				ascii = true;  				if (inptr < inend && IsAsciiAtom (*inptr)) {  					if (options.Rfc2047ComplianceMode == RfcComplianceMode.Loose) {  						// Make an extra effort to detect and separate encoded-word  						// tokens that have been merged with other words.  						bool is_rfc2047 = false;    						if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?') {  							inptr += 2;    							// skip past the charset (if one is even declared' sigh)  							while (inptr < inend && *inptr != '?') {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							// sanity check encoding type  							if (inptr + 3 >= inend || *inptr != '?' || !IsBbQq (*(inptr + 1)) || *(inptr + 2) != '?') {  								ascii = true;  								goto non_rfc2047;  							}    							inptr += 3;    							// find the end of the rfc2047 encoded word token  							while (inptr + 2 < inend && !(*inptr == '?' && *(inptr + 1) == '=')) {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							if (inptr + 2 > inend || *inptr != '?' || *(inptr + 1) != '=') {  								// didn't find an end marker...  								inptr = word + 2;  								ascii = true;    								goto non_rfc2047;  							}    							is_rfc2047 = true;  							inptr += 2;  						}    					non_rfc2047:  						if (!is_rfc2047) {  							// stop if we encounter a possible rfc2047 encoded  							// token even if it's inside another word' sigh.  							while (inptr < inend && IsAtom (*inptr)) {  								if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?')  									break;  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}  						}  					} else {  						// encoded-word tokens are atoms  						while (inptr < inend && IsAsciiAtom (*inptr)) {  							//ascii = ascii && IsAscii (*inptr);  							inptr++;  						}  					}    					n = (int) (inptr - word);  					if (TryGetEncodedWordToken (inbuf' word' n' out token)) {  						// rfc2047 states that you must ignore all whitespace between  						// encoded-word tokens  						if (!encoded && lwsp != null) {  							// previous token was not encoded' so preserve whitespace  							tokens.Add (lwsp);  						}    						tokens.Add (token);  						encoded = true;  					} else {  						// append the lwsp and atom tokens  						if (lwsp != null)  							tokens.Add (lwsp);    						token = new Token ((int) (word - inbuf)' n);  						token.Is8bit = !ascii;  						tokens.Add (token);    						encoded = false;  					}  				} else {  					// append the lwsp token  					if (lwsp != null)  						tokens.Add (lwsp);    					// append the non-ascii atom token  					ascii = true;  					while (inptr < inend && !IsLwsp (*inptr) && !IsAsciiAtom (*inptr)) {  						ascii = ascii && IsAscii (*inptr);  						inptr++;  					}    					token = new Token ((int) (word - inbuf)' (int) (inptr - word));  					token.Is8bit = !ascii;  					tokens.Add (token);    					encoded = false;  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TokenizePhrase,The following statement contains a magic number: while (inptr < inend) {  				text = inptr;  				while (inptr < inend && IsLwsp (*inptr))  					inptr++;    				if (inptr > text)  					lwsp = new Token ((int) (text - inbuf)' (int) (inptr - text));  				else  					lwsp = null;    				word = inptr;  				ascii = true;  				if (inptr < inend && IsAsciiAtom (*inptr)) {  					if (options.Rfc2047ComplianceMode == RfcComplianceMode.Loose) {  						// Make an extra effort to detect and separate encoded-word  						// tokens that have been merged with other words.  						bool is_rfc2047 = false;    						if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?') {  							inptr += 2;    							// skip past the charset (if one is even declared' sigh)  							while (inptr < inend && *inptr != '?') {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							// sanity check encoding type  							if (inptr + 3 >= inend || *inptr != '?' || !IsBbQq (*(inptr + 1)) || *(inptr + 2) != '?') {  								ascii = true;  								goto non_rfc2047;  							}    							inptr += 3;    							// find the end of the rfc2047 encoded word token  							while (inptr + 2 < inend && !(*inptr == '?' && *(inptr + 1) == '=')) {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							if (inptr + 2 > inend || *inptr != '?' || *(inptr + 1) != '=') {  								// didn't find an end marker...  								inptr = word + 2;  								ascii = true;    								goto non_rfc2047;  							}    							is_rfc2047 = true;  							inptr += 2;  						}    					non_rfc2047:  						if (!is_rfc2047) {  							// stop if we encounter a possible rfc2047 encoded  							// token even if it's inside another word' sigh.  							while (inptr < inend && IsAtom (*inptr)) {  								if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?')  									break;  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}  						}  					} else {  						// encoded-word tokens are atoms  						while (inptr < inend && IsAsciiAtom (*inptr)) {  							//ascii = ascii && IsAscii (*inptr);  							inptr++;  						}  					}    					n = (int) (inptr - word);  					if (TryGetEncodedWordToken (inbuf' word' n' out token)) {  						// rfc2047 states that you must ignore all whitespace between  						// encoded-word tokens  						if (!encoded && lwsp != null) {  							// previous token was not encoded' so preserve whitespace  							tokens.Add (lwsp);  						}    						tokens.Add (token);  						encoded = true;  					} else {  						// append the lwsp and atom tokens  						if (lwsp != null)  							tokens.Add (lwsp);    						token = new Token ((int) (word - inbuf)' n);  						token.Is8bit = !ascii;  						tokens.Add (token);    						encoded = false;  					}  				} else {  					// append the lwsp token  					if (lwsp != null)  						tokens.Add (lwsp);    					// append the non-ascii atom token  					ascii = true;  					while (inptr < inend && !IsLwsp (*inptr) && !IsAsciiAtom (*inptr)) {  						ascii = ascii && IsAscii (*inptr);  						inptr++;  					}    					token = new Token ((int) (word - inbuf)' (int) (inptr - word));  					token.Is8bit = !ascii;  					tokens.Add (token);    					encoded = false;  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TokenizePhrase,The following statement contains a magic number: while (inptr < inend) {  				text = inptr;  				while (inptr < inend && IsLwsp (*inptr))  					inptr++;    				if (inptr > text)  					lwsp = new Token ((int) (text - inbuf)' (int) (inptr - text));  				else  					lwsp = null;    				word = inptr;  				ascii = true;  				if (inptr < inend && IsAsciiAtom (*inptr)) {  					if (options.Rfc2047ComplianceMode == RfcComplianceMode.Loose) {  						// Make an extra effort to detect and separate encoded-word  						// tokens that have been merged with other words.  						bool is_rfc2047 = false;    						if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?') {  							inptr += 2;    							// skip past the charset (if one is even declared' sigh)  							while (inptr < inend && *inptr != '?') {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							// sanity check encoding type  							if (inptr + 3 >= inend || *inptr != '?' || !IsBbQq (*(inptr + 1)) || *(inptr + 2) != '?') {  								ascii = true;  								goto non_rfc2047;  							}    							inptr += 3;    							// find the end of the rfc2047 encoded word token  							while (inptr + 2 < inend && !(*inptr == '?' && *(inptr + 1) == '=')) {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							if (inptr + 2 > inend || *inptr != '?' || *(inptr + 1) != '=') {  								// didn't find an end marker...  								inptr = word + 2;  								ascii = true;    								goto non_rfc2047;  							}    							is_rfc2047 = true;  							inptr += 2;  						}    					non_rfc2047:  						if (!is_rfc2047) {  							// stop if we encounter a possible rfc2047 encoded  							// token even if it's inside another word' sigh.  							while (inptr < inend && IsAtom (*inptr)) {  								if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?')  									break;  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}  						}  					} else {  						// encoded-word tokens are atoms  						while (inptr < inend && IsAsciiAtom (*inptr)) {  							//ascii = ascii && IsAscii (*inptr);  							inptr++;  						}  					}    					n = (int) (inptr - word);  					if (TryGetEncodedWordToken (inbuf' word' n' out token)) {  						// rfc2047 states that you must ignore all whitespace between  						// encoded-word tokens  						if (!encoded && lwsp != null) {  							// previous token was not encoded' so preserve whitespace  							tokens.Add (lwsp);  						}    						tokens.Add (token);  						encoded = true;  					} else {  						// append the lwsp and atom tokens  						if (lwsp != null)  							tokens.Add (lwsp);    						token = new Token ((int) (word - inbuf)' n);  						token.Is8bit = !ascii;  						tokens.Add (token);    						encoded = false;  					}  				} else {  					// append the lwsp token  					if (lwsp != null)  						tokens.Add (lwsp);    					// append the non-ascii atom token  					ascii = true;  					while (inptr < inend && !IsLwsp (*inptr) && !IsAsciiAtom (*inptr)) {  						ascii = ascii && IsAscii (*inptr);  						inptr++;  					}    					token = new Token ((int) (word - inbuf)' (int) (inptr - word));  					token.Is8bit = !ascii;  					tokens.Add (token);    					encoded = false;  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TokenizeText,The following statement contains a magic number: while (inptr < inend) {  				text = inptr;  				while (inptr < inend && IsLwsp (*inptr))  					inptr++;    				if (inptr > text)  					lwsp = new Token ((int) (text - inbuf)' (int) (inptr - text));  				else  					lwsp = null;    				if (inptr < inend) {  					word = inptr;  					ascii = true;    					if (options.Rfc2047ComplianceMode == RfcComplianceMode.Loose) {  						// Make an extra effort to detect and separate encoded-word  						// tokens that have been merged with other words.  						bool is_rfc2047 = false;    						if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?') {  							inptr += 2;    							// skip past the charset (if one is even declared' sigh)  							while (inptr < inend && *inptr != '?') {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							// sanity check encoding type  							if (inptr + 3 >= inend || *inptr != '?' || !IsBbQq (*(inptr + 1)) || *(inptr + 2) != '?') {  								ascii = true;  								goto non_rfc2047;  							}    							inptr += 3;    							// find the end of the rfc2047 encoded word token  							while (inptr + 2 < inend && !(*inptr == '?' && *(inptr + 1) == '=')) {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							if (inptr + 2 > inend || *inptr != '?' || *(inptr + 1) != '=') {  								// didn't find an end marker...  								inptr = word + 2;  								ascii = true;    								goto non_rfc2047;  							}    							is_rfc2047 = true;  							inptr += 2;  						}    					non_rfc2047:  						if (!is_rfc2047) {  							// stop if we encounter a possible rfc2047 encoded  							// token even if it's inside another word' sigh.  							while (inptr < inend && !IsLwsp (*inptr)) {  								if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?')  									break;    								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}  						}  					} else {  						// find the end of a run of text...  						while (inptr < inend && !IsLwsp (*inptr)) {  							ascii = ascii && IsAscii (*inptr);  							inptr++;  						}  					}    					n = (int) (inptr - word);  					if (TryGetEncodedWordToken (inbuf' word' n' out token)) {  						// rfc2047 states that you must ignore all whitespace between  						// encoded-word tokens  						if (!encoded && lwsp != null) {  							// previous token was not encoded' so preserve whitespace  							tokens.Add (lwsp);  						}    						tokens.Add (token);  						encoded = true;  					} else {  						// append the lwsp and atom tokens  						if (lwsp != null)  							tokens.Add (lwsp);    						token = new Token ((int) (word - inbuf)' n);  						token.Is8bit = !ascii;  						tokens.Add (token);    						encoded = false;  					}  				} else {  					// append the trailing lwsp token  					if (lwsp != null)  						tokens.Add (lwsp);    					break;  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TokenizeText,The following statement contains a magic number: while (inptr < inend) {  				text = inptr;  				while (inptr < inend && IsLwsp (*inptr))  					inptr++;    				if (inptr > text)  					lwsp = new Token ((int) (text - inbuf)' (int) (inptr - text));  				else  					lwsp = null;    				if (inptr < inend) {  					word = inptr;  					ascii = true;    					if (options.Rfc2047ComplianceMode == RfcComplianceMode.Loose) {  						// Make an extra effort to detect and separate encoded-word  						// tokens that have been merged with other words.  						bool is_rfc2047 = false;    						if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?') {  							inptr += 2;    							// skip past the charset (if one is even declared' sigh)  							while (inptr < inend && *inptr != '?') {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							// sanity check encoding type  							if (inptr + 3 >= inend || *inptr != '?' || !IsBbQq (*(inptr + 1)) || *(inptr + 2) != '?') {  								ascii = true;  								goto non_rfc2047;  							}    							inptr += 3;    							// find the end of the rfc2047 encoded word token  							while (inptr + 2 < inend && !(*inptr == '?' && *(inptr + 1) == '=')) {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							if (inptr + 2 > inend || *inptr != '?' || *(inptr + 1) != '=') {  								// didn't find an end marker...  								inptr = word + 2;  								ascii = true;    								goto non_rfc2047;  							}    							is_rfc2047 = true;  							inptr += 2;  						}    					non_rfc2047:  						if (!is_rfc2047) {  							// stop if we encounter a possible rfc2047 encoded  							// token even if it's inside another word' sigh.  							while (inptr < inend && !IsLwsp (*inptr)) {  								if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?')  									break;    								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}  						}  					} else {  						// find the end of a run of text...  						while (inptr < inend && !IsLwsp (*inptr)) {  							ascii = ascii && IsAscii (*inptr);  							inptr++;  						}  					}    					n = (int) (inptr - word);  					if (TryGetEncodedWordToken (inbuf' word' n' out token)) {  						// rfc2047 states that you must ignore all whitespace between  						// encoded-word tokens  						if (!encoded && lwsp != null) {  							// previous token was not encoded' so preserve whitespace  							tokens.Add (lwsp);  						}    						tokens.Add (token);  						encoded = true;  					} else {  						// append the lwsp and atom tokens  						if (lwsp != null)  							tokens.Add (lwsp);    						token = new Token ((int) (word - inbuf)' n);  						token.Is8bit = !ascii;  						tokens.Add (token);    						encoded = false;  					}  				} else {  					// append the trailing lwsp token  					if (lwsp != null)  						tokens.Add (lwsp);    					break;  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TokenizeText,The following statement contains a magic number: while (inptr < inend) {  				text = inptr;  				while (inptr < inend && IsLwsp (*inptr))  					inptr++;    				if (inptr > text)  					lwsp = new Token ((int) (text - inbuf)' (int) (inptr - text));  				else  					lwsp = null;    				if (inptr < inend) {  					word = inptr;  					ascii = true;    					if (options.Rfc2047ComplianceMode == RfcComplianceMode.Loose) {  						// Make an extra effort to detect and separate encoded-word  						// tokens that have been merged with other words.  						bool is_rfc2047 = false;    						if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?') {  							inptr += 2;    							// skip past the charset (if one is even declared' sigh)  							while (inptr < inend && *inptr != '?') {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							// sanity check encoding type  							if (inptr + 3 >= inend || *inptr != '?' || !IsBbQq (*(inptr + 1)) || *(inptr + 2) != '?') {  								ascii = true;  								goto non_rfc2047;  							}    							inptr += 3;    							// find the end of the rfc2047 encoded word token  							while (inptr + 2 < inend && !(*inptr == '?' && *(inptr + 1) == '=')) {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							if (inptr + 2 > inend || *inptr != '?' || *(inptr + 1) != '=') {  								// didn't find an end marker...  								inptr = word + 2;  								ascii = true;    								goto non_rfc2047;  							}    							is_rfc2047 = true;  							inptr += 2;  						}    					non_rfc2047:  						if (!is_rfc2047) {  							// stop if we encounter a possible rfc2047 encoded  							// token even if it's inside another word' sigh.  							while (inptr < inend && !IsLwsp (*inptr)) {  								if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?')  									break;    								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}  						}  					} else {  						// find the end of a run of text...  						while (inptr < inend && !IsLwsp (*inptr)) {  							ascii = ascii && IsAscii (*inptr);  							inptr++;  						}  					}    					n = (int) (inptr - word);  					if (TryGetEncodedWordToken (inbuf' word' n' out token)) {  						// rfc2047 states that you must ignore all whitespace between  						// encoded-word tokens  						if (!encoded && lwsp != null) {  							// previous token was not encoded' so preserve whitespace  							tokens.Add (lwsp);  						}    						tokens.Add (token);  						encoded = true;  					} else {  						// append the lwsp and atom tokens  						if (lwsp != null)  							tokens.Add (lwsp);    						token = new Token ((int) (word - inbuf)' n);  						token.Is8bit = !ascii;  						tokens.Add (token);    						encoded = false;  					}  				} else {  					// append the trailing lwsp token  					if (lwsp != null)  						tokens.Add (lwsp);    					break;  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TokenizeText,The following statement contains a magic number: while (inptr < inend) {  				text = inptr;  				while (inptr < inend && IsLwsp (*inptr))  					inptr++;    				if (inptr > text)  					lwsp = new Token ((int) (text - inbuf)' (int) (inptr - text));  				else  					lwsp = null;    				if (inptr < inend) {  					word = inptr;  					ascii = true;    					if (options.Rfc2047ComplianceMode == RfcComplianceMode.Loose) {  						// Make an extra effort to detect and separate encoded-word  						// tokens that have been merged with other words.  						bool is_rfc2047 = false;    						if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?') {  							inptr += 2;    							// skip past the charset (if one is even declared' sigh)  							while (inptr < inend && *inptr != '?') {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							// sanity check encoding type  							if (inptr + 3 >= inend || *inptr != '?' || !IsBbQq (*(inptr + 1)) || *(inptr + 2) != '?') {  								ascii = true;  								goto non_rfc2047;  							}    							inptr += 3;    							// find the end of the rfc2047 encoded word token  							while (inptr + 2 < inend && !(*inptr == '?' && *(inptr + 1) == '=')) {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							if (inptr + 2 > inend || *inptr != '?' || *(inptr + 1) != '=') {  								// didn't find an end marker...  								inptr = word + 2;  								ascii = true;    								goto non_rfc2047;  							}    							is_rfc2047 = true;  							inptr += 2;  						}    					non_rfc2047:  						if (!is_rfc2047) {  							// stop if we encounter a possible rfc2047 encoded  							// token even if it's inside another word' sigh.  							while (inptr < inend && !IsLwsp (*inptr)) {  								if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?')  									break;    								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}  						}  					} else {  						// find the end of a run of text...  						while (inptr < inend && !IsLwsp (*inptr)) {  							ascii = ascii && IsAscii (*inptr);  							inptr++;  						}  					}    					n = (int) (inptr - word);  					if (TryGetEncodedWordToken (inbuf' word' n' out token)) {  						// rfc2047 states that you must ignore all whitespace between  						// encoded-word tokens  						if (!encoded && lwsp != null) {  							// previous token was not encoded' so preserve whitespace  							tokens.Add (lwsp);  						}    						tokens.Add (token);  						encoded = true;  					} else {  						// append the lwsp and atom tokens  						if (lwsp != null)  							tokens.Add (lwsp);    						token = new Token ((int) (word - inbuf)' n);  						token.Is8bit = !ascii;  						tokens.Add (token);    						encoded = false;  					}  				} else {  					// append the trailing lwsp token  					if (lwsp != null)  						tokens.Add (lwsp);    					break;  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TokenizeText,The following statement contains a magic number: while (inptr < inend) {  				text = inptr;  				while (inptr < inend && IsLwsp (*inptr))  					inptr++;    				if (inptr > text)  					lwsp = new Token ((int) (text - inbuf)' (int) (inptr - text));  				else  					lwsp = null;    				if (inptr < inend) {  					word = inptr;  					ascii = true;    					if (options.Rfc2047ComplianceMode == RfcComplianceMode.Loose) {  						// Make an extra effort to detect and separate encoded-word  						// tokens that have been merged with other words.  						bool is_rfc2047 = false;    						if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?') {  							inptr += 2;    							// skip past the charset (if one is even declared' sigh)  							while (inptr < inend && *inptr != '?') {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							// sanity check encoding type  							if (inptr + 3 >= inend || *inptr != '?' || !IsBbQq (*(inptr + 1)) || *(inptr + 2) != '?') {  								ascii = true;  								goto non_rfc2047;  							}    							inptr += 3;    							// find the end of the rfc2047 encoded word token  							while (inptr + 2 < inend && !(*inptr == '?' && *(inptr + 1) == '=')) {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							if (inptr + 2 > inend || *inptr != '?' || *(inptr + 1) != '=') {  								// didn't find an end marker...  								inptr = word + 2;  								ascii = true;    								goto non_rfc2047;  							}    							is_rfc2047 = true;  							inptr += 2;  						}    					non_rfc2047:  						if (!is_rfc2047) {  							// stop if we encounter a possible rfc2047 encoded  							// token even if it's inside another word' sigh.  							while (inptr < inend && !IsLwsp (*inptr)) {  								if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?')  									break;    								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}  						}  					} else {  						// find the end of a run of text...  						while (inptr < inend && !IsLwsp (*inptr)) {  							ascii = ascii && IsAscii (*inptr);  							inptr++;  						}  					}    					n = (int) (inptr - word);  					if (TryGetEncodedWordToken (inbuf' word' n' out token)) {  						// rfc2047 states that you must ignore all whitespace between  						// encoded-word tokens  						if (!encoded && lwsp != null) {  							// previous token was not encoded' so preserve whitespace  							tokens.Add (lwsp);  						}    						tokens.Add (token);  						encoded = true;  					} else {  						// append the lwsp and atom tokens  						if (lwsp != null)  							tokens.Add (lwsp);    						token = new Token ((int) (word - inbuf)' n);  						token.Is8bit = !ascii;  						tokens.Add (token);    						encoded = false;  					}  				} else {  					// append the trailing lwsp token  					if (lwsp != null)  						tokens.Add (lwsp);    					break;  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TokenizeText,The following statement contains a magic number: while (inptr < inend) {  				text = inptr;  				while (inptr < inend && IsLwsp (*inptr))  					inptr++;    				if (inptr > text)  					lwsp = new Token ((int) (text - inbuf)' (int) (inptr - text));  				else  					lwsp = null;    				if (inptr < inend) {  					word = inptr;  					ascii = true;    					if (options.Rfc2047ComplianceMode == RfcComplianceMode.Loose) {  						// Make an extra effort to detect and separate encoded-word  						// tokens that have been merged with other words.  						bool is_rfc2047 = false;    						if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?') {  							inptr += 2;    							// skip past the charset (if one is even declared' sigh)  							while (inptr < inend && *inptr != '?') {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							// sanity check encoding type  							if (inptr + 3 >= inend || *inptr != '?' || !IsBbQq (*(inptr + 1)) || *(inptr + 2) != '?') {  								ascii = true;  								goto non_rfc2047;  							}    							inptr += 3;    							// find the end of the rfc2047 encoded word token  							while (inptr + 2 < inend && !(*inptr == '?' && *(inptr + 1) == '=')) {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							if (inptr + 2 > inend || *inptr != '?' || *(inptr + 1) != '=') {  								// didn't find an end marker...  								inptr = word + 2;  								ascii = true;    								goto non_rfc2047;  							}    							is_rfc2047 = true;  							inptr += 2;  						}    					non_rfc2047:  						if (!is_rfc2047) {  							// stop if we encounter a possible rfc2047 encoded  							// token even if it's inside another word' sigh.  							while (inptr < inend && !IsLwsp (*inptr)) {  								if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?')  									break;    								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}  						}  					} else {  						// find the end of a run of text...  						while (inptr < inend && !IsLwsp (*inptr)) {  							ascii = ascii && IsAscii (*inptr);  							inptr++;  						}  					}    					n = (int) (inptr - word);  					if (TryGetEncodedWordToken (inbuf' word' n' out token)) {  						// rfc2047 states that you must ignore all whitespace between  						// encoded-word tokens  						if (!encoded && lwsp != null) {  							// previous token was not encoded' so preserve whitespace  							tokens.Add (lwsp);  						}    						tokens.Add (token);  						encoded = true;  					} else {  						// append the lwsp and atom tokens  						if (lwsp != null)  							tokens.Add (lwsp);    						token = new Token ((int) (word - inbuf)' n);  						token.Is8bit = !ascii;  						tokens.Add (token);    						encoded = false;  					}  				} else {  					// append the trailing lwsp token  					if (lwsp != null)  						tokens.Add (lwsp);    					break;  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TokenizeText,The following statement contains a magic number: while (inptr < inend) {  				text = inptr;  				while (inptr < inend && IsLwsp (*inptr))  					inptr++;    				if (inptr > text)  					lwsp = new Token ((int) (text - inbuf)' (int) (inptr - text));  				else  					lwsp = null;    				if (inptr < inend) {  					word = inptr;  					ascii = true;    					if (options.Rfc2047ComplianceMode == RfcComplianceMode.Loose) {  						// Make an extra effort to detect and separate encoded-word  						// tokens that have been merged with other words.  						bool is_rfc2047 = false;    						if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?') {  							inptr += 2;    							// skip past the charset (if one is even declared' sigh)  							while (inptr < inend && *inptr != '?') {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							// sanity check encoding type  							if (inptr + 3 >= inend || *inptr != '?' || !IsBbQq (*(inptr + 1)) || *(inptr + 2) != '?') {  								ascii = true;  								goto non_rfc2047;  							}    							inptr += 3;    							// find the end of the rfc2047 encoded word token  							while (inptr + 2 < inend && !(*inptr == '?' && *(inptr + 1) == '=')) {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							if (inptr + 2 > inend || *inptr != '?' || *(inptr + 1) != '=') {  								// didn't find an end marker...  								inptr = word + 2;  								ascii = true;    								goto non_rfc2047;  							}    							is_rfc2047 = true;  							inptr += 2;  						}    					non_rfc2047:  						if (!is_rfc2047) {  							// stop if we encounter a possible rfc2047 encoded  							// token even if it's inside another word' sigh.  							while (inptr < inend && !IsLwsp (*inptr)) {  								if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?')  									break;    								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}  						}  					} else {  						// find the end of a run of text...  						while (inptr < inend && !IsLwsp (*inptr)) {  							ascii = ascii && IsAscii (*inptr);  							inptr++;  						}  					}    					n = (int) (inptr - word);  					if (TryGetEncodedWordToken (inbuf' word' n' out token)) {  						// rfc2047 states that you must ignore all whitespace between  						// encoded-word tokens  						if (!encoded && lwsp != null) {  							// previous token was not encoded' so preserve whitespace  							tokens.Add (lwsp);  						}    						tokens.Add (token);  						encoded = true;  					} else {  						// append the lwsp and atom tokens  						if (lwsp != null)  							tokens.Add (lwsp);    						token = new Token ((int) (word - inbuf)' n);  						token.Is8bit = !ascii;  						tokens.Add (token);    						encoded = false;  					}  				} else {  					// append the trailing lwsp token  					if (lwsp != null)  						tokens.Add (lwsp);    					break;  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TokenizeText,The following statement contains a magic number: while (inptr < inend) {  				text = inptr;  				while (inptr < inend && IsLwsp (*inptr))  					inptr++;    				if (inptr > text)  					lwsp = new Token ((int) (text - inbuf)' (int) (inptr - text));  				else  					lwsp = null;    				if (inptr < inend) {  					word = inptr;  					ascii = true;    					if (options.Rfc2047ComplianceMode == RfcComplianceMode.Loose) {  						// Make an extra effort to detect and separate encoded-word  						// tokens that have been merged with other words.  						bool is_rfc2047 = false;    						if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?') {  							inptr += 2;    							// skip past the charset (if one is even declared' sigh)  							while (inptr < inend && *inptr != '?') {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							// sanity check encoding type  							if (inptr + 3 >= inend || *inptr != '?' || !IsBbQq (*(inptr + 1)) || *(inptr + 2) != '?') {  								ascii = true;  								goto non_rfc2047;  							}    							inptr += 3;    							// find the end of the rfc2047 encoded word token  							while (inptr + 2 < inend && !(*inptr == '?' && *(inptr + 1) == '=')) {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							if (inptr + 2 > inend || *inptr != '?' || *(inptr + 1) != '=') {  								// didn't find an end marker...  								inptr = word + 2;  								ascii = true;    								goto non_rfc2047;  							}    							is_rfc2047 = true;  							inptr += 2;  						}    					non_rfc2047:  						if (!is_rfc2047) {  							// stop if we encounter a possible rfc2047 encoded  							// token even if it's inside another word' sigh.  							while (inptr < inend && !IsLwsp (*inptr)) {  								if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?')  									break;    								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}  						}  					} else {  						// find the end of a run of text...  						while (inptr < inend && !IsLwsp (*inptr)) {  							ascii = ascii && IsAscii (*inptr);  							inptr++;  						}  					}    					n = (int) (inptr - word);  					if (TryGetEncodedWordToken (inbuf' word' n' out token)) {  						// rfc2047 states that you must ignore all whitespace between  						// encoded-word tokens  						if (!encoded && lwsp != null) {  							// previous token was not encoded' so preserve whitespace  							tokens.Add (lwsp);  						}    						tokens.Add (token);  						encoded = true;  					} else {  						// append the lwsp and atom tokens  						if (lwsp != null)  							tokens.Add (lwsp);    						token = new Token ((int) (word - inbuf)' n);  						token.Is8bit = !ascii;  						tokens.Add (token);    						encoded = false;  					}  				} else {  					// append the trailing lwsp token  					if (lwsp != null)  						tokens.Add (lwsp);    					break;  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TokenizeText,The following statement contains a magic number: while (inptr < inend) {  				text = inptr;  				while (inptr < inend && IsLwsp (*inptr))  					inptr++;    				if (inptr > text)  					lwsp = new Token ((int) (text - inbuf)' (int) (inptr - text));  				else  					lwsp = null;    				if (inptr < inend) {  					word = inptr;  					ascii = true;    					if (options.Rfc2047ComplianceMode == RfcComplianceMode.Loose) {  						// Make an extra effort to detect and separate encoded-word  						// tokens that have been merged with other words.  						bool is_rfc2047 = false;    						if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?') {  							inptr += 2;    							// skip past the charset (if one is even declared' sigh)  							while (inptr < inend && *inptr != '?') {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							// sanity check encoding type  							if (inptr + 3 >= inend || *inptr != '?' || !IsBbQq (*(inptr + 1)) || *(inptr + 2) != '?') {  								ascii = true;  								goto non_rfc2047;  							}    							inptr += 3;    							// find the end of the rfc2047 encoded word token  							while (inptr + 2 < inend && !(*inptr == '?' && *(inptr + 1) == '=')) {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							if (inptr + 2 > inend || *inptr != '?' || *(inptr + 1) != '=') {  								// didn't find an end marker...  								inptr = word + 2;  								ascii = true;    								goto non_rfc2047;  							}    							is_rfc2047 = true;  							inptr += 2;  						}    					non_rfc2047:  						if (!is_rfc2047) {  							// stop if we encounter a possible rfc2047 encoded  							// token even if it's inside another word' sigh.  							while (inptr < inend && !IsLwsp (*inptr)) {  								if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?')  									break;    								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}  						}  					} else {  						// find the end of a run of text...  						while (inptr < inend && !IsLwsp (*inptr)) {  							ascii = ascii && IsAscii (*inptr);  							inptr++;  						}  					}    					n = (int) (inptr - word);  					if (TryGetEncodedWordToken (inbuf' word' n' out token)) {  						// rfc2047 states that you must ignore all whitespace between  						// encoded-word tokens  						if (!encoded && lwsp != null) {  							// previous token was not encoded' so preserve whitespace  							tokens.Add (lwsp);  						}    						tokens.Add (token);  						encoded = true;  					} else {  						// append the lwsp and atom tokens  						if (lwsp != null)  							tokens.Add (lwsp);    						token = new Token ((int) (word - inbuf)' n);  						token.Is8bit = !ascii;  						tokens.Add (token);    						encoded = false;  					}  				} else {  					// append the trailing lwsp token  					if (lwsp != null)  						tokens.Add (lwsp);    					break;  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,TokenizeText,The following statement contains a magic number: while (inptr < inend) {  				text = inptr;  				while (inptr < inend && IsLwsp (*inptr))  					inptr++;    				if (inptr > text)  					lwsp = new Token ((int) (text - inbuf)' (int) (inptr - text));  				else  					lwsp = null;    				if (inptr < inend) {  					word = inptr;  					ascii = true;    					if (options.Rfc2047ComplianceMode == RfcComplianceMode.Loose) {  						// Make an extra effort to detect and separate encoded-word  						// tokens that have been merged with other words.  						bool is_rfc2047 = false;    						if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?') {  							inptr += 2;    							// skip past the charset (if one is even declared' sigh)  							while (inptr < inend && *inptr != '?') {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							// sanity check encoding type  							if (inptr + 3 >= inend || *inptr != '?' || !IsBbQq (*(inptr + 1)) || *(inptr + 2) != '?') {  								ascii = true;  								goto non_rfc2047;  							}    							inptr += 3;    							// find the end of the rfc2047 encoded word token  							while (inptr + 2 < inend && !(*inptr == '?' && *(inptr + 1) == '=')) {  								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}    							if (inptr + 2 > inend || *inptr != '?' || *(inptr + 1) != '=') {  								// didn't find an end marker...  								inptr = word + 2;  								ascii = true;    								goto non_rfc2047;  							}    							is_rfc2047 = true;  							inptr += 2;  						}    					non_rfc2047:  						if (!is_rfc2047) {  							// stop if we encounter a possible rfc2047 encoded  							// token even if it's inside another word' sigh.  							while (inptr < inend && !IsLwsp (*inptr)) {  								if (inptr + 2 < inend && *inptr == '=' && *(inptr + 1) == '?')  									break;    								ascii = ascii && IsAscii (*inptr);  								inptr++;  							}  						}  					} else {  						// find the end of a run of text...  						while (inptr < inend && !IsLwsp (*inptr)) {  							ascii = ascii && IsAscii (*inptr);  							inptr++;  						}  					}    					n = (int) (inptr - word);  					if (TryGetEncodedWordToken (inbuf' word' n' out token)) {  						// rfc2047 states that you must ignore all whitespace between  						// encoded-word tokens  						if (!encoded && lwsp != null) {  							// previous token was not encoded' so preserve whitespace  							tokens.Add (lwsp);  						}    						tokens.Add (token);  						encoded = true;  					} else {  						// append the lwsp and atom tokens  						if (lwsp != null)  							tokens.Add (lwsp);    						token = new Token ((int) (word - inbuf)' n);  						token.Is8bit = !ascii;  						tokens.Add (token);    						encoded = false;  					}  				} else {  					// append the trailing lwsp token  					if (lwsp != null)  						tokens.Add (lwsp);    					break;  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,FoldTokens,The following statement contains a magic number: var output = new StringBuilder (input.Length + 2);
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,FoldTokens,The following statement contains a magic number: int lineLength = field.Length + 2;
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,FoldTokens,The following statement contains a magic number: for (int i = 0; i < tokens.Count; i++) {  				token = tokens[i];    				if (input[token.StartIndex].IsWhitespace ()) {  					for (int n = token.StartIndex; n < token.StartIndex + token.Length; n++) {  						if (input[n] == (byte) '\r')  							continue;    						lwsp = output.Length;  						if (input[n] == (byte) '\t')  							tab = output.Length;    						output.Append ((char) input[n]);  						if (input[n] == (byte) '\n') {  							lwsp = tab = 0;  							lineLength = 0;  						} else {  							lineLength++;  						}  					}    					if (lineLength == 0 && i + 1 < tokens.Count) {  						output.Append (' ');  						lineLength = 1;  					}  				} else if (token.Encoding != ContentEncoding.Default) {  					string charset = token.CharsetCulture;    					if (lineLength + token.Length + charset.Length + 7 > options.MaxLineLength) {  						if (tab != 0) {  							// tabs are the perfect breaking opportunity...  							output.Insert (tab' options.NewLine);  							lineLength = (lwsp - tab) + 1;  						} else if (lwsp != 0) {  							// break just before the last lwsp character  							output.Insert (lwsp' options.NewLine);  							lineLength = 1;  						} else if (lineLength > 1) {  							// force a line break...  							output.Append (options.NewLine);  							output.Append (' ');  							lineLength = 1;  						}  					}    					// Note: if the encoded-word token is longer than the fold length' oh well...  					// it probably just means that we are folding a header written by a user-agent  					// with a different max line length than ours.    					output.AppendFormat ("=?{0}?{1}?"' charset' token.Encoding == ContentEncoding.Base64 ? 'b' : 'q');  					for (int n = token.StartIndex; n < token.StartIndex + token.Length; n++)  						output.Append ((char) input[n]);  					output.Append ("?=");    					lineLength += token.Length + charset.Length + 7;  					lwsp = 0;  					tab = 0;  				} else if (lineLength + token.Length > options.MaxLineLength) {  					if (tab != 0) {  						// tabs are the perfect breaking opportunity...  						output.Insert (tab' options.NewLine);  						lineLength = (lwsp - tab) + 1;  					} else if (lwsp != 0) {  						// break just before the last lwsp character  						output.Insert (lwsp' options.NewLine);  						lineLength = 1;  					} else if (lineLength > 1) {  						// force a line break...  						output.Append (options.NewLine);  						output.Append (' ');  						lineLength = 1;  					}    					if (token.Length >= options.MaxLineLength) {  						// the token is longer than the maximum allowable line length'  						// so we'll have to break it apart...  						for (int n = token.StartIndex; n < token.StartIndex + token.Length; n++) {  							if (lineLength >= options.MaxLineLength) {  								output.Append (options.NewLine);  								output.Append (' ');  								lineLength = 1;  							}    							output.Append ((char) input[n]);  							lineLength++;  						}  					} else {  						for (int n = token.StartIndex; n < token.StartIndex + token.Length; n++)  							output.Append ((char) input[n]);    						lineLength += token.Length;  					}    					lwsp = 0;  					tab = 0;  				} else {  					for (int n = token.StartIndex; n < token.StartIndex + token.Length; n++)  						output.Append ((char) input[n]);    					lineLength += token.Length;  					lwsp = 0;  					tab = 0;  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,FoldTokens,The following statement contains a magic number: for (int i = 0; i < tokens.Count; i++) {  				token = tokens[i];    				if (input[token.StartIndex].IsWhitespace ()) {  					for (int n = token.StartIndex; n < token.StartIndex + token.Length; n++) {  						if (input[n] == (byte) '\r')  							continue;    						lwsp = output.Length;  						if (input[n] == (byte) '\t')  							tab = output.Length;    						output.Append ((char) input[n]);  						if (input[n] == (byte) '\n') {  							lwsp = tab = 0;  							lineLength = 0;  						} else {  							lineLength++;  						}  					}    					if (lineLength == 0 && i + 1 < tokens.Count) {  						output.Append (' ');  						lineLength = 1;  					}  				} else if (token.Encoding != ContentEncoding.Default) {  					string charset = token.CharsetCulture;    					if (lineLength + token.Length + charset.Length + 7 > options.MaxLineLength) {  						if (tab != 0) {  							// tabs are the perfect breaking opportunity...  							output.Insert (tab' options.NewLine);  							lineLength = (lwsp - tab) + 1;  						} else if (lwsp != 0) {  							// break just before the last lwsp character  							output.Insert (lwsp' options.NewLine);  							lineLength = 1;  						} else if (lineLength > 1) {  							// force a line break...  							output.Append (options.NewLine);  							output.Append (' ');  							lineLength = 1;  						}  					}    					// Note: if the encoded-word token is longer than the fold length' oh well...  					// it probably just means that we are folding a header written by a user-agent  					// with a different max line length than ours.    					output.AppendFormat ("=?{0}?{1}?"' charset' token.Encoding == ContentEncoding.Base64 ? 'b' : 'q');  					for (int n = token.StartIndex; n < token.StartIndex + token.Length; n++)  						output.Append ((char) input[n]);  					output.Append ("?=");    					lineLength += token.Length + charset.Length + 7;  					lwsp = 0;  					tab = 0;  				} else if (lineLength + token.Length > options.MaxLineLength) {  					if (tab != 0) {  						// tabs are the perfect breaking opportunity...  						output.Insert (tab' options.NewLine);  						lineLength = (lwsp - tab) + 1;  					} else if (lwsp != 0) {  						// break just before the last lwsp character  						output.Insert (lwsp' options.NewLine);  						lineLength = 1;  					} else if (lineLength > 1) {  						// force a line break...  						output.Append (options.NewLine);  						output.Append (' ');  						lineLength = 1;  					}    					if (token.Length >= options.MaxLineLength) {  						// the token is longer than the maximum allowable line length'  						// so we'll have to break it apart...  						for (int n = token.StartIndex; n < token.StartIndex + token.Length; n++) {  							if (lineLength >= options.MaxLineLength) {  								output.Append (options.NewLine);  								output.Append (' ');  								lineLength = 1;  							}    							output.Append ((char) input[n]);  							lineLength++;  						}  					} else {  						for (int n = token.StartIndex; n < token.StartIndex + token.Length; n++)  							output.Append ((char) input[n]);    						lineLength += token.Length;  					}    					lwsp = 0;  					tab = 0;  				} else {  					for (int n = token.StartIndex; n < token.StartIndex + token.Length; n++)  						output.Append ((char) input[n]);    					lineLength += token.Length;  					lwsp = 0;  					tab = 0;  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,GetBestContentEncoding,The following statement contains a magic number: for (int i = startIndex; i < startIndex + length; i++) {  				if (text[i] > 127)  					count++;  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,GetBestContentEncoding,The following statement contains a magic number: if ((double) count < (length * 0.17))  				return ContentEncoding.QuotedPrintable;
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,EstimateEncodedWordLength,The following statement contains a magic number: int length = charset.Length + 7;
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,EstimateEncodedWordLength,The following statement contains a magic number: if ((double) encodeCount < (byteCount * 0.17)) {  				// quoted-printable encoding  				return length + (byteCount - encodeCount) + (encodeCount * 3);  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,EstimateEncodedWordLength,The following statement contains a magic number: if ((double) encodeCount < (byteCount * 0.17)) {  				// quoted-printable encoding  				return length + (byteCount - encodeCount) + (encodeCount * 3);  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,EstimateEncodedWordLength,The following statement contains a magic number: return length + ((byteCount + 2) / 3) * 4;
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,EstimateEncodedWordLength,The following statement contains a magic number: return length + ((byteCount + 2) / 3) * 4;
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,EstimateEncodedWordLength,The following statement contains a magic number: return length + ((byteCount + 2) / 3) * 4;
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,ExceedsMaxLineLength,The following statement contains a magic number: switch (word.Type) {  			case WordType.EncodedWord:  				switch (word.Encoding) {  				case 1:  					length = EstimateEncodedWordLength ("iso-8859-1"' word.ByteCount' word.EncodeCount);  					break;  				case 0:  					length = EstimateEncodedWordLength ("us-ascii"' word.ByteCount' word.EncodeCount);  					break;  				default:  					length = EstimateEncodedWordLength (charset' word.ByteCount' word.EncodeCount);  					break;  				}  				break;  			case WordType.QuotedString:  				length = word.ByteCount + word.QuotedPairs + 2;  				break;  			default:  				length = word.ByteCount;  				break;  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,GetRfc822Words,The following statement contains a magic number: var chars = new char[2];
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,GetRfc822Words,The following statement contains a magic number: while (i < text.Length) {  				c = text[i++];    				if (c < 256 && IsBlank (c)) {  					if (word.ByteCount > 0) {  						words.Add (word);  						word = new Word ();  					}    					word.StartIndex = i;  				} else {  					// save state in case adding this character exceeds the max line length  					word.CopyTo (saved);    					if (c < 127) {  						if (IsCtrl (c)) {  							word.Encoding = options.AllowMixedHeaderCharsets ? Math.Max (word.Encoding' 1) : 2;  							word.Type = WordType.EncodedWord;  							word.EncodeCount++;  						} else if (phrase && !IsAtom (c)) {  							// phrases can have quoted strings  							if (word.Type == WordType.Atom)  								word.Type = WordType.QuotedString;  						}    						if (c == '"' || c == '\\')  							word.QuotedPairs++;    						word.ByteCount++;  						word.CharCount++;  						nchars = 1;  					} else if (c < 256) {  						// iso-8859-1  						word.Encoding = options.AllowMixedHeaderCharsets ? Math.Max (word.Encoding' 1) : 2;  						word.Type = WordType.EncodedWord;  						word.EncodeCount++;  						word.ByteCount++;  						word.CharCount++;  						nchars = 1;  					} else {  						if (char.IsSurrogatePair (text' i - 1)) {  							chars[1] = text[i++];  							nchars = 2;  						} else {  							nchars = 1;  						}    						chars[0] = c;    						try {  							n = encoder.GetByteCount (chars' 0' nchars' true);  						} catch {  							n = 3;  						}    						word.Type = WordType.EncodedWord;  						word.CharCount += nchars;  						word.EncodeCount += n;  						word.ByteCount += n;  						word.Encoding = 2;  					}    					if (ExceedsMaxLineLength (options' charset' word)) {  						// restore our previous state  						saved.CopyTo (word);  						i -= nchars;    						// Note: if the word is longer than what we can fit on  						// one line' then we need to encode it.  						if (word.Type == WordType.Atom) {  							word.Type = WordType.EncodedWord;    							// in order to fit this long atom under MaxLineLength' we need to  							// account for the added length of =?us-ascii?q?...?=  							n = "us-ascii".Length + 7;  							word.CharCount -= n;  							word.ByteCount -= n;  							i -= n;  						}    						words.Add (word);    						saved.Type = word.Type;  						word = new Word ();    						// Note: the word-type needs to be preserved when breaking long words.  						word.Type = saved.Type;  						word.StartIndex = i;  					}  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,GetRfc822Words,The following statement contains a magic number: while (i < text.Length) {  				c = text[i++];    				if (c < 256 && IsBlank (c)) {  					if (word.ByteCount > 0) {  						words.Add (word);  						word = new Word ();  					}    					word.StartIndex = i;  				} else {  					// save state in case adding this character exceeds the max line length  					word.CopyTo (saved);    					if (c < 127) {  						if (IsCtrl (c)) {  							word.Encoding = options.AllowMixedHeaderCharsets ? Math.Max (word.Encoding' 1) : 2;  							word.Type = WordType.EncodedWord;  							word.EncodeCount++;  						} else if (phrase && !IsAtom (c)) {  							// phrases can have quoted strings  							if (word.Type == WordType.Atom)  								word.Type = WordType.QuotedString;  						}    						if (c == '"' || c == '\\')  							word.QuotedPairs++;    						word.ByteCount++;  						word.CharCount++;  						nchars = 1;  					} else if (c < 256) {  						// iso-8859-1  						word.Encoding = options.AllowMixedHeaderCharsets ? Math.Max (word.Encoding' 1) : 2;  						word.Type = WordType.EncodedWord;  						word.EncodeCount++;  						word.ByteCount++;  						word.CharCount++;  						nchars = 1;  					} else {  						if (char.IsSurrogatePair (text' i - 1)) {  							chars[1] = text[i++];  							nchars = 2;  						} else {  							nchars = 1;  						}    						chars[0] = c;    						try {  							n = encoder.GetByteCount (chars' 0' nchars' true);  						} catch {  							n = 3;  						}    						word.Type = WordType.EncodedWord;  						word.CharCount += nchars;  						word.EncodeCount += n;  						word.ByteCount += n;  						word.Encoding = 2;  					}    					if (ExceedsMaxLineLength (options' charset' word)) {  						// restore our previous state  						saved.CopyTo (word);  						i -= nchars;    						// Note: if the word is longer than what we can fit on  						// one line' then we need to encode it.  						if (word.Type == WordType.Atom) {  							word.Type = WordType.EncodedWord;    							// in order to fit this long atom under MaxLineLength' we need to  							// account for the added length of =?us-ascii?q?...?=  							n = "us-ascii".Length + 7;  							word.CharCount -= n;  							word.ByteCount -= n;  							i -= n;  						}    						words.Add (word);    						saved.Type = word.Type;  						word = new Word ();    						// Note: the word-type needs to be preserved when breaking long words.  						word.Type = saved.Type;  						word.StartIndex = i;  					}  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,GetRfc822Words,The following statement contains a magic number: while (i < text.Length) {  				c = text[i++];    				if (c < 256 && IsBlank (c)) {  					if (word.ByteCount > 0) {  						words.Add (word);  						word = new Word ();  					}    					word.StartIndex = i;  				} else {  					// save state in case adding this character exceeds the max line length  					word.CopyTo (saved);    					if (c < 127) {  						if (IsCtrl (c)) {  							word.Encoding = options.AllowMixedHeaderCharsets ? Math.Max (word.Encoding' 1) : 2;  							word.Type = WordType.EncodedWord;  							word.EncodeCount++;  						} else if (phrase && !IsAtom (c)) {  							// phrases can have quoted strings  							if (word.Type == WordType.Atom)  								word.Type = WordType.QuotedString;  						}    						if (c == '"' || c == '\\')  							word.QuotedPairs++;    						word.ByteCount++;  						word.CharCount++;  						nchars = 1;  					} else if (c < 256) {  						// iso-8859-1  						word.Encoding = options.AllowMixedHeaderCharsets ? Math.Max (word.Encoding' 1) : 2;  						word.Type = WordType.EncodedWord;  						word.EncodeCount++;  						word.ByteCount++;  						word.CharCount++;  						nchars = 1;  					} else {  						if (char.IsSurrogatePair (text' i - 1)) {  							chars[1] = text[i++];  							nchars = 2;  						} else {  							nchars = 1;  						}    						chars[0] = c;    						try {  							n = encoder.GetByteCount (chars' 0' nchars' true);  						} catch {  							n = 3;  						}    						word.Type = WordType.EncodedWord;  						word.CharCount += nchars;  						word.EncodeCount += n;  						word.ByteCount += n;  						word.Encoding = 2;  					}    					if (ExceedsMaxLineLength (options' charset' word)) {  						// restore our previous state  						saved.CopyTo (word);  						i -= nchars;    						// Note: if the word is longer than what we can fit on  						// one line' then we need to encode it.  						if (word.Type == WordType.Atom) {  							word.Type = WordType.EncodedWord;    							// in order to fit this long atom under MaxLineLength' we need to  							// account for the added length of =?us-ascii?q?...?=  							n = "us-ascii".Length + 7;  							word.CharCount -= n;  							word.ByteCount -= n;  							i -= n;  						}    						words.Add (word);    						saved.Type = word.Type;  						word = new Word ();    						// Note: the word-type needs to be preserved when breaking long words.  						word.Type = saved.Type;  						word.StartIndex = i;  					}  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,GetRfc822Words,The following statement contains a magic number: while (i < text.Length) {  				c = text[i++];    				if (c < 256 && IsBlank (c)) {  					if (word.ByteCount > 0) {  						words.Add (word);  						word = new Word ();  					}    					word.StartIndex = i;  				} else {  					// save state in case adding this character exceeds the max line length  					word.CopyTo (saved);    					if (c < 127) {  						if (IsCtrl (c)) {  							word.Encoding = options.AllowMixedHeaderCharsets ? Math.Max (word.Encoding' 1) : 2;  							word.Type = WordType.EncodedWord;  							word.EncodeCount++;  						} else if (phrase && !IsAtom (c)) {  							// phrases can have quoted strings  							if (word.Type == WordType.Atom)  								word.Type = WordType.QuotedString;  						}    						if (c == '"' || c == '\\')  							word.QuotedPairs++;    						word.ByteCount++;  						word.CharCount++;  						nchars = 1;  					} else if (c < 256) {  						// iso-8859-1  						word.Encoding = options.AllowMixedHeaderCharsets ? Math.Max (word.Encoding' 1) : 2;  						word.Type = WordType.EncodedWord;  						word.EncodeCount++;  						word.ByteCount++;  						word.CharCount++;  						nchars = 1;  					} else {  						if (char.IsSurrogatePair (text' i - 1)) {  							chars[1] = text[i++];  							nchars = 2;  						} else {  							nchars = 1;  						}    						chars[0] = c;    						try {  							n = encoder.GetByteCount (chars' 0' nchars' true);  						} catch {  							n = 3;  						}    						word.Type = WordType.EncodedWord;  						word.CharCount += nchars;  						word.EncodeCount += n;  						word.ByteCount += n;  						word.Encoding = 2;  					}    					if (ExceedsMaxLineLength (options' charset' word)) {  						// restore our previous state  						saved.CopyTo (word);  						i -= nchars;    						// Note: if the word is longer than what we can fit on  						// one line' then we need to encode it.  						if (word.Type == WordType.Atom) {  							word.Type = WordType.EncodedWord;    							// in order to fit this long atom under MaxLineLength' we need to  							// account for the added length of =?us-ascii?q?...?=  							n = "us-ascii".Length + 7;  							word.CharCount -= n;  							word.ByteCount -= n;  							i -= n;  						}    						words.Add (word);    						saved.Type = word.Type;  						word = new Word ();    						// Note: the word-type needs to be preserved when breaking long words.  						word.Type = saved.Type;  						word.StartIndex = i;  					}  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,GetRfc822Words,The following statement contains a magic number: while (i < text.Length) {  				c = text[i++];    				if (c < 256 && IsBlank (c)) {  					if (word.ByteCount > 0) {  						words.Add (word);  						word = new Word ();  					}    					word.StartIndex = i;  				} else {  					// save state in case adding this character exceeds the max line length  					word.CopyTo (saved);    					if (c < 127) {  						if (IsCtrl (c)) {  							word.Encoding = options.AllowMixedHeaderCharsets ? Math.Max (word.Encoding' 1) : 2;  							word.Type = WordType.EncodedWord;  							word.EncodeCount++;  						} else if (phrase && !IsAtom (c)) {  							// phrases can have quoted strings  							if (word.Type == WordType.Atom)  								word.Type = WordType.QuotedString;  						}    						if (c == '"' || c == '\\')  							word.QuotedPairs++;    						word.ByteCount++;  						word.CharCount++;  						nchars = 1;  					} else if (c < 256) {  						// iso-8859-1  						word.Encoding = options.AllowMixedHeaderCharsets ? Math.Max (word.Encoding' 1) : 2;  						word.Type = WordType.EncodedWord;  						word.EncodeCount++;  						word.ByteCount++;  						word.CharCount++;  						nchars = 1;  					} else {  						if (char.IsSurrogatePair (text' i - 1)) {  							chars[1] = text[i++];  							nchars = 2;  						} else {  							nchars = 1;  						}    						chars[0] = c;    						try {  							n = encoder.GetByteCount (chars' 0' nchars' true);  						} catch {  							n = 3;  						}    						word.Type = WordType.EncodedWord;  						word.CharCount += nchars;  						word.EncodeCount += n;  						word.ByteCount += n;  						word.Encoding = 2;  					}    					if (ExceedsMaxLineLength (options' charset' word)) {  						// restore our previous state  						saved.CopyTo (word);  						i -= nchars;    						// Note: if the word is longer than what we can fit on  						// one line' then we need to encode it.  						if (word.Type == WordType.Atom) {  							word.Type = WordType.EncodedWord;    							// in order to fit this long atom under MaxLineLength' we need to  							// account for the added length of =?us-ascii?q?...?=  							n = "us-ascii".Length + 7;  							word.CharCount -= n;  							word.ByteCount -= n;  							i -= n;  						}    						words.Add (word);    						saved.Type = word.Type;  						word = new Word ();    						// Note: the word-type needs to be preserved when breaking long words.  						word.Type = saved.Type;  						word.StartIndex = i;  					}  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,GetRfc822Words,The following statement contains a magic number: while (i < text.Length) {  				c = text[i++];    				if (c < 256 && IsBlank (c)) {  					if (word.ByteCount > 0) {  						words.Add (word);  						word = new Word ();  					}    					word.StartIndex = i;  				} else {  					// save state in case adding this character exceeds the max line length  					word.CopyTo (saved);    					if (c < 127) {  						if (IsCtrl (c)) {  							word.Encoding = options.AllowMixedHeaderCharsets ? Math.Max (word.Encoding' 1) : 2;  							word.Type = WordType.EncodedWord;  							word.EncodeCount++;  						} else if (phrase && !IsAtom (c)) {  							// phrases can have quoted strings  							if (word.Type == WordType.Atom)  								word.Type = WordType.QuotedString;  						}    						if (c == '"' || c == '\\')  							word.QuotedPairs++;    						word.ByteCount++;  						word.CharCount++;  						nchars = 1;  					} else if (c < 256) {  						// iso-8859-1  						word.Encoding = options.AllowMixedHeaderCharsets ? Math.Max (word.Encoding' 1) : 2;  						word.Type = WordType.EncodedWord;  						word.EncodeCount++;  						word.ByteCount++;  						word.CharCount++;  						nchars = 1;  					} else {  						if (char.IsSurrogatePair (text' i - 1)) {  							chars[1] = text[i++];  							nchars = 2;  						} else {  							nchars = 1;  						}    						chars[0] = c;    						try {  							n = encoder.GetByteCount (chars' 0' nchars' true);  						} catch {  							n = 3;  						}    						word.Type = WordType.EncodedWord;  						word.CharCount += nchars;  						word.EncodeCount += n;  						word.ByteCount += n;  						word.Encoding = 2;  					}    					if (ExceedsMaxLineLength (options' charset' word)) {  						// restore our previous state  						saved.CopyTo (word);  						i -= nchars;    						// Note: if the word is longer than what we can fit on  						// one line' then we need to encode it.  						if (word.Type == WordType.Atom) {  							word.Type = WordType.EncodedWord;    							// in order to fit this long atom under MaxLineLength' we need to  							// account for the added length of =?us-ascii?q?...?=  							n = "us-ascii".Length + 7;  							word.CharCount -= n;  							word.ByteCount -= n;  							i -= n;  						}    						words.Add (word);    						saved.Type = word.Type;  						word = new Word ();    						// Note: the word-type needs to be preserved when breaking long words.  						word.Type = saved.Type;  						word.StartIndex = i;  					}  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,GetRfc822Words,The following statement contains a magic number: while (i < text.Length) {  				c = text[i++];    				if (c < 256 && IsBlank (c)) {  					if (word.ByteCount > 0) {  						words.Add (word);  						word = new Word ();  					}    					word.StartIndex = i;  				} else {  					// save state in case adding this character exceeds the max line length  					word.CopyTo (saved);    					if (c < 127) {  						if (IsCtrl (c)) {  							word.Encoding = options.AllowMixedHeaderCharsets ? Math.Max (word.Encoding' 1) : 2;  							word.Type = WordType.EncodedWord;  							word.EncodeCount++;  						} else if (phrase && !IsAtom (c)) {  							// phrases can have quoted strings  							if (word.Type == WordType.Atom)  								word.Type = WordType.QuotedString;  						}    						if (c == '"' || c == '\\')  							word.QuotedPairs++;    						word.ByteCount++;  						word.CharCount++;  						nchars = 1;  					} else if (c < 256) {  						// iso-8859-1  						word.Encoding = options.AllowMixedHeaderCharsets ? Math.Max (word.Encoding' 1) : 2;  						word.Type = WordType.EncodedWord;  						word.EncodeCount++;  						word.ByteCount++;  						word.CharCount++;  						nchars = 1;  					} else {  						if (char.IsSurrogatePair (text' i - 1)) {  							chars[1] = text[i++];  							nchars = 2;  						} else {  							nchars = 1;  						}    						chars[0] = c;    						try {  							n = encoder.GetByteCount (chars' 0' nchars' true);  						} catch {  							n = 3;  						}    						word.Type = WordType.EncodedWord;  						word.CharCount += nchars;  						word.EncodeCount += n;  						word.ByteCount += n;  						word.Encoding = 2;  					}    					if (ExceedsMaxLineLength (options' charset' word)) {  						// restore our previous state  						saved.CopyTo (word);  						i -= nchars;    						// Note: if the word is longer than what we can fit on  						// one line' then we need to encode it.  						if (word.Type == WordType.Atom) {  							word.Type = WordType.EncodedWord;    							// in order to fit this long atom under MaxLineLength' we need to  							// account for the added length of =?us-ascii?q?...?=  							n = "us-ascii".Length + 7;  							word.CharCount -= n;  							word.ByteCount -= n;  							i -= n;  						}    						words.Add (word);    						saved.Type = word.Type;  						word = new Word ();    						// Note: the word-type needs to be preserved when breaking long words.  						word.Type = saved.Type;  						word.StartIndex = i;  					}  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,GetRfc822Words,The following statement contains a magic number: while (i < text.Length) {  				c = text[i++];    				if (c < 256 && IsBlank (c)) {  					if (word.ByteCount > 0) {  						words.Add (word);  						word = new Word ();  					}    					word.StartIndex = i;  				} else {  					// save state in case adding this character exceeds the max line length  					word.CopyTo (saved);    					if (c < 127) {  						if (IsCtrl (c)) {  							word.Encoding = options.AllowMixedHeaderCharsets ? Math.Max (word.Encoding' 1) : 2;  							word.Type = WordType.EncodedWord;  							word.EncodeCount++;  						} else if (phrase && !IsAtom (c)) {  							// phrases can have quoted strings  							if (word.Type == WordType.Atom)  								word.Type = WordType.QuotedString;  						}    						if (c == '"' || c == '\\')  							word.QuotedPairs++;    						word.ByteCount++;  						word.CharCount++;  						nchars = 1;  					} else if (c < 256) {  						// iso-8859-1  						word.Encoding = options.AllowMixedHeaderCharsets ? Math.Max (word.Encoding' 1) : 2;  						word.Type = WordType.EncodedWord;  						word.EncodeCount++;  						word.ByteCount++;  						word.CharCount++;  						nchars = 1;  					} else {  						if (char.IsSurrogatePair (text' i - 1)) {  							chars[1] = text[i++];  							nchars = 2;  						} else {  							nchars = 1;  						}    						chars[0] = c;    						try {  							n = encoder.GetByteCount (chars' 0' nchars' true);  						} catch {  							n = 3;  						}    						word.Type = WordType.EncodedWord;  						word.CharCount += nchars;  						word.EncodeCount += n;  						word.ByteCount += n;  						word.Encoding = 2;  					}    					if (ExceedsMaxLineLength (options' charset' word)) {  						// restore our previous state  						saved.CopyTo (word);  						i -= nchars;    						// Note: if the word is longer than what we can fit on  						// one line' then we need to encode it.  						if (word.Type == WordType.Atom) {  							word.Type = WordType.EncodedWord;    							// in order to fit this long atom under MaxLineLength' we need to  							// account for the added length of =?us-ascii?q?...?=  							n = "us-ascii".Length + 7;  							word.CharCount -= n;  							word.ByteCount -= n;  							i -= n;  						}    						words.Add (word);    						saved.Type = word.Type;  						word = new Word ();    						// Note: the word-type needs to be preserved when breaking long words.  						word.Type = saved.Type;  						word.StartIndex = i;  					}  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,GetRfc822Words,The following statement contains a magic number: while (i < text.Length) {  				c = text[i++];    				if (c < 256 && IsBlank (c)) {  					if (word.ByteCount > 0) {  						words.Add (word);  						word = new Word ();  					}    					word.StartIndex = i;  				} else {  					// save state in case adding this character exceeds the max line length  					word.CopyTo (saved);    					if (c < 127) {  						if (IsCtrl (c)) {  							word.Encoding = options.AllowMixedHeaderCharsets ? Math.Max (word.Encoding' 1) : 2;  							word.Type = WordType.EncodedWord;  							word.EncodeCount++;  						} else if (phrase && !IsAtom (c)) {  							// phrases can have quoted strings  							if (word.Type == WordType.Atom)  								word.Type = WordType.QuotedString;  						}    						if (c == '"' || c == '\\')  							word.QuotedPairs++;    						word.ByteCount++;  						word.CharCount++;  						nchars = 1;  					} else if (c < 256) {  						// iso-8859-1  						word.Encoding = options.AllowMixedHeaderCharsets ? Math.Max (word.Encoding' 1) : 2;  						word.Type = WordType.EncodedWord;  						word.EncodeCount++;  						word.ByteCount++;  						word.CharCount++;  						nchars = 1;  					} else {  						if (char.IsSurrogatePair (text' i - 1)) {  							chars[1] = text[i++];  							nchars = 2;  						} else {  							nchars = 1;  						}    						chars[0] = c;    						try {  							n = encoder.GetByteCount (chars' 0' nchars' true);  						} catch {  							n = 3;  						}    						word.Type = WordType.EncodedWord;  						word.CharCount += nchars;  						word.EncodeCount += n;  						word.ByteCount += n;  						word.Encoding = 2;  					}    					if (ExceedsMaxLineLength (options' charset' word)) {  						// restore our previous state  						saved.CopyTo (word);  						i -= nchars;    						// Note: if the word is longer than what we can fit on  						// one line' then we need to encode it.  						if (word.Type == WordType.Atom) {  							word.Type = WordType.EncodedWord;    							// in order to fit this long atom under MaxLineLength' we need to  							// account for the added length of =?us-ascii?q?...?=  							n = "us-ascii".Length + 7;  							word.CharCount -= n;  							word.ByteCount -= n;  							i -= n;  						}    						words.Add (word);    						saved.Type = word.Type;  						word = new Word ();    						// Note: the word-type needs to be preserved when breaking long words.  						word.Type = saved.Type;  						word.StartIndex = i;  					}  				}  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,ShouldMergeWords,The following statement contains a magic number: switch (word.Type) {  			case WordType.Atom:  				if (next.Type == WordType.EncodedWord)  					return false;    				return length + 1 < options.MaxLineLength;  			case WordType.QuotedString:  				if (next.Type == WordType.EncodedWord)  					return false;    				return length + quoted + 3 < options.MaxLineLength;  			case WordType.EncodedWord:  				if (next.Type == WordType.Atom) {  					// whether we merge or not is dependent upon:  					// 1. the number of atoms in a row after 'word'  					// 2. if there is another encoded-word after  					//    the string of atoms.  					bool merge = false;  					int natoms = 0;    					for (int j = i + 1; j < words.Count && natoms < 3; j++) {  						if (words[j].Type != WordType.Atom) {  							merge = true;  							break;  						}    						natoms++;  					}    					// if all the words after the encoded-word are atoms' don't merge  					if (!merge)  						return false;  				}    				// avoid merging with qstrings  				if (next.Type == WordType.QuotedString)  					return false;    				switch (Math.Max (word.Encoding' next.Encoding)) {  				case 1:  					length = EstimateEncodedWordLength ("iso-8859-1"' length' encoded);  					break;  				case 0:  					length = EstimateEncodedWordLength ("us-ascii"' length' encoded);  					break;  				default:  					length = EstimateEncodedWordLength (charset' length' encoded);  					break;  				}    				return length + 1 < options.MaxLineLength;  			default:  				return false;  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,ShouldMergeWords,The following statement contains a magic number: switch (word.Type) {  			case WordType.Atom:  				if (next.Type == WordType.EncodedWord)  					return false;    				return length + 1 < options.MaxLineLength;  			case WordType.QuotedString:  				if (next.Type == WordType.EncodedWord)  					return false;    				return length + quoted + 3 < options.MaxLineLength;  			case WordType.EncodedWord:  				if (next.Type == WordType.Atom) {  					// whether we merge or not is dependent upon:  					// 1. the number of atoms in a row after 'word'  					// 2. if there is another encoded-word after  					//    the string of atoms.  					bool merge = false;  					int natoms = 0;    					for (int j = i + 1; j < words.Count && natoms < 3; j++) {  						if (words[j].Type != WordType.Atom) {  							merge = true;  							break;  						}    						natoms++;  					}    					// if all the words after the encoded-word are atoms' don't merge  					if (!merge)  						return false;  				}    				// avoid merging with qstrings  				if (next.Type == WordType.QuotedString)  					return false;    				switch (Math.Max (word.Encoding' next.Encoding)) {  				case 1:  					length = EstimateEncodedWordLength ("iso-8859-1"' length' encoded);  					break;  				case 0:  					length = EstimateEncodedWordLength ("us-ascii"' length' encoded);  					break;  				default:  					length = EstimateEncodedWordLength (charset' length' encoded);  					break;  				}    				return length + 1 < options.MaxLineLength;  			default:  				return false;  			}
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,Merge,The following statement contains a magic number: if (words.Count < 2)  				return words;
Magic Number,MimeKit.Utils,Rfc2047,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\Rfc2047.cs,Merge,The following statement contains a magic number: for (int i = 1; i < words.Count; i++) {  				next = words[i];    				if (word.Type != WordType.Atom && word.Type == next.Type) {  					lwspCount = next.StartIndex - (word.StartIndex + word.CharCount);  					byteCount = word.ByteCount + lwspCount + next.ByteCount;  					encoding = Math.Max (word.Encoding' next.Encoding);  					encoded = word.EncodeCount + next.EncodeCount;  					quoted = word.QuotedPairs + next.QuotedPairs;    					if (word.Type == WordType.EncodedWord) {  						switch (encoding) {  						case 1:  							length = EstimateEncodedWordLength ("iso-8859-1"' byteCount' encoded);  							break;  						case 0:  							length = EstimateEncodedWordLength ("us-ascii"' byteCount' encoded);  							break;  						default:  							length = EstimateEncodedWordLength (charset' byteCount' encoded);  							break;  						}  					} else {  						length = byteCount + quoted + 2;  					}    					if (length + 1 < options.MaxLineLength) {  						word.CharCount = (next.StartIndex + next.CharCount) - word.StartIndex;  						word.ByteCount = byteCount;  						word.EncodeCount = encoded;  						word.QuotedPairs = quoted;  						word.Encoding = encoding;  						continue;  					}  				}    				merged.Add (next);  				word = next;  			}
Magic Number,MimeKit.Utils,StringBuilderExtensions,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\StringBuilderExtensions.cs,AppendCStringByte,The following statement contains a magic number: switch (c) {  			case 0x00: text.Append ("\\0"); break;  			case 0x07: text.Append ("\\a"); break;  			case 0x08: text.Append ("\\b"); break;  			case 0x09: text.Append ("\\t"); break;  			case 0x0A: text.Append ("\\n"); break;  			case 0x0B: text.Append ("\\v"); break;  			case 0x0D: text.Append ("\\r"); break;  			default:  				if (c < 020 || c > 0x7e) {  					text.AppendFormat ("\\x{0:x2}"' c);  				} else {  					text.Append ((char) c);  				}  				break;  			}
Magic Number,MimeKit,AttachmentCollection,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\AttachmentCollection.cs,LoadContent,The following statement contains a magic number: var buf = new byte[4096];
Magic Number,MimeKit,ContentObject,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\ContentObject.cs,WriteTo,The following statement contains a magic number: var buf = new byte[4096];
Magic Number,MimeKit,ContentType,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\ContentType.cs,ContentType,The following statement contains a magic number: for (int i = 0; i < mediaType.Length; i++) {  				if (mediaType[i] >= 127 || !IsAsciiAtom ((byte) mediaType[i]))  					throw new ArgumentException ("Illegal characters in type."' "mediaType");  			}
Magic Number,MimeKit,ContentType,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\ContentType.cs,ContentType,The following statement contains a magic number: for (int i = 0; i < mediaSubtype.Length; i++) {  				if (mediaSubtype[i] >= 127 || !IsToken ((byte) mediaSubtype[i]))  					throw new ArgumentException ("Illegal characters in subtype."' "mediaSubtype");  			}
Magic Number,MimeKit,GroupAddress,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\GroupAddress.cs,Encode,The following statement contains a magic number: lineLength += 2;
Magic Number,MimeKit,Header,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Header.cs,Header,The following statement contains a magic number: for (int i = 0; i < field.Length; i++) {  				if (field[i] >= 127 || !IsAsciiAtom ((byte) field[i]))  					throw new ArgumentException ("Illegal characters in header field name."' "field");  			}
Magic Number,MimeKit,Header,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Header.cs,Header,The following statement contains a magic number: for (int i = 0; i < field.Length; i++) {  				if (field[i] >= 127 || !IsAsciiAtom ((byte) field[i]))  					throw new ArgumentException ("Illegal characters in header field name."' "field");  			}
Magic Number,MimeKit,Header,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Header.cs,EncodeAddressHeader,The following statement contains a magic number: int lineLength = field.Length + 2;
Magic Number,MimeKit,Header,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Header.cs,EncodeReferencesHeader,The following statement contains a magic number: foreach (var reference in MimeUtils.EnumerateReferences (value)) {  				if (count > 0 && lineLength + reference.Length + 3 > format.MaxLineLength) {  					encoded.Append (format.NewLine);  					encoded.Append ('\t');  					lineLength = 1;  					count = 0;  				} else {  					encoded.Append (' ');  					lineLength++;  				}    				encoded.Append ('<').Append (reference).Append ('>');  				lineLength += reference.Length + 2;  				count++;  			}
Magic Number,MimeKit,Header,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Header.cs,EncodeReferencesHeader,The following statement contains a magic number: foreach (var reference in MimeUtils.EnumerateReferences (value)) {  				if (count > 0 && lineLength + reference.Length + 3 > format.MaxLineLength) {  					encoded.Append (format.NewLine);  					encoded.Append ('\t');  					lineLength = 1;  					count = 0;  				} else {  					encoded.Append (' ');  					lineLength++;  				}    				encoded.Append ('<').Append (reference).Append ('>');  				lineLength += reference.Length + 2;  				count++;  			}
Magic Number,MimeKit,Header,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Header.cs,Fold,The following statement contains a magic number: int lineLength = field.Length + 2;
Magic Number,MimeKit,InternetAddress,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\InternetAddress.cs,TryParse,The following statement contains a magic number: if (text[index] == (byte) ':') {  				// rfc2822 group address  				int codepage = -1;  				string name;    				if (length > 0) {  					name = Rfc2047.DecodePhrase (options' text' startIndex' length' out codepage);  				} else {  					name = string.Empty;  				}    				if (codepage == -1)  					codepage = 65001;    				return TryParseGroup (options' text' startIndex' ref index' endIndex' MimeUtils.Unquote (name)' codepage' throwOnError' out address);  			}
Magic Number,MimeKit,InternetAddress,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\InternetAddress.cs,TryParse,The following statement contains a magic number: if (text[index] == (byte) '<') {  				// rfc2822 angle-addr token  				int codepage = -1;  				string name;    				if (length > 0) {  					name = Rfc2047.DecodePhrase (options' text' startIndex' length' out codepage);  				} else {  					name = string.Empty;  				}    				if (codepage == -1)  					codepage = 65001;    				return TryParseMailbox (options' text' startIndex' ref index' endIndex' MimeUtils.Unquote (name)' codepage' throwOnError' out address);  			}
Magic Number,MimeKit,MailboxAddress,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MailboxAddress.cs,Encode,The following statement contains a magic number: if (!string.IsNullOrEmpty (Name)) {  				string name;    				if (!options.International) {  					var encoded = Rfc2047.EncodePhrase (options' Encoding' Name);  					name = Encoding.ASCII.GetString (encoded' 0' encoded.Length);  				} else {  					name = EncodeInternationalizedPhrase (Name);  				}    				if (lineLength + name.Length > options.MaxLineLength) {  					if (name.Length > options.MaxLineLength) {  						// we need to break up the name...  						builder.AppendFolded (options' name' ref lineLength);  					} else {  						// the name itself is short enough to fit on a single line'  						// but only if we write it on a line by itself  						if (lineLength > 1) {  							builder.LineWrap (options);  							lineLength = 1;  						}    						lineLength += name.Length;  						builder.Append (name);  					}  				} else {  					// we can safely fit the name on this line...  					lineLength += name.Length;  					builder.Append (name);  				}    				if ((lineLength + route.Length + Address.Length + 3) > options.MaxLineLength) {  					builder.Append (options.NewLine);  					builder.Append ("\t<");  					lineLength = 2;  				} else {  					builder.Append (" <");  					lineLength += 2;  				}    				lineLength += route.Length;  				builder.Append (route);    				lineLength += Address.Length + 1;  				builder.Append (Address);  				builder.Append ('>');  			} else if (!string.IsNullOrEmpty (route)) {  				if ((lineLength + route.Length + Address.Length + 2) > options.MaxLineLength) {  					builder.Append (options.NewLine);  					builder.Append ("\t<");  					lineLength = 2;  				} else {  					builder.Append ('<');  					lineLength++;  				}    				lineLength += route.Length;  				builder.Append (route);    				lineLength += Address.Length + 1;  				builder.Append (Address);  				builder.Append ('>');  			} else {  				if ((lineLength + Address.Length) > options.MaxLineLength) {  					builder.LineWrap (options);  					lineLength = 1;  				}    				lineLength += Address.Length;  				builder.Append (Address);  			}
Magic Number,MimeKit,MailboxAddress,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MailboxAddress.cs,Encode,The following statement contains a magic number: if (!string.IsNullOrEmpty (Name)) {  				string name;    				if (!options.International) {  					var encoded = Rfc2047.EncodePhrase (options' Encoding' Name);  					name = Encoding.ASCII.GetString (encoded' 0' encoded.Length);  				} else {  					name = EncodeInternationalizedPhrase (Name);  				}    				if (lineLength + name.Length > options.MaxLineLength) {  					if (name.Length > options.MaxLineLength) {  						// we need to break up the name...  						builder.AppendFolded (options' name' ref lineLength);  					} else {  						// the name itself is short enough to fit on a single line'  						// but only if we write it on a line by itself  						if (lineLength > 1) {  							builder.LineWrap (options);  							lineLength = 1;  						}    						lineLength += name.Length;  						builder.Append (name);  					}  				} else {  					// we can safely fit the name on this line...  					lineLength += name.Length;  					builder.Append (name);  				}    				if ((lineLength + route.Length + Address.Length + 3) > options.MaxLineLength) {  					builder.Append (options.NewLine);  					builder.Append ("\t<");  					lineLength = 2;  				} else {  					builder.Append (" <");  					lineLength += 2;  				}    				lineLength += route.Length;  				builder.Append (route);    				lineLength += Address.Length + 1;  				builder.Append (Address);  				builder.Append ('>');  			} else if (!string.IsNullOrEmpty (route)) {  				if ((lineLength + route.Length + Address.Length + 2) > options.MaxLineLength) {  					builder.Append (options.NewLine);  					builder.Append ("\t<");  					lineLength = 2;  				} else {  					builder.Append ('<');  					lineLength++;  				}    				lineLength += route.Length;  				builder.Append (route);    				lineLength += Address.Length + 1;  				builder.Append (Address);  				builder.Append ('>');  			} else {  				if ((lineLength + Address.Length) > options.MaxLineLength) {  					builder.LineWrap (options);  					lineLength = 1;  				}    				lineLength += Address.Length;  				builder.Append (Address);  			}
Magic Number,MimeKit,MailboxAddress,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MailboxAddress.cs,Encode,The following statement contains a magic number: if (!string.IsNullOrEmpty (Name)) {  				string name;    				if (!options.International) {  					var encoded = Rfc2047.EncodePhrase (options' Encoding' Name);  					name = Encoding.ASCII.GetString (encoded' 0' encoded.Length);  				} else {  					name = EncodeInternationalizedPhrase (Name);  				}    				if (lineLength + name.Length > options.MaxLineLength) {  					if (name.Length > options.MaxLineLength) {  						// we need to break up the name...  						builder.AppendFolded (options' name' ref lineLength);  					} else {  						// the name itself is short enough to fit on a single line'  						// but only if we write it on a line by itself  						if (lineLength > 1) {  							builder.LineWrap (options);  							lineLength = 1;  						}    						lineLength += name.Length;  						builder.Append (name);  					}  				} else {  					// we can safely fit the name on this line...  					lineLength += name.Length;  					builder.Append (name);  				}    				if ((lineLength + route.Length + Address.Length + 3) > options.MaxLineLength) {  					builder.Append (options.NewLine);  					builder.Append ("\t<");  					lineLength = 2;  				} else {  					builder.Append (" <");  					lineLength += 2;  				}    				lineLength += route.Length;  				builder.Append (route);    				lineLength += Address.Length + 1;  				builder.Append (Address);  				builder.Append ('>');  			} else if (!string.IsNullOrEmpty (route)) {  				if ((lineLength + route.Length + Address.Length + 2) > options.MaxLineLength) {  					builder.Append (options.NewLine);  					builder.Append ("\t<");  					lineLength = 2;  				} else {  					builder.Append ('<');  					lineLength++;  				}    				lineLength += route.Length;  				builder.Append (route);    				lineLength += Address.Length + 1;  				builder.Append (Address);  				builder.Append ('>');  			} else {  				if ((lineLength + Address.Length) > options.MaxLineLength) {  					builder.LineWrap (options);  					lineLength = 1;  				}    				lineLength += Address.Length;  				builder.Append (Address);  			}
Magic Number,MimeKit,MailboxAddress,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MailboxAddress.cs,Encode,The following statement contains a magic number: if (!string.IsNullOrEmpty (Name)) {  				string name;    				if (!options.International) {  					var encoded = Rfc2047.EncodePhrase (options' Encoding' Name);  					name = Encoding.ASCII.GetString (encoded' 0' encoded.Length);  				} else {  					name = EncodeInternationalizedPhrase (Name);  				}    				if (lineLength + name.Length > options.MaxLineLength) {  					if (name.Length > options.MaxLineLength) {  						// we need to break up the name...  						builder.AppendFolded (options' name' ref lineLength);  					} else {  						// the name itself is short enough to fit on a single line'  						// but only if we write it on a line by itself  						if (lineLength > 1) {  							builder.LineWrap (options);  							lineLength = 1;  						}    						lineLength += name.Length;  						builder.Append (name);  					}  				} else {  					// we can safely fit the name on this line...  					lineLength += name.Length;  					builder.Append (name);  				}    				if ((lineLength + route.Length + Address.Length + 3) > options.MaxLineLength) {  					builder.Append (options.NewLine);  					builder.Append ("\t<");  					lineLength = 2;  				} else {  					builder.Append (" <");  					lineLength += 2;  				}    				lineLength += route.Length;  				builder.Append (route);    				lineLength += Address.Length + 1;  				builder.Append (Address);  				builder.Append ('>');  			} else if (!string.IsNullOrEmpty (route)) {  				if ((lineLength + route.Length + Address.Length + 2) > options.MaxLineLength) {  					builder.Append (options.NewLine);  					builder.Append ("\t<");  					lineLength = 2;  				} else {  					builder.Append ('<');  					lineLength++;  				}    				lineLength += route.Length;  				builder.Append (route);    				lineLength += Address.Length + 1;  				builder.Append (Address);  				builder.Append ('>');  			} else {  				if ((lineLength + Address.Length) > options.MaxLineLength) {  					builder.LineWrap (options);  					lineLength = 1;  				}    				lineLength += Address.Length;  				builder.Append (Address);  			}
Magic Number,MimeKit,MailboxAddress,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MailboxAddress.cs,Encode,The following statement contains a magic number: if (!string.IsNullOrEmpty (Name)) {  				string name;    				if (!options.International) {  					var encoded = Rfc2047.EncodePhrase (options' Encoding' Name);  					name = Encoding.ASCII.GetString (encoded' 0' encoded.Length);  				} else {  					name = EncodeInternationalizedPhrase (Name);  				}    				if (lineLength + name.Length > options.MaxLineLength) {  					if (name.Length > options.MaxLineLength) {  						// we need to break up the name...  						builder.AppendFolded (options' name' ref lineLength);  					} else {  						// the name itself is short enough to fit on a single line'  						// but only if we write it on a line by itself  						if (lineLength > 1) {  							builder.LineWrap (options);  							lineLength = 1;  						}    						lineLength += name.Length;  						builder.Append (name);  					}  				} else {  					// we can safely fit the name on this line...  					lineLength += name.Length;  					builder.Append (name);  				}    				if ((lineLength + route.Length + Address.Length + 3) > options.MaxLineLength) {  					builder.Append (options.NewLine);  					builder.Append ("\t<");  					lineLength = 2;  				} else {  					builder.Append (" <");  					lineLength += 2;  				}    				lineLength += route.Length;  				builder.Append (route);    				lineLength += Address.Length + 1;  				builder.Append (Address);  				builder.Append ('>');  			} else if (!string.IsNullOrEmpty (route)) {  				if ((lineLength + route.Length + Address.Length + 2) > options.MaxLineLength) {  					builder.Append (options.NewLine);  					builder.Append ("\t<");  					lineLength = 2;  				} else {  					builder.Append ('<');  					lineLength++;  				}    				lineLength += route.Length;  				builder.Append (route);    				lineLength += Address.Length + 1;  				builder.Append (Address);  				builder.Append ('>');  			} else {  				if ((lineLength + Address.Length) > options.MaxLineLength) {  					builder.LineWrap (options);  					lineLength = 1;  				}    				lineLength += Address.Length;  				builder.Append (Address);  			}
Magic Number,MimeKit,MimeMessage,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeMessage.cs,SerializeAddressList,The following statement contains a magic number: int lineLength = field.Length + 2;
Magic Number,MimeKit,MimeMessage,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeMessage.cs,ReferencesChanged,The following statement contains a magic number: if (references.Count > 0) {  				int lineLength = "References".Length + 1;  				var options = FormatOptions.Default;  				var builder = new StringBuilder ();    				for (int i = 0; i < references.Count; i++) {  					if (i > 0 && lineLength + references[i].Length + 2 >= options.MaxLineLength) {  						builder.Append (options.NewLine);  						builder.Append ('\t');  						lineLength = 1;  					} else {  						builder.Append (' ');  						lineLength++;  					}    					lineLength += references[i].Length;  					builder.Append ("<" + references[i] + ">");  				}    				builder.Append (options.NewLine);    				var raw = Encoding.UTF8.GetBytes (builder.ToString ());    				ReplaceHeader (HeaderId.References' "References"' raw);  			} else {  				RemoveHeader (HeaderId.References);  			}
Magic Number,MimeKit,Boundary,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeParser.cs,Boundary,The following statement contains a magic number: Length = Marker.Length - 2;
Magic Number,MimeKit,Boundary,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeParser.cs,CreateMboxBoundary,The following statement contains a magic number: boundary.MaxLength = 5;
Magic Number,MimeKit,Boundary,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeParser.cs,CreateMboxBoundary,The following statement contains a magic number: boundary.Length = 5;
Magic Number,MimeKit,MimeParser,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeParser.cs,NextAllocSize,The following statement contains a magic number: return (need + 63) & ~63;
Magic Number,MimeKit,MimeParser,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeParser.cs,NextAllocSize,The following statement contains a magic number: return (need + 63) & ~63;
Magic Number,MimeKit,MimeParser,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeParser.cs,StepMboxMarker,The following statement contains a magic number: do {  				if (ReadAhead (Math.Max (ReadAheadSize' left)' 0) <= left) {  					// failed to find a From line; EOF reached  					state = MimeParserState.Error;  					inputIndex = inputEnd;  					return;  				}    				needInput = false;    				byte* inptr = inbuf + inputIndex;  				byte* inend = inbuf + inputEnd;    				*inend = (byte) '\n';    				while (inptr < inend) {  					byte* start = inptr;    					// scan for the end of the line  					while (*inptr != (byte) '\n')  						inptr++;    					long length = inptr - start;    					// consume the '\n'  					inptr++;    					if (inptr >= inend) {  						// we don't have enough input data  						inputIndex = (int) (start - inbuf);  						left = (int) length;  						needInput = true;  						break;  					}    					if (length >= 5 && IsMboxMarker (start)) {  						int startIndex = (int) (start - inbuf);    						mboxMarkerOffset = GetOffset (startIndex);  						mboxMarkerLength = (int) length;    						if (mboxMarkerBuffer.Length < mboxMarkerLength)  							Array.Resize (ref mboxMarkerBuffer' mboxMarkerLength);    						Buffer.BlockCopy (input' startIndex' mboxMarkerBuffer' 0' (int) length);  						complete = true;  						break;  					}  				}    				if (!needInput) {  					inputIndex = (int) (inptr - inbuf);  					left = 0;  				}  			} while (!complete);
Magic Number,MimeKit,MimeParser,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeParser.cs,StepHeaders,The following statement contains a magic number: do {  				if (ReadAhead (Math.Max (ReadAheadSize' left)' 0) <= left) {  					// EOF reached before we reached the end of the headers...  					if (left == 0 && !midline && headers.Count > 0) {  						// the last header we encountered has been parsed cleanly' so try to  						// fail gracefully by pretending we found the end of the headers...  						//  						// For more details' see https://github.com/jstedfast/MimeKit/pull/51  						state = MimeParserState.Content;  					} else {  						// the last header we encountered was truncated - probably best  						// to error out in this case  						if (left > 0)  							AppendRawHeaderData (inputIndex' left);    						state = MimeParserState.Error;  					}    					ParseAndAppendHeader ();  					inputIndex = inputEnd;  					return;  				}    				byte* inptr = inbuf + inputIndex;  				byte* inend = inbuf + inputEnd;  				bool needInput = false;    				*inend = (byte) '\n';    				while (inptr < inend) {  					byte* start = inptr;    					// if we are scanning a new line' check for a folded header  					if (!midline && checkFolded && !IsBlank (*inptr)) {  						ParseAndAppendHeader ();    						headerOffset = GetOffset ((int) (inptr - inbuf));  						scanningFieldName = true;  						checkFolded = false;  						blank = false;  						valid = true;  					}    					eoln = IsEoln (inptr);  					if (scanningFieldName && !eoln) {  						// scan and validate the field name  						if (*inptr != (byte) ':') {  							*inend = (byte) ':';    							while (*inptr != (byte) ':') {  								// Blank spaces are allowed between the field name and  								// the ':'' but field names themselves are not allowed  								// to contain spaces.  								if (IsBlank (*inptr)) {  									if (!blank) {  										valid = false;  										break;  									}    									blank = true;  								} else if (blank || IsControl (*inptr)) {  									valid = false;  									break;  								}    								inptr++;  							}    							if (inptr == inend) {  								// we don't have enough input data  								left = (int) (inend - start);  								inputIndex = (int) (start - inbuf);  								needInput = true;  								break;  							}    							*inend = (byte) '\n';  						} else {  							valid = false;  						}    						if (!valid) {  							length = inptr - start;    							if (format == MimeFormat.Mbox && length == 4 && IsMboxMarker (start)) {  								// we've found the start of the next message...  								inputIndex = (int) (start - inbuf);  								state = MimeParserState.Complete;  								headerIndex = 0;  								return;  							}    							if (state == MimeParserState.MessageHeaders && headers.Count == 0) {  								// ignore From-lines that might appear at the start of a message  								if (length != 4 || !IsMboxMarker (start)) {  									inputIndex = (int) (start - inbuf);  									state = MimeParserState.Error;  									headerIndex = 0;  									return;  								}  							}  						}  					}    					scanningFieldName = false;    					while (*inptr != (byte) '\n')  						inptr++;    					if (inptr == inend) {  						// we didn't manage to slurp up a full line' save what we have and refill our input buffer  						length = inptr - start;    						if (inptr > start) {  							// Note: if the last byte we got was a '\r'' rewind a byte  							inptr--;  							if (*inptr == (byte) '\r')  								length--;  							else  								inptr++;  						}    						if (length > 0) {  							AppendRawHeaderData ((int) (start - inbuf)' (int) length);  							midline = true;  						}    						inputIndex = (int) (inptr - inbuf);  						left = (int) (inend - inptr);  						needInput = true;  						break;  					}    					// check to see if we've reached the end of the headers  					if (!midline && IsEoln (start)) {  						inputIndex = (int) (inptr - inbuf) + 1;  						state = MimeParserState.Content;  						ParseAndAppendHeader ();  						headerIndex = 0;  						return;  					}    					length = (inptr + 1) - start;    					AppendRawHeaderData ((int) (start - inbuf)' (int) length);  					checkFolded = true;  					midline = false;  					inptr++;  				}    				if (!needInput) {  					inputIndex = (int) (inptr - inbuf);  					left = (int) (inend - inptr);  				}  			} while (true);
Magic Number,MimeKit,MimeParser,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeParser.cs,StepHeaders,The following statement contains a magic number: do {  				if (ReadAhead (Math.Max (ReadAheadSize' left)' 0) <= left) {  					// EOF reached before we reached the end of the headers...  					if (left == 0 && !midline && headers.Count > 0) {  						// the last header we encountered has been parsed cleanly' so try to  						// fail gracefully by pretending we found the end of the headers...  						//  						// For more details' see https://github.com/jstedfast/MimeKit/pull/51  						state = MimeParserState.Content;  					} else {  						// the last header we encountered was truncated - probably best  						// to error out in this case  						if (left > 0)  							AppendRawHeaderData (inputIndex' left);    						state = MimeParserState.Error;  					}    					ParseAndAppendHeader ();  					inputIndex = inputEnd;  					return;  				}    				byte* inptr = inbuf + inputIndex;  				byte* inend = inbuf + inputEnd;  				bool needInput = false;    				*inend = (byte) '\n';    				while (inptr < inend) {  					byte* start = inptr;    					// if we are scanning a new line' check for a folded header  					if (!midline && checkFolded && !IsBlank (*inptr)) {  						ParseAndAppendHeader ();    						headerOffset = GetOffset ((int) (inptr - inbuf));  						scanningFieldName = true;  						checkFolded = false;  						blank = false;  						valid = true;  					}    					eoln = IsEoln (inptr);  					if (scanningFieldName && !eoln) {  						// scan and validate the field name  						if (*inptr != (byte) ':') {  							*inend = (byte) ':';    							while (*inptr != (byte) ':') {  								// Blank spaces are allowed between the field name and  								// the ':'' but field names themselves are not allowed  								// to contain spaces.  								if (IsBlank (*inptr)) {  									if (!blank) {  										valid = false;  										break;  									}    									blank = true;  								} else if (blank || IsControl (*inptr)) {  									valid = false;  									break;  								}    								inptr++;  							}    							if (inptr == inend) {  								// we don't have enough input data  								left = (int) (inend - start);  								inputIndex = (int) (start - inbuf);  								needInput = true;  								break;  							}    							*inend = (byte) '\n';  						} else {  							valid = false;  						}    						if (!valid) {  							length = inptr - start;    							if (format == MimeFormat.Mbox && length == 4 && IsMboxMarker (start)) {  								// we've found the start of the next message...  								inputIndex = (int) (start - inbuf);  								state = MimeParserState.Complete;  								headerIndex = 0;  								return;  							}    							if (state == MimeParserState.MessageHeaders && headers.Count == 0) {  								// ignore From-lines that might appear at the start of a message  								if (length != 4 || !IsMboxMarker (start)) {  									inputIndex = (int) (start - inbuf);  									state = MimeParserState.Error;  									headerIndex = 0;  									return;  								}  							}  						}  					}    					scanningFieldName = false;    					while (*inptr != (byte) '\n')  						inptr++;    					if (inptr == inend) {  						// we didn't manage to slurp up a full line' save what we have and refill our input buffer  						length = inptr - start;    						if (inptr > start) {  							// Note: if the last byte we got was a '\r'' rewind a byte  							inptr--;  							if (*inptr == (byte) '\r')  								length--;  							else  								inptr++;  						}    						if (length > 0) {  							AppendRawHeaderData ((int) (start - inbuf)' (int) length);  							midline = true;  						}    						inputIndex = (int) (inptr - inbuf);  						left = (int) (inend - inptr);  						needInput = true;  						break;  					}    					// check to see if we've reached the end of the headers  					if (!midline && IsEoln (start)) {  						inputIndex = (int) (inptr - inbuf) + 1;  						state = MimeParserState.Content;  						ParseAndAppendHeader ();  						headerIndex = 0;  						return;  					}    					length = (inptr + 1) - start;    					AppendRawHeaderData ((int) (start - inbuf)' (int) length);  					checkFolded = true;  					midline = false;  					inptr++;  				}    				if (!needInput) {  					inputIndex = (int) (inptr - inbuf);  					left = (int) (inend - inptr);  				}  			} while (true);
Magic Number,MimeKit,MimeParser,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeParser.cs,IsPossibleBoundary,The following statement contains a magic number: if (length < 2)  				return false;
Magic Number,MimeKit,MimeParser,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeParser.cs,IsPossibleBoundary,The following statement contains a magic number: if (format == MimeFormat.Mbox && length >= 5 && IsMboxMarker (text))  				return true;
Magic Number,MimeKit,MimeParser,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeParser.cs,GetMaxBoundaryLength,The following statement contains a magic number: return bounds.Count > 0 ? bounds[0].MaxLength + 2 : 0;
Magic Number,MimeKit,MimeParser,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeParser.cs,ScanContent,The following statement contains a magic number: do {  				if (contentIndex < inputIndex)  					content.Write (input' contentIndex' inputIndex - contentIndex);    				nleft = inputEnd - inputIndex;  				if (ReadAhead (atleast' 2) <= 0) {  					contentIndex = inputIndex;  					found = BoundaryType.Eos;  					break;  				}    				byte* inptr = inbuf + inputIndex;  				byte* inend = inbuf + inputEnd;  				int startIndex = inputIndex;    				length = inputEnd - inputIndex;  				contentIndex = inputIndex;    				if (midline && length == nleft)  					found = BoundaryType.Eos;    				*inend = (byte) '\n';    				while (inptr < inend) {  					// Note: we can always depend on byte[] arrays being 4-byte aligned on 32bit and 64bit architectures  					int alignment = (startIndex + 3) & ~3;  					byte* aligned = inbuf + alignment;  					byte* start = inptr;  					byte c = *aligned;  					uint mask;    					*aligned = (byte) '\n';  					while (*inptr != (byte) '\n')  						inptr++;  					*aligned = c;    					if (inptr == aligned && c != (byte) '\n') {  						// -funroll-loops' bitches.  						uint* dword = (uint*) inptr;    						do {  							mask = *dword++ ^ 0x0A0A0A0A;  							mask = ((mask - 0x01010101) & (~mask & 0x80808080));  						} while (mask == 0);    						inptr = (byte*) (dword - 1);  						while (*inptr != (byte) '\n')  							inptr++;  					}    					length = (int) (inptr - start);    					if (inptr < inend) {  						found = CheckBoundary (startIndex' start' length);  						if (found != BoundaryType.None)  							break;    						length++;  						inptr++;  					} else {  						// didn't find the end of the line...  						midline = true;    						if (found == BoundaryType.None) {  							// not enough to tell if we found a boundary  							break;  						}    						found = CheckBoundary (startIndex' start' length);  						if (found != BoundaryType.None)  							break;  					}    					startIndex += length;  				}    				inputIndex = startIndex;  			} while (found == BoundaryType.None);
Magic Number,MimeKit,MimeParser,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeParser.cs,ScanContent,The following statement contains a magic number: do {  				if (contentIndex < inputIndex)  					content.Write (input' contentIndex' inputIndex - contentIndex);    				nleft = inputEnd - inputIndex;  				if (ReadAhead (atleast' 2) <= 0) {  					contentIndex = inputIndex;  					found = BoundaryType.Eos;  					break;  				}    				byte* inptr = inbuf + inputIndex;  				byte* inend = inbuf + inputEnd;  				int startIndex = inputIndex;    				length = inputEnd - inputIndex;  				contentIndex = inputIndex;    				if (midline && length == nleft)  					found = BoundaryType.Eos;    				*inend = (byte) '\n';    				while (inptr < inend) {  					// Note: we can always depend on byte[] arrays being 4-byte aligned on 32bit and 64bit architectures  					int alignment = (startIndex + 3) & ~3;  					byte* aligned = inbuf + alignment;  					byte* start = inptr;  					byte c = *aligned;  					uint mask;    					*aligned = (byte) '\n';  					while (*inptr != (byte) '\n')  						inptr++;  					*aligned = c;    					if (inptr == aligned && c != (byte) '\n') {  						// -funroll-loops' bitches.  						uint* dword = (uint*) inptr;    						do {  							mask = *dword++ ^ 0x0A0A0A0A;  							mask = ((mask - 0x01010101) & (~mask & 0x80808080));  						} while (mask == 0);    						inptr = (byte*) (dword - 1);  						while (*inptr != (byte) '\n')  							inptr++;  					}    					length = (int) (inptr - start);    					if (inptr < inend) {  						found = CheckBoundary (startIndex' start' length);  						if (found != BoundaryType.None)  							break;    						length++;  						inptr++;  					} else {  						// didn't find the end of the line...  						midline = true;    						if (found == BoundaryType.None) {  							// not enough to tell if we found a boundary  							break;  						}    						found = CheckBoundary (startIndex' start' length);  						if (found != BoundaryType.None)  							break;  					}    					startIndex += length;  				}    				inputIndex = startIndex;  			} while (found == BoundaryType.None);
Magic Number,MimeKit,MimeParser,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeParser.cs,ScanContent,The following statement contains a magic number: do {  				if (contentIndex < inputIndex)  					content.Write (input' contentIndex' inputIndex - contentIndex);    				nleft = inputEnd - inputIndex;  				if (ReadAhead (atleast' 2) <= 0) {  					contentIndex = inputIndex;  					found = BoundaryType.Eos;  					break;  				}    				byte* inptr = inbuf + inputIndex;  				byte* inend = inbuf + inputEnd;  				int startIndex = inputIndex;    				length = inputEnd - inputIndex;  				contentIndex = inputIndex;    				if (midline && length == nleft)  					found = BoundaryType.Eos;    				*inend = (byte) '\n';    				while (inptr < inend) {  					// Note: we can always depend on byte[] arrays being 4-byte aligned on 32bit and 64bit architectures  					int alignment = (startIndex + 3) & ~3;  					byte* aligned = inbuf + alignment;  					byte* start = inptr;  					byte c = *aligned;  					uint mask;    					*aligned = (byte) '\n';  					while (*inptr != (byte) '\n')  						inptr++;  					*aligned = c;    					if (inptr == aligned && c != (byte) '\n') {  						// -funroll-loops' bitches.  						uint* dword = (uint*) inptr;    						do {  							mask = *dword++ ^ 0x0A0A0A0A;  							mask = ((mask - 0x01010101) & (~mask & 0x80808080));  						} while (mask == 0);    						inptr = (byte*) (dword - 1);  						while (*inptr != (byte) '\n')  							inptr++;  					}    					length = (int) (inptr - start);    					if (inptr < inend) {  						found = CheckBoundary (startIndex' start' length);  						if (found != BoundaryType.None)  							break;    						length++;  						inptr++;  					} else {  						// didn't find the end of the line...  						midline = true;    						if (found == BoundaryType.None) {  							// not enough to tell if we found a boundary  							break;  						}    						found = CheckBoundary (startIndex' start' length);  						if (found != BoundaryType.None)  							break;  					}    					startIndex += length;  				}    				inputIndex = startIndex;  			} while (found == BoundaryType.None);
Magic Number,MimeKit,MimeParser,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeParser.cs,ScanContent,The following statement contains a magic number: if (found != BoundaryType.Eos && trimNewLine) {  				// the last \r\n belongs to the boundary  				if (content.Length > 0) {  					if (input[inputIndex - 2] == (byte) '\r')  						content.SetLength (content.Length - 2);  					else  						content.SetLength (content.Length - 1);  				}  			}
Magic Number,MimeKit,MimeParser,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeParser.cs,ScanContent,The following statement contains a magic number: if (found != BoundaryType.Eos && trimNewLine) {  				// the last \r\n belongs to the boundary  				if (content.Length > 0) {  					if (input[inputIndex - 2] == (byte) '\r')  						content.SetLength (content.Length - 2);  					else  						content.SetLength (content.Length - 1);  				}  			}
Magic Number,MimeKit,MimePart,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimePart.cs,GetBestEncoding,The following statement contains a magic number: return GetBestEncoding (constraint' 78' cancellationToken);
Magic Number,MimeKit,Multipart,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Multipart.cs,GenerateBoundary,The following statement contains a magic number: var digest = new byte[16];
Magic Number,MimeKit,Multipart,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Multipart.cs,GenerateBoundary,The following statement contains a magic number: var buf = new byte[24];
Magic Number,MimeKit,Multipart,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Multipart.cs,WriteTo,The following statement contains a magic number: if (cancellable != null) {  				for (int i = 0; i < children.Count; i++) {  					cancellable.Write (boundary' 0' boundary.Length - 2' cancellationToken);  					cancellable.Write (options.NewLineBytes' 0' options.NewLineBytes.Length' cancellationToken);  					children[i].WriteTo (options' stream' cancellationToken);  					cancellable.Write (options.NewLineBytes' 0' options.NewLineBytes.Length' cancellationToken);  				}    				cancellable.Write (boundary' 0' boundary.Length' cancellationToken);  				cancellable.Write (options.NewLineBytes' 0' options.NewLineBytes.Length' cancellationToken);  			} else {  				for (int i = 0; i < children.Count; i++) {  					cancellationToken.ThrowIfCancellationRequested ();  					stream.Write (boundary' 0' boundary.Length - 2);  					stream.Write (options.NewLineBytes' 0' options.NewLineBytes.Length);  					children[i].WriteTo (options' stream' cancellationToken);  					stream.Write (options.NewLineBytes' 0' options.NewLineBytes.Length);  				}    				cancellationToken.ThrowIfCancellationRequested ();  				stream.Write (boundary' 0' boundary.Length);  				stream.Write (options.NewLineBytes' 0' options.NewLineBytes.Length);  			}
Magic Number,MimeKit,Multipart,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Multipart.cs,WriteTo,The following statement contains a magic number: if (cancellable != null) {  				for (int i = 0; i < children.Count; i++) {  					cancellable.Write (boundary' 0' boundary.Length - 2' cancellationToken);  					cancellable.Write (options.NewLineBytes' 0' options.NewLineBytes.Length' cancellationToken);  					children[i].WriteTo (options' stream' cancellationToken);  					cancellable.Write (options.NewLineBytes' 0' options.NewLineBytes.Length' cancellationToken);  				}    				cancellable.Write (boundary' 0' boundary.Length' cancellationToken);  				cancellable.Write (options.NewLineBytes' 0' options.NewLineBytes.Length' cancellationToken);  			} else {  				for (int i = 0; i < children.Count; i++) {  					cancellationToken.ThrowIfCancellationRequested ();  					stream.Write (boundary' 0' boundary.Length - 2);  					stream.Write (options.NewLineBytes' 0' options.NewLineBytes.Length);  					children[i].WriteTo (options' stream' cancellationToken);  					stream.Write (options.NewLineBytes' 0' options.NewLineBytes.Length);  				}    				cancellationToken.ThrowIfCancellationRequested ();  				stream.Write (boundary' 0' boundary.Length);  				stream.Write (options.NewLineBytes' 0' options.NewLineBytes.Length);  			}
Magic Number,MimeKit,Parameter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Parameter.cs,Parameter,The following statement contains a magic number: for (int i = 0; i < name.Length; i++) {  				if (name[i] > 127 || !IsAttr ((byte) name[i]))  					throw new ArgumentException ("Illegal characters in parameter name."' "name");  			}
Magic Number,MimeKit,Parameter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Parameter.cs,GetEncodeMethod,The following statement contains a magic number: for (int i = 0; i < value.Length; i++) {  				if (value[i] < 128) {  					var c = (byte) value[i];    					if (c.IsCtrl ())  						return EncodeMethod.Rfc2184;    					if (!c.IsAttr ())  						method = EncodeMethod.Quote;  				} else if (options.International) {  					method = EncodeMethod.Quote;  				} else {  					return EncodeMethod.Rfc2184;  				}  			}
Magic Number,MimeKit,Parameter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Parameter.cs,GetEncodeMethod,The following statement contains a magic number: for (int i = startIndex; i < startIndex + length; i++) {  				if (value[i] < 128) {  					var c = (byte) value[i];    					if (c.IsCtrl ())  						return EncodeMethod.Rfc2184;    					if (!c.IsAttr ())  						method = EncodeMethod.Quote;  				} else if (options.International) {  					method = EncodeMethod.Quote;  				} else {  					return EncodeMethod.Rfc2184;  				}  			}
Magic Number,MimeKit,Parameter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Parameter.cs,GetEncodeMethod,The following statement contains a magic number: for (int i = 0; i < length; i++) {  				if (value[i] >= 127 || value[i].IsCtrl ())  					return EncodeMethod.Rfc2184;    				if (!value[i].IsAttr ())  					method = EncodeMethod.Quote;  			}
Magic Number,MimeKit,Parameter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Parameter.cs,GetBestEncoding,The following statement contains a magic number: for (int i = 0; i < value.Length; i++) {  				if (value[i] < 127) {  					if (IsCtrl (value[i]))  						encoding = Math.Max (encoding' 1);  				} else if (value[i] < 256) {  					encoding = Math.Max (encoding' 1);  				} else {  					encoding = 2;  				}  			}
Magic Number,MimeKit,Parameter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Parameter.cs,GetBestEncoding,The following statement contains a magic number: for (int i = 0; i < value.Length; i++) {  				if (value[i] < 127) {  					if (IsCtrl (value[i]))  						encoding = Math.Max (encoding' 1);  				} else if (value[i] < 256) {  					encoding = Math.Max (encoding' 1);  				} else {  					encoding = 2;  				}  			}
Magic Number,MimeKit,Parameter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Parameter.cs,GetBestEncoding,The following statement contains a magic number: for (int i = 0; i < value.Length; i++) {  				if (value[i] < 127) {  					if (IsCtrl (value[i]))  						encoding = Math.Max (encoding' 1);  				} else if (value[i] < 256) {  					encoding = Math.Max (encoding' 1);  				} else {  					encoding = 2;  				}  			}
Magic Number,MimeKit,Parameter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Parameter.cs,GetBestEncoding,The following statement contains a magic number: switch (encoding) {  			case 0: return Encoding.ASCII;  			case 1: return Encoding.GetEncoding (28591); // iso-8859-1  			default: return defaultEncoding;  			}
Magic Number,MimeKit,Parameter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Parameter.cs,GetNextValue,The following statement contains a magic number: do {  				count = encoder.GetByteCount (chars' index' length' true);  				if (count > maxLength && length > 1) {  					if ((ratio = (int) Math.Round ((double) count / (double) length)) > 1)  						length -= Math.Max ((count - maxLength) / ratio' 1);  					else  						length--;  					continue;  				}    				if (bytes.Length < count)  					Array.Resize<byte> (ref bytes' count);    				count = encoder.GetBytes (chars' index' length' bytes' 0' true);    				// Note: the first chunk needs to be encoded in order to declare the charset  				if (index > 0 || charset == "us-ascii") {  					var method = GetEncodeMethod (bytes' count);    					if (method == EncodeMethod.Quote) {  						value = MimeUtils.Quote (Encoding.ASCII.GetString (bytes' 0' count));  						index += length;  						return false;  					}    					if (method == EncodeMethod.None) {  						value = Encoding.ASCII.GetString (bytes' 0' count);  						index += length;  						return false;  					}  				}    				n = hex.EstimateOutputLength (count);  				if (encoded.Length < n)  					Array.Resize<byte> (ref encoded' n);    				// only the first value gets a charset declaration  				int charsetLength = index == 0 ? charset.Length + 2 : 0;    				n = hex.Encode (bytes' 0' count' encoded);  				if (n > 3 && (charsetLength + n) > maxLength) {  					int x = 0;    					for (int i = n - 1; i >= 0 && charsetLength + i >= maxLength; i--) {  						if (encoded[i] == (byte) '%')  							x--;  						else  							x++;  					}    					if ((ratio = (int) Math.Round ((double) count / (double) length)) > 1)  						length -= Math.Max (x / ratio' 1);  					else  						length--;  					continue;  				}    				if (index == 0)  					value = charset + "''" + Encoding.ASCII.GetString (encoded' 0' n);  				else  					value = Encoding.ASCII.GetString (encoded' 0' n);  				index += length;  				return true;  			} while (true);
Magic Number,MimeKit,Parameter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Parameter.cs,GetNextValue,The following statement contains a magic number: do {  				count = encoder.GetByteCount (chars' index' length' true);  				if (count > maxLength && length > 1) {  					if ((ratio = (int) Math.Round ((double) count / (double) length)) > 1)  						length -= Math.Max ((count - maxLength) / ratio' 1);  					else  						length--;  					continue;  				}    				if (bytes.Length < count)  					Array.Resize<byte> (ref bytes' count);    				count = encoder.GetBytes (chars' index' length' bytes' 0' true);    				// Note: the first chunk needs to be encoded in order to declare the charset  				if (index > 0 || charset == "us-ascii") {  					var method = GetEncodeMethod (bytes' count);    					if (method == EncodeMethod.Quote) {  						value = MimeUtils.Quote (Encoding.ASCII.GetString (bytes' 0' count));  						index += length;  						return false;  					}    					if (method == EncodeMethod.None) {  						value = Encoding.ASCII.GetString (bytes' 0' count);  						index += length;  						return false;  					}  				}    				n = hex.EstimateOutputLength (count);  				if (encoded.Length < n)  					Array.Resize<byte> (ref encoded' n);    				// only the first value gets a charset declaration  				int charsetLength = index == 0 ? charset.Length + 2 : 0;    				n = hex.Encode (bytes' 0' count' encoded);  				if (n > 3 && (charsetLength + n) > maxLength) {  					int x = 0;    					for (int i = n - 1; i >= 0 && charsetLength + i >= maxLength; i--) {  						if (encoded[i] == (byte) '%')  							x--;  						else  							x++;  					}    					if ((ratio = (int) Math.Round ((double) count / (double) length)) > 1)  						length -= Math.Max (x / ratio' 1);  					else  						length--;  					continue;  				}    				if (index == 0)  					value = charset + "''" + Encoding.ASCII.GetString (encoded' 0' n);  				else  					value = Encoding.ASCII.GetString (encoded' 0' n);  				index += length;  				return true;  			} while (true);
Magic Number,MimeKit,Parameter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Parameter.cs,Encode,The following statement contains a magic number: int maxLength = options.MaxLineLength - (Name.Length + 6);
Magic Number,MimeKit,Parameter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Parameter.cs,Encode,The following statement contains a magic number: var bytes = new byte[Math.Max (maxLength' 6)];
Magic Number,MimeKit,Parameter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Parameter.cs,Encode,The following statement contains a magic number: var hexbuf = new byte[bytes.Length * 3 + 3];
Magic Number,MimeKit,Parameter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Parameter.cs,Encode,The following statement contains a magic number: var hexbuf = new byte[bytes.Length * 3 + 3];
Magic Number,MimeKit,ParameterList,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\ParameterList.cs,DecodeRfc2184,The following statement contains a magic number: if (decoder == null) {  				if (TryGetCharset (text' ref index' endIndex' out charset)) {  					try {  						var encoding = CharsetUtils.GetEncoding (charset' "?");  						decoder = (Decoder) encoding.GetDecoder ();  					} catch (NotSupportedException) {  						var encoding = Encoding.GetEncoding (28591); // iso-8859-1  						decoder = (Decoder) encoding.GetDecoder ();  					}  				} else {  					// When no charset is specified' it should be safe to assume US-ASCII...  					// but we all know what assume means' right??  					var encoding = Encoding.GetEncoding (28591); // iso-8859-1  					decoder = (Decoder) encoding.GetDecoder ();  				}  			}
Magic Number,MimeKit,ParameterList,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\ParameterList.cs,DecodeRfc2184,The following statement contains a magic number: if (decoder == null) {  				if (TryGetCharset (text' ref index' endIndex' out charset)) {  					try {  						var encoding = CharsetUtils.GetEncoding (charset' "?");  						decoder = (Decoder) encoding.GetDecoder ();  					} catch (NotSupportedException) {  						var encoding = Encoding.GetEncoding (28591); // iso-8859-1  						decoder = (Decoder) encoding.GetDecoder ();  					}  				} else {  					// When no charset is specified' it should be safe to assume US-ASCII...  					// but we all know what assume means' right??  					var encoding = Encoding.GetEncoding (28591); // iso-8859-1  					decoder = (Decoder) encoding.GetDecoder ();  				}  			}
Magic Number,MimeKit,ParameterList,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\ParameterList.cs,TryParse,The following statement contains a magic number: foreach (var param in @params) {  				int startIndex = param.ValueStart;  				int length = param.ValueLength;  				Decoder decoder = null;  				string value;    				if (param.Id.HasValue) {  					parts = rfc2184[param.Name];  					parts.Sort ();    					value = string.Empty;  					for (int i = 0; i < parts.Count; i++) {  						startIndex = parts[i].ValueStart;  						length = parts[i].ValueLength;    						if (parts[i].Encoded) {  							bool flush = i + 1 >= parts.Count || !parts[i+1].Encoded;    							// Note: Some mail clients mistakenly quote encoded parameter values when they shouldn't  							if (length >= 2 && text[startIndex] == (byte) '"' && text[startIndex + length - 1] == (byte) '"') {  								startIndex++;  								length -= 2;  							}    							value += DecodeRfc2184 (ref decoder' hex' text' startIndex' length' flush);  						} else if (length >= 2 && text[startIndex] == (byte) '"') {  							var quoted = CharsetUtils.ConvertToUnicode (options' text' startIndex' length);  							value += MimeUtils.Unquote (quoted);  							hex.Reset ();  						} else if (length > 0) {  							value += CharsetUtils.ConvertToUnicode (options' text' startIndex' length);  							hex.Reset ();  						}  					}  					hex.Reset ();  				} else if (param.Encoded) {  					value = DecodeRfc2184 (ref decoder' hex' text' startIndex' length' true);  					hex.Reset ();  				} else if (!paramList.Contains (param.Name)) {  					// Note: If we've got an rfc2184-encoded version of the same parameter' then  					// we'll want to choose that one as opposed to the ASCII variant (i.e. this one).  					//  					// While most mail clients that I know of do not send multiple parameters of the  					// same name' rfc6266 suggests that HTTP servers are using this approach to work  					// around HTTP clients that do not (yet) implement support for the rfc2184/2231  					// encoding of parameter values. Since none of the MIME specifications provide  					// any suggestions for dealing with this' following rfc6266 seems to make the  					// most sense' even though it is meant for HTTP clients and servers.  					if (length >= 2 && text[startIndex] == (byte) '"') {  						var quoted = Rfc2047.DecodeText (options' text' startIndex' length);  						value = MimeUtils.Unquote (quoted);  					} else if (length > 0) {  						value = Rfc2047.DecodeText (options' text' startIndex' length);  					} else {  						value = string.Empty;  					}  				} else {  					continue;  				}    				paramList[param.Name] = value;  			}
Magic Number,MimeKit,ParameterList,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\ParameterList.cs,TryParse,The following statement contains a magic number: foreach (var param in @params) {  				int startIndex = param.ValueStart;  				int length = param.ValueLength;  				Decoder decoder = null;  				string value;    				if (param.Id.HasValue) {  					parts = rfc2184[param.Name];  					parts.Sort ();    					value = string.Empty;  					for (int i = 0; i < parts.Count; i++) {  						startIndex = parts[i].ValueStart;  						length = parts[i].ValueLength;    						if (parts[i].Encoded) {  							bool flush = i + 1 >= parts.Count || !parts[i+1].Encoded;    							// Note: Some mail clients mistakenly quote encoded parameter values when they shouldn't  							if (length >= 2 && text[startIndex] == (byte) '"' && text[startIndex + length - 1] == (byte) '"') {  								startIndex++;  								length -= 2;  							}    							value += DecodeRfc2184 (ref decoder' hex' text' startIndex' length' flush);  						} else if (length >= 2 && text[startIndex] == (byte) '"') {  							var quoted = CharsetUtils.ConvertToUnicode (options' text' startIndex' length);  							value += MimeUtils.Unquote (quoted);  							hex.Reset ();  						} else if (length > 0) {  							value += CharsetUtils.ConvertToUnicode (options' text' startIndex' length);  							hex.Reset ();  						}  					}  					hex.Reset ();  				} else if (param.Encoded) {  					value = DecodeRfc2184 (ref decoder' hex' text' startIndex' length' true);  					hex.Reset ();  				} else if (!paramList.Contains (param.Name)) {  					// Note: If we've got an rfc2184-encoded version of the same parameter' then  					// we'll want to choose that one as opposed to the ASCII variant (i.e. this one).  					//  					// While most mail clients that I know of do not send multiple parameters of the  					// same name' rfc6266 suggests that HTTP servers are using this approach to work  					// around HTTP clients that do not (yet) implement support for the rfc2184/2231  					// encoding of parameter values. Since none of the MIME specifications provide  					// any suggestions for dealing with this' following rfc6266 seems to make the  					// most sense' even though it is meant for HTTP clients and servers.  					if (length >= 2 && text[startIndex] == (byte) '"') {  						var quoted = Rfc2047.DecodeText (options' text' startIndex' length);  						value = MimeUtils.Unquote (quoted);  					} else if (length > 0) {  						value = Rfc2047.DecodeText (options' text' startIndex' length);  					} else {  						value = string.Empty;  					}  				} else {  					continue;  				}    				paramList[param.Name] = value;  			}
Magic Number,MimeKit,ParameterList,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\ParameterList.cs,TryParse,The following statement contains a magic number: foreach (var param in @params) {  				int startIndex = param.ValueStart;  				int length = param.ValueLength;  				Decoder decoder = null;  				string value;    				if (param.Id.HasValue) {  					parts = rfc2184[param.Name];  					parts.Sort ();    					value = string.Empty;  					for (int i = 0; i < parts.Count; i++) {  						startIndex = parts[i].ValueStart;  						length = parts[i].ValueLength;    						if (parts[i].Encoded) {  							bool flush = i + 1 >= parts.Count || !parts[i+1].Encoded;    							// Note: Some mail clients mistakenly quote encoded parameter values when they shouldn't  							if (length >= 2 && text[startIndex] == (byte) '"' && text[startIndex + length - 1] == (byte) '"') {  								startIndex++;  								length -= 2;  							}    							value += DecodeRfc2184 (ref decoder' hex' text' startIndex' length' flush);  						} else if (length >= 2 && text[startIndex] == (byte) '"') {  							var quoted = CharsetUtils.ConvertToUnicode (options' text' startIndex' length);  							value += MimeUtils.Unquote (quoted);  							hex.Reset ();  						} else if (length > 0) {  							value += CharsetUtils.ConvertToUnicode (options' text' startIndex' length);  							hex.Reset ();  						}  					}  					hex.Reset ();  				} else if (param.Encoded) {  					value = DecodeRfc2184 (ref decoder' hex' text' startIndex' length' true);  					hex.Reset ();  				} else if (!paramList.Contains (param.Name)) {  					// Note: If we've got an rfc2184-encoded version of the same parameter' then  					// we'll want to choose that one as opposed to the ASCII variant (i.e. this one).  					//  					// While most mail clients that I know of do not send multiple parameters of the  					// same name' rfc6266 suggests that HTTP servers are using this approach to work  					// around HTTP clients that do not (yet) implement support for the rfc2184/2231  					// encoding of parameter values. Since none of the MIME specifications provide  					// any suggestions for dealing with this' following rfc6266 seems to make the  					// most sense' even though it is meant for HTTP clients and servers.  					if (length >= 2 && text[startIndex] == (byte) '"') {  						var quoted = Rfc2047.DecodeText (options' text' startIndex' length);  						value = MimeUtils.Unquote (quoted);  					} else if (length > 0) {  						value = Rfc2047.DecodeText (options' text' startIndex' length);  					} else {  						value = string.Empty;  					}  				} else {  					continue;  				}    				paramList[param.Name] = value;  			}
Magic Number,MimeKit,ParameterList,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\ParameterList.cs,TryParse,The following statement contains a magic number: foreach (var param in @params) {  				int startIndex = param.ValueStart;  				int length = param.ValueLength;  				Decoder decoder = null;  				string value;    				if (param.Id.HasValue) {  					parts = rfc2184[param.Name];  					parts.Sort ();    					value = string.Empty;  					for (int i = 0; i < parts.Count; i++) {  						startIndex = parts[i].ValueStart;  						length = parts[i].ValueLength;    						if (parts[i].Encoded) {  							bool flush = i + 1 >= parts.Count || !parts[i+1].Encoded;    							// Note: Some mail clients mistakenly quote encoded parameter values when they shouldn't  							if (length >= 2 && text[startIndex] == (byte) '"' && text[startIndex + length - 1] == (byte) '"') {  								startIndex++;  								length -= 2;  							}    							value += DecodeRfc2184 (ref decoder' hex' text' startIndex' length' flush);  						} else if (length >= 2 && text[startIndex] == (byte) '"') {  							var quoted = CharsetUtils.ConvertToUnicode (options' text' startIndex' length);  							value += MimeUtils.Unquote (quoted);  							hex.Reset ();  						} else if (length > 0) {  							value += CharsetUtils.ConvertToUnicode (options' text' startIndex' length);  							hex.Reset ();  						}  					}  					hex.Reset ();  				} else if (param.Encoded) {  					value = DecodeRfc2184 (ref decoder' hex' text' startIndex' length' true);  					hex.Reset ();  				} else if (!paramList.Contains (param.Name)) {  					// Note: If we've got an rfc2184-encoded version of the same parameter' then  					// we'll want to choose that one as opposed to the ASCII variant (i.e. this one).  					//  					// While most mail clients that I know of do not send multiple parameters of the  					// same name' rfc6266 suggests that HTTP servers are using this approach to work  					// around HTTP clients that do not (yet) implement support for the rfc2184/2231  					// encoding of parameter values. Since none of the MIME specifications provide  					// any suggestions for dealing with this' following rfc6266 seems to make the  					// most sense' even though it is meant for HTTP clients and servers.  					if (length >= 2 && text[startIndex] == (byte) '"') {  						var quoted = Rfc2047.DecodeText (options' text' startIndex' length);  						value = MimeUtils.Unquote (quoted);  					} else if (length > 0) {  						value = Rfc2047.DecodeText (options' text' startIndex' length);  					} else {  						value = string.Empty;  					}  				} else {  					continue;  				}    				paramList[param.Name] = value;  			}
Duplicate Code,MimeKit,InternetAddress,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\InternetAddress.cs,TryParse,The method contains a code clone-set at the following line numbers (starting from the method definition): ((49' 74)' (117' 142))
Missing Default,MimeKit.Cryptography,MultipartSigned,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\MultipartSigned.cs,PrepareEntityForSigning,The following switch statement is missing a default case: switch (part.ContentTransferEncoding) {  				case ContentEncoding.SevenBit:  					// need to make sure that "From "-lines are properly armored and wrapped at 78 bytes  					part.ContentTransferEncoding = part.GetBestEncoding (EncodingConstraint.SevenBit' 78);  					break;  				case ContentEncoding.EightBit:  					part.ContentTransferEncoding = ContentEncoding.QuotedPrintable;  					break;  				case ContentEncoding.Binary:  					part.ContentTransferEncoding = ContentEncoding.Base64;  					break;  				}
Missing Default,MimeKit.Cryptography,NpgsqlCertificateDatabase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\NpgsqlCertificateDatabase.cs,GetCreateCertificatesTableCommand,The following switch statement is missing a default case: switch (columns[i]) {  				case "ID": statement.Append ("serial PRIMARY KEY"); break;  				case "BASICCONSTRAINTS": statement.Append ("integer NOT NULL"); break;  				case "TRUSTED":  statement.Append ("boolean NOT NULL"); break;  				case "KEYUSAGE": statement.Append ("integer NOT NULL"); break;  				case "NOTBEFORE": statement.Append ("timestamp NOT NULL"); break;  				case "NOTAFTER": statement.Append ("timestamp NOT NULL"); break;  				case "ISSUERNAME": statement.Append ("text NOT NULL"); break;  				case "SERIALNUMBER": statement.Append ("text NOT NULL"); break;  				case "SUBJECTEMAIL": statement.Append ("text "); break;  				case "FINGERPRINT": statement.Append ("text NOT NULL"); break;  				case "ALGORITHMS": statement.Append ("text"); break;  				case "ALGORITHMSUPDATED": statement.Append ("timestamp NOT NULL"); break;  				case "CERTIFICATE": statement.Append ("bytea UNIQUE NOT NULL"); break;  				case "PRIVATEKEY": statement.Append ("bytea"); break;  				}
Missing Default,MimeKit.Cryptography,NpgsqlCertificateDatabase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\NpgsqlCertificateDatabase.cs,GetCreateCrlsTableCommand,The following switch statement is missing a default case: switch (columns[i]) {  				case "ID": statement.Append ("serial PRIMARY KEY"); break;  				case "DELTA" : statement.Append ("integer NOT NULL"); break;  				case "ISSUERNAME": statement.Append ("text NOT NULL"); break;  				case "THISUPDATE": statement.Append ("integer NOT NULL"); break;  				case "NEXTUPDATE": statement.Append ("integer NOT NULL"); break;  				case "CRL": statement.Append ("bytea NOT NULL"); break;  				}
Missing Default,MimeKit.Cryptography,SecureMimeContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SecureMimeContext.cs,AddSecureMimeCapabilities,The following switch statement is missing a default case: switch (algorithm) {  				case EncryptionAlgorithm.Camellia256:  					capabilities.AddCapability (NttObjectIdentifiers.IdCamellia256Cbc);  					break;  				case EncryptionAlgorithm.Camellia192:  					capabilities.AddCapability (NttObjectIdentifiers.IdCamellia192Cbc);  					break;  				case EncryptionAlgorithm.Camellia128:  					capabilities.AddCapability (NttObjectIdentifiers.IdCamellia128Cbc);  					break;  				case EncryptionAlgorithm.Aes256:  					capabilities.AddCapability (SmimeCapabilities.Aes256Cbc);  					break;  				case EncryptionAlgorithm.Aes192:  					capabilities.AddCapability (SmimeCapabilities.Aes192Cbc);  					break;  				case EncryptionAlgorithm.Aes128:  					capabilities.AddCapability (SmimeCapabilities.Aes128Cbc);  					break;  				case EncryptionAlgorithm.Idea:  					capabilities.AddCapability (SmimeCapabilities.IdeaCbc);  					break;  				case EncryptionAlgorithm.Cast5:  					capabilities.AddCapability (SmimeCapabilities.Cast5Cbc);  					break;  				case EncryptionAlgorithm.TripleDes:  					capabilities.AddCapability (SmimeCapabilities.DesEde3Cbc);  					break;  				case EncryptionAlgorithm.RC2128:  					capabilities.AddCapability (SmimeCapabilities.RC2Cbc' 128);  					break;  				case EncryptionAlgorithm.RC264:  					capabilities.AddCapability (SmimeCapabilities.RC2Cbc' 64);  					break;  				case EncryptionAlgorithm.RC240:  					capabilities.AddCapability (SmimeCapabilities.RC2Cbc' 40);  					break;  				case EncryptionAlgorithm.Des:  					capabilities.AddCapability (SmimeCapabilities.DesCbc);  					break;  				}
Missing Default,MimeKit.Cryptography,SecureMimeContext,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SecureMimeContext.cs,TryGetEncryptionAlgorithm,The following switch statement is missing a default case: switch (bits) {  				case 128: algorithm = EncryptionAlgorithm.RC2128; return true;  				case 64: algorithm = EncryptionAlgorithm.RC264; return true;  				case 40: algorithm = EncryptionAlgorithm.RC240; return true;  				}
Missing Default,MimeKit.Cryptography,SqliteCertificateDatabase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SqliteCertificateDatabase.cs,GetCreateCertificatesTableCommand,The following switch statement is missing a default case: switch (columns[i]) {  				case "ID": statement.Append ("INTEGER PRIMARY KEY AUTOINCREMENT"); break;  				case "BASICCONSTRAINTS": statement.Append ("INTEGER NOT NULL"); break;  				case "TRUSTED":  statement.Append ("INTEGER NOT NULL"); break;  				case "KEYUSAGE": statement.Append ("INTEGER NOT NULL"); break;  				case "NOTBEFORE": statement.Append ("INTEGER NOT NULL"); break;  				case "NOTAFTER": statement.Append ("INTEGER NOT NULL"); break;  				case "ISSUERNAME": statement.Append ("TEXT NOT NULL"); break;  				case "SERIALNUMBER": statement.Append ("TEXT NOT NULL"); break;  				case "SUBJECTEMAIL": statement.Append ("TEXT"); break;  				case "FINGERPRINT": statement.Append ("TEXT NOT NULL"); break;  				case "ALGORITHMS": statement.Append ("TEXT"); break;  				case "ALGORITHMSUPDATED": statement.Append ("INTEGER NOT NULL"); break;  				case "CERTIFICATE": statement.Append ("BLOB UNIQUE NOT NULL"); break;  				case "PRIVATEKEY": statement.Append ("BLOB"); break;  				}
Missing Default,MimeKit.Cryptography,SqliteCertificateDatabase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\SqliteCertificateDatabase.cs,GetCreateCrlsTableCommand,The following switch statement is missing a default case: switch (columns[i]) {  				case "ID": statement.Append ("INTEGER PRIMARY KEY AUTOINCREMENT"); break;  				case "DELTA" : statement.Append ("INTEGER NOT NULL"); break;  				case "ISSUERNAME": statement.Append ("TEXT NOT NULL"); break;  				case "THISUPDATE": statement.Append ("INTEGER NOT NULL"); break;  				case "NEXTUPDATE": statement.Append ("INTEGER NOT NULL"); break;  				case "CRL": statement.Append ("BLOB NOT NULL"); break;  				}
Missing Default,MimeKit.Cryptography,X509CertificateDatabase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\X509CertificateDatabase.cs,LoadCertificateRecord,The following switch statement is missing a default case: switch (reader.GetName (i).ToUpperInvariant ()) {  				case "CERTIFICATE":  					record.Certificate = DecodeCertificate (reader' parser' i' ref buffer);  					break;  				case "PRIVATEKEY":  					record.PrivateKey = DecodePrivateKey (reader' i' ref buffer);  					break;  				case "ALGORITHMS":  					record.Algorithms = DecodeEncryptionAlgorithms (reader' i);  					break;  				case "ALGORITHMSUPDATED":  					record.AlgorithmsUpdated = reader.GetDateTime (i);  					break;  				case "TRUSTED":  					record.IsTrusted = reader.GetBoolean (i);  					break;  				case "ID":  					record.Id = reader.GetInt32 (i);  					break;  				}
Missing Default,MimeKit.Cryptography,X509CertificateDatabase,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Cryptography\X509CertificateDatabase.cs,LoadCrlRecord,The following switch statement is missing a default case: switch (reader.GetName (i).ToUpperInvariant ()) {  				case "CRL":  					record.Crl = DecodeX509Crl (reader' parser' i' ref buffer);  					break;  				case "THISUPDATE":  					record.ThisUpdate = reader.GetDateTime (i);  					break;  				case "NEXTUPDATE":  					record.NextUpdate = reader.GetDateTime (i);  					break;  				case "DELTA":  					record.IsDelta = reader.GetBoolean (i);  					break;  				case "ID":  					record.Id = reader.GetInt32 (i);  					break;  				}
Missing Default,MimeKit.Encodings,HexDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\HexDecoder.cs,Decode,The following switch statement is missing a default case: switch (state) {  				case HexDecoderState.PassThrough:  					while (inptr < inend) {  						c = *inptr++;    						if (c == '%') {  							state = HexDecoderState.Percent;  							break;  						}    						*outptr++ = c;  					}  					break;  				case HexDecoderState.Percent:  					c = *inptr++;  					state = HexDecoderState.DecodeByte;  					saved = c;  					break;  				case HexDecoderState.DecodeByte:  					c = *inptr++;  					if (c.IsXDigit () && saved.IsXDigit ()) {  						saved = saved.ToXDigit ();  						c = c.ToXDigit ();    						*outptr++ = (byte) ((saved << 4) | c);  					} else {  						// invalid encoded sequence - pass it through undecoded  						*outptr++ = (byte) '%';  						*outptr++ = saved;  						*outptr++ = c;  					}    					state = HexDecoderState.PassThrough;  					break;  				}
Missing Default,MimeKit.Encodings,QuotedPrintableDecoder,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Encodings\QuotedPrintableDecoder.cs,Decode,The following switch statement is missing a default case: switch (state) {  				case QpDecoderState.PassThrough:  					while (inptr < inend) {  						c = *inptr++;    						if (c == '=') {  							state = QpDecoderState.EqualSign;  							break;  						} else if (rfc2047 && c == '_') {  							*outptr++ = (byte) ' ';  						} else {  							*outptr++ = c;  						}  					}  					break;  				case QpDecoderState.EqualSign:  					c = *inptr++;  					if (c == '\n') {  						// this is a soft break ("=\n")  						state = QpDecoderState.PassThrough;  					} else {  						state = QpDecoderState.DecodeByte;  						saved = c;  					}  					break;  				case QpDecoderState.DecodeByte:  					c = *inptr++;  					if (c.IsXDigit () && saved.IsXDigit ()) {  						saved = saved.ToXDigit ();  						c = c.ToXDigit ();    						*outptr++ = (byte) ((saved << 4) | c);  					} else if (saved == '\r' && c == '\n') {  						// end-of-line  					} else {  						// invalid encoded sequence - pass it through undecoded  						*outptr++ = (byte) '=';  						*outptr++ = saved;  						*outptr++ = c;  					}    					state = QpDecoderState.PassThrough;  					break;  				}
Missing Default,MimeKit.Tnef,RtfCompressedToRtf,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\RtfCompressedToRtf.cs,TryReadInt32,The following switch statement is missing a default case: switch (nread) {  			case 0:  				saved = buffer[index++];  				nread++;    				if (index == endIndex)  					break;    				goto case 1;  			case 1:  				saved |= (buffer[index++] << 8);  				nread++;    				if (index == endIndex)  					break;    				goto case 2;  			case 2:  				saved |= (buffer[index++] << 16);  				nread++;    				if (index == endIndex)  					break;    				goto case 3;  			case 3:  				saved |= (buffer[index++] << 24);  				nread++;  				break;  			}
Missing Default,MimeKit.Tnef,RtfCompressedToRtf,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\RtfCompressedToRtf.cs,Filter,The following switch statement is missing a default case: switch (state) {  				case FilterState.BeginControlRun:  					flags = value;  					flagCount = 1;    					if ((flags & 0x1) != 0)  						state = FilterState.ReadControlOffset;  					else  						state = FilterState.ReadLiteral;  					break;  				case FilterState.ReadLiteral:  					EnsureOutputSize (outputLength + 1' true);  					OutputBuffer[outputLength++] = value;  					dict[dictWriteOffset++] = value;    					dictEndOffset = Math.Max (dictWriteOffset' dictEndOffset);  					dictWriteOffset = (short) (dictWriteOffset % 4096);    					if ((flagCount++ % 8) != 0) {  						flags = (byte) (flags >> 1);    						if ((flags & 0x1) != 0)  							state = FilterState.ReadControlOffset;  						else  							state = FilterState.ReadLiteral;  					} else {  						state = FilterState.BeginControlRun;  					}  					break;  				case FilterState.ReadControlOffset:  					state = FilterState.ProcessControl;  					dictReadOffset = value;  					break;  				case FilterState.ProcessControl:  					dictReadOffset = (short) ((dictReadOffset << 4) | (value >> 4));  					int controlLength = (value & 0x0F) + 2;    					if (dictReadOffset == dictWriteOffset) {  						state = FilterState.Complete;  						break;  					}    					EnsureOutputSize (outputLength + controlLength' true);    					int controlEnd = dictReadOffset + controlLength;    					while (dictReadOffset < controlEnd) {  						value = dict[dictReadOffset++ % 4096];  						OutputBuffer[outputLength++] = value;  						dict[dictWriteOffset++] = value;    						dictEndOffset = Math.Max (dictWriteOffset' dictEndOffset);  						dictWriteOffset = (short) (dictWriteOffset % 4096);  					}    					if ((flagCount++ % 8) != 0) {  						flags = (byte) (flags >> 1);    						if ((flags & 0x1) != 0)  							state = FilterState.ReadControlOffset;  						else  							state = FilterState.ReadLiteral;  					} else {  						state = FilterState.BeginControlRun;  					}  					break;  				case FilterState.Complete:  					break;  				}
Missing Default,MimeKit.Tnef,TnefPart,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPart.cs,ExtractRecipientTable,The following switch statement is missing a default case: switch (prop.PropertyTag.Id) {  					case TnefPropertyId.RecipientType:  						int recipientType = prop.ReadValueAsInt32 ();  						switch (recipientType) {  						case 1: list = message.To; break;  						case 2: list = message.Cc; break;  						case 3: list = message.Bcc; break;  						}  						break;  					case TnefPropertyId.TransmitableDisplayName:  						if (string.IsNullOrEmpty (name))  							name = prop.ReadValueAsString ();  						break;  					case TnefPropertyId.DisplayName:  						name = prop.ReadValueAsString ();  						break;  					case TnefPropertyId.EmailAddress:  						if (string.IsNullOrEmpty (addr))  							addr = prop.ReadValueAsString ();  						break;  					case TnefPropertyId.SmtpAddress:  						// The SmtpAddress' if it exists' should take precedence over the EmailAddress  						// (since the SmtpAddress is meant to be used in the RCPT TO command).  						addr = prop.ReadValueAsString ();  						break;  					}
Missing Default,MimeKit.Tnef,TnefPart,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPart.cs,ExtractRecipientTable,The following switch statement is missing a default case: switch (recipientType) {  						case 1: list = message.To; break;  						case 2: list = message.Cc; break;  						case 3: list = message.Bcc; break;  						}
Missing Default,MimeKit.Tnef,TnefPart,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPart.cs,ExtractMapiProperties,The following switch statement is missing a default case: switch (prop.PropertyTag.Id) {  				case TnefPropertyId.InternetMessageId:  					if (prop.PropertyTag.ValueTnefType == TnefPropertyType.String8 ||  						prop.PropertyTag.ValueTnefType == TnefPropertyType.Unicode) {  						message.MessageId = prop.ReadValueAsString ();  					}  					break;  				case TnefPropertyId.Subject:  					if (prop.PropertyTag.ValueTnefType == TnefPropertyType.String8 ||  						prop.PropertyTag.ValueTnefType == TnefPropertyType.Unicode) {  						message.Subject = prop.ReadValueAsString ();  					}  					break;  				case TnefPropertyId.RtfCompressed:  					if (prop.PropertyTag.ValueTnefType == TnefPropertyType.String8 ||  						prop.PropertyTag.ValueTnefType == TnefPropertyType.Unicode ||  						prop.PropertyTag.ValueTnefType == TnefPropertyType.Binary) {  						var rtf = new TextPart ("rtf");  						rtf.ContentType.Name = "body.rtf";    						var converter = new RtfCompressedToRtf ();  						var content = new MemoryBlockStream ();    						using (var filtered = new FilteredStream (content)) {  							filtered.Add (converter);    							using (var compressed = prop.GetRawValueReadStream ()) {  								compressed.CopyTo (filtered' 4096);  								filtered.Flush ();  							}  						}    						rtf.ContentObject = new ContentObject (content);  						content.Position = 0;    						builder.Attachments.Add (rtf);  					}  					break;  				case TnefPropertyId.BodyHtml:  					if (prop.PropertyTag.ValueTnefType == TnefPropertyType.String8 ||  						prop.PropertyTag.ValueTnefType == TnefPropertyType.Unicode ||  						prop.PropertyTag.ValueTnefType == TnefPropertyType.Binary) {  						var html = new TextPart ("html");  						html.ContentType.Name = "body.html";  						html.Text = prop.ReadValueAsString ();    						builder.Attachments.Add (html);  					}  					break;  				case TnefPropertyId.Body:  					if (prop.PropertyTag.ValueTnefType == TnefPropertyType.String8 ||  						prop.PropertyTag.ValueTnefType == TnefPropertyType.Unicode ||  						prop.PropertyTag.ValueTnefType == TnefPropertyType.Binary) {  						var plain = new TextPart ("plain");  						plain.ContentType.Name = "body.txt";  						plain.Text = prop.ReadValueAsString ();    						builder.Attachments.Add (plain);  					}  					break;  				}
Missing Default,MimeKit.Tnef,TnefPart,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPart.cs,ExtractAttachments,The following switch statement is missing a default case: switch (reader.AttributeTag) {  				case TnefAttributeTag.AttachRenderData:  					attachMethod = TnefAttachMethod.ByValue;  					attachment = new MimePart ();  					break;  				case TnefAttributeTag.Attachment:  					if (attachment == null)  						break;    					while (prop.ReadNextProperty ()) {  						switch (prop.PropertyTag.Id) {  						case TnefPropertyId.AttachLongFilename:  							attachment.FileName = prop.ReadValueAsString ();  							break;  						case TnefPropertyId.AttachFilename:  							if (attachment.FileName == null)  								attachment.FileName = prop.ReadValueAsString ();  							break;  						case TnefPropertyId.AttachContentLocation:  							text = prop.ReadValueAsString ();  							if (Uri.IsWellFormedUriString (text' UriKind.Absolute))  								attachment.ContentLocation = new Uri (text' UriKind.Absolute);  							else if (Uri.IsWellFormedUriString (text' UriKind.Relative))  								attachment.ContentLocation = new Uri (text' UriKind.Relative);  							break;  						case TnefPropertyId.AttachContentBase:  							text = prop.ReadValueAsString ();  							attachment.ContentBase = new Uri (text' UriKind.Absolute);  							break;  						case TnefPropertyId.AttachContentId:  							attachment.ContentId = prop.ReadValueAsString ();  							break;  						case TnefPropertyId.AttachDisposition:  							text = prop.ReadValueAsString ();  							if (attachment.ContentDisposition == null)  								attachment.ContentDisposition = new ContentDisposition (text);  							else  								attachment.ContentDisposition.Disposition = text;  							break;  						case TnefPropertyId.AttachData:  							var stream = prop.GetRawValueReadStream ();  							var content = new MemoryStream ();  							var guid = new byte[16];    							if (attachMethod == TnefAttachMethod.EmbeddedMessage) {  								var tnef = new TnefPart ();    								foreach (var param in attachment.ContentType.Parameters)  									tnef.ContentType.Parameters[param.Name] = param.Value;    								if (attachment.ContentDisposition != null)  									tnef.ContentDisposition = attachment.ContentDisposition;    								attachment = tnef;  							}    							// read the GUID  							stream.Read (guid' 0' 16);    							// the rest is content  							using (var filtered = new FilteredStream (content)) {  								filtered.Add (filter);  								stream.CopyTo (filtered' 4096);  								filtered.Flush ();  							}    							content.Position = 0;    							attachment.ContentTransferEncoding = filter.GetBestEncoding (EncodingConstraint.SevenBit);  							attachment.ContentObject = new ContentObject (content);  							filter.Reset ();    							builder.Attachments.Add (attachment);  							break;  						case TnefPropertyId.AttachMethod:  							attachMethod = (TnefAttachMethod) prop.ReadValueAsInt32 ();  							break;  						case TnefPropertyId.AttachMimeTag:  							mimeType = prop.ReadValueAsString ().Split ('/');  							if (mimeType.Length == 2) {  								attachment.ContentType.MediaType = mimeType[0].Trim ();  								attachment.ContentType.MediaSubtype = mimeType[1].Trim ();  							}  							break;  						case TnefPropertyId.AttachFlags:  							flags = (TnefAttachFlags) prop.ReadValueAsInt32 ();  							if ((flags & TnefAttachFlags.RenderedInBody) != 0) {  								if (attachment.ContentDisposition == null)  									attachment.ContentDisposition = new ContentDisposition (ContentDisposition.Inline);  								else  									attachment.ContentDisposition.Disposition = ContentDisposition.Inline;  							}  							break;  						case TnefPropertyId.AttachSize:  							if (attachment.ContentDisposition == null)  								attachment.ContentDisposition = new ContentDisposition ();    							attachment.ContentDisposition.Size = prop.ReadValueAsInt64 ();  							break;  						case TnefPropertyId.DisplayName:  							attachment.ContentType.Name = prop.ReadValueAsString ();  							break;  						}  					}  					break;  				case TnefAttributeTag.AttachCreateDate:  					if (attachment != null) {  						if (attachment.ContentDisposition == null)  							attachment.ContentDisposition = new ContentDisposition ();    						attachment.ContentDisposition.CreationDate = prop.ReadValueAsDateTime ();  					}  					break;  				case TnefAttributeTag.AttachModifyDate:  					if (attachment != null) {  						if (attachment.ContentDisposition == null)  							attachment.ContentDisposition = new ContentDisposition ();    						attachment.ContentDisposition.ModificationDate = prop.ReadValueAsDateTime ();  					}  					break;  				case TnefAttributeTag.AttachTitle:  					if (attachment != null && string.IsNullOrEmpty (attachment.FileName))  						attachment.FileName = prop.ReadValueAsString ();  					break;  				case TnefAttributeTag.AttachMetaFile:  					if (attachment == null)  						break;    					// TODO: what to do with the meta data?  					break;  				case TnefAttributeTag.AttachData:  					if (attachment == null || attachMethod != TnefAttachMethod.ByValue)  						break;    					attachData = prop.ReadValueAsBytes ();  					filter.Flush (attachData' 0' attachData.Length' out outIndex' out outLength);  					attachment.ContentTransferEncoding = filter.GetBestEncoding (EncodingConstraint.EightBit);  					attachment.ContentObject = new ContentObject (new MemoryStream (attachData' false));  					filter.Reset ();    					builder.Attachments.Add (attachment);  					break;  				}
Missing Default,MimeKit.Tnef,TnefPart,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPart.cs,ExtractAttachments,The following switch statement is missing a default case: switch (prop.PropertyTag.Id) {  						case TnefPropertyId.AttachLongFilename:  							attachment.FileName = prop.ReadValueAsString ();  							break;  						case TnefPropertyId.AttachFilename:  							if (attachment.FileName == null)  								attachment.FileName = prop.ReadValueAsString ();  							break;  						case TnefPropertyId.AttachContentLocation:  							text = prop.ReadValueAsString ();  							if (Uri.IsWellFormedUriString (text' UriKind.Absolute))  								attachment.ContentLocation = new Uri (text' UriKind.Absolute);  							else if (Uri.IsWellFormedUriString (text' UriKind.Relative))  								attachment.ContentLocation = new Uri (text' UriKind.Relative);  							break;  						case TnefPropertyId.AttachContentBase:  							text = prop.ReadValueAsString ();  							attachment.ContentBase = new Uri (text' UriKind.Absolute);  							break;  						case TnefPropertyId.AttachContentId:  							attachment.ContentId = prop.ReadValueAsString ();  							break;  						case TnefPropertyId.AttachDisposition:  							text = prop.ReadValueAsString ();  							if (attachment.ContentDisposition == null)  								attachment.ContentDisposition = new ContentDisposition (text);  							else  								attachment.ContentDisposition.Disposition = text;  							break;  						case TnefPropertyId.AttachData:  							var stream = prop.GetRawValueReadStream ();  							var content = new MemoryStream ();  							var guid = new byte[16];    							if (attachMethod == TnefAttachMethod.EmbeddedMessage) {  								var tnef = new TnefPart ();    								foreach (var param in attachment.ContentType.Parameters)  									tnef.ContentType.Parameters[param.Name] = param.Value;    								if (attachment.ContentDisposition != null)  									tnef.ContentDisposition = attachment.ContentDisposition;    								attachment = tnef;  							}    							// read the GUID  							stream.Read (guid' 0' 16);    							// the rest is content  							using (var filtered = new FilteredStream (content)) {  								filtered.Add (filter);  								stream.CopyTo (filtered' 4096);  								filtered.Flush ();  							}    							content.Position = 0;    							attachment.ContentTransferEncoding = filter.GetBestEncoding (EncodingConstraint.SevenBit);  							attachment.ContentObject = new ContentObject (content);  							filter.Reset ();    							builder.Attachments.Add (attachment);  							break;  						case TnefPropertyId.AttachMethod:  							attachMethod = (TnefAttachMethod) prop.ReadValueAsInt32 ();  							break;  						case TnefPropertyId.AttachMimeTag:  							mimeType = prop.ReadValueAsString ().Split ('/');  							if (mimeType.Length == 2) {  								attachment.ContentType.MediaType = mimeType[0].Trim ();  								attachment.ContentType.MediaSubtype = mimeType[1].Trim ();  							}  							break;  						case TnefPropertyId.AttachFlags:  							flags = (TnefAttachFlags) prop.ReadValueAsInt32 ();  							if ((flags & TnefAttachFlags.RenderedInBody) != 0) {  								if (attachment.ContentDisposition == null)  									attachment.ContentDisposition = new ContentDisposition (ContentDisposition.Inline);  								else  									attachment.ContentDisposition.Disposition = ContentDisposition.Inline;  							}  							break;  						case TnefPropertyId.AttachSize:  							if (attachment.ContentDisposition == null)  								attachment.ContentDisposition = new ContentDisposition ();    							attachment.ContentDisposition.Size = prop.ReadValueAsInt64 ();  							break;  						case TnefPropertyId.DisplayName:  							attachment.ContentType.Name = prop.ReadValueAsString ();  							break;  						}
Missing Default,MimeKit.Tnef,TnefPart,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPart.cs,ExtractTnefMessage,The following switch statement is missing a default case: switch (reader.AttributeTag) {  				case TnefAttributeTag.RecipientTable:  					ExtractRecipientTable (reader' message);  					break;  				case TnefAttributeTag.MapiProperties:  					ExtractMapiProperties (reader' message' builder);  					break;  				case TnefAttributeTag.DateSent:  					message.Date = prop.ReadValueAsDateTime ();  					break;  				case TnefAttributeTag.Body:  					builder.TextBody = prop.ReadValueAsString ();  					break;  				}
Missing Default,MimeKit.Tnef,TnefPropertyReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyReader.cs,GetRawValueReadStream,The following switch statement is missing a default case: switch (propertyTag.ValueTnefType) {  				case TnefPropertyType.Unicode:  				case TnefPropertyType.String8:  				case TnefPropertyType.Binary:  				case TnefPropertyType.Object:  					ReadInt32 ();  					break;  				}
Missing Default,MimeKit.Tnef,TnefPropertyReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyReader.cs,ReadNextProperty,The following switch statement is missing a default case: switch (id) {  				case TnefPropertyId.AttachMethod:  					AttachMethod = (TnefAttachMethod) PeekInt32 ();  					break;  				}
Missing Default,MimeKit.Tnef,TnefPropertyReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyReader.cs,ReadRawValue,The following switch statement is missing a default case: switch (propertyTag.ValueTnefType) {  				case TnefPropertyType.Unicode:  				case TnefPropertyType.String8:  				case TnefPropertyType.Binary:  				case TnefPropertyType.Object:  					ReadInt32 ();  					break;  				}
Missing Default,MimeKit.Tnef,TnefPropertyReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyReader.cs,ReadTextValue,The following switch statement is missing a default case: switch (propertyTag.ValueTnefType) {  				case TnefPropertyType.Unicode:  					ReadInt32 ();  					decoder = (Decoder) Encoding.Unicode.GetDecoder ();  					break;  				case TnefPropertyType.String8:  				case TnefPropertyType.Binary:  				case TnefPropertyType.Object:  					ReadInt32 ();  					decoder = (Decoder) GetMessageEncoding ().GetDecoder ();  					break;  				}
Missing Default,MimeKit.Tnef,TnefPropertyReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefPropertyReader.cs,ReadValue,The following switch statement is missing a default case: switch (reader.AttributeType) {  			case TnefAttributeType.Triples: value = ReadAttrBytes (); break;  			case TnefAttributeType.String: value = ReadAttrString (); break;  			case TnefAttributeType.Text:   value = ReadAttrString (); break;  			case TnefAttributeType.Date:   value = ReadAttrDateTime (); break;  			case TnefAttributeType.Short:  value = ReadInt16 (); break;  			case TnefAttributeType.Long:   value = ReadInt32 (); break;  			case TnefAttributeType.Byte:   value = ReadAttrBytes (); break;  			case TnefAttributeType.Word:   value = ReadInt16 (); break;  			case TnefAttributeType.DWord:  value = ReadInt32 (); break;  			}
Missing Default,MimeKit.Tnef,TnefReader,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Tnef\TnefReader.cs,SetComplianceError,The following switch statement is missing a default case: switch (error) {  			case TnefComplianceStatus.AttributeOverflow:        message = "Too many attributes."; break;  			case TnefComplianceStatus.InvalidAttribute:         message = "Invalid attribute."; break;  			case TnefComplianceStatus.InvalidAttributeChecksum: message = "Invalid attribute checksum."; break;  			case TnefComplianceStatus.InvalidAttributeLength:   message = "Invalid attribute length."; break;  			case TnefComplianceStatus.InvalidAttributeLevel:    message = "Invalid attribute level."; break;  			case TnefComplianceStatus.InvalidAttributeValue:    message = "Invalid attribute value."; break;  			case TnefComplianceStatus.InvalidDate:              message = "Invalid date."; break;  			case TnefComplianceStatus.InvalidMessageClass:      message = "Invalid message class."; break;  			case TnefComplianceStatus.InvalidMessageCodepage:   message = "Invalid message codepage."; break;  			case TnefComplianceStatus.InvalidPropertyLength:    message = "Invalid property length."; break;  			case TnefComplianceStatus.InvalidRowCount:          message = "Invalid row count."; break;  			case TnefComplianceStatus.InvalidTnefSignature:     message = "Invalid TNEF signature."; break;  			case TnefComplianceStatus.InvalidTnefVersion:       message = "Invalid TNEF version."; break;  			case TnefComplianceStatus.NestingTooDeep:           message = "Nesting too deep."; break;  			case TnefComplianceStatus.StreamTruncated:          message = "Truncated TNEF stream."; break;  			case TnefComplianceStatus.UnsupportedPropertyType:  message = "Unsupported property type."; break;  			}
Missing Default,MimeKit.Utils,DateUtils,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Utils\DateUtils.cs,Parse,The following switch statement is missing a default case: switch (format[i]) {  				case 'y': year = (year * 10) + digit; break;  				case 'M': month = (month * 10) + digit; break;  				case 'd': day = (day * 10) + digit; break;  				case 'H': hour = (hour * 10) + digit; break;  				case 'm': minute = (minute * 10) + digit; break;  				case 's': second = (second * 10) + digit; break;  				}
Missing Default,MimeKit,MimeEntity,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeEntity.cs,OnHeadersChanged,The following switch statement is missing a default case: switch (header.Id) {  				case HeaderId.ContentDisposition:  					if (disposition != null)  						disposition.Changed -= ContentDispositionChanged;    					if (ContentDisposition.TryParse (Headers.Options' header.RawValue' out disposition))  						disposition.Changed += ContentDispositionChanged;  					break;  				case HeaderId.ContentLocation:  					text = header.Value.Trim ();    					if (Uri.IsWellFormedUriString (text' UriKind.Absolute))  						location = new Uri (text' UriKind.Absolute);  					else if (Uri.IsWellFormedUriString (text' UriKind.Relative))  						location = new Uri (text' UriKind.Relative);  					else  						location = null;  					break;  				case HeaderId.ContentBase:  					text = header.Value.Trim ();    					if (Uri.IsWellFormedUriString (text' UriKind.Absolute))  						baseUri = new Uri (text' UriKind.Absolute);  					else  						baseUri = null;  					break;  				case HeaderId.ContentId:  					contentId = MimeUtils.EnumerateReferences (header.RawValue' 0' header.RawValue.Length).FirstOrDefault ();  					break;  				}
Missing Default,MimeKit,MimeEntity,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeEntity.cs,OnHeadersChanged,The following switch statement is missing a default case: switch (header.Id) {  				case HeaderId.ContentDisposition:  					if (disposition != null)  						disposition.Changed -= ContentDispositionChanged;    					disposition = null;  					break;  				case HeaderId.ContentLocation:  					location = null;  					break;  				case HeaderId.ContentBase:  					baseUri = null;  					break;  				case HeaderId.ContentId:  					contentId = null;  					break;  				}
Missing Default,MimeKit,MimeMessage,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeMessage.cs,ReloadHeader,The following switch statement is missing a default case: switch (id) {  			case HeaderId.ResentMessageId:  				resentMessageId = null;  				break;  			case HeaderId.ResentSender:  				resentSender = null;  				break;  			case HeaderId.ResentDate:  				resentDate = DateTimeOffset.MinValue;  				break;  			case HeaderId.References:  				references.Changed -= ReferencesChanged;  				references.Clear ();  				references.Changed += ReferencesChanged;  				break;  			case HeaderId.InReplyTo:  				inreplyto = null;  				break;  			case HeaderId.MessageId:  				messageId = null;  				break;  			case HeaderId.Sender:  				sender = null;  				break;  			case HeaderId.Date:  				date = DateTimeOffset.MinValue;  				break;  			}
Missing Default,MimeKit,MimeMessage,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeMessage.cs,ReloadHeader,The following switch statement is missing a default case: switch (id) {  				case HeaderId.MimeVersion:  					if (MimeUtils.TryParse (rawValue' 0' rawValue.Length' out version))  						return;  					break;  				case HeaderId.References:  					references.Changed -= ReferencesChanged;  					foreach (var msgid in MimeUtils.EnumerateReferences (rawValue' 0' rawValue.Length))  						references.Add (msgid);  					references.Changed += ReferencesChanged;  					break;  				case HeaderId.InReplyTo:  					inreplyto = MimeUtils.EnumerateReferences (rawValue' 0' rawValue.Length).FirstOrDefault ();  					break;  				case HeaderId.ResentMessageId:  					resentMessageId = MimeUtils.EnumerateReferences (rawValue' 0' rawValue.Length).FirstOrDefault ();  					if (resentMessageId != null)  						return;  					break;  				case HeaderId.MessageId:  					messageId = MimeUtils.EnumerateReferences (rawValue' 0' rawValue.Length).FirstOrDefault ();  					if (messageId != null)  						return;  					break;  				case HeaderId.ResentSender:  					if (InternetAddress.TryParse (Headers.Options' rawValue' ref index' rawValue.Length' false' out address))  						resentSender = address as MailboxAddress;  					if (resentSender != null)  						return;  					break;  				case HeaderId.Sender:  					if (InternetAddress.TryParse (Headers.Options' rawValue' ref index' rawValue.Length' false' out address))  						sender = address as MailboxAddress;  					if (sender != null)  						return;  					break;  				case HeaderId.ResentDate:  					if (DateUtils.TryParse (rawValue' 0' rawValue.Length' out resentDate))  						return;  					break;  				case HeaderId.Date:  					if (DateUtils.TryParse (rawValue' 0' rawValue.Length' out date))  						return;  					break;  				}
Missing Default,MimeKit,MimeMessage,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeMessage.cs,HeadersChanged,The following switch statement is missing a default case: switch (e.Header.Id) {  				case HeaderId.MimeVersion:  					MimeUtils.TryParse (rawValue' 0' rawValue.Length' out version);  					break;  				case HeaderId.References:  					references.Changed -= ReferencesChanged;  					foreach (var msgid in MimeUtils.EnumerateReferences (rawValue' 0' rawValue.Length))  						references.Add (msgid);  					references.Changed += ReferencesChanged;  					break;  				case HeaderId.InReplyTo:  					inreplyto = MimeUtils.EnumerateReferences (rawValue' 0' rawValue.Length).FirstOrDefault ();  					break;  				case HeaderId.ResentMessageId:  					resentMessageId = MimeUtils.EnumerateReferences (rawValue' 0' rawValue.Length).FirstOrDefault ();  					break;  				case HeaderId.MessageId:  					messageId = MimeUtils.EnumerateReferences (rawValue' 0' rawValue.Length).FirstOrDefault ();  					break;  				case HeaderId.ResentSender:  					if (InternetAddress.TryParse (Headers.Options' rawValue' ref index' rawValue.Length' false' out address))  						resentSender = address as MailboxAddress;  					break;  				case HeaderId.Sender:  					if (InternetAddress.TryParse (Headers.Options' rawValue' ref index' rawValue.Length' false' out address))  						sender = address as MailboxAddress;  					break;  				case HeaderId.ResentDate:  					DateUtils.TryParse (rawValue' 0' rawValue.Length' out resentDate);  					break;  				case HeaderId.Date:  					DateUtils.TryParse (rawValue' 0' rawValue.Length' out date);  					break;  				}
Missing Default,MimeKit,MimeMessage,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeMessage.cs,GetMimePart,The following switch statement is missing a default case: switch (item.TransferEncoding) {  			case System.Net.Mime.TransferEncoding.QuotedPrintable:  				part.ContentTransferEncoding = ContentEncoding.QuotedPrintable;  				break;  			case System.Net.Mime.TransferEncoding.Base64:  				part.ContentTransferEncoding = ContentEncoding.Base64;  				break;  			case System.Net.Mime.TransferEncoding.SevenBit:  				part.ContentTransferEncoding = ContentEncoding.SevenBit;  				break;  			}
Missing Default,MimeKit,MimeMessage,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeMessage.cs,CreateFromMailMessage,The following switch statement is missing a default case: switch (message.Priority) {  			case MailPriority.High:  				msg.Headers.Replace (HeaderId.Priority' "urgent");  				msg.Headers.Replace (HeaderId.Importance' "high");  				msg.Headers.Replace ("X-Priority"' "1");  				break;  			case MailPriority.Low:  				msg.Headers.Replace (HeaderId.Priority' "non-urgent");  				msg.Headers.Replace (HeaderId.Importance' "low");  				msg.Headers.Replace ("X-Priority"' "5");  				break;  			}
Missing Default,MimeKit,MimeParser,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeParser.cs,ConstructMessagePart,The following switch statement is missing a default case: switch (found) {  				case BoundaryType.ImmediateEndBoundary:  				case BoundaryType.ImmediateBoundary:  				case BoundaryType.ParentBoundary:  					return found;  				case BoundaryType.ParentEndBoundary:  					// ignore "From " boundaries' broken mailers tend to include these...  					if (!IsMboxMarker (start))  						return found;  					break;  				}
Missing Default,MimeKit,MimeParser,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimeParser.cs,ParseMessage,The following switch statement is missing a default case: switch (Step (inbuf)) {  				case MimeParserState.Error:  					throw new FormatException ("Failed to find mbox From marker.");  				case MimeParserState.Eos:  					throw new FormatException ("End of stream.");  				}
Missing Default,MimeKit,MimePart,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimePart.cs,OnHeadersChanged,The following switch statement is missing a default case: switch (header.Id) {  				case HeaderId.ContentTransferEncoding:  					MimeUtils.TryParse (header.Value' out encoding);  					break;  				case HeaderId.ContentDuration:  					if (int.TryParse (header.Value' out value))  						duration = value;  					else  						duration = null;  					break;  				case HeaderId.ContentMd5:  					md5sum = header.Value.Trim ();  					break;  				}
Missing Default,MimeKit,MimePart,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\MimePart.cs,OnHeadersChanged,The following switch statement is missing a default case: switch (header.Id) {  				case HeaderId.ContentTransferEncoding:  					encoding = ContentEncoding.Default;  					break;  				case HeaderId.ContentDuration:  					duration = null;  					break;  				case HeaderId.ContentMd5:  					md5sum = null;  					break;  				}
Missing Default,MimeKit,Parameter,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\Parameter.cs,GetNextValue,The following switch statement is missing a default case: switch (GetEncodeMethod (options' chars' index' length)) {  				case EncodeMethod.Quote:  					value = MimeUtils.Quote (new string (chars' index' length));  					index += length;  					return false;  				case EncodeMethod.None:  					value = new string (chars' index' length);  					index += length;  					return false;  				}
Missing Default,MimeKit,ParserOptions,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\ParserOptions.cs,CreateEntity,The following switch statement is missing a default case: switch (subtype) {  				case "disposition-notification":  					return new MessageDispositionNotification (entity);  				case "partial":  					if (!IsEncoded (headers))  						return new MessagePartial (entity);  					break;  				case "external-body":  				case "rfc2822":  				case "rfc822":  				case "news":  					if (!IsEncoded (headers))  						return new MessagePart (entity);  					break;  				}
Missing Default,MimeKit,ParserOptions,C:\repos\dejavusecurity_OutlookPrivacyPlugin\MimeKit\ParserOptions.cs,CreateEntity,The following switch statement is missing a default case: switch (subtype) {  				case "x-pkcs7-signature":  				case "pkcs7-signature":  					return new ApplicationPkcs7Signature (entity);  				case "x-pgp-encrypted":  				case "pgp-encrypted":  					return new ApplicationPgpEncrypted (entity);  				case "x-pgp-signature":  				case "pgp-signature":  					return new ApplicationPgpSignature (entity);  				case "x-pkcs7-mime":  				case "pkcs7-mime":  					return new ApplicationPkcs7Mime (entity);  				case "vnd.ms-tnef":  				case "ms-tnef":  					return new TnefPart (entity);  				}
