Implementation smell,Namespace,Class,File,Method,Description
Complex Method,DClark.MQTT,Server,C:\repos\darren-clark_mqtt\Lib\MqttServer.cs,handleConnection,Cyclomatic complexity of the method is 43
Complex Method,DClark.MQTT,Server,C:\repos\darren-clark_mqtt\Lib\MqttServer.cs,PublishReceived,Cyclomatic complexity of the method is 12
Complex Method,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Read,Cyclomatic complexity of the method is 18
Long Parameter List,DClark.MQTT.Messages,ConnectMessage,C:\repos\darren-clark_mqtt\Lib\Messages\ConnectMessage.cs,ConnectMessage,The method has 9 parameters.
Long Parameter List,DClark.MQTT.Messages,PublishMessage,C:\repos\darren-clark_mqtt\Lib\Messages\PublishMessage.cs,PublishMessage,The method has 6 parameters.
Long Statement,DClark.MQTT,Server,C:\repos\darren-clark_mqtt\Lib\MqttServer.cs,handleConnection,The length of the statement  "	Console.WriteLine ("Client {0} connected from {1} ({2}'{3})"' clientId' ep' connectMessage.CleanSession' connectMessage.KeepAlive); " is 131.
Long Statement,DClark.MQTT,Server,C:\repos\darren-clark_mqtt\Lib\MqttServer.cs,handleConnection,The length of the statement  "					message = new PublishMessage (pendingPublish.Duplicate' false' pendingPublish.QoS' messageInfo.Topic' messageInfo.Payload' pendingPublish.PacketId); " is 148.
Long Statement,DClark.MQTT,Server,C:\repos\darren-clark_mqtt\Lib\MqttServer.cs,SubscribeReceived,The length of the statement  "	SubAckMessage subAck = new SubAckMessage (subscribeMessage.PacketId' await sessionProvider.AddSubscriptions (session' subscribeMessage.Subscriptions)); " is 151.
Long Statement,DClark.MQTT,Server,C:\repos\darren-clark_mqtt\Lib\MqttServer.cs,PublishReceived,The length of the statement  "	await PublishMessage (await sessionProvider.GetSubscriptions (publishMessage.Topic)' publishMessage.Topic' publishMessage.Payload); " is 131.
Long Statement,DClark.MQTT,Server,C:\repos\darren-clark_mqtt\Lib\MqttServer.cs,PublishMessages,The length of the statement  "			PublishMessage publishMessage = new PublishMessage (false' retained' message.Item2' message.Item1' message.Item3' packetId); " is 124.
Long Statement,DClark.MQTT,Server,C:\repos\darren-clark_mqtt\Lib\MqttServer.cs,PublishMessage,The length of the statement  "			//Non-Clean subscribers won't have a TcpConnection. Currently we drop messages to QoS 0 subscriptions on non-clean connection. " is 126.
Long Statement,DClark.MQTT.Messages,ConnectMessage,C:\repos\darren-clark_mqtt\Lib\Messages\ConnectMessage.cs,WriteMessage,The length of the statement  "	Write ((byte)((username != null ? 1 << 7 : 0) | (password != null ? 1 << 6 : 0) | (willRetain ? 1 << 5 : 0) | ((byte)willQoS) << 3 | (willTopic != null ? 1 << 2 : 0) | (cleanSession ? 1 << 1 : 0))); " is 198.
Long Statement,DClark.MQTT.Messages,PublishMessage,C:\repos\darren-clark_mqtt\Lib\Messages\PublishMessage.cs,ToString,The length of the statement  "	return String.Format ("{0}'{1}'{2}'{3}'{4}'{5}"' PacketId' QoS' Duplicate' Retain' Topic' payload == null ? RemainingSize : payload.Length); " is 140.
Empty Catch Block,DClark.MQTT,Server,C:\repos\darren-clark_mqtt\Lib\MqttServer.cs,PublishMessage,The method has an empty catch block.
Magic Number,DClark.MQTT,Server,C:\repos\darren-clark_mqtt\Lib\MqttServer.cs,Start,The following statement contains a magic number: listener = new TcpListener (IPAddress.Any' 1883);  
Magic Number,DClark.MQTT,Server,C:\repos\darren-clark_mqtt\Lib\MqttServer.cs,handleConnection,The following statement contains a magic number: while (connection.Connected) {  	try {  		if (await Task.WhenAny (incoming' outgoing) == incoming) {  			try {  				message = incoming.Result;  			}  			catch (AggregateException e) {  				Console.WriteLine (e.InnerException.Message);  				connections.Remove (session);  				connection.Close ();  				continue;  			}  			catch (Exception e) {  				Console.WriteLine (e.Message);  				connections.Remove (session);  				connection.Close ();  				continue;  			}  			switch (message.Type) {  			case MessageType.Publish:  				await PublishReceived (session' stream' (PublishMessage)message);  				break;  			case MessageType.Disconnect:  				Console.WriteLine ("Client {0} disconnected cleanly"' clientId);  				connections.Remove (session);  				connection.Close ();  				//Skip reading the next message. Loop should exit.  				continue;  			case MessageType.Subscribe:  				await SubscribeReceived (session' stream' (SubscribeMessage)message);  				break;  			case MessageType.Unsubscribe:  				await sessionProvider.RemoveSubscriptions (session' ((UnsubscribeMessage)message).TopicFilters);  				await new UnsubAckMessage (((UnsubscribeMessage)message).PacketId).Write (stream);  				break;  			case MessageType.PubAck:  				string messageId = await session.PublishAcknowledged (((PubAckMessage)message).PacketId);  				if (messageId != null)  					await storageProvider.ReleaseMessage (messageId);  				break;  			case MessageType.PubRec:  				messageId = await session.PublishReceived (((PubRecMessage)message).PacketId);  				if (messageId != null)  					await storageProvider.ReleaseMessage (messageId);  				break;  			case MessageType.PubRel:  				await session.RemoveQoS2 (((PubRelMessage)message).PacketId);  				await new PubCompMessage (((PubRelMessage)message).PacketId).Write (stream);  				break;  			case MessageType.PubComp:  				await session.PublishCompleted (((PubCompMessage)message).PacketId);  				break;  			case MessageType.PingReq:  				await new PingRespMessage ().Write (stream);  				break;  			}  			incoming = MqttMessage.Read (stream);  		}  		else {  			PendingMessage pendingMessage = outgoing.Result;  			PendingPublishMessage pendingPublish = pendingMessage as PendingPublishMessage;  			if (pendingPublish != null) {  				var messageInfo = await storageProvider.GetMessage (pendingPublish.MessageId);  				message = new PublishMessage (pendingPublish.Duplicate' false' pendingPublish.QoS' messageInfo.Topic' messageInfo.Payload' pendingPublish.PacketId);  			}  			else {  				message = new PubRelMessage (pendingMessage.PacketId);  			}  			await message.Write (stream);  			outgoing = session.NextPending (pendingMessage' 5000);  		}  	}  	catch (Exception e) {  		Console.Out.WriteLine (e.Message);  	}  }  
Magic Number,DClark.MQTT,Server,C:\repos\darren-clark_mqtt\Lib\MqttServer.cs,handleConnection,The following statement contains a magic number: try {  	if (await Task.WhenAny (incoming' outgoing) == incoming) {  		try {  			message = incoming.Result;  		}  		catch (AggregateException e) {  			Console.WriteLine (e.InnerException.Message);  			connections.Remove (session);  			connection.Close ();  			continue;  		}  		catch (Exception e) {  			Console.WriteLine (e.Message);  			connections.Remove (session);  			connection.Close ();  			continue;  		}  		switch (message.Type) {  		case MessageType.Publish:  			await PublishReceived (session' stream' (PublishMessage)message);  			break;  		case MessageType.Disconnect:  			Console.WriteLine ("Client {0} disconnected cleanly"' clientId);  			connections.Remove (session);  			connection.Close ();  			//Skip reading the next message. Loop should exit.  			continue;  		case MessageType.Subscribe:  			await SubscribeReceived (session' stream' (SubscribeMessage)message);  			break;  		case MessageType.Unsubscribe:  			await sessionProvider.RemoveSubscriptions (session' ((UnsubscribeMessage)message).TopicFilters);  			await new UnsubAckMessage (((UnsubscribeMessage)message).PacketId).Write (stream);  			break;  		case MessageType.PubAck:  			string messageId = await session.PublishAcknowledged (((PubAckMessage)message).PacketId);  			if (messageId != null)  				await storageProvider.ReleaseMessage (messageId);  			break;  		case MessageType.PubRec:  			messageId = await session.PublishReceived (((PubRecMessage)message).PacketId);  			if (messageId != null)  				await storageProvider.ReleaseMessage (messageId);  			break;  		case MessageType.PubRel:  			await session.RemoveQoS2 (((PubRelMessage)message).PacketId);  			await new PubCompMessage (((PubRelMessage)message).PacketId).Write (stream);  			break;  		case MessageType.PubComp:  			await session.PublishCompleted (((PubCompMessage)message).PacketId);  			break;  		case MessageType.PingReq:  			await new PingRespMessage ().Write (stream);  			break;  		}  		incoming = MqttMessage.Read (stream);  	}  	else {  		PendingMessage pendingMessage = outgoing.Result;  		PendingPublishMessage pendingPublish = pendingMessage as PendingPublishMessage;  		if (pendingPublish != null) {  			var messageInfo = await storageProvider.GetMessage (pendingPublish.MessageId);  			message = new PublishMessage (pendingPublish.Duplicate' false' pendingPublish.QoS' messageInfo.Topic' messageInfo.Payload' pendingPublish.PacketId);  		}  		else {  			message = new PubRelMessage (pendingMessage.PacketId);  		}  		await message.Write (stream);  		outgoing = session.NextPending (pendingMessage' 5000);  	}  }  catch (Exception e) {  	Console.Out.WriteLine (e.Message);  }  
Magic Number,DClark.MQTT,Server,C:\repos\darren-clark_mqtt\Lib\MqttServer.cs,handleConnection,The following statement contains a magic number: if (await Task.WhenAny (incoming' outgoing) == incoming) {  	try {  		message = incoming.Result;  	}  	catch (AggregateException e) {  		Console.WriteLine (e.InnerException.Message);  		connections.Remove (session);  		connection.Close ();  		continue;  	}  	catch (Exception e) {  		Console.WriteLine (e.Message);  		connections.Remove (session);  		connection.Close ();  		continue;  	}  	switch (message.Type) {  	case MessageType.Publish:  		await PublishReceived (session' stream' (PublishMessage)message);  		break;  	case MessageType.Disconnect:  		Console.WriteLine ("Client {0} disconnected cleanly"' clientId);  		connections.Remove (session);  		connection.Close ();  		//Skip reading the next message. Loop should exit.  		continue;  	case MessageType.Subscribe:  		await SubscribeReceived (session' stream' (SubscribeMessage)message);  		break;  	case MessageType.Unsubscribe:  		await sessionProvider.RemoveSubscriptions (session' ((UnsubscribeMessage)message).TopicFilters);  		await new UnsubAckMessage (((UnsubscribeMessage)message).PacketId).Write (stream);  		break;  	case MessageType.PubAck:  		string messageId = await session.PublishAcknowledged (((PubAckMessage)message).PacketId);  		if (messageId != null)  			await storageProvider.ReleaseMessage (messageId);  		break;  	case MessageType.PubRec:  		messageId = await session.PublishReceived (((PubRecMessage)message).PacketId);  		if (messageId != null)  			await storageProvider.ReleaseMessage (messageId);  		break;  	case MessageType.PubRel:  		await session.RemoveQoS2 (((PubRelMessage)message).PacketId);  		await new PubCompMessage (((PubRelMessage)message).PacketId).Write (stream);  		break;  	case MessageType.PubComp:  		await session.PublishCompleted (((PubCompMessage)message).PacketId);  		break;  	case MessageType.PingReq:  		await new PingRespMessage ().Write (stream);  		break;  	}  	incoming = MqttMessage.Read (stream);  }  else {  	PendingMessage pendingMessage = outgoing.Result;  	PendingPublishMessage pendingPublish = pendingMessage as PendingPublishMessage;  	if (pendingPublish != null) {  		var messageInfo = await storageProvider.GetMessage (pendingPublish.MessageId);  		message = new PublishMessage (pendingPublish.Duplicate' false' pendingPublish.QoS' messageInfo.Topic' messageInfo.Payload' pendingPublish.PacketId);  	}  	else {  		message = new PubRelMessage (pendingMessage.PacketId);  	}  	await message.Write (stream);  	outgoing = session.NextPending (pendingMessage' 5000);  }  
Magic Number,DClark.MQTT,Server,C:\repos\darren-clark_mqtt\Lib\MqttServer.cs,handleConnection,The following statement contains a magic number: outgoing = session.NextPending (pendingMessage' 5000);  
Magic Number,DClark.MQTT.Messages,ConnectMessage,C:\repos\darren-clark_mqtt\Lib\Messages\ConnectMessage.cs,ConnectMessage,The following statement contains a magic number: willQoS = (QoS)((connectFlags >> 3) & 0x03);  
Magic Number,DClark.MQTT.Messages,ConnectMessage,C:\repos\darren-clark_mqtt\Lib\Messages\ConnectMessage.cs,WriteMessage,The following statement contains a magic number: Write ((byte)4);  
Magic Number,DClark.MQTT.Messages,ConnectMessage,C:\repos\darren-clark_mqtt\Lib\Messages\ConnectMessage.cs,WriteMessage,The following statement contains a magic number: Write ((byte)((username != null ? 1 << 7 : 0) | (password != null ? 1 << 6 : 0) | (willRetain ? 1 << 5 : 0) | ((byte)willQoS) << 3 | (willTopic != null ? 1 << 2 : 0) | (cleanSession ? 1 << 1 : 0)));  
Magic Number,DClark.MQTT.Messages,ConnectMessage,C:\repos\darren-clark_mqtt\Lib\Messages\ConnectMessage.cs,WriteMessage,The following statement contains a magic number: Write ((byte)((username != null ? 1 << 7 : 0) | (password != null ? 1 << 6 : 0) | (willRetain ? 1 << 5 : 0) | ((byte)willQoS) << 3 | (willTopic != null ? 1 << 2 : 0) | (cleanSession ? 1 << 1 : 0)));  
Magic Number,DClark.MQTT.Messages,ConnectMessage,C:\repos\darren-clark_mqtt\Lib\Messages\ConnectMessage.cs,WriteMessage,The following statement contains a magic number: Write ((byte)((username != null ? 1 << 7 : 0) | (password != null ? 1 << 6 : 0) | (willRetain ? 1 << 5 : 0) | ((byte)willQoS) << 3 | (willTopic != null ? 1 << 2 : 0) | (cleanSession ? 1 << 1 : 0)));  
Magic Number,DClark.MQTT.Messages,ConnectMessage,C:\repos\darren-clark_mqtt\Lib\Messages\ConnectMessage.cs,WriteMessage,The following statement contains a magic number: Write ((byte)((username != null ? 1 << 7 : 0) | (password != null ? 1 << 6 : 0) | (willRetain ? 1 << 5 : 0) | ((byte)willQoS) << 3 | (willTopic != null ? 1 << 2 : 0) | (cleanSession ? 1 << 1 : 0)));  
Magic Number,DClark.MQTT.Messages,ConnectMessage,C:\repos\darren-clark_mqtt\Lib\Messages\ConnectMessage.cs,WriteMessage,The following statement contains a magic number: Write ((byte)((username != null ? 1 << 7 : 0) | (password != null ? 1 << 6 : 0) | (willRetain ? 1 << 5 : 0) | ((byte)willQoS) << 3 | (willTopic != null ? 1 << 2 : 0) | (cleanSession ? 1 << 1 : 0)));  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Read,The following statement contains a magic number: if (read != 2)  	throw new MqttException ("Socket closed");  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Read,The following statement contains a magic number: while ((sizeDigit & 0x80) != 0) {  	sizeDigit = stream.ReadByte ();  	size += (sizeDigit & 0x7F) * digitSize;  	digitSize *= 128;  }  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Read,The following statement contains a magic number: digitSize *= 128;  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,ReadInt16,The following statement contains a magic number: remainingSize -= 2;  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,ReadInt16,The following statement contains a magic number: return (short)((stream.ReadByte () << 8) | stream.ReadByte ());  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: if (size <= 127)  	header = new byte[2];  else if (size <= 16383)  	header = new byte[3];  else if (size <= 2097151)  	header = new byte[4];  else if (size <= 268435455)  	header = new byte[5];  else  	throw new MqttProtocolException ("Invalid packet size");  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: if (size <= 127)  	header = new byte[2];  else if (size <= 16383)  	header = new byte[3];  else if (size <= 2097151)  	header = new byte[4];  else if (size <= 268435455)  	header = new byte[5];  else  	throw new MqttProtocolException ("Invalid packet size");  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: if (size <= 127)  	header = new byte[2];  else if (size <= 16383)  	header = new byte[3];  else if (size <= 2097151)  	header = new byte[4];  else if (size <= 268435455)  	header = new byte[5];  else  	throw new MqttProtocolException ("Invalid packet size");  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: if (size <= 127)  	header = new byte[2];  else if (size <= 16383)  	header = new byte[3];  else if (size <= 2097151)  	header = new byte[4];  else if (size <= 268435455)  	header = new byte[5];  else  	throw new MqttProtocolException ("Invalid packet size");  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: if (size <= 127)  	header = new byte[2];  else if (size <= 16383)  	header = new byte[3];  else if (size <= 2097151)  	header = new byte[4];  else if (size <= 268435455)  	header = new byte[5];  else  	throw new MqttProtocolException ("Invalid packet size");  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: if (size <= 127)  	header = new byte[2];  else if (size <= 16383)  	header = new byte[3];  else if (size <= 2097151)  	header = new byte[4];  else if (size <= 268435455)  	header = new byte[5];  else  	throw new MqttProtocolException ("Invalid packet size");  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: if (size <= 127)  	header = new byte[2];  else if (size <= 16383)  	header = new byte[3];  else if (size <= 2097151)  	header = new byte[4];  else if (size <= 268435455)  	header = new byte[5];  else  	throw new MqttProtocolException ("Invalid packet size");  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: if (size <= 127)  	header = new byte[2];  else if (size <= 16383)  	header = new byte[3];  else if (size <= 2097151)  	header = new byte[4];  else if (size <= 268435455)  	header = new byte[5];  else  	throw new MqttProtocolException ("Invalid packet size");  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: header = new byte[2];  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: if (size <= 16383)  	header = new byte[3];  else if (size <= 2097151)  	header = new byte[4];  else if (size <= 268435455)  	header = new byte[5];  else  	throw new MqttProtocolException ("Invalid packet size");  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: if (size <= 16383)  	header = new byte[3];  else if (size <= 2097151)  	header = new byte[4];  else if (size <= 268435455)  	header = new byte[5];  else  	throw new MqttProtocolException ("Invalid packet size");  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: if (size <= 16383)  	header = new byte[3];  else if (size <= 2097151)  	header = new byte[4];  else if (size <= 268435455)  	header = new byte[5];  else  	throw new MqttProtocolException ("Invalid packet size");  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: if (size <= 16383)  	header = new byte[3];  else if (size <= 2097151)  	header = new byte[4];  else if (size <= 268435455)  	header = new byte[5];  else  	throw new MqttProtocolException ("Invalid packet size");  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: if (size <= 16383)  	header = new byte[3];  else if (size <= 2097151)  	header = new byte[4];  else if (size <= 268435455)  	header = new byte[5];  else  	throw new MqttProtocolException ("Invalid packet size");  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: if (size <= 16383)  	header = new byte[3];  else if (size <= 2097151)  	header = new byte[4];  else if (size <= 268435455)  	header = new byte[5];  else  	throw new MqttProtocolException ("Invalid packet size");  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: header = new byte[3];  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: if (size <= 2097151)  	header = new byte[4];  else if (size <= 268435455)  	header = new byte[5];  else  	throw new MqttProtocolException ("Invalid packet size");  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: if (size <= 2097151)  	header = new byte[4];  else if (size <= 268435455)  	header = new byte[5];  else  	throw new MqttProtocolException ("Invalid packet size");  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: if (size <= 2097151)  	header = new byte[4];  else if (size <= 268435455)  	header = new byte[5];  else  	throw new MqttProtocolException ("Invalid packet size");  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: if (size <= 2097151)  	header = new byte[4];  else if (size <= 268435455)  	header = new byte[5];  else  	throw new MqttProtocolException ("Invalid packet size");  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: header = new byte[4];  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: if (size <= 268435455)  	header = new byte[5];  else  	throw new MqttProtocolException ("Invalid packet size");  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: if (size <= 268435455)  	header = new byte[5];  else  	throw new MqttProtocolException ("Invalid packet size");  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: header = new byte[5];  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: header [0] = (byte)(((byte)type << 4) | flags);  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: for (int i = 1; i < header.Length; i++) {  	header [i] = (byte)(left % 128);  	left = left / 128;  }  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: for (int i = 1; i < header.Length; i++) {  	header [i] = (byte)(left % 128);  	left = left / 128;  }  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: header [i] = (byte)(left % 128);  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: left = left / 128;  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: VerifySize (2);  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,Write,The following statement contains a magic number: stream.WriteByte ((byte)(value >> 8));  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,WriteAsync,The following statement contains a magic number: if (includeLength) {  	VerifySize (2);  	Write ((short)data.Length);  }  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,WriteAsync,The following statement contains a magic number: VerifySize (2);  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,GetSize,The following statement contains a magic number: return (includeLength ? 2 : 0) + value.Length;  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,GetSize,The following statement contains a magic number: if (value == null)  	return 2;  
Magic Number,DClark.MQTT.Messages,MqttMessage,C:\repos\darren-clark_mqtt\Lib\Messages\MqttMessage.cs,GetSize,The following statement contains a magic number: return 2;  
Magic Number,DClark.MQTT.Messages,SubscribeMessage,C:\repos\darren-clark_mqtt\Lib\Messages\SubscribeMessage.cs,SubscribeMessage,The following statement contains a magic number: if (flags != 2)  	throw new MqttProtocolException ("Invalid flags");  
Magic Number,DClark.MQTT.Messages,UnsubscribeMessage,C:\repos\darren-clark_mqtt\Lib\Messages\UnsubscribeMessage.cs,UnsubscribeMessage,The following statement contains a magic number: if (flags != 2)  	throw new MqttProtocolException ("Invalid flags");  
Missing Default,DClark.MQTT,Server,C:\repos\darren-clark_mqtt\Lib\MqttServer.cs,handleConnection,The following switch statement is missing a default case: switch (message.Type) {  case MessageType.Publish:  	await PublishReceived (session' stream' (PublishMessage)message);  	break;  case MessageType.Disconnect:  	Console.WriteLine ("Client {0} disconnected cleanly"' clientId);  	connections.Remove (session);  	connection.Close ();  	//Skip reading the next message. Loop should exit.  	continue;  case MessageType.Subscribe:  	await SubscribeReceived (session' stream' (SubscribeMessage)message);  	break;  case MessageType.Unsubscribe:  	await sessionProvider.RemoveSubscriptions (session' ((UnsubscribeMessage)message).TopicFilters);  	await new UnsubAckMessage (((UnsubscribeMessage)message).PacketId).Write (stream);  	break;  case MessageType.PubAck:  	string messageId = await session.PublishAcknowledged (((PubAckMessage)message).PacketId);  	if (messageId != null)  		await storageProvider.ReleaseMessage (messageId);  	break;  case MessageType.PubRec:  	messageId = await session.PublishReceived (((PubRecMessage)message).PacketId);  	if (messageId != null)  		await storageProvider.ReleaseMessage (messageId);  	break;  case MessageType.PubRel:  	await session.RemoveQoS2 (((PubRelMessage)message).PacketId);  	await new PubCompMessage (((PubRelMessage)message).PacketId).Write (stream);  	break;  case MessageType.PubComp:  	await session.PublishCompleted (((PubCompMessage)message).PacketId);  	break;  case MessageType.PingReq:  	await new PingRespMessage ().Write (stream);  	break;  }  
