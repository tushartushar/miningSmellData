Implementation smell,Namespace,Class,File,Method,Description
Long Method,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,SongToSong2014,The method has 130 lines of code.
Long Method,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,ToneToTone2014,The method has 190 lines of code.
Long Method,RocksmithToolkitLib.Conversion,Rs2014Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs2014Converter.cs,AddDifferences,The method has 207 lines of code.
Long Method,RocksmithToolkitLib.DLCPackage,Arrangement,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Arrangement.cs,Arrangement,The method has 135 lines of code.
Long Method,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The method has 275 lines of code.
Long Method,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014InlayPsarc,The method has 150 lines of code.
Long Method,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateSongPsarcRS1,The method has 105 lines of code.
Long Method,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,RS1LoadFromFolder,The method has 315 lines of code.
Long Method,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,LoadFromFolder,The method has 208 lines of code.
Long Method,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,DoLikeProject,The method has 122 lines of code.
Long Method,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,Unpack,The method has 125 lines of code.
Long Method,RocksmithToolkitLib.SngToTab,TabMeasure,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\TabMeasure.cs,GetLines,The method has 110 lines of code.
Long Method,RocksmithToolkitLib.DLCPackage.Manifest2014,Attributes2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest2014\Attributes2014.cs,Attributes2014,The method has 100 lines of code.
Long Method,RocksmithToolkitLib.DLCPackage.Manifest,ManifestBuilder,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\ManifestBuilder.cs,GenerateManifest,The method has 138 lines of code.
Long Method,RocksmithToolkitLib.XML,SongNote2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,parseNoteMask,The method has 105 lines of code.
Long Method,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,BetterDialog2,The method has 221 lines of code.
Long Method,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The method has 144 lines of code.
Long Method,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Write,The method has 107 lines of code.
Long Method,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngLevelNotes,The method has 106 lines of code.
Long Method,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngMetaDetails,The method has 109 lines of code.
Long Method,RocksmithToolkitLib.DLCPackage.AggregateGraph2014,AggregateGraph2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph2014\AggregateGraph2014.cs,SongAggregateGraph,The method has 193 lines of code.
Long Method,RocksmithToolkitLib.DLCPackage.AggregateGraph2014,AggregateGraph2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph2014\AggregateGraph2014.cs,InlayAggregateGraph,The method has 107 lines of code.
Long Method,RocksmithToolkitLib.DLCPackage.AggregateGraph2014,AggregateGraph2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph2014\AggregateGraph2014.cs,DoLikeSongPack,The method has 168 lines of code.
Long Method,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Write,The method has 107 lines of code.
Long Method,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseArrangements,The method has 307 lines of code.
Complex Method,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,SongToSong2014,Cyclomatic complexity of the method is 8
Complex Method,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,ConvertLevels,Cyclomatic complexity of the method is 13
Complex Method,RocksmithToolkitLib.Conversion,Rs2014Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs2014Converter.cs,AddDifferences,Cyclomatic complexity of the method is 27
Complex Method,RocksmithToolkitLib.DLCPackage,Arrangement,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Arrangement.cs,ToString,Cyclomatic complexity of the method is 10
Complex Method,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,EncryptPS3EdatFiles,Cyclomatic complexity of the method is 14
Complex Method,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,Cyclomatic complexity of the method is 13
Complex Method,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,RS1LoadFromFolder,Cyclomatic complexity of the method is 29
Complex Method,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,LoadFromFolder,Cyclomatic complexity of the method is 34
Complex Method,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,DoLikeProject,Cyclomatic complexity of the method is 20
Complex Method,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,Unpack,Cyclomatic complexity of the method is 15
Complex Method,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,PackXBox360,Cyclomatic complexity of the method is 18
Complex Method,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,UnpackPS3Package,Cyclomatic complexity of the method is 11
Complex Method,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,GetPlatform,Cyclomatic complexity of the method is 16
Complex Method,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,UpdateManifest2014,Cyclomatic complexity of the method is 9
Complex Method,RocksmithToolkitLib.SngToTab,TabFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\TabFile.cs,TabFile,Cyclomatic complexity of the method is 11
Complex Method,RocksmithToolkitLib.SngToTab,TabMeasure,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\TabMeasure.cs,GetLines,Cyclomatic complexity of the method is 15
Complex Method,RocksmithToolkitLib.SngToTab,TabNote,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\TabNote.cs,GetLines,Cyclomatic complexity of the method is 10
Complex Method,RocksmithToolkitLib.DLCPackage.Manifest,ManifestBuilder,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\ManifestBuilder.cs,GenerateManifest,Cyclomatic complexity of the method is 24
Complex Method,RocksmithToolkitLib.DLCPackage.Manifest.Tone,Tone,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Tone\Tone.cs,Transform,Cyclomatic complexity of the method is 12
Complex Method,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,AdjustShowlights,Cyclomatic complexity of the method is 13
Complex Method,RocksmithToolkitLib.XML,Song2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Song2014,Cyclomatic complexity of the method is 9
Complex Method,RocksmithToolkitLib.XML,Song2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,WriteXmlComments,Cyclomatic complexity of the method is 14
Complex Method,RocksmithToolkitLib.XML,SongNote2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Parse,Cyclomatic complexity of the method is 12
Complex Method,RocksmithToolkitLib.XML,SongNote2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,parseNoteMask,Cyclomatic complexity of the method is 23
Complex Method,RocksmithToolkitLib.XML,SongChord2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,parseChordMask,Cyclomatic complexity of the method is 14
Complex Method,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,BetterDialog2,Cyclomatic complexity of the method is 11
Complex Method,RocksmithToolkitLib.Extensions,ExternalApps,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ExternalApps.cs,VerifyExternalApps,Cyclomatic complexity of the method is 8
Complex Method,RocksmithToolkitLib.Extensions,DirectoryExtension,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\DirectoryExtension.cs,Move,Cyclomatic complexity of the method is 10
Complex Method,RocksmithToolkitLib.Ogg,Wwise,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\Wwise.cs,GetWwisePath,Cyclomatic complexity of the method is 10
Complex Method,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,Revorb,Cyclomatic complexity of the method is 9
Complex Method,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,RocksmithToolkitLib.Sng,SongLevel,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFile.cs,SongLevel,Cyclomatic complexity of the method is 8
Complex Method,RocksmithToolkitLib.Sng,SongLevel,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFile.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngSections,Cyclomatic complexity of the method is 9
Complex Method,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngLevels,Cyclomatic complexity of the method is 9
Complex Method,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngLevelAnchors,Cyclomatic complexity of the method is 8
Complex Method,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngLevelNotes,Cyclomatic complexity of the method is 10
Complex Method,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngMetaDetails,Cyclomatic complexity of the method is 14
Complex Method,RocksmithToolkitLib.DLCPackage.Manifest.Functions,ManifestFunctions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Functions\ManifestFunctions.cs,GenerateTechniques,Cyclomatic complexity of the method is 9
Complex Method,RocksmithToolkitLib.DLCPackage.Manifest.Functions,ManifestFunctions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Functions\ManifestFunctions.cs,getNoteTech,Cyclomatic complexity of the method is 18
Complex Method,RocksmithToolkitLib.DLCPackage.Manifest.Functions,ManifestFunctions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Functions\ManifestFunctions.cs,GeneratePhraseIterationsData,Cyclomatic complexity of the method is 14
Complex Method,RocksmithToolkitLib.DLCPackage.Manifest.Functions,ManifestFunctions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Functions\ManifestFunctions.cs,GenerateSectionData,Cyclomatic complexity of the method is 11
Complex Method,RocksmithToolkitLib.DLCPackage.Manifest.Functions,ManifestFunctions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Functions\ManifestFunctions.cs,GenerateChords,Cyclomatic complexity of the method is 8
Complex Method,RocksmithToolkitLib.DLCPackage.AggregateGraph2014,AggregateGraph2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph2014\AggregateGraph2014.cs,SongAggregateGraph,Cyclomatic complexity of the method is 12
Complex Method,RocksmithToolkitLib.DLCPackage.AggregateGraph2014,AggregateGraph2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph2014\AggregateGraph2014.cs,Serialize,Cyclomatic complexity of the method is 21
Complex Method,RocksmithToolkitLib.DLCPackage.AggregateGraph2014,AggregateGraph2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph2014\AggregateGraph2014.cs,LoadFromFile,Cyclomatic complexity of the method is 17
Complex Method,RocksmithToolkitLib.DLCPackage.AggregateGraph2014,AggregateGraph2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph2014\AggregateGraph2014.cs,DoLikeSongPack,Cyclomatic complexity of the method is 18
Complex Method,RocksmithToolkitLib.DLCPackage.AggregateGraph,AggregateGraph,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph\AggregateGraph.cs,Write,Cyclomatic complexity of the method is 18
Complex Method,RocksmithToolkitLib.DLCPackage.AggregateGraph,AggregateGraph,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph\AggregateGraph.cs,ProjectMap,Cyclomatic complexity of the method is 14
Complex Method,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,addChordNotes,Cyclomatic complexity of the method is 9
Complex Method,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseSections,Cyclomatic complexity of the method is 16
Complex Method,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseNoteMask,Cyclomatic complexity of the method is 24
Complex Method,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseChord,Cyclomatic complexity of the method is 15
Complex Method,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseArrangements,Cyclomatic complexity of the method is 52
Complex Method,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,numberNotes,Cyclomatic complexity of the method is 11
Long Parameter List,RocksmithToolkitLib.DLCPackage,DDCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DDCreator.cs,ApplyDD,The method has 8 parameters. Parameters: filePath' phraseLen' removeSus' rampPath' cfgPath' consoleOutput' overWrite' keepLog
Long Parameter List,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,Generate,The method has 5 parameters. Parameters: packagePath' info' platform' dlcType' pnum
Long Parameter List,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,BuildXBox360Package,The method has 5 parameters. Parameters: songFileName' info' xboxFiles' gameVersion' dlcType
Long Parameter List,RocksmithToolkitLib.DLCPackage,DLCPackageConverter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageConverter.cs,ConvertPackageForSimilarPlatform,The method has 5 parameters. Parameters: unpackedDir' targetFileName' sourcePlatform' targetPlatform' appId
Long Parameter List,RocksmithToolkitLib.DLCPackage,DLCPackageConverter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageConverter.cs,ConvertPackageRebuilding,The method has 5 parameters. Parameters: unpackedDir' targetFileName' sourcePlatform' targetPlatform' appId
Long Parameter List,RocksmithToolkitLib.DLCPackage,Crc32,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Crc32.cs,CalculateHash,The method has 5 parameters. Parameters: table' seed' buffer' start' size
Long Parameter List,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,LoadFromFolder,The method has 5 parameters. Parameters: unpackedDir' targetPlatform' sourcePlatform' fixMultiTone' fixLowBass
Long Parameter List,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,Pack,The method has 5 parameters. Parameters: sourcePath' saveFileName' updateSng' predefinedPlatform' updateManifest
Long Parameter List,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,Unpack,The method has 5 parameters. Parameters: sourceFileName' savePath' decodeAudio' overwriteSongXml' predefinedPlatform
Long Parameter List,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,Pack2014,The method has 5 parameters. Parameters: sourcePath' saveFileName' platform' updateSng' updateManifest
Long Parameter List,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,PackXBox360,The method has 5 parameters. Parameters: sourcePath' saveFileName' platform' updateSng' updateManifest
Long Parameter List,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,PackPS3,The method has 5 parameters. Parameters: sourcePath' saveFileName' platform' updateSng' updateManifest
Long Parameter List,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,ExtractPSARC,The method has 5 parameters. Parameters: filename' savePath' inputStream' platform' isExternalFile
Long Parameter List,RocksmithToolkitLib.DLCPackage,SoundBankGenerator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,GenerateSoundBank,The method has 5 parameters. Parameters: soundbankName' audioStream' outStream' volume' platform
Long Parameter List,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,HierarchySound,The method has 6 parameters. Parameters: id' fileid' mixerid' volume' preview' isConsole
Long Parameter List,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,Hierarchy,The method has 7 parameters. Parameters: bankid' soundid' fileid' name' volume' preview' isConsole
Long Parameter List,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,GenerateSoundBank,The method has 7 parameters. Parameters: soundbankName' audioStream' outStream' volume' platform' preview' sameID
Long Parameter List,RocksmithToolkitLib.DLCPackage,ToneGenerator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\ToneGenerator.cs,Generate,The method has 5 parameters. Parameters: toneKey' tone' outManifest' outXblock' aggregateGraph
Long Parameter List,RocksmithToolkitLib.XML,Song2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,WriteXmlComments,The method has 5 parameters. Parameters: xmlSongFile' commentNodes' saveOldVers' writeNewVers' customComment
Long Parameter List,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,ShowDialog,The method has 9 parameters. Parameters: dialogMessage' dialogTitle' textDialogButton1' textDialogButton2' textDialogButton3' dialogIcon' iconMessage' topFromCenter' leftFromCenter
Long Parameter List,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,BetterDialog2,The method has 9 parameters. Parameters: dialogMessage' dialogTitle' textDialogButton1' textDialogButton2' textDialogButton3' dialogIcon' iconMessage' topFromCenter' leftFromCenter
Long Parameter List,RocksmithToolkitLib.Extensions,StringExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\StringExtensions.cs,ObsoleteGetValidName,The method has 5 parameters. Parameters: value' allowSpace' allowStartsWithNumber' underscoreSpace' frets24
Long Parameter List,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,Save,The method has 5 parameters. Parameters: inputFilePath' maxWidth' maxHeight' quality' saveFilePath
Long Parameter List,RocksmithToolkitLib.Extensions,GeneralExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\GeneralExtension.cs,RunExternalExecutable,The method has 5 parameters. Parameters: exeFileName' toolkitRootFolder' runInBackground' waitToFinish' arguments
Long Parameter List,RocksmithToolkitLib.PsarcLoader,PsarcExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PsarcExtensions.cs,InjectArchiveEntry,The method has 7 parameters. Parameters: psarcPath' entryName' sourcePath' updateToolkitVersion' packageAuthor' packageVersion' packageComment
Long Parameter List,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngFile,The method has 5 parameters. Parameters: rocksmithSong' tuning' arrangementType' outputFile' bitConverter
Long Parameter List,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngLevels,The method has 5 parameters. Parameters: w' levels' songLength' iterationInfo' arrangementType
Long Parameter List,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngLevelAnchors,The method has 5 parameters. Parameters: w' anchors' level' iterationInfo' songLength
Long Parameter List,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngLevelNotes,The method has 6 parameters. Parameters: w' iterationInfo' notes' chords' songLength' arrangementType
Long Parameter List,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,GetMidiNote,The method has 5 parameters. Parameters: tuning' str' fret' bass' capo
Long Parameter List,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,GetMidiNote,The method has 6 parameters. Parameters: tuning' str' fret' bass' capo' template
Long Parameter List,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,getChordNote,The method has 5 parameters. Parameters: tuning' crd' handShape' bass' capo
Long Parameter List,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseChord,The method has 5 parameters. Parameters: xml' sng' chord' n' chordNotesId
Long Statement,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,SongToSong2014,The length of the statement  "            rsSong2014.Tuning = rsSong.Tuning == null ? new TuningStrings { String0 = 0' String1 = 0' String2 = 0' String3 = 0' String4 = 0' String5 = 0 } : rsSong.Tuning; " is 159.
Long Statement,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,ConvertChordTemplates,The length of the statement  "                chordTemplate.Add(new SongChordTemplate2014 { ChordName = songChordTemplate.ChordName' DisplayName = songChordTemplate.ChordName' Finger0 = (sbyte)songChordTemplate.Finger0' Finger1 = (sbyte)songChordTemplate.Finger1' Finger2 = (sbyte)songChordTemplate.Finger2' Finger3 = (sbyte)songChordTemplate.Finger3' Finger4 = (sbyte)songChordTemplate.Finger4' Finger5 = (sbyte)songChordTemplate.Finger5' Fret0 = (sbyte)songChordTemplate.Fret0' Fret1 = (sbyte)songChordTemplate.Fret1' Fret2 = (sbyte)songChordTemplate.Fret2' Fret3 = (sbyte)songChordTemplate.Fret3' Fret4 = (sbyte)songChordTemplate.Fret4' Fret5 = (sbyte)songChordTemplate.Fret5 }); " is 636.
Long Statement,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,ConvertLevels,The length of the statement  "                        chords.Add(new SongChord2014 { ChordId = zChord.ChordId' ChordNotes = chordNotes.ToArray()' HighDensity = zChord.HighDensity' Ignore = zChord.Ignore' Strum = zChord.Strum' Time = zChord.Time }); " is 194.
Long Statement,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,ConvertLevels,The length of the statement  "                    handShapes.Add(new SongHandShape { ChordId = handshape.ChordId' EndTime = handshape.EndTime' StartTime = handshape.StartTime }); " is 128.
Long Statement,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,ConvertLevels,The length of the statement  "                levels.Add(new SongLevel2014 { Anchors = anchors.ToArray()' Chords = chords.ToArray()' Difficulty = songLevel.Difficulty' HandShapes = handShapes.ToArray()' Notes = notes.ToArray() }); " is 184.
Long Statement,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,ConvertPhraseIterations,The length of the statement  "                phraseIterations.Add(new SongPhraseIteration2014 { PhraseId = songPhraseIteration.PhraseId' HeroLevels = null' Time = songPhraseIteration.Time }); " is 146.
Long Statement,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,GetNoteInfo,The length of the statement  "                // CRITICAL CALCULATION - DO NOT CHANGE - MULTIPLIER VALUE MUST BE 0.3333 TO ACHEIVE PROPER ACCURACY AND MATCH EOF OUTPUT " is 121.
Long Statement,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,GetNoteInfo,The length of the statement  "                bendValues.Add(new BendValue { Step = songNote.Bend' Time = (float)Math.Round((songNote.Sustain * 0.3333 / songNote.Bend) + songNote.Time' 3)' Unk5 = 0 }); " is 155.
Long Statement,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,DecodeChordTemplate,The length of the statement  "            //<chord time="83.366" linkNext="0" accent="0" chordId="19" fretHandMute="0" highDensity="0" ignore="0" palmMute="0" hopo="0" strum="down"> " is 139.
Long Statement,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,DecodeChordTemplate,The length of the statement  "            //  <chordNote time="83.366" linkNext="0" accent="0" bend="0" fret="3" hammerOn="0" harmonic="0" hopo="0" ignore="0" leftHand="-1" mute="0" palmMute="0" pluck="-1" pullOff="0" slap="-1" slideTo="-1" string="4" sustain="0.000" tremolo="0" harmonicPinch="0" pickDirection="0" rightHand="-1" slideUnpitchTo="-1" tap="0" vibrato="0"/> " is 330.
Long Statement,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,DecodeChordTemplate,The length of the statement  "            //  <chordNote time="83.366" linkNext="0" accent="0" bend="0" fret="3" hammerOn="0" harmonic="0" hopo="0" ignore="0" leftHand="-1" mute="0" palmMute="0" pluck="-1" pullOff="0" slap="-1" slideTo="-1" string="5" sustain="0.000" tremolo="0" harmonicPinch="0" pickDirection="0" rightHand="-1" slideUnpitchTo="-1" tap="0" vibrato="0"/> " is 330.
Long Statement,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,DecodeChordTemplate,The length of the statement  "            //<chordTemplate chordName="A" finger0="-1" finger1="0" finger2="1" finger3="1" finger4="1" finger5="-1" fret0="-1" fret1="0" fret2="2" fret3="2" fret4="2" fret5="-1"/> " is 168.
Long Statement,RocksmithToolkitLib.DLCPackage,DDCSettings,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DDCreator.cs,LoadConfigXml,The length of the statement  "            //    // -m "D:\Documents and Settings\Administrator\My Documents\Visual Studio 2010\Projects\rocksmith-custom-song-toolkit\RocksmithTookitGUI\bin\Debug\ddc\ddc_default.xml" " is 173.
Long Statement,RocksmithToolkitLib.DLCPackage,DDCSettings,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DDCreator.cs,LoadConfigXml,The length of the statement  "            //    // -c "D:\Documents and Settings\Administrator\My Documents\Visual Studio 2010\Projects\rocksmith-custom-song-toolkit\RocksmithTookitGUI\bin\Debug\ddc\ddc_default.cfg" " is 173.
Long Statement,RocksmithToolkitLib.DLCPackage,Arrangement,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Arrangement.cs,DetectTuning,The length of the statement  "            var t = TuningDefinitionRepository.Instance.Detect(song.Tuning' GameVersion.RS2014' ArrangementType == ArrangementType.Guitar); " is 127.
Long Statement,RocksmithToolkitLib.DLCPackage,Arrangement,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Arrangement.cs,ToString,The length of the statement  "                    return String.Format("{0} - {1} [{2}{3}{4}] ({5}){6}"' ArrangementType' Name' Tuning' pitchInfo' capoInfo' toneDesc' metDesc); " is 126.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,Generate,The length of the statement  "                var songFileName = String.Format("{0}{1}"' Path.Combine(Path.GetDirectoryName(packagePath)' packageName)' platform.GetPathName()[2]); " is 133.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,BuildXBox360Package,The length of the statement  "            RSAParams xboxRSA = info.SignatureType == PackageMagic.CON ? new RSAParams(new DJsIO(Resources.XBox360_KV' true)) : new RSAParams(StrongSigned.LIVE); " is 149.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,EncryptPS3EdatFiles,The length of the statement  "                throw new InvalidOperationException("You need install Java SE 7 (x86) or higher on your machine. The Java path should be in PATH Environment Variable:" + Environment.NewLine + Environment.NewLine + encryptResult); " is 213.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,EncryptPS3EdatFiles,The length of the statement  "                throw new InvalidOperationException("Rebuilder error' please check if .edat files are created correctly and see output bellow:" + Environment.NewLine + Environment.NewLine + encryptResult); " is 189.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The length of the statement  "                        new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }' " is 138.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The length of the statement  "                        new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }' " is 140.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The length of the statement  "                        new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") } " is 139.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The length of the statement  "                    packPsarc.AddEntry(String.Format("gfxassets/album_art/album_{0}_{1}.dds"' dlcName' dds.sizeX)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read)); " is 180.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The length of the statement  "                    packPsarc.AddEntry(String.Format("assets/ui/lyrics/{0}/lyrics_{0}.dds"' dlcName)' new FileStream(info.LyricArtPath' FileMode.Open' FileAccess.Read' FileShare.Read)); " is 165.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The length of the statement  "                    GenerateToolkitVersion(toolkitVersionStream' info.ToolkitInfo.PackageAuthor' info.ToolkitInfo.PackageVersion' info.ToolkitInfo.PackageComment); " is 143.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The length of the statement  "                    var audioFileNameId = SoundBankGenerator2014.GenerateSoundBank(info.Name' soundStream' soundbankStream' info.Volume' platform); " is 127.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The length of the statement  "                    packPsarc.AddEntry(String.Format("audio/{0}/{1}.bnk"' platform.GetPathName()[0].ToLower()' soundbankFileName)' soundbankStream); " is 128.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The length of the statement  "                    packPsarc.AddEntry(String.Format("audio/{0}/{1}.wem"' platform.GetPathName()[0].ToLower()' audioFileNameId)' soundStream); " is 122.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The length of the statement  "                    audioPreviewFileNameId = SoundBankGenerator2014.GenerateSoundBank(info.Name + "_Preview"' soundPreviewStream' soundbankPreviewStream' previewVolume' platform' true' !(File.Exists(previewAudioFile))); " is 199.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The length of the statement  "                    packPsarc.AddEntry(String.Format("audio/{0}/{1}.bnk"' platform.GetPathName()[0].ToLower()' soundbankPreviewFileName)' soundbankPreviewStream); " is 142.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The length of the statement  "                    if (!soundPreviewStream.Equals(soundStream)) packPsarc.AddEntry(String.Format("audio/{0}/{1}.wem"' platform.GetPathName()[0].ToLower()' audioPreviewFileNameId)' soundPreviewStream); " is 181.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The length of the statement  "                        var arrangementFileName = songPartition.GetArrangementFileName(arrangement.Name' arrangement.ArrangementType).ToLower(); " is 120.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The length of the statement  "                        packPsarc.AddEntry(String.Format("songs/bin/{0}/{1}_{2}.sng"' platform.GetPathName()[1].ToLower()' dlcName' arrangementFileName)' sngSongFile); " is 143.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The length of the statement  "                        packPsarc.AddEntry(String.Format((platform.IsConsole ? jsonPathConsole : jsonPathPC)' dlcName' arrangementFileName)' manifestStream); " is 133.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The length of the statement  "                        var attributeHeaderDictionary = new Dictionary<string' AttributesHeader2014> { { "Attributes"' new AttributesHeader2014(attribute) } }; " is 135.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The length of the statement  "                            packPsarc.AddEntry(String.Format("manifests/songs_dlc/{0}_{1}.hson"' dlcName' arrangementFileName)' manifestHeaderStream); " is 122.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The length of the statement  "                            string shlFilePath = Path.Combine(Path.GetDirectoryName(info.Arrangements[0].SongXml.File)' String.Format("{0}_showlights.xml"' "cst")); " is 136.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The length of the statement  "                            throw new InvalidOperationException("<ERROR> Insufficient showlight changes will crash game: " + showlight.ShowlightList.Count); " is 128.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014InlayPsarc,The length of the statement  "                        ddsfiles.Add(new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }); " is 148.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014InlayPsarc,The length of the statement  "                        ddsfiles.Add(new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }); " is 150.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014InlayPsarc,The length of the statement  "                        ddsfiles.Add(new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }); " is 150.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014InlayPsarc,The length of the statement  "                        ddsfiles.Add(new DDSConvertedFile() { sizeX = 512' sizeY = 512' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }); " is 150.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014InlayPsarc,The length of the statement  "                        ddsfiles.Add(new DDSConvertedFile() { sizeX = 1024' sizeY = 512' sourceFile = inlayPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }); " is 152.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014InlayPsarc,The length of the statement  "                            packPsarc.AddEntry(String.Format("assets/gameplay/inlay/inlay_{0}.dds"' dlcName)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read)); " is 167.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014InlayPsarc,The length of the statement  "                            packPsarc.AddEntry(String.Format("gfxassets/rewards/guitar_inlays/reward_inlay_{0}_{1}.dds"' dlcName' dds.sizeX)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read)); " is 199.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateSongPsarcRS1,The length of the statement  "                    ddsfiles.Add(new DDSConvertedFile() { sizeX = 512' sizeY = 512' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }); " is 154.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateSongPsarcRS1,The length of the statement  "                    var soundFileName = SoundBankGenerator.GenerateSoundBank(info.Name' soundStream' soundbankStream' info.Volume' platform); " is 121.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateSongPsarcRS1,The length of the statement  "                    songPsarc.AddEntry(String.Format("GRAssets/AlbumArt/{0}.dds"' manifestBuilder.AggregateGraph.AlbumArt.Name)' albumArtStream); " is 125.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateSongPsarcRS1,The length of the statement  "                        songPsarc.AddEntry(String.Format("GR/Behaviors/Songs/{0}.xml"' Path.GetFileNameWithoutExtension(x.SongXml.File))' xmlFile); " is 123.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateSongPsarcRS1,The length of the statement  "                        songPsarc.AddEntry(String.Format("GRExports/{0}/{1}.sng"' platform.GetPathName()[1]' Path.GetFileNameWithoutExtension(x.SongFile.File))' sngFile); " is 146.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,ToDDS,The length of the statement  "                    args = "-file \"{0}\" -output \"{1}\" -prescale {2} {3} -quality_highest -max -dxt5 -nomipmap -alpha -overwrite -forcewrite"; " is 125.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,ToDDS,The length of the statement  "                GeneralExtensions.RunExternalExecutable("nvdxt.exe"' true' true' true' String.Format(args' item.sourceFile' item.destinationFile' item.sizeX' item.sizeY)); " is 155.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageConverter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageConverter.cs,Convert,The length of the statement  "            var targetFileName = String.Format(nameTemplate' Path.Combine(Path.GetDirectoryName(sourcePackage)' packageName)' targetPlatform.GetPathName()[2]); " is 147.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageConverter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageConverter.cs,ConvertPackageForSimilarPlatform,The length of the statement  "            aggregateGraphText = Regex.Replace(aggregateGraphText' GraphItem.GetPlatformTagDescription(sourcePlatform.platform)' GraphItem.GetPlatformTagDescription(targetPlatform.platform)' RegexOptions.Multiline); " is 203.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageConverter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageConverter.cs,ConvertPackageForSimilarPlatform,The length of the statement  "            bool updateSNG = ((sourcePlatform.platform == GamePlatform.Pc && targetPlatform.platform == GamePlatform.Mac) || (sourcePlatform.platform == GamePlatform.Mac && targetPlatform.platform == GamePlatform.Pc)); " is 206.
Long Statement,RocksmithToolkitLib.DLCPackage,TuningFrequency,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\TuningFrequency.cs,ApplyBassFix,The length of the statement  "            var isBassFixed = xmlComments.Any(xComment => xComment.ToString().Contains("Low Bass Tuning Fixed")) || arr.TuningPitch.Equals(220.0); " is 134.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,RS1LoadFromFolder,The length of the statement  "                    var result = projectMap.First(m => String.Equals(Path.GetFileName(m.SongXmlPath)' Path.GetFileName(xmlFile)' StringComparison.CurrentCultureIgnoreCase)); " is 153.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,RS1LoadFromFolder,The length of the statement  "                    var arrangement = attr.First(s => s.SongXml.ToLower().Contains(result.LLID));//FIXME: Sequence contains no matching element issue " is 129.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,RS1LoadFromFolder,The length of the statement  "                        rsSong.Tuning = new TuningStrings { String0 = -1' String1 = -1' String2 = -1' String3 = -1' String4 = -1' String5 = -1 }; " is 121.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,RS1LoadFromFolder,The length of the statement  "                        attr2014.ArrangementProperties.RouteMask = arrangement.EffectChainName.ToLower().Contains("lead") ? (int)RouteMask.Lead : (int)RouteMask.Rhythm; " is 144.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,RS1LoadFromFolder,The length of the statement  "                        // <note time="58.366" linkNext="0" accent="0" bend="0" fret="7" hammerOn="0" harmonic="0" hopo="0" ignore="0" leftHand="-1" mute="0" palmMute="0" pluck="-1" pullOff="0" slap="-1" slideTo="-1" string="3" sustain="0.108" tremolo="0" harmonicPinch="0" pickDirection="0" rightHand="-1" slideUnpitchTo="-1" tap="0" vibrato="0" /> " is 325.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,RS1LoadFromFolder,The length of the statement  "                        Console.WriteLine(@"This CDLC could not be auto converted." + Environment.NewLine + "You can still try manually adding the arrangements and assets." + Environment.NewLine + ex.Message); " is 185.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,RS1LoadFromFolder,The length of the statement  "            targetArtFiles.Add(new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = artFiles[0]' destinationFile = artFiles[0].CopyToTempFile(".dds") }); " is 152.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,RS1LoadFromFolder,The length of the statement  "                var newFile = Path.Combine(Path.GetDirectoryName(audioFiles[i])' String.Format("{0}_cap.ogg"' Path.GetFileNameWithoutExtension(audioFiles[i]))); " is 144.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,RS1LoadFromFolder,The length of the statement  "                var versionFile = Directory.EnumerateFiles(unpackedDir' "toolkit.version"' SearchOption.AllDirectories).FirstOrDefault(); " is 121.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,LoadFromFolder,The length of the statement  "                        data.SongInfo = new SongInfo { SongDisplayName = attr.SongName' SongDisplayNameSort = attr.SongNameSort' Album = attr.AlbumName' AlbumSort = attr.AlbumNameSort' SongYear = attr.SongYear ?? 0' Artist = attr.ArtistName' ArtistSort = attr.ArtistNameSort' AverageTempo = (int)attr.SongAverageTempo }; " is 296.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,LoadFromFolder,The length of the statement  "                        throw new Exception("<CRITICAL ERROR> vocSng.IsCustomFont: " + xmlFile + Environment.NewLine + "Please report this error to the toolkit developers along with the song that you are currently working on." + Environment.NewLine + "This is important!"); " is 249.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,LoadFromFolder,The length of the statement  "            var xmlShowLights = Directory.EnumerateFiles(unpackedDir' "*_showlights.xml"' SearchOption.AllDirectories).FirstOrDefault(); " is 124.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,LoadFromFolder,The length of the statement  "                            ddsFilesC.Add(new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = file' destinationFile = file.CopyToTempFile(".dds") }); " is 133.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,LoadFromFolder,The length of the statement  "                            ddsFilesC.Add(new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = file' destinationFile = file.CopyToTempFile(".dds") }); " is 133.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,LoadFromFolder,The length of the statement  "                            ddsFilesC.Add(new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = file' destinationFile = file.CopyToTempFile(".dds") }); " is 131.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,LoadFromFolder,The length of the statement  "                data.Volume = _volume ?? SoundBankGenerator2014.ReadBNKVolume(File.OpenRead(bnkfiles[0])' targetPlatform' GameVersion.RS2014); " is 126.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,LoadFromFolder,The length of the statement  "                data.PreviewVolume = _volume_preview ?? SoundBankGenerator2014.ReadBNKVolume(File.OpenRead(bnkfiles[1])' targetPlatform' GameVersion.RS2014); " is 141.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,LoadFromFolder,The length of the statement  "                var newFile = Path.Combine(Path.GetDirectoryName(file)' String.Format("{0}_fixed{1}"' Path.GetFileNameWithoutExtension(file)' Path.GetExtension(file))); " is 152.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,LoadFromFolder,The length of the statement  "                var newPreviewFileName = Path.Combine(Path.GetDirectoryName(audioPath)' String.Format("{0}_preview{1}"' Path.GetFileNameWithoutExtension(audioPath)' Path.GetExtension(audioPath))); " is 180.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,LoadFromFolder,The length of the statement  "            var versionFile = Directory.EnumerateFiles(unpackedDir' "toolkit.version"' SearchOption.AllDirectories).FirstOrDefault(); " is 121.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,DoLikeProject,The length of the statement  "            var outdir = Path.Combine(Path.GetDirectoryName(unpackedDir)' String.Format("{0}_{1}"' SongName' songVersion).Replace(" "' "-")); " is 129.
Long Statement,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,DoLikeProject,The length of the statement  "            var toolkitVersion = Directory.EnumerateFiles(unpackedDir' "toolkit.version"' SearchOption.AllDirectories).FirstOrDefault(); " is 124.
Long Statement,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,Pack,The length of the statement  "            if (predefinedPlatform != null && predefinedPlatform.platform != GamePlatform.None && predefinedPlatform.version != GameVersion.None) " is 133.
Long Statement,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,Pack,The length of the statement  "                    throw new InvalidOperationException(String.Format("Invalid directory structure of package. {0}Directory: {1}"' Environment.NewLine' sourcePath)); " is 145.
Long Statement,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,Unpack,The length of the statement  "            if (predefinedPlatform != null && predefinedPlatform.platform != GamePlatform.None && predefinedPlatform.version != GameVersion.None) " is 133.
Long Statement,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,Unpack,The length of the statement  "                var audioFiles = Directory.EnumerateFiles(unpackedDir' "*.*"' SearchOption.AllDirectories).Where(s => s.EndsWith(".ogg") || s.EndsWith(".wem")); " is 144.
Long Statement,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,Unpack,The length of the statement  "                    var outputAudioFileName = Path.Combine(Path.GetDirectoryName(file)' String.Format("{0}_fixed{1}"' Path.GetFileNameWithoutExtension(file)' ".ogg")); " is 147.
Long Statement,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,Unpack,The length of the statement  "                    OggFile.Revorb(file' outputAudioFileName' Path.GetDirectoryName(Application.ExecutablePath)' Path.GetExtension(file).GetWwiseVersion()); " is 136.
Long Statement,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,Unpack,The length of the statement  "                    var xmlEofFile = Path.Combine(Path.GetDirectoryName(sngFile)' String.Format("{0}.xml"' Path.GetFileNameWithoutExtension(sngFile))); " is 131.
Long Statement,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,Unpack,The length of the statement  "                    xmlEofFile = xmlEofFile.Replace(String.Format("bin{0}{1}"' Path.DirectorySeparatorChar' platform.GetPathName()[1].ToLower())' "arr"); " is 133.
Long Statement,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,Unpack,The length of the statement  "                        var jsonFiles = Directory.EnumerateFiles(unpackedDir' String.Format("{0}.json"' Path.GetFileNameWithoutExtension(sngFile))' SearchOption.AllDirectories).FirstOrDefault(); " is 170.
Long Statement,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,PackXBox360,The length of the statement  "                    if (Path.GetFileNameWithoutExtension(xml).ToLower().Contains("vocal") || Path.GetFileNameWithoutExtension(xml).ToLower().Contains("showlight")) " is 143.
Long Statement,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,PackXBox360,The length of the statement  "                                                       "The file is in the same level at 'Root' folder along with the files: 'Content image.png' and 'Package image.png' and no other file .txt can be here."' ex); " is 156.
Long Statement,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,UnpackXBox360Package,The length of the statement  "            var rootDir = Path.Combine(savePath' Path.GetFileNameWithoutExtension(sourceFileName)) + String.Format("_{0}"' platform.platform.ToString()); " is 141.
Long Statement,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,UnpackXBox360Package,The length of the statement  "                        ExtractPSARC(fileName' Path.GetDirectoryName(fileName)' outputFileStream' new Platform(GamePlatform.XBox360' GameVersion.None)' false); " is 135.
Long Statement,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,UnpackPS3Package,The length of the statement  "                    ExtractPSARC(fileName' Path.GetDirectoryName(fileName)' outputFileStream' new Platform(GamePlatform.PS3' GameVersion.None)); " is 124.
Long Statement,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,UnpackPS3Package,The length of the statement  "            var outputDir = Path.Combine(savePath' outName.Substring(0' outName.LastIndexOf(".")) + String.Format("_{0}"' platform.platform.ToString())); " is 141.
Long Statement,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,UnpackPS3Package,The length of the statement  "                throw new InvalidOperationException("Rebuilder error' please check if .edat files are created correctly and see output below:" + Environment.NewLine + Environment.NewLine + outputMessage); " is 188.
Long Statement,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,DeleteFixedAudio,The length of the statement  "                foreach (var file in Directory.EnumerateFiles(sourcePath' "*"' SearchOption.AllDirectories).Where(s => s.EndsWith("RS2012.dlc.xml") || s.EndsWith("RS2014.dlc.xml"))) " is 165.
Long Statement,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,DeleteFixedAudio,The length of the statement  "                foreach (var file in Directory.EnumerateFiles(sourcePath' "*_preview.*"' SearchOption.AllDirectories).Where(s => s.EndsWith(".ogg") || s.EndsWith(".wem"))) " is 155.
Long Statement,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,DeleteFixedAudio,The length of the statement  "                foreach (var file in Directory.EnumerateFiles(sourcePath' "*_fixed.*"' SearchOption.AllDirectories).Where(s => s.EndsWith(".ogg") || s.EndsWith(".wem"))) " is 153.
Long Statement,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,UpdateSng,The length of the statement  "                    var sngFile = Path.Combine(songDirectory' "GRExports"' targetPlatform.GetPathName()[1]' Path.GetFileNameWithoutExtension(xmlFile) + ".sng"); " is 140.
Long Statement,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,UpdateSng2014,The length of the statement  "            var xmlFiles = Directory.EnumerateFiles(Path.Combine(songDirectory' "songs"' "arr")' "*_*.xml"' SearchOption.AllDirectories).ToList(); " is 134.
Long Statement,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,UpdateSng2014,The length of the statement  "            var sngFolder = Path.Combine(songDirectory' "songs"' "bin"' targetPlatform.GetPathName()[1].ToLower()); //-3 or more times re-calculation " is 137.
Long Statement,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,UpdateManifest2014,The length of the statement  "                var attributeHeaderDictionary = new Dictionary<string' AttributesHeader2014> { { "Attributes"' new AttributesHeader2014(attr) } }; " is 130.
Long Statement,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,GenerateSoundBank,The length of the statement  "            byte[] dataChunk = audioReader.ReadBytes(51200); // wwise is based on audio length' we'll just make it up(prefetch lookup is 100ms) " is 131.
Long Statement,RocksmithToolkitLib.DLCPackage,ToneGenerator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\ToneGenerator.cs,generateAggregateGraph,The length of the statement  "            writer.WriteLine("<urn:uuid:{0}> <http://emergent.net/aweb/1.0/relpath> \"/ContentMounts/DLC_Tone_{1}/Exports/Pedals/DLC_Tone_{1}.xblock\"."' guid' toneKey); " is 157.
Long Statement,RocksmithToolkitLib.DLCPackage.Manifest,ManifestBuilder,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\ManifestBuilder.cs,GenerateManifest,The length of the statement  "                attribute.EffectChainName = isVocal ? "" : (dlcKey + "_" + x.ToneBase == null ? "Default" : x.ToneBase.Replace(' '' '_')); " is 122.
Long Statement,RocksmithToolkitLib.DLCPackage.Manifest,ManifestBuilder,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\ManifestBuilder.cs,GenerateManifest,The length of the statement  "                attribute.VocalsAssetId = x.ArrangementType == Sng.ArrangementType.Vocal ? "" : (vocal != null) ? String.Format("{0}|GRSong_{1}"' vocal.Id' vocal.Name) : ""; " is 157.
Long Statement,RocksmithToolkitLib.DLCPackage.Manifest,ManifestBuilder,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\ManifestBuilder.cs,AssociateTechniques,The length of the statement  "            att.AssociatedTechniques.Add(String.Format("{0}{1}"' x.ArrangementType == Sng.ArrangementType.Bass ? "Bass" : ""' technique)); " is 126.
Long Statement,RocksmithToolkitLib.DLCPackage.Manifest.Tone,Tone,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Tone\Tone.cs,Import,The length of the statement  "                            throw new NotSupportedException(String.Format("Unknown file extension exception '{0}'. File not supported."' toneExtension)); " is 125.
Long Statement,RocksmithToolkitLib.DLCPackage.Manifest.Tone,Tone,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Tone\Tone.cs,Transform,The length of the statement  "            if (name.Equals("Pedal") && num == 1 && !Keys.Contains("Amp") && !Keys.Contains("Cabinet") && !Keys.Contains("PostPedal2")) " is 123.
Long Statement,RocksmithToolkitLib.DLCPackage.Manifest.Tone,Tone,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Tone\Tone.cs,Transform,The length of the statement  "            if (name.Equals("Pedal") && num == 2 && !Keys.Contains("Amp") && !Keys.Contains("Cabinet") && !Keys.Contains("PostPedal1")) " is 123.
Long Statement,RocksmithToolkitLib.DLCPackage.Manifest.Tone,Tone,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Tone\Tone.cs,Transform,The length of the statement  "            if (name.Equals("Pedal") && num >= 1 && !Keys.Contains("Amp") && Keys.Contains("Cabinet") && !Keys.Contains("LoopPedal3")) " is 122.
Long Statement,RocksmithToolkitLib.DLCPackage.Manifest.Tone,Tone,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Tone\Tone.cs,Transform,The length of the statement  "            if (name.Equals("Pedal") && num >= 2 && !Keys.Contains("Amp") && Keys.Contains("Cabinet") && !Keys.Contains("LoopPedal2")) " is 122.
Long Statement,RocksmithToolkitLib.DLCPackage.Manifest.Tone,Tone,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Tone\Tone.cs,Transform,The length of the statement  "            if (name.Equals("Pedal") && num >= 3 && !Keys.Contains("Amp") && Keys.Contains("Cabinet") && !Keys.Contains("LoopPedal1")) " is 122.
Long Statement,RocksmithToolkitLib.DLCPackage.Manifest.Tone,Tone,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Tone\Tone.cs,Transform,The length of the statement  "            if (name.Equals("Pedal") && num >= 2 && Keys.Contains("Cabinet") && Keys.Contains("Amp") && !Keys.Contains("PrePedal3")) " is 120.
Long Statement,RocksmithToolkitLib.DLCPackage.Manifest.Tone,Tone,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Tone\Tone.cs,Transform,The length of the statement  "            if (name.Equals("Pedal") && num >= 3 && Keys.Contains("Cabinet") && Keys.Contains("Amp") && !Keys.Contains("PrePedal2")) " is 120.
Long Statement,RocksmithToolkitLib.DLCPackage.Manifest.Tone,Tone,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Tone\Tone.cs,Transform,The length of the statement  "            if (name.Equals("Pedal") && num >= 4 && Keys.Contains("Cabinet") && Keys.Contains("Amp") && !Keys.Contains("PrePedal1")) " is 120.
Long Statement,RocksmithToolkitLib.XmlRepository,ConfigRepository,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XmlRepository\ConfigRepository.cs,GetDecimal,The length of the statement  "            return Convert.ToDecimal(List.FirstOrDefault(s => s.Key == configKey).Value.Replace('''' '.')' System.Globalization.CultureInfo.InvariantCulture); " is 146.
Long Statement,RocksmithToolkitLib.XmlRepository,TuningDefinitionRepository,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XmlRepository\TuningDefinitionRepository.cs,Select,The length of the statement  "            return List.FirstOrDefault(s => s.Tuning.ToArray().SequenceEqual(tuningStrings.ToArray()) && s.GameVersion == gameVersion); " is 123.
Long Statement,RocksmithToolkitLib.XmlRepository,TuningDefinitionRepository,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XmlRepository\TuningDefinitionRepository.cs,SelectForBass,The length of the statement  "            return List.FirstOrDefault(s => s.Tuning.ToBassArray().SequenceEqual(tuningStrings.ToBassArray()) && s.GameVersion == gameVersion); " is 131.
Long Statement,RocksmithToolkitLib.XmlRepository,TuningDefinition,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XmlRepository\TuningDefinition.cs,NoteName,The length of the statement  "            String[] notesNamesHi = { "C"' "C#"' "D"' "D#"' "E"' "F"' "F#"' "G"' "G#"' "A"' "A#"' "B" }; //TODO: use maj\min or intervals classification... " is 143.
Long Statement,RocksmithToolkitLib.XmlRepository,TuningDefinition,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XmlRepository\TuningDefinition.cs,TuningStringToName,The length of the statement  "                if ("" + (tuning.Tuning.String0) + (tuning.Tuning.String1) + (tuning.Tuning.String2) + (tuning.Tuning.String3) + (tuning.Tuning.String4) + (tuning.Tuning.String5) == strings) " is 174.
Long Statement,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,Generate,The length of the statement  "                // var mNote = Sng2014FileWriter.GetMidiNote(tuning' (Byte)note.String' (Byte)note.Fret' song.Arrangement == "Bass"' song.Capo); " is 128.
Long Statement,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,Generate,The length of the statement  "                //var mNote = Sng2014FileWriter.getChordNote(tuning' chord' song.ChordTemplates' song.Arrangement == "Bass"' song.Capo); " is 120.
Long Statement,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,AdjustShowlights,The length of the statement  "                    //if ((showlightList[i].Note > 23 && showlightList[i].Note < 36) && (showlightList[i - 1].Note > 23 && showlightList[i - 1].Note < 36)) " is 135.
Long Statement,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,AdjustShowlights,The length of the statement  "                    showlightList.Add(new Showlight { Note = GetBeamNote(showlightList[showlightList.Count - 1].Note)' Time = showlightList[showlightList.Count - 1].Time }); " is 153.
Long Statement,RocksmithToolkitLib.XML,Song2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Serialize,The length of the statement  "            using (var writer = XmlWriter.Create(song' new XmlWriterSettings { Indent = true' OmitXmlDeclaration = omitXmlDeclaration' Encoding = new UTF8Encoding(false) })) " is 161.
Long Statement,RocksmithToolkitLib.XML,Song2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,FixArrayAttribs,The length of the statement  "            string[] anodes = { "phrases"' "phraseIterations"' "newLinkedDiffs"' "linkedDiffs"' "phraseProperties"' "chordTemplates"' "fretHandMuteTemplates"' "fretHandMutes" /*DDC*/' "ebeats"' "sections"' "events"' "levels"' "notes"' "chords"' "anchors"' "handShapes"' "tones" }; " is 268.
Long Statement,RocksmithToolkitLib.XML,SongChord2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Parse,The length of the statement  "                        chord.ParseChordNotes(sngData.Chords.Chords[chord.ChordId]' sngData.ChordNotes.ChordNotes[cnId]' notesSection.Notes[i].Sustain); " is 128.
Long Statement,RocksmithToolkitLib.DLCPackage.XBlock,XblockX,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\XBlock\XblockX.cs,Serialize,The length of the statement  "            using (var writer = XmlWriter.Create(stream' new XmlWriterSettings { Indent = true' OmitXmlDeclaration = omitXmlDeclaration })) " is 127.
Long Statement,RocksmithToolkitLib.DLCPackage.XBlock,GameXblock<T>,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\XBlock\GameXblock.cs,Generate2014,The length of the statement  "                            entity.Properties.Add(new Property2014() { Name = "Header"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Database.GetDescription()' TagValue.HsonDB.GetDescription()' String.Format(AggregateGraph2014.AggregateGraph2014.NAME_ARRANGEMENT' dlcName' arrangementFileName.ToLower())) } }); " is 300.
Long Statement,RocksmithToolkitLib.DLCPackage.XBlock,GameXblock<T>,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\XBlock\GameXblock.cs,Generate2014,The length of the statement  "                            entity.Properties.Add(new Property2014() { Name = "Header"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Database.GetDescription()' TagValue.HsanDB.GetDescription()' String.Format("songs_dlc_{0}"' dlcName)) } }); " is 230.
Long Statement,RocksmithToolkitLib.DLCPackage.XBlock,GameXblock<T>,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\XBlock\GameXblock.cs,Generate2014,The length of the statement  "                        entity.Properties.Add(new Property2014() { Name = "Manifest"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Database.GetDescription()' TagValue.JsonDB.GetDescription()' String.Format(AggregateGraph2014.AggregateGraph2014.NAME_ARRANGEMENT' dlcName' arrangementFileName.ToLower())) } }); " is 302.
Long Statement,RocksmithToolkitLib.DLCPackage.XBlock,GameXblock<T>,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\XBlock\GameXblock.cs,Generate2014,The length of the statement  "                        entity.Properties.Add(new Property2014() { Name = "SngAsset"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Application.GetDescription()' TagValue.MusicgameSong.GetDescription()' String.Format(AggregateGraph2014.AggregateGraph2014.NAME_ARRANGEMENT' dlcName' arrangementFileName.ToLower())) } }); " is 312.
Long Statement,RocksmithToolkitLib.DLCPackage.XBlock,GameXblock<T>,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\XBlock\GameXblock.cs,Generate2014,The length of the statement  "                        entity.Properties.Add(new Property2014() { Name = "AlbumArtSmall"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Image.GetDescription()' TagValue.DDS.GetDescription()' String.Format("album_{0}_64"' dlcName)) } }); " is 230.
Long Statement,RocksmithToolkitLib.DLCPackage.XBlock,GameXblock<T>,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\XBlock\GameXblock.cs,Generate2014,The length of the statement  "                        entity.Properties.Add(new Property2014() { Name = "AlbumArtMedium"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Image.GetDescription()' TagValue.DDS.GetDescription()' String.Format("album_{0}_128"' dlcName)) } }); " is 232.
Long Statement,RocksmithToolkitLib.DLCPackage.XBlock,GameXblock<T>,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\XBlock\GameXblock.cs,Generate2014,The length of the statement  "                        entity.Properties.Add(new Property2014() { Name = "AlbumArtLarge"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Image.GetDescription()' TagValue.DDS.GetDescription()' String.Format("album_{0}_256"' dlcName)) } }); " is 231.
Long Statement,RocksmithToolkitLib.DLCPackage.XBlock,GameXblock<T>,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\XBlock\GameXblock.cs,Generate2014,The length of the statement  "                            entity.Properties.Add(new Property2014() { Name = "LyricArt"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Image.GetDescription()' TagValue.DDS.GetDescription()' String.Format("lyrics_{0}"' dlcName)) } }); " is 223.
Long Statement,RocksmithToolkitLib.DLCPackage.XBlock,GameXblock<T>,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\XBlock\GameXblock.cs,Generate2014,The length of the statement  "                        entity.Properties.Add(new Property2014() { Name = "ShowLightsXMLAsset"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Application.GetDescription()' TagValue.XML.GetDescription()' String.Format(AggregateGraph2014.AggregateGraph2014.NAME_SHOWLIGHT' dlcName)) } }); " is 279.
Long Statement,RocksmithToolkitLib.DLCPackage.XBlock,GameXblock<T>,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\XBlock\GameXblock.cs,Generate2014,The length of the statement  "                        entity.Properties.Add(new Property2014() { Name = "SoundBank"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Audio.GetDescription()' TagValue.WwiseSoundBank.GetDescription()' String.Format("song_{0}"' dlcName)) } }); " is 233.
Long Statement,RocksmithToolkitLib.DLCPackage.XBlock,GameXblock<T>,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\XBlock\GameXblock.cs,Generate2014,The length of the statement  "                        entity.Properties.Add(new Property2014() { Name = "PreviewSoundBank"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Audio.GetDescription()' TagValue.WwiseSoundBank.GetDescription()' String.Format("song_{0}_preview"' dlcName)) } }); " is 248.
Long Statement,RocksmithToolkitLib.DLCPackage.XBlock,GameXblock<T>,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\XBlock\GameXblock.cs,Generate2014,The length of the statement  "                        inlayEntity.Properties.Add(new Property2014() { Name = "Header"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Database.GetDescription()' TagValue.HsonDB.GetDescription()' String.Format("dlc_{0}"' dlcName)) } }); " is 229.
Long Statement,RocksmithToolkitLib.DLCPackage.XBlock,GameXblock<T>,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\XBlock\GameXblock.cs,Generate2014,The length of the statement  "                        inlayEntity.Properties.Add(new Property2014() { Name = "Header"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Database.GetDescription()' TagValue.HsanDB.GetDescription()' String.Format("dlc_{0}"' dlcName)) } }); " is 229.
Long Statement,RocksmithToolkitLib.DLCPackage.XBlock,GameXblock<T>,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\XBlock\GameXblock.cs,Generate2014,The length of the statement  "                    inlayEntity.Properties.Add(new Property2014() { Name = "Manifest"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Database.GetDescription()' TagValue.JsonDB.GetDescription()' String.Format("dlc_guitar_{0}"' dlcName)) } }); " is 238.
Long Statement,RocksmithToolkitLib.DLCPackage.XBlock,GameXblock<T>,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\XBlock\GameXblock.cs,Generate2014,The length of the statement  "                    inlayEntity.Properties.Add(new Property2014() { Name = "PreviewArt"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Image.GetDescription()' TagValue.DDS.GetDescription()' String.Format("reward_inlay_{0}"' dlcName)) } }); " is 236.
Long Statement,RocksmithToolkitLib.DLCPackage.XBlock,GameXblock<T>,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\XBlock\GameXblock.cs,Generate2014,The length of the statement  "                    inlayEntity.Properties.Add(new Property2014() { Name = "DecorativeInlays"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Application.GetDescription()' TagValue.GamebryoSceneGraph.GetDescription()' dlcName) } }); " is 228.
Long Statement,RocksmithToolkitLib.DLCPackage.XBlock,GameXblock<T>,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\XBlock\GameXblock.cs,Generate,The length of the statement  "            var ent = new Entity() { Id = IdGenerator.Guid().ToString().Replace("-"' "")' Name = "SoundScene0"' Iterations = 1' ModelName = "SoundScene"' Properties = new List<Property>() { CreateMultiItemProperty("SoundBanks"' new string[1] { aggregateGraph.SoundBank.Name + ".bnk" }) } }; " is 278.
Long Statement,RocksmithToolkitLib.DLCPackage.XBlock,GameXblock<T>,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\XBlock\GameXblock.cs,Generate,The length of the statement  "                    addProperty("VocalsAssetId"' entry.VocalsAssetId.Split(new string[1] { "|" }' StringSplitOptions.RemoveEmptyEntries)[0]); " is 121.
Long Statement,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The length of the statement  "            this.lblIconMessage.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) " is 150.
Long Statement,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The length of the statement  "            this.lblIconMessage.Font = new System.Drawing.Font("Microsoft Sans Serif"' 9.75F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 161.
Long Statement,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The length of the statement  "            this.btn3.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right))); " is 143.
Long Statement,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The length of the statement  "            this.btn1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right))); " is 143.
Long Statement,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The length of the statement  "            this.btn2.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right))); " is 143.
Long Statement,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The length of the statement  "            this.lblDialogMessage.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) " is 152.
Long Statement,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The length of the statement  "            this.lblDialogMessage.Font = new System.Drawing.Font("Microsoft Sans Serif"' 9F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 163.
Long Statement,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The length of the statement  "            this.tlpDialog.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) " is 145.
Long Statement,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The length of the statement  "            this.pbLine.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) " is 142.
Long Statement,RocksmithToolkitLib.Extensions,StringExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\StringExtensions.cs,GetValidAtaSpaceName,The length of the statement  "            // may need to be escaped \t\n\f\r#$()*+.?[\^{|  ... '-' needs to be escaped if not at the beginning or end of regex sequence " is 125.
Long Statement,RocksmithToolkitLib.Extensions,StringExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\StringExtensions.cs,GetValidLyric,The length of the statement  "            //!"#$%&'()*+'-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_abcdefghijklmnopqrstuvwxyz{|}~¡¢¥¦§¨ª«°²³´•¸¹º»¼½¾¿ÀÁÂÄÅÆÇÈÉÊËÌÎÏÑÒÓÔÖØÙÚÛÜÞßàáâäåæçèéêëìíîïñòóôöøùúûüŒœŠšž„…€™␀★➨ " is 179.
Long Statement,RocksmithToolkitLib.Extensions,StringExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\StringExtensions.cs,GetValidLyric,The length of the statement  "            string validSpecialCharacters = " !\"#$%&'()*+'-./:;<=>?@[\\]^_{|}~¡¢¥¦§¨ª«°²³´•¸¹º»¼½¾¿ÀÁÂÄÅÆÇÈÉÊËÌÎÏÑÒÓÔÖØÙÚÛÜÞßàáâäåæçèéêëìíîïñòóôöøùúûüŒœŠšž€™␀﻿﻿﻿﻿﻿﻿"; " is 155.
Long Statement,RocksmithToolkitLib.Extensions,StringExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\StringExtensions.cs,GetValidShortFileName,The length of the statement  "                value = String.Format("{0}_{1}_{2}"' artist.GetValidAtaSpaceName()' title.GetValidAtaSpaceName()' version).Replace(" "' "-"); " is 125.
Long Statement,RocksmithToolkitLib.Extensions,StringExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\StringExtensions.cs,GetValidShortFileName,The length of the statement  "                value = String.Format("{0}_{1}_{2}"' artist.GetValidAcronym()' title.GetValidAtaSpaceName()' version).Replace(" "' "-"); " is 120.
Long Statement,RocksmithToolkitLib.Extensions,StringExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\StringExtensions.cs,ObsoleteGetValidName,The length of the statement  "                // may need to be escaped \t\n\f\r#$()*+.?[\^{|  ... '-' needs to be escaped if not at the beginning or end of regex sequence " is 125.
Long Statement,RocksmithToolkitLib.Extensions,StringExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\StringExtensions.cs,ShortWordMover,The length of the statement  "                        value = String.Format("{0}{1}"' value.Substring(shortWord[i].Length' value.Length - shortWord[i].Length)' newEnding[i]).Trim(); " is 127.
Long Statement,RocksmithToolkitLib.Extensions,ExternalApps,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ExternalApps.cs,Png2Dds,The length of the statement  "            var cmdArgs = String.Format(" -file \"{0}\" -prescale {2} {3} -quality_highest -max -dxt5 -nomipmap -alpha -overwrite -output \"{1}\""' sourcePath' destinationPath' xSize' ySize); " is 179.
Long Statement,RocksmithToolkitLib.Extensions,ExternalApps,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ExternalApps.cs,UnpackPsarc,The length of the statement  "            var cmdArgs = String.Format(" --unpack --input=\"{0}\" --platform={2} --version=RS2014 --output=\"{1}\""' sourcePath' destinationPath' targetPlatform); " is 151.
Long Statement,RocksmithToolkitLib.Extensions,ExternalApps,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ExternalApps.cs,RepackPsarc,The length of the statement  "            var cmdArgs = String.Format(" --pack --input=\"{0}\" --platform={2} --version=RS2014 --output=\"{1}\""' sourcePath' destinationPath' targetPlatform); " is 149.
Long Statement,RocksmithToolkitLib.Extensions,ExternalApps,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ExternalApps.cs,Wav2Ogg,The length of the statement  "            var cmdArgs = String.Format(" -q {2} \"{0}\" -o \"{1}\""' sourcePath' destinationPath' Convert.ToString(qualityFactor)); " is 120.
Long Statement,RocksmithToolkitLib.Extensions,ExternalApps,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ExternalApps.cs,Wav2Wem,The length of the statement  "            var cmdArgs = String.Format(" \"{0}\" -GenerateSoundBanks -Platform Windows -Language English(US) -NoWwiseDat -ClearAudioFileCache -Save"' templatePath); " is 153.
Long Statement,RocksmithToolkitLib.Extensions,DirectoryExtension,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\DirectoryExtension.cs,Move,The length of the statement  "            if (String.IsNullOrWhiteSpace(sourceDirName)) { throw new ArgumentNullException("sourceDirName"' "The source directory cannot be null."); } " is 139.
Long Statement,RocksmithToolkitLib.Extensions,DirectoryExtension,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\DirectoryExtension.cs,Move,The length of the statement  "            if (String.IsNullOrWhiteSpace(destDirName)) { throw new ArgumentNullException("destDirName"' "The destination directory cannot be null."); } " is 140.
Long Statement,RocksmithToolkitLib.Extensions,DirectoryExtension,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\DirectoryExtension.cs,Move,The length of the statement  "            if (sourceDirName.Contains(invalidChars)) { throw new ArgumentException("The directory contains invalid path characters."' "sourceDirName"); } " is 142.
Long Statement,RocksmithToolkitLib.Extensions,DirectoryExtension,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\DirectoryExtension.cs,Move,The length of the statement  "            if (destDirName.Contains(invalidChars)) { throw new ArgumentException("The directory contains invalid path characters."' "destDirName"); } " is 138.
Long Statement,RocksmithToolkitLib.Extensions,DirectoryExtension,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\DirectoryExtension.cs,Move,The length of the statement  "            if (!sourceDir.Exists) { throw new DirectoryNotFoundException("The path specified by sourceDirName is invalid: " + sourceDirName); } " is 132.
Long Statement,RocksmithToolkitLib.Extensions,DirectoryExtension,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\DirectoryExtension.cs,RelativeTo,The length of the statement  "            int length = absoluteDirectories.Length < relativeDirectories.Length ? absoluteDirectories.Length : relativeDirectories.Length; " is 127.
Long Statement,RocksmithToolkitLib.Extensions,GeneralExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\GeneralExtension.cs,GetDescription,The length of the statement  "            DescriptionAttribute[] attributes = (DescriptionAttribute[])fi.GetCustomAttributes(typeof(DescriptionAttribute)' false); " is 120.
Long Statement,RocksmithToolkitLib.Ogg,Wwise,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\Wwise.cs,GetWwisePath,The length of the statement  "                throw new FileNotFoundException("Could not find Audiokinetic Wwise installation." + Environment.NewLine + "Please confirm that either Wwise v2013.2.x v2014.1.x 2015.1.x or 2016.2.x series is installed."); " is 204.
Long Statement,RocksmithToolkitLib.Ogg,Wwise,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\Wwise.cs,GetWwisePath,The length of the statement  "                    wwiseCLIPath = Directory.EnumerateFiles(Environment.GetEnvironmentVariable("WWISEROOT")' "WwiseCLI.exe"' SearchOption.AllDirectories); " is 134.
Long Statement,RocksmithToolkitLib.Ogg,Wwise,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\Wwise.cs,GetWwisePath,The length of the statement  "                throw new FileNotFoundException("Could not find WwiseCLI.exe in " + wwiseRoot + Environment.NewLine + "Please confirm that either Wwise v2013.2.x v2014.1.x 2015.1.x or 2016.2.x series is installed."); " is 200.
Long Statement,RocksmithToolkitLib.Ogg,Wwise,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\Wwise.cs,GetWwisePath,The length of the statement  "                Environment.NewLine + "Install supportend Wwise version' which are v2013.2.x || v2014.1.x || v2015.1.x || v2016.2.x series" + " is 125.
Long Statement,RocksmithToolkitLib.Ogg,Wwise,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\Wwise.cs,LoadWwiseTemplate,The length of the statement  "                throw new FileNotFoundException("Could not find Wwise template originals SFX directory.\r\nReinstall CST to fix problem."); " is 123.
Long Statement,RocksmithToolkitLib.Ogg,Wwise,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\Wwise.cs,GetWwiseFiles,The length of the statement  "            //var destPreviewPath = Path.Combine(Path.GetDirectoryName(destinationPath)' Path.GetFileNameWithoutExtension(destinationPath) + "_preview.wem"); " is 145.
Long Statement,RocksmithToolkitLib.Ogg,Wwise,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\Wwise.cs,GetWwiseFiles,The length of the statement  "            var destPreviewPath = string.Format("{0}_preview.wem"' destinationPath.Substring(0' destinationPath.LastIndexOf("."' StringComparison.Ordinal))); " is 145.
Long Statement,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,Revorb,The length of the statement  "                    ww2oggProcess.StartInfo.Arguments = String.Format("\"{0}\" -o \"{1}\" --pcb \"{2}\""' file' outputFileName' codebooks603Path); " is 126.
Long Statement,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,Revorb,The length of the statement  "            if (ww2oggResult.IndexOf("Error "' StringComparison.Ordinal) > -1 || ww2oggResult.IndexOf(" error:"' StringComparison.Ordinal) > -1) " is 132.
Long Statement,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,Revorb,The length of the statement  "                throw new Exception("ww2ogg process error or CDLC file name contains reserved word 'error'." + Environment.NewLine + ww2oggResult); " is 131.
Long Statement,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,Revorb,The length of the statement  "            if (ww2oggResult.IndexOf("Error "' StringComparison.Ordinal) > -1 || ww2oggResult.IndexOf(" error:"' StringComparison.Ordinal) > -1) " is 132.
Long Statement,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,Revorb,The length of the statement  "                throw new Exception("revorb process error or CDLC file name contains reserved word 'error'." + Environment.NewLine + revorbResult); " is 131.
Long Statement,RocksmithToolkitLib.PsarcLoader,Entry,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\Entry.cs,UpdateNameMD5,The length of the statement  "            MD5 = (Name == String.Empty) ? new byte[16] : new MD5CryptoServiceProvider().ComputeHash(Encoding.ASCII.GetBytes(Name)); " is 120.
Long Statement,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,InflateEntry,The length of the statement  "                                    entry.ErrMsg = String.Format(@"{2}CDLC contains a broken datachunk in file '{0}'.{2}Warning: {1}{2}"' entry.Name.Split('/').Last()' ex.Message' Environment.NewLine); " is 165.
Long Statement,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,InflateEntry,The length of the statement  "                    entry.ErrMsg = String.Format(@"{2}CDLC contains a broken datachunk in file '{0}'.{2}Warning: {1}{2}"' entry.Name.Split('/').Last()' ex.Message' Environment.NewLine); " is 165.
Long Statement,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,ParseTOC,The length of the statement  "                _toc.Add(new Entry { Id = i' MD5 = _reader.ReadBytes(16)' zIndexBegin = _reader.ReadUInt32()' Length = _reader.ReadUInt40()' Offset = _reader.ReadUInt40() }); /* FIXME: general idea was to implement parallel inflate route' still need to re-think this. " is 251.
Long Statement,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Read,The length of the statement  "                int tocChunkSize = (int)(_header.NumFiles * _header.TOCEntrySize); //(int)_reader.BaseStream.Position //don't alter this with. causes issues " is 140.
Long Statement,RocksmithToolkitLib.PsarcLoader,PsarcExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PsarcExtensions.cs,TuningStringToName,The length of the statement  "                if ((string)("" + (tuning.Tuning.String0) + (tuning.Tuning.String1) + (tuning.Tuning.String2) + (tuning.Tuning.String3) + (tuning.Tuning.String4) + (tuning.Tuning.String5)) == strings) " is 184.
Long Statement,RocksmithToolkitLib.PsarcLoader,PsarcLoader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PsarcLoader.cs,FullErrorCheck,The length of the statement  "                    using (var reader = new StreamReader(ms' new UTF8Encoding()' false' 65536)) //4Kb is default alloc size for windows .. 64Kb is default PSARC alloc " is 146.
Long Statement,RocksmithToolkitLib.PsarcLoader,PsarcLoader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PsarcLoader.cs,ExtractJsonManifests,The length of the statement  "            var xblockEntries = _archive.TOC.Where(x => x.Name.StartsWith("gamexblocks/nsongs") && x.Name.EndsWith(".xblock")).ToList(); " is 124.
Long Statement,RocksmithToolkitLib.PsarcLoader,PsarcLoader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PsarcLoader.cs,ExtractJsonManifests,The length of the statement  "                var jsonEntries = _archive.TOC.Where(x => x.Name.StartsWith("manifests/songs") && x.Name.EndsWith(".json") && x.Name.Contains(strippedName)).OrderBy(x => x.Name).ToList(); " is 171.
Long Statement,RocksmithToolkitLib.PsarcLoader,PsarcLoader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PsarcLoader.cs,ExtractJsonManifests,The length of the statement  "                    using (var reader = new StreamReader(ms' new UTF8Encoding()' false' 65536)) //4Kb is default alloc size for windows .. 64Kb is default PSARC alloc " is 146.
Long Statement,RocksmithToolkitLib.PsarcLoader,PsarcLoader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PsarcLoader.cs,ExtractJsonManifests,The length of the statement  "            GlobalExtension.ShowProgress(String.Format("{0} parsing json manifest entries took: {1} (msec)"' Path.GetFileName(_filePath)' sw.ElapsedMilliseconds)); " is 151.
Long Statement,RocksmithToolkitLib.PsarcLoader,PsarcLoader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PsarcLoader.cs,ExtractHsanManifest,The length of the statement  "            using (var reader = new StreamReader(ms' new UTF8Encoding()' false' 65536)) //4Kb is default alloc size for windows .. 64Kb is default PSARC alloc " is 146.
Long Statement,RocksmithToolkitLib.PsarcLoader,PsarcLoader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PsarcLoader.cs,ExtractHsanManifest,The length of the statement  "            GlobalExtension.ShowProgress(String.Format("{0} parsing hsan manifest entry took: {1} (msec)"' Path.GetFileName(_filePath)' sw.ElapsedMilliseconds)); " is 149.
Long Statement,RocksmithToolkitLib.PsarcLoader,PsarcLoader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PsarcLoader.cs,ExtractAlbumArt,The length of the statement  "            //    using (var reader = new StreamReader(ms' new UTF8Encoding()' false' 65536)) //4Kb is default alloc size for windows .. 64Kb is default PSARC alloc " is 152.
Long Statement,RocksmithToolkitLib.PsarcLoader,PsarcLoader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PsarcLoader.cs,ExtractAlbumArt,The length of the statement  "            GlobalExtension.ShowProgress(String.Format("{0} parsing albumart entry took: {1} (msec)"' Path.GetFileName(_filePath)' sw.ElapsedMilliseconds)); " is 144.
Long Statement,RocksmithToolkitLib.PsarcLoader,PsarcLoader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PsarcLoader.cs,ConvertWemEntries,The length of the statement  "                        OggFile.Revorb(tempAudioPath' audioOggPath' Path.GetDirectoryName(Application.ExecutablePath)' Path.GetExtension(tempAudioPath).GetWwiseVersion()); " is 147.
Long Statement,RocksmithToolkitLib.PsarcLoader,PsarcLoader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PsarcLoader.cs,ConvertWemEntries,The length of the statement  "                        OggFile.Revorb(tempAudioPath' previewOggPath' Path.GetDirectoryName(Application.ExecutablePath)' Path.GetExtension(tempAudioPath).GetWwiseVersion()); " is 149.
Long Statement,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,Write,The length of the statement  "                    WriteRocksmithSngFile(song' InstrumentTuningExtensions.GetTuningByOffsets(tuning)' arrangementType' outputFile' bitConverter); " is 126.
Long Statement,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithVocalsFile,The length of the statement  "                        throw new InvalidDataException(string.Format("Vocal lyric '{0}' at position {1} exceeded the maximum width of 32 bytes."' lyric' i)); " is 133.
Long Statement,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngSections,The length of the statement  "                    //    throw new Exception(string.Format("No end phrase iteration found with matching time for section {0}."' i.ToString())); " is 124.
Long Statement,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngLevels,The length of the statement  "                    w.Write(notes / count); // This is the number of notes + chords in all iterations of this phrase for this level' divided by number of iterations of this phrase " is 159.
Long Statement,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngLevelAnchors,The length of the statement  "                var chords = (level.Chords == null) ? null : level.Chords.Where(chord => chord.Time >= startTime && chord.Time < endTime); " is 122.
Long Statement,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngLevelAnchors,The length of the statement  "                float lastTime = lastNote == null && lastChord == null ? endTime : Math.Max(lastNote ?? startTime' lastChord ?? startTime); " is 123.
Long Statement,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngLevelHandShapes,The length of the statement  "                var chords = level.Chords == null ? null : level.Chords.Where(chord => chord.Time >= handShape.StartTime && chord.Time < endTime); " is 130.
Long Statement,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngLevelNotes,The length of the statement  "                w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? ((SongNote)notesChords[i].Entity).Ignore : ((SongChord)notesChords[i].Entity).Ignore); " is 148.
Long Statement,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngLevelNotes,The length of the statement  "                    w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? new byte() : (byte)((SongChord)notesChords[i].Entity).HighDensity); " is 129.
Long Statement,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngLevelNotes,The length of the statement  "                    w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? new byte() : ((SongChord)notesChords[i].Entity).HighDensity); " is 123.
Long Statement,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngMetaDetails,The length of the statement  "                    throw new Exception("There is a phrase defined with maxDifficulty=" + iteration.MaxDifficulty + "' but the highest difficulty level is " + (s.Levels.Length - 1)); " is 162.
Long Statement,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngMetaDetails,The length of the statement  "            float firstNote = s.Levels.Min(level => level.Notes == null || level.Notes.Length == 0 ? float.MaxValue : level.Notes.Min(note => note.Time)); " is 142.
Long Statement,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngMetaDetails,The length of the statement  "            float firstChord = s.Levels.Min(level => level.Chords == null || level.Chords.Length == 0 ? float.MaxValue : level.Chords.Min(chord => chord.Time)); " is 148.
Long Statement,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngMetaDetails,The length of the statement  "            w.Write(new byte[4]); // header with repeating array; song works in game if array is defaulted to 0 count so will leave this alone for now " is 138.
Long Statement,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngMetaDetails,The length of the statement  "            // There seems to be 1 entry per letter in the chord templates' although there are songs with chord templates that don't have this section. " is 139.
Long Statement,RocksmithToolkitLib,ToolkitVersionOnline,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\ToolkitVersionOnline.cs,Load,The length of the statement  "                    versionInfoJson = "{\"version\":\"2.7.1.0\"'\"date\":1470934174'\"update\":true'\"commits\":[\"2016-08-11:AppVeyour build failed so recommitting\"'\"2016-08-11: Commit for Beta Version 2.7.1.0\"]'\"revision\":\"7f8f5233\"}"; " is 224.
Long Statement,RocksmithToolkitLib,ToolkitVersion,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\ToolkitVersion.cs,RSTKLibVersion,The length of the statement  "            var assemblyInformationVersion = Assembly.LoadFrom("RocksmithToolkitLib.dll").GetCustomAttributes(typeof(AssemblyInformationalVersionAttribute)' false).Cast<AssemblyInformationalVersionAttribute>().FirstOrDefault().InformationalVersion.ToString(); " is 247.
Long Statement,RocksmithToolkitLib,ToolkitVersion,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\ToolkitVersion.cs,RSTKLibVersion,The length of the statement  "            var assemblyConfiguration = Assembly.LoadFrom("RocksmithToolkitLib.dll").GetCustomAttributes(typeof(AssemblyConfigurationAttribute)' false).Cast<AssemblyConfigurationAttribute>().FirstOrDefault().Configuration.ToString() ?? ""; " is 227.
Long Statement,RocksmithToolkitLib,ToolkitVersion,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\ToolkitVersion.cs,RSTKUpdaterVersion,The length of the statement  "            var assemblyInformationVersion = Assembly.LoadFrom("RocksmithToolkitUpdater.exe").GetCustomAttributes(typeof(AssemblyInformationalVersionAttribute)' false).Cast<AssemblyInformationalVersionAttribute>().FirstOrDefault().InformationalVersion.ToString(); " is 251.
Long Statement,RocksmithToolkitLib,ToolkitVersion,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\ToolkitVersion.cs,RSTKUpdaterVersion,The length of the statement  "            var assemblyConfiguration = Assembly.LoadFrom("RocksmithToolkitUpdater.exe").GetCustomAttributes(typeof(AssemblyConfigurationAttribute)' false).Cast<AssemblyConfigurationAttribute>().FirstOrDefault().Configuration.ToString() ?? ""; " is 231.
Long Statement,RocksmithToolkitLib.DLCPackage.Manifest2014.Tone,ToneDescriptor,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest2014\Tone\ToneDescriptor.cs,List,The length of the statement  "            yield return new ToneDescriptor { Name = "SPECIAL_EFFECT"' ShortName = "sitar"' Descriptor = "$[35750]SPECIAL EFFECT" }; " is 120.
Long Statement,RocksmithToolkitLib.DLCPackage.Manifest2014.Tone,Tone2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest2014\Tone\Tone2014.cs,Import,The length of the statement  "                            throw new NotSupportedException(String.Format("Unknown file extension exception '{0}'. File not supported."' toneExtension)); " is 125.
Long Statement,RocksmithToolkitLib.DLCPackage.Manifest2014.Tone,Tone2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest2014\Tone\Tone2014.cs,ReadFromManifest,The length of the statement  "            Attributes2014 jsonManifestAttributes = Manifest2014<Attributes2014>.LoadFromFile(manifestFilePath).Entries.ToArray()[0].Value.ToArray()[0].Value; " is 146.
Long Statement,RocksmithToolkitLib.DLCPackage.Manifest2014.Tone,Tone2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest2014\Tone\Tone2014.cs,ReadFromManifest,The length of the statement  "            if (jsonManifestAttributes.ArrangementName != ArrangementName.Vocals.ToString() && jsonManifestAttributes.Tones != null) " is 120.
Long Statement,RocksmithToolkitLib.DLCPackage.Manifest2014.Tone,Tone2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest2014\Tone\Tone2014.cs,ReadFromPackage,The length of the statement  "                string tmpDir = Path.Combine(appDir' String.Format("{0}_{1}"' Path.GetFileNameWithoutExtension(packagePath)' platform.platform)); " is 129.
Long Statement,RocksmithToolkitLib.DLCPackage.AggregateGraph2014,AggregateGraph2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph2014\AggregateGraph2014.cs,SongAggregateGraph,The length of the statement  "                var name = String.Format(NAME_ARRANGEMENT' dlcName' songPartition.GetArrangementFileName(arrangement.Name' arrangement.ArrangementType).ToLower()); " is 147.
Long Statement,RocksmithToolkitLib.DLCPackage.AggregateGraph2014,AggregateGraph2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph2014\AggregateGraph2014.cs,SongAggregateGraph,The length of the statement  "                json.Canonical = currentPlatform.IsConsole ? CANONICAL_MANIFEST_CONSOLE : String.Format(CANONICAL_MANIFEST_PC' dlcName); " is 120.
Long Statement,RocksmithToolkitLib.DLCPackage.AggregateGraph2014,AggregateGraph2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph2014\AggregateGraph2014.cs,InlayAggregateGraph,The length of the statement  "            json.Canonical = currentPlatform.IsConsole ? CANONICAL_MANIFEST_CONSOLE : String.Format(CANONICAL_MANIFEST_PC' dlcName); " is 120.
Long Statement,RocksmithToolkitLib.DLCPackage.AggregateGraph2014,AggregateGraph2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph2014\AggregateGraph2014.cs,DoLikeSongPack,The length of the statement  "                            Debug.WriteLine(String.Format("Arrangement file '{0}' => {1}"' Path.GetFileNameWithoutExtension(xml)' "DDC ended with system error " + consoleOutput)); " is 151.
Long Statement,RocksmithToolkitLib.DLCPackage.AggregateGraph2014,AggregateGraph2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph2014\AggregateGraph2014.cs,DoLikeSongPack,The length of the statement  "                            Debug.WriteLine(String.Format("Arrangement file '{0}' => {1}"' Path.GetFileNameWithoutExtension(xml)' "DDC ended with application error " + consoleOutput)); " is 156.
Long Statement,RocksmithToolkitLib.DLCPackage.AggregateGraph2014,GraphPart,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph2014\GraphPart.cs,SingleByValue,The length of the statement  "            return graphPartList.SingleOrDefault<GraphPart>(g => g.Type == String.Format(TYPE_TEMPLATE' "tag") && g.Value == String.Format(VALUE_TEMPLATE' value)); " is 151.
Long Statement,RocksmithToolkitLib.DLCPackage.AggregateGraph2014,GraphPart,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph2014\GraphPart.cs,WhereByValue,The length of the statement  "            return graphPartList.Where<GraphPart>(g => g.Type == String.Format(TYPE_TEMPLATE' "tag") && g.Value == String.Format(VALUE_TEMPLATE' value)).ToList<GraphPart>(); " is 161.
Long Statement,RocksmithToolkitLib.DLCPackage.AggregateGraph,AggregateGraph,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph\AggregateGraph.cs,Write,The length of the statement  "                writer.WriteLine("<urn:uuid:{0}> <http://emergent.net/aweb/1.0/canonical> \"/GRExports/{1}\"."' x.UUID' platformPathNames[1]); " is 126.
Long Statement,RocksmithToolkitLib.DLCPackage.AggregateGraph,AggregateGraph,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph\AggregateGraph.cs,Write,The length of the statement  "            writer.WriteLine("<urn:uuid:{0}> <http://emergent.net/aweb/1.0/canonical> \"/Audio/{1}\"."' SoundBank.UUID' platformPathNames[0]); " is 130.
Long Statement,RocksmithToolkitLib.DLCPackage.AggregateGraph,AggregateGraph,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph\AggregateGraph.cs,Write,The length of the statement  "                writer.WriteLine("<urn:uuid:{0}> <http://emergent.net/aweb/1.0/relpath> \"/ContentMounts/{1}/GRExports/{2}/{3}.sng\"."' x.UUID' dlcName' platformPathNames[1]' x.Name); " is 167.
Long Statement,RocksmithToolkitLib.DLCPackage.AggregateGraph,AggregateGraph,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph\AggregateGraph.cs,Write,The length of the statement  "                writer.WriteLine("<urn:uuid:{0}> <http://emergent.net/aweb/1.0/relpath> \"/ContentMounts/{1}/GR/Behaviors/Songs/{2}.xml\"."' x.UUID' dlcName' x.Name); " is 150.
Long Statement,RocksmithToolkitLib.DLCPackage.AggregateGraph,AggregateGraph,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph\AggregateGraph.cs,Write,The length of the statement  "            writer.WriteLine("<urn:uuid:{0}> <http://emergent.net/aweb/1.0/relpath> \"/ContentMounts/{1}/GRAssets/AlbumArt/{2}.dds\"."' AlbumArt.UUID' dlcName' AlbumArt.Name); " is 163.
Long Statement,RocksmithToolkitLib.DLCPackage.AggregateGraph,AggregateGraph,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph\AggregateGraph.cs,Write,The length of the statement  "            writer.WriteLine("<urn:uuid:{0}> <http://emergent.net/aweb/1.0/relpath> \"/ContentMounts/{1}/Audio/{2}/{3}.bnk\"."' SoundBank.UUID' dlcName' platformPathNames[0]' SoundBank.Name); " is 179.
Long Statement,RocksmithToolkitLib.DLCPackage.AggregateGraph,AggregateGraph,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph\AggregateGraph.cs,Write,The length of the statement  "            writer.WriteLine("<urn:uuid:{0}> <http://emergent.net/aweb/1.0/relpath> \"/ContentMounts/{1}/Exports/Songs/{2}.xblock\"."' XBlock.UUID' dlcName' XBlock.Name); " is 158.
Long Statement,RocksmithToolkitLib.DLCPackage.AggregateGraph,AggregateGraph,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph\AggregateGraph.cs,Write,The length of the statement  "                writer.WriteLine("<urn:uuid:{0}> <http://emergent.net/aweb/1.0/logpath> \"/grexports/{1}.sng\"."' x.UUID' x.Name.ToLower()); " is 124.
Long Statement,RocksmithToolkitLib.DLCPackage.AggregateGraph,AggregateGraph,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph\AggregateGraph.cs,Write,The length of the statement  "                writer.WriteLine("<urn:uuid:{0}> <http://emergent.net/aweb/1.0/logpath> \"/gr/behaviors/songs/{1}.xml\"."' x.UUID' x.Name.ToLower()); " is 133.
Long Statement,RocksmithToolkitLib.DLCPackage.AggregateGraph,AggregateGraph,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph\AggregateGraph.cs,Write,The length of the statement  "            writer.WriteLine("<urn:uuid:{0}> <http://emergent.net/aweb/1.0/logpath> \"/grassets/albumart/{1}.dds\"."' AlbumArt.UUID' AlbumArt.Name.ToLower()); " is 146.
Long Statement,RocksmithToolkitLib.DLCPackage.AggregateGraph,AggregateGraph,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph\AggregateGraph.cs,Write,The length of the statement  "            writer.WriteLine("<urn:uuid:{0}> <http://emergent.net/aweb/1.0/logpath> \"/audio/{1}/{2}.bnk\"."' SoundBank.UUID' platformPathNames[0].ToLower()' SoundBank.Name.ToLower()); " is 172.
Long Statement,RocksmithToolkitLib.DLCPackage.AggregateGraph,AggregateGraph,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph\AggregateGraph.cs,ReadFromFile,The length of the statement  "            //<urn:uuid:5394311c-b576-4a65-9d0a-f5737d270c63> <http://emergent.net/aweb/1.0/llid> "292f0d67-0000-0000-0000-000000000000". " is 125.
Long Statement,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,InflateEntry,The length of the statement  "                                    ErrMSG = String.Format(@"{2}CDLC contains a broken datachunk in file '{0}'.{2}Warning: {1}{2}"' entry.Name.Split('/').Last()' ex.Message' Environment.NewLine); " is 159.
Long Statement,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,InflateEntry,The length of the statement  "                    ErrMSG = String.Format(@"{2}CDLC contains a broken datachunk in file '{0}'.{2}Warning: {1}{2}"' entry.Name.Split('/').Last()' ex.Message' Environment.NewLine); " is 159.
Long Statement,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Read,The length of the statement  "                int tocChunkSize = (int)(_header.NumFiles * _header.TOCEntrySize);//(int)_reader.BaseStream.Position //don't alter this with. causes issues " is 139.
Long Statement,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseMetadata,The length of the statement  "            sng.Metadata.MaxNotesAndChords_Real = sng.Metadata.MaxNotesAndChords - getIngoreCount(xml); //num "unique notes - ignored" " is 122.
Long Statement,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseTones,The length of the statement  "                    throw new InvalidDataException("There is tone name error in XML Arrangement: " + xml.Arrangement + "  " + tn.Name + " is not properly defined." + Environment.NewLine +  " is 167.
Long Statement,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseArrangements,The length of the statement  "                    var prev = a.Notes.Notes[j - prvnote]; //this will be either the first note of piter' or the last note on the same string at previous timestamp " is 143.
Long Statement,RocksmithToolkitLib.Sng2014HSL,BpmSection,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The length of the statement  "                throw new Exception("Corrupt CDLC ... Regenerating or Converting the original with Creator GUI may fix it." + Environment.NewLine + "Make sure the song information is complete and correct' including Song Year and Avg Tempo information. (HINT)" + Environment.NewLine + ex.Message + Environment.NewLine + Environment.NewLine); " is 324.
Long Statement,RocksmithToolkitLib.Sng2014HSL,BendData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The length of the statement  "            BendData32 = new BendData32[32]; for (int i = 0; i < 32; i++) { var obj = new BendData32(); obj.read(r); BendData32[i] = obj; } " is 127.
Long Statement,RocksmithToolkitLib.Sng2014HSL,BendDataSection,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The length of the statement  "            BendData = new BendData32[Count]; for (int i = 0; i < Count; i++) { var obj = new BendData32(); obj.read(r); BendData[i] = obj; } " is 129.
Long Statement,RocksmithToolkitLib.Sng2014HSL,ChordNotesSection,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The length of the statement  "            ChordNotes = new ChordNotes[Count]; for (int i = 0; i < Count; i++) { var obj = new ChordNotes(); obj.read(r); ChordNotes[i] = obj; } " is 133.
Long Statement,RocksmithToolkitLib.Sng2014HSL,SymbolsHeaderSection,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The length of the statement  "            SymbolsHeader = new SymbolsHeader[Count]; for (int i = 0; i < Count; i++) { var obj = new SymbolsHeader(); obj.read(r); SymbolsHeader[i] = obj; } " is 145.
Long Statement,RocksmithToolkitLib.Sng2014HSL,SymbolsTextureSection,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The length of the statement  "            SymbolsTextures = new SymbolsTexture[Count]; for (int i = 0; i < Count; i++) { var obj = new SymbolsTexture(); obj.read(r); SymbolsTextures[i] = obj; } " is 151.
Long Statement,RocksmithToolkitLib.Sng2014HSL,SymbolDefinitionSection,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The length of the statement  "            SymbolDefinitions = new SymbolDefinition[Count]; for (int i = 0; i < Count; i++) { var obj = new SymbolDefinition(); obj.read(r); SymbolDefinitions[i] = obj; } " is 159.
Long Statement,RocksmithToolkitLib.Sng2014HSL,PhraseIterationSection,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The length of the statement  "            PhraseIterations = new PhraseIteration[Count]; for (int i = 0; i < Count; i++) { var obj = new PhraseIteration(); obj.read(r); PhraseIterations[i] = obj; } " is 155.
Long Statement,RocksmithToolkitLib.Sng2014HSL,PhraseExtraInfoByLevelSection,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The length of the statement  "            PhraseExtraInfoByLevel = new PhraseExtraInfoByLevel[Count]; for (int i = 0; i < Count; i++) { var obj = new PhraseExtraInfoByLevel(); obj.read(r); PhraseExtraInfoByLevel[i] = obj; } " is 181.
Long Statement,RocksmithToolkitLib.Sng2014HSL,NLinkedDifficultySection,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The length of the statement  "            NLinkedDifficulties = new NLinkedDifficulty[Count]; for (int i = 0; i < Count; i++) { var obj = new NLinkedDifficulty(); obj.read(r); NLinkedDifficulties[i] = obj; } " is 165.
Long Statement,RocksmithToolkitLib.Sng2014HSL,SectionSection,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The length of the statement  "            Sections = new Section[Count]; for (int i = 0; i < Count; i++) { var obj = new Section(); obj.read(r); Sections[i] = obj; } " is 123.
Long Statement,RocksmithToolkitLib.Sng2014HSL,AnchorExtensionSection,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The length of the statement  "            AnchorExtensions = new AnchorExtension[Count]; for (int i = 0; i < Count; i++) { var obj = new AnchorExtension(); obj.read(r); AnchorExtensions[i] = obj; } " is 155.
Long Statement,RocksmithToolkitLib.Sng2014HSL,FingerprintSection,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The length of the statement  "            Fingerprints = new Fingerprint[Count]; for (int i = 0; i < Count; i++) { var obj = new Fingerprint(); obj.read(r); Fingerprints[i] = obj; } " is 139.
Long Statement,RocksmithToolkitLib.Sng2014HSL,Arrangement,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The length of the statement  "            AverageNotesPerIteration = new float[PhraseCount]; for (int i = 0; i < PhraseCount; i++) AverageNotesPerIteration[i] = r.ReadSingle(); " is 134.
Long Statement,RocksmithToolkitLib.Sng2014HSL,Arrangement,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The length of the statement  "            NotesInIteration1 = new Int32[PhraseIterationCount1]; for (int i = 0; i < PhraseIterationCount1; i++) NotesInIteration1[i] = r.ReadInt32(); " is 139.
Long Statement,RocksmithToolkitLib.Sng2014HSL,Arrangement,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The length of the statement  "            NotesInIteration2 = new Int32[PhraseIterationCount2]; for (int i = 0; i < PhraseIterationCount2; i++) NotesInIteration2[i] = r.ReadInt32(); " is 139.
Long Statement,RocksmithToolkitLib.Sng2014HSL,ArrangementSection,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The length of the statement  "            Arrangements = new Arrangement[Count]; for (int i = 0; i < Count; i++) { var obj = new Arrangement(); obj.read(r); Arrangements[i] = obj; } " is 139.
Long Statement,RocksmithToolkitLib.ToolkitTone,ToolkitPedal,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\ToolkitTone\ToolkitPedal.cs,LoadFromResource,The length of the statement  "            var pedalsJson = Encoding.ASCII.GetString((gameVersion != GameVersion.RS2012) ? Properties.Resources.pedals2014 : Properties.Resources.pedals); " is 143.
Complex Conditional,RocksmithToolkitLib.DLCPackage,Arrangement,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Arrangement.cs,Arrangement,The conditional expression  "attr.Tone_A != null || attr.Tone_B != null || attr.Tone_C != null || attr.Tone_D != null"  is complex.
Complex Conditional,RocksmithToolkitLib.SngToTab,TabMeasure,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\TabMeasure.cs,GetLines,The conditional expression  "i != 0 && slotIsNote[i] && slotIsNote[i - 1] && nextSlots[i] == nextSlots[i - 1]"  is complex.
Complex Conditional,RocksmithToolkitLib.DLCPackage.Manifest.Tone,Tone,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Tone\Tone.cs,Transform,The conditional expression  "name.Equals("Pedal") && num == 1 && !Keys.Contains("Amp") && !Keys.Contains("Cabinet") && !Keys.Contains("PostPedal2")"  is complex.
Complex Conditional,RocksmithToolkitLib.DLCPackage.Manifest.Tone,Tone,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Tone\Tone.cs,Transform,The conditional expression  "name.Equals("Pedal") && num == 2 && !Keys.Contains("Amp") && !Keys.Contains("Cabinet") && !Keys.Contains("PostPedal1")"  is complex.
Complex Conditional,RocksmithToolkitLib.DLCPackage.Manifest.Tone,Tone,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Tone\Tone.cs,Transform,The conditional expression  "name.Equals("Pedal") && num >= 1 && !Keys.Contains("Amp") && Keys.Contains("Cabinet") && !Keys.Contains("LoopPedal3")"  is complex.
Complex Conditional,RocksmithToolkitLib.DLCPackage.Manifest.Tone,Tone,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Tone\Tone.cs,Transform,The conditional expression  "name.Equals("Pedal") && num >= 2 && !Keys.Contains("Amp") && Keys.Contains("Cabinet") && !Keys.Contains("LoopPedal2")"  is complex.
Complex Conditional,RocksmithToolkitLib.DLCPackage.Manifest.Tone,Tone,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Tone\Tone.cs,Transform,The conditional expression  "name.Equals("Pedal") && num >= 3 && !Keys.Contains("Amp") && Keys.Contains("Cabinet") && !Keys.Contains("LoopPedal1")"  is complex.
Complex Conditional,RocksmithToolkitLib.DLCPackage.Manifest.Tone,Tone,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Tone\Tone.cs,Transform,The conditional expression  "name.Equals("Pedal") && num >= 2 && Keys.Contains("Cabinet") && Keys.Contains("Amp") && !Keys.Contains("PrePedal3")"  is complex.
Complex Conditional,RocksmithToolkitLib.DLCPackage.Manifest.Tone,Tone,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Tone\Tone.cs,Transform,The conditional expression  "name.Equals("Pedal") && num >= 3 && Keys.Contains("Cabinet") && Keys.Contains("Amp") && !Keys.Contains("PrePedal2")"  is complex.
Complex Conditional,RocksmithToolkitLib.DLCPackage.Manifest.Tone,Tone,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Tone\Tone.cs,Transform,The conditional expression  "name.Equals("Pedal") && num >= 4 && Keys.Contains("Cabinet") && Keys.Contains("Amp") && !Keys.Contains("PrePedal1")"  is complex.
Complex Conditional,RocksmithToolkitLib.XmlRepository,TuningDefinition,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XmlRepository\TuningDefinition.cs,GetTuningFamily,The conditional expression  "t[1] != t[2] || t[2] != t[3] || t[3] != t[4] || t[4] != t[5]"  is complex.
Complex Conditional,RocksmithToolkitLib.XmlRepository,TuningDefinition,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XmlRepository\TuningDefinition.cs,TuningToName,The conditional expression  "tuning.Tuning.String0 == songTuning.String0 &&                      tuning.Tuning.String1 == songTuning.String1 &&                      tuning.Tuning.String2 == songTuning.String2 &&                      tuning.Tuning.String3 == songTuning.String3 &&                      tuning.Tuning.String4 == songTuning.String4 &&                      tuning.Tuning.String5 == songTuning.String5"  is complex.
Complex Conditional,RocksmithToolkitLib.XmlRepository,TuningDefinition,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XmlRepository\TuningDefinition.cs,TuningToName,The conditional expression  "tuning.Tuning.String0 == songTuning.String0 &&                      tuning.Tuning.String1 == songTuning.String1 &&                      tuning.Tuning.String2 == songTuning.String2 &&                      tuning.Tuning.String3 == songTuning.String3 &&                      tuning.Tuning.String4 == songTuning.String4 &&                      tuning.Tuning.String5 == songTuning.String5"  is complex.
Complex Conditional,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,AdjustShowlights,The conditional expression  "(showlightList[i].Note > -1 && showlightList[i].Note < 24) ||                          (showlightList[i].Note > 35 && showlightList[i].Note < 42) ||                          (showlightList[i].Note > 42 && showlightList[i].Note < 48) ||                          (showlightList[i].Note > 59 && showlightList[i].Note < 66) ||                          (showlightList[i].Note > 67 && showlightList[i].Note < 128)"  is complex.
Complex Conditional,RocksmithToolkitLib.XML,SongChord2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,ParseChordNotes,The conditional expression  "(chordNotes != null && chordNotes.NoteMask[i] != 0) || //notes with techniques                      (chordNotes == null && template.Frets[i] != 255)"  is complex.
Complex Conditional,RocksmithToolkitLib.Extensions,StringExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\StringExtensions.cs,StripPlatformEndName,The conditional expression  "filePath.EndsWith(GamePlatform.Pc.GetPathName()[2]) ||                 filePath.EndsWith(GamePlatform.Mac.GetPathName()[2]) ||                 filePath.EndsWith(GamePlatform.XBox360.GetPathName()[2]) ||                 filePath.EndsWith(GamePlatform.PS3.GetPathName()[2]) ||                 filePath.EndsWith(GamePlatform.PS3.GetPathName()[2] + ".psarc")"  is complex.
Complex Conditional,RocksmithToolkitLib.PsarcLoader,PsarcExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PsarcExtensions.cs,TuningToName,The conditional expression  "tuning.Tuning.String0 == songTuning.String0 &&                      tuning.Tuning.String1 == songTuning.String1 &&                      tuning.Tuning.String2 == songTuning.String2 &&                      tuning.Tuning.String3 == songTuning.String3 &&                      tuning.Tuning.String4 == songTuning.String4 &&                      tuning.Tuning.String5 == songTuning.String5"  is complex.
Complex Conditional,RocksmithToolkitLib,ToolkitVersionOnline,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\ToolkitVersionOnline.cs,Load,The conditional expression  "(!useBeta && ToolkitVersion.AssemblyConfiguration == "BETA") ||                           (useBeta && ToolkitVersion.AssemblyConfiguration != "BETA") ||                           (String.IsNullOrEmpty(toolkitVersionOnline.Revision) &&                           !toolkitVersionOnline.UpdateAvailable)"  is complex.
Complex Conditional,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,GetMidiNote,The conditional expression  "capo > 0 && fret != 0 && (!template && fret < capo)"  is complex.
Complex Conditional,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,numberNotes,The conditional expression  "(current.ChordId == -1 && notes[i].FretId == current.FretId) ||                          (current.ChordId != -1 && notes[i].ChordId == current.ChordId)"  is complex.
Virtual Method Call from Constructor,RocksmithToolkitLib.SngToTab,TabFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\TabFile.cs,TabFile,The constructor "TabFile" calls a virtual method "Apply".
Empty Catch Block,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,DeleteTmpFiles,The method has an empty catch block.
Empty Catch Block,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GeneratePsarcsForRS1,The method has an empty catch block.
Empty Catch Block,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,RS1LoadFromFolder,The method has an empty catch block.
Empty Catch Block,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,CleanCache,The method has an empty catch block.
Empty Catch Block,RocksmithToolkitLib.Extensions,DirectoryExtension,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\DirectoryExtension.cs,SafeDelete,The method has an empty catch block.
Empty Catch Block,RocksmithToolkitLib.DLCPackage.Manifest.Functions,ManifestFunctions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Functions\ManifestFunctions.cs,GenerateSectionData,The method has an empty catch block.
Empty Catch Block,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,ReadSong,The method has an empty catch block.
Magic Number,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,SongToSong2014,The following statement contains a magic number: rsSong2014.ArrangementProperties.RouteMask = rsSong.Arrangement.ToLower().Contains("lead") ? 1                  : (rsSong.Arrangement.ToLower().Contains("rhythm") ? 2                  : (rsSong.Arrangement.ToLower().Contains("combo") ? 2 // may not always be true                   : (rsSong.Arrangement.ToLower().Contains("bass") ? 4 : 1)));
Magic Number,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,SongToSong2014,The following statement contains a magic number: rsSong2014.ArrangementProperties.RouteMask = rsSong.Arrangement.ToLower().Contains("lead") ? 1                  : (rsSong.Arrangement.ToLower().Contains("rhythm") ? 2                  : (rsSong.Arrangement.ToLower().Contains("combo") ? 2 // may not always be true                   : (rsSong.Arrangement.ToLower().Contains("bass") ? 4 : 1)));
Magic Number,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,SongToSong2014,The following statement contains a magic number: rsSong2014.ArrangementProperties.RouteMask = rsSong.Arrangement.ToLower().Contains("lead") ? 1                  : (rsSong.Arrangement.ToLower().Contains("rhythm") ? 2                  : (rsSong.Arrangement.ToLower().Contains("combo") ? 2 // may not always be true                   : (rsSong.Arrangement.ToLower().Contains("bass") ? 4 : 1)));
Magic Number,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,SongToSong2014,The following statement contains a magic number: foreach (var section in rsSong2014.Sections)              {                  foreach (var ebeat in rsSong2014.Ebeats)                  {                      // save Ebeats first beat of measure time                      if (ebeat.Measure != -1)                          fbomTime = ebeat.Time;                      else                          nfbomTime = ebeat.Time;                        if (section.Name.ToLower().Contains("noguitar") && Math.Abs(ebeat.Time - section.StartTime) < 0.001)                      {                          // CRITICAL - fix Section noguitar time (matches EOF output)                          if (ebeat.Measure != -1)                          {                              section.StartTime = nfbomTime;                              Console.WriteLine("Applied fix to RS1->RS2 Section StartTime for: " + section.Name);                          }                            break;                      }                        // found a valid Section time                      if (ebeat.Measure != -1 && Math.Abs(ebeat.Time - section.StartTime) < 0.001)                          break;                        // fix invalid Section time                      if (ebeat.Measure == -1 && ebeat.Time > section.StartTime)                      {                          section.StartTime = fbomTime;                          Console.WriteLine("Applied fix to RS1->RS2 Section StartTime for: " + section.Name);                          break;                      }                  }              }
Magic Number,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,SongToSong2014,The following statement contains a magic number: foreach (var section in rsSong2014.Sections)              {                  foreach (var ebeat in rsSong2014.Ebeats)                  {                      // save Ebeats first beat of measure time                      if (ebeat.Measure != -1)                          fbomTime = ebeat.Time;                      else                          nfbomTime = ebeat.Time;                        if (section.Name.ToLower().Contains("noguitar") && Math.Abs(ebeat.Time - section.StartTime) < 0.001)                      {                          // CRITICAL - fix Section noguitar time (matches EOF output)                          if (ebeat.Measure != -1)                          {                              section.StartTime = nfbomTime;                              Console.WriteLine("Applied fix to RS1->RS2 Section StartTime for: " + section.Name);                          }                            break;                      }                        // found a valid Section time                      if (ebeat.Measure != -1 && Math.Abs(ebeat.Time - section.StartTime) < 0.001)                          break;                        // fix invalid Section time                      if (ebeat.Measure == -1 && ebeat.Time > section.StartTime)                      {                          section.StartTime = fbomTime;                          Console.WriteLine("Applied fix to RS1->RS2 Section StartTime for: " + section.Name);                          break;                      }                  }              }
Magic Number,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,AverageBPM,The following statement contains a magic number: float endTimeMins = rsSong.Ebeats[rsSong.Ebeats.Length - 1].Time / 60;
Magic Number,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,ConvertLevels,The following statement contains a magic number: foreach (var songLevel in rsSong.Levels)              {                  var anchors = new List<SongAnchor2014>();                  var notes = new List<SongNote2014>();                  var chords = new List<SongChord2014>();                  var handShapes = new List<SongHandShape>();                    for (int anchorIndex = 0; anchorIndex < songLevel.Anchors.Length; anchorIndex++)                  {                      var anchor = songLevel.Anchors[anchorIndex];                      anchors.Add(new SongAnchor2014 { Fret = anchor.Fret' Time = anchor.Time' Width = 4 });                  }                    for (int noteIndex = 0; noteIndex < songLevel.Notes.Length; noteIndex++)                  {                      var songNote = songLevel.Notes[noteIndex];                      notes.Add(GetNoteInfo(songNote));                  }                    for (int chordIndex = 0; chordIndex < songLevel.Chords.Length; chordIndex++)                  {                      // RS1 does not contain chordNotes so need to make them from chordtemplate                      List<SongNote2014> chordNotes = new List<SongNote2014>();                      var zChord = songLevel.Chords[chordIndex];                      var zChordId = zChord.ChordId;                      var zChordTemplate = rsSong.ChordTemplates[zChordId];                        // this is ok no code crash                      //if (String.IsNullOrEmpty(zChordTemplate.ChordName))                      //    continue;                        if (zChordTemplate.Finger0 != -1) // finger > -1 is a string played                          chordNotes.Add(DecodeChordTemplate(zChord' 0' zChordTemplate.Fret0));                        if (zChordTemplate.Finger1 != -1)                          chordNotes.Add(DecodeChordTemplate(zChord' 1' zChordTemplate.Fret1));                        if (zChordTemplate.Finger2 != -1)                          chordNotes.Add(DecodeChordTemplate(zChord' 2' zChordTemplate.Fret2));                        if (zChordTemplate.Finger3 != -1)                          chordNotes.Add(DecodeChordTemplate(zChord' 3' zChordTemplate.Fret3));                        if (zChordTemplate.Finger4 != -1)                          chordNotes.Add(DecodeChordTemplate(zChord' 4' zChordTemplate.Fret4));                        if (zChordTemplate.Finger5 != -1)                          chordNotes.Add(DecodeChordTemplate(zChord' 5' zChordTemplate.Fret5));                        if (chordNotes.Any())                      {                          chords.Add(new SongChord2014 { ChordId = zChord.ChordId' ChordNotes = chordNotes.ToArray()' HighDensity = zChord.HighDensity' Ignore = zChord.Ignore' Strum = zChord.Strum' Time = zChord.Time });                          // add chordNotes to songNotes for compatibility                          notes.AddRange(chordNotes);                      }                  }                    // tested ... not the source of game hangs                  // get rid of duplicate notes if any                  // notes = notes.Distinct().ToList();                    for (int shapeIndex = 0; shapeIndex < songLevel.HandShapes.Length; shapeIndex++)                  {                      var handshape = songLevel.HandShapes[shapeIndex];                      handShapes.Add(new SongHandShape { ChordId = handshape.ChordId' EndTime = handshape.EndTime' StartTime = handshape.StartTime });                  }                    levels.Add(new SongLevel2014 { Anchors = anchors.ToArray()' Chords = chords.ToArray()' Difficulty = songLevel.Difficulty' HandShapes = handShapes.ToArray()' Notes = notes.ToArray() });              }
Magic Number,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,ConvertLevels,The following statement contains a magic number: foreach (var songLevel in rsSong.Levels)              {                  var anchors = new List<SongAnchor2014>();                  var notes = new List<SongNote2014>();                  var chords = new List<SongChord2014>();                  var handShapes = new List<SongHandShape>();                    for (int anchorIndex = 0; anchorIndex < songLevel.Anchors.Length; anchorIndex++)                  {                      var anchor = songLevel.Anchors[anchorIndex];                      anchors.Add(new SongAnchor2014 { Fret = anchor.Fret' Time = anchor.Time' Width = 4 });                  }                    for (int noteIndex = 0; noteIndex < songLevel.Notes.Length; noteIndex++)                  {                      var songNote = songLevel.Notes[noteIndex];                      notes.Add(GetNoteInfo(songNote));                  }                    for (int chordIndex = 0; chordIndex < songLevel.Chords.Length; chordIndex++)                  {                      // RS1 does not contain chordNotes so need to make them from chordtemplate                      List<SongNote2014> chordNotes = new List<SongNote2014>();                      var zChord = songLevel.Chords[chordIndex];                      var zChordId = zChord.ChordId;                      var zChordTemplate = rsSong.ChordTemplates[zChordId];                        // this is ok no code crash                      //if (String.IsNullOrEmpty(zChordTemplate.ChordName))                      //    continue;                        if (zChordTemplate.Finger0 != -1) // finger > -1 is a string played                          chordNotes.Add(DecodeChordTemplate(zChord' 0' zChordTemplate.Fret0));                        if (zChordTemplate.Finger1 != -1)                          chordNotes.Add(DecodeChordTemplate(zChord' 1' zChordTemplate.Fret1));                        if (zChordTemplate.Finger2 != -1)                          chordNotes.Add(DecodeChordTemplate(zChord' 2' zChordTemplate.Fret2));                        if (zChordTemplate.Finger3 != -1)                          chordNotes.Add(DecodeChordTemplate(zChord' 3' zChordTemplate.Fret3));                        if (zChordTemplate.Finger4 != -1)                          chordNotes.Add(DecodeChordTemplate(zChord' 4' zChordTemplate.Fret4));                        if (zChordTemplate.Finger5 != -1)                          chordNotes.Add(DecodeChordTemplate(zChord' 5' zChordTemplate.Fret5));                        if (chordNotes.Any())                      {                          chords.Add(new SongChord2014 { ChordId = zChord.ChordId' ChordNotes = chordNotes.ToArray()' HighDensity = zChord.HighDensity' Ignore = zChord.Ignore' Strum = zChord.Strum' Time = zChord.Time });                          // add chordNotes to songNotes for compatibility                          notes.AddRange(chordNotes);                      }                  }                    // tested ... not the source of game hangs                  // get rid of duplicate notes if any                  // notes = notes.Distinct().ToList();                    for (int shapeIndex = 0; shapeIndex < songLevel.HandShapes.Length; shapeIndex++)                  {                      var handshape = songLevel.HandShapes[shapeIndex];                      handShapes.Add(new SongHandShape { ChordId = handshape.ChordId' EndTime = handshape.EndTime' StartTime = handshape.StartTime });                  }                    levels.Add(new SongLevel2014 { Anchors = anchors.ToArray()' Chords = chords.ToArray()' Difficulty = songLevel.Difficulty' HandShapes = handShapes.ToArray()' Notes = notes.ToArray() });              }
Magic Number,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,ConvertLevels,The following statement contains a magic number: foreach (var songLevel in rsSong.Levels)              {                  var anchors = new List<SongAnchor2014>();                  var notes = new List<SongNote2014>();                  var chords = new List<SongChord2014>();                  var handShapes = new List<SongHandShape>();                    for (int anchorIndex = 0; anchorIndex < songLevel.Anchors.Length; anchorIndex++)                  {                      var anchor = songLevel.Anchors[anchorIndex];                      anchors.Add(new SongAnchor2014 { Fret = anchor.Fret' Time = anchor.Time' Width = 4 });                  }                    for (int noteIndex = 0; noteIndex < songLevel.Notes.Length; noteIndex++)                  {                      var songNote = songLevel.Notes[noteIndex];                      notes.Add(GetNoteInfo(songNote));                  }                    for (int chordIndex = 0; chordIndex < songLevel.Chords.Length; chordIndex++)                  {                      // RS1 does not contain chordNotes so need to make them from chordtemplate                      List<SongNote2014> chordNotes = new List<SongNote2014>();                      var zChord = songLevel.Chords[chordIndex];                      var zChordId = zChord.ChordId;                      var zChordTemplate = rsSong.ChordTemplates[zChordId];                        // this is ok no code crash                      //if (String.IsNullOrEmpty(zChordTemplate.ChordName))                      //    continue;                        if (zChordTemplate.Finger0 != -1) // finger > -1 is a string played                          chordNotes.Add(DecodeChordTemplate(zChord' 0' zChordTemplate.Fret0));                        if (zChordTemplate.Finger1 != -1)                          chordNotes.Add(DecodeChordTemplate(zChord' 1' zChordTemplate.Fret1));                        if (zChordTemplate.Finger2 != -1)                          chordNotes.Add(DecodeChordTemplate(zChord' 2' zChordTemplate.Fret2));                        if (zChordTemplate.Finger3 != -1)                          chordNotes.Add(DecodeChordTemplate(zChord' 3' zChordTemplate.Fret3));                        if (zChordTemplate.Finger4 != -1)                          chordNotes.Add(DecodeChordTemplate(zChord' 4' zChordTemplate.Fret4));                        if (zChordTemplate.Finger5 != -1)                          chordNotes.Add(DecodeChordTemplate(zChord' 5' zChordTemplate.Fret5));                        if (chordNotes.Any())                      {                          chords.Add(new SongChord2014 { ChordId = zChord.ChordId' ChordNotes = chordNotes.ToArray()' HighDensity = zChord.HighDensity' Ignore = zChord.Ignore' Strum = zChord.Strum' Time = zChord.Time });                          // add chordNotes to songNotes for compatibility                          notes.AddRange(chordNotes);                      }                  }                    // tested ... not the source of game hangs                  // get rid of duplicate notes if any                  // notes = notes.Distinct().ToList();                    for (int shapeIndex = 0; shapeIndex < songLevel.HandShapes.Length; shapeIndex++)                  {                      var handshape = songLevel.HandShapes[shapeIndex];                      handShapes.Add(new SongHandShape { ChordId = handshape.ChordId' EndTime = handshape.EndTime' StartTime = handshape.StartTime });                  }                    levels.Add(new SongLevel2014 { Anchors = anchors.ToArray()' Chords = chords.ToArray()' Difficulty = songLevel.Difficulty' HandShapes = handShapes.ToArray()' Notes = notes.ToArray() });              }
Magic Number,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,ConvertLevels,The following statement contains a magic number: foreach (var songLevel in rsSong.Levels)              {                  var anchors = new List<SongAnchor2014>();                  var notes = new List<SongNote2014>();                  var chords = new List<SongChord2014>();                  var handShapes = new List<SongHandShape>();                    for (int anchorIndex = 0; anchorIndex < songLevel.Anchors.Length; anchorIndex++)                  {                      var anchor = songLevel.Anchors[anchorIndex];                      anchors.Add(new SongAnchor2014 { Fret = anchor.Fret' Time = anchor.Time' Width = 4 });                  }                    for (int noteIndex = 0; noteIndex < songLevel.Notes.Length; noteIndex++)                  {                      var songNote = songLevel.Notes[noteIndex];                      notes.Add(GetNoteInfo(songNote));                  }                    for (int chordIndex = 0; chordIndex < songLevel.Chords.Length; chordIndex++)                  {                      // RS1 does not contain chordNotes so need to make them from chordtemplate                      List<SongNote2014> chordNotes = new List<SongNote2014>();                      var zChord = songLevel.Chords[chordIndex];                      var zChordId = zChord.ChordId;                      var zChordTemplate = rsSong.ChordTemplates[zChordId];                        // this is ok no code crash                      //if (String.IsNullOrEmpty(zChordTemplate.ChordName))                      //    continue;                        if (zChordTemplate.Finger0 != -1) // finger > -1 is a string played                          chordNotes.Add(DecodeChordTemplate(zChord' 0' zChordTemplate.Fret0));                        if (zChordTemplate.Finger1 != -1)                          chordNotes.Add(DecodeChordTemplate(zChord' 1' zChordTemplate.Fret1));                        if (zChordTemplate.Finger2 != -1)                          chordNotes.Add(DecodeChordTemplate(zChord' 2' zChordTemplate.Fret2));                        if (zChordTemplate.Finger3 != -1)                          chordNotes.Add(DecodeChordTemplate(zChord' 3' zChordTemplate.Fret3));                        if (zChordTemplate.Finger4 != -1)                          chordNotes.Add(DecodeChordTemplate(zChord' 4' zChordTemplate.Fret4));                        if (zChordTemplate.Finger5 != -1)                          chordNotes.Add(DecodeChordTemplate(zChord' 5' zChordTemplate.Fret5));                        if (chordNotes.Any())                      {                          chords.Add(new SongChord2014 { ChordId = zChord.ChordId' ChordNotes = chordNotes.ToArray()' HighDensity = zChord.HighDensity' Ignore = zChord.Ignore' Strum = zChord.Strum' Time = zChord.Time });                          // add chordNotes to songNotes for compatibility                          notes.AddRange(chordNotes);                      }                  }                    // tested ... not the source of game hangs                  // get rid of duplicate notes if any                  // notes = notes.Distinct().ToList();                    for (int shapeIndex = 0; shapeIndex < songLevel.HandShapes.Length; shapeIndex++)                  {                      var handshape = songLevel.HandShapes[shapeIndex];                      handShapes.Add(new SongHandShape { ChordId = handshape.ChordId' EndTime = handshape.EndTime' StartTime = handshape.StartTime });                  }                    levels.Add(new SongLevel2014 { Anchors = anchors.ToArray()' Chords = chords.ToArray()' Difficulty = songLevel.Difficulty' HandShapes = handShapes.ToArray()' Notes = notes.ToArray() });              }
Magic Number,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,ConvertLevels,The following statement contains a magic number: foreach (var songLevel in rsSong.Levels)              {                  var anchors = new List<SongAnchor2014>();                  var notes = new List<SongNote2014>();                  var chords = new List<SongChord2014>();                  var handShapes = new List<SongHandShape>();                    for (int anchorIndex = 0; anchorIndex < songLevel.Anchors.Length; anchorIndex++)                  {                      var anchor = songLevel.Anchors[anchorIndex];                      anchors.Add(new SongAnchor2014 { Fret = anchor.Fret' Time = anchor.Time' Width = 4 });                  }                    for (int noteIndex = 0; noteIndex < songLevel.Notes.Length; noteIndex++)                  {                      var songNote = songLevel.Notes[noteIndex];                      notes.Add(GetNoteInfo(songNote));                  }                    for (int chordIndex = 0; chordIndex < songLevel.Chords.Length; chordIndex++)                  {                      // RS1 does not contain chordNotes so need to make them from chordtemplate                      List<SongNote2014> chordNotes = new List<SongNote2014>();                      var zChord = songLevel.Chords[chordIndex];                      var zChordId = zChord.ChordId;                      var zChordTemplate = rsSong.ChordTemplates[zChordId];                        // this is ok no code crash                      //if (String.IsNullOrEmpty(zChordTemplate.ChordName))                      //    continue;                        if (zChordTemplate.Finger0 != -1) // finger > -1 is a string played                          chordNotes.Add(DecodeChordTemplate(zChord' 0' zChordTemplate.Fret0));                        if (zChordTemplate.Finger1 != -1)                          chordNotes.Add(DecodeChordTemplate(zChord' 1' zChordTemplate.Fret1));                        if (zChordTemplate.Finger2 != -1)                          chordNotes.Add(DecodeChordTemplate(zChord' 2' zChordTemplate.Fret2));                        if (zChordTemplate.Finger3 != -1)                          chordNotes.Add(DecodeChordTemplate(zChord' 3' zChordTemplate.Fret3));                        if (zChordTemplate.Finger4 != -1)                          chordNotes.Add(DecodeChordTemplate(zChord' 4' zChordTemplate.Fret4));                        if (zChordTemplate.Finger5 != -1)                          chordNotes.Add(DecodeChordTemplate(zChord' 5' zChordTemplate.Fret5));                        if (chordNotes.Any())                      {                          chords.Add(new SongChord2014 { ChordId = zChord.ChordId' ChordNotes = chordNotes.ToArray()' HighDensity = zChord.HighDensity' Ignore = zChord.Ignore' Strum = zChord.Strum' Time = zChord.Time });                          // add chordNotes to songNotes for compatibility                          notes.AddRange(chordNotes);                      }                  }                    // tested ... not the source of game hangs                  // get rid of duplicate notes if any                  // notes = notes.Distinct().ToList();                    for (int shapeIndex = 0; shapeIndex < songLevel.HandShapes.Length; shapeIndex++)                  {                      var handshape = songLevel.HandShapes[shapeIndex];                      handShapes.Add(new SongHandShape { ChordId = handshape.ChordId' EndTime = handshape.EndTime' StartTime = handshape.StartTime });                  }                    levels.Add(new SongLevel2014 { Anchors = anchors.ToArray()' Chords = chords.ToArray()' Difficulty = songLevel.Difficulty' HandShapes = handShapes.ToArray()' Notes = notes.ToArray() });              }
Magic Number,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,GetNoteInfo,The following statement contains a magic number: if (songNote.Bend > 0)              {                  var bendValues = new List<BendValue>();                  // CRITICAL CALCULATION - DO NOT CHANGE - MULTIPLIER VALUE MUST BE 0.3333 TO ACHEIVE PROPER ACCURACY AND MATCH EOF OUTPUT                  bendValues.Add(new BendValue { Step = songNote.Bend' Time = (float)Math.Round((songNote.Sustain * 0.3333 / songNote.Bend) + songNote.Time' 3)' Unk5 = 0 });                  songNote2014.BendValues = bendValues.ToArray();              }
Magic Number,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,GetNoteInfo,The following statement contains a magic number: if (songNote.Bend > 0)              {                  var bendValues = new List<BendValue>();                  // CRITICAL CALCULATION - DO NOT CHANGE - MULTIPLIER VALUE MUST BE 0.3333 TO ACHEIVE PROPER ACCURACY AND MATCH EOF OUTPUT                  bendValues.Add(new BendValue { Step = songNote.Bend' Time = (float)Math.Round((songNote.Sustain * 0.3333 / songNote.Bend) + songNote.Time' 3)' Unk5 = 0 });                  songNote2014.BendValues = bendValues.ToArray();              }
Magic Number,RocksmithToolkitLib.Conversion,Rs2014Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs2014Converter.cs,AddDifferences,The following statement contains a magic number: for (var i = 0; i < rs2014Song.PhraseProperties.Count(); i++)              {                  // TODO: Verify this element accuracy                  if (rs2014Song.PhraseProperties[i].Redundant == 256)                      // there may be a second phraseProperties[].redudant                       rs1Song.PhraseProperties[i].Redundant = 0;              }
Magic Number,RocksmithToolkitLib.DLCPackage,DDCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DDCreator.cs,ApplyDD,The following statement contains a magic number: using (var DDC = new Process())              {                  DDC.StartInfo = startInfo;                  DDC.Start();                  consoleOutput = DDC.StandardOutput.ReadToEnd();                  consoleOutput += DDC.StandardError.ReadToEnd();                  DDC.WaitForExit(1000 * 60 * 15); //wait for 15 minutes' crunchy solution for AV-sandboxing issues                  return DDC.ExitCode;              }
Magic Number,RocksmithToolkitLib.DLCPackage,DDCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DDCreator.cs,ApplyDD,The following statement contains a magic number: using (var DDC = new Process())              {                  DDC.StartInfo = startInfo;                  DDC.Start();                  consoleOutput = DDC.StandardOutput.ReadToEnd();                  consoleOutput += DDC.StandardError.ReadToEnd();                  DDC.WaitForExit(1000 * 60 * 15); //wait for 15 minutes' crunchy solution for AV-sandboxing issues                  return DDC.ExitCode;              }
Magic Number,RocksmithToolkitLib.DLCPackage,DDCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DDCreator.cs,ApplyDD,The following statement contains a magic number: using (var DDC = new Process())              {                  DDC.StartInfo = startInfo;                  DDC.Start();                  consoleOutput = DDC.StandardOutput.ReadToEnd();                  consoleOutput += DDC.StandardError.ReadToEnd();                  DDC.WaitForExit(1000 * 60 * 15); //wait for 15 minutes' crunchy solution for AV-sandboxing issues                  return DDC.ExitCode;              }
Magic Number,RocksmithToolkitLib.DLCPackage,Arrangement,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Arrangement.cs,Arrangement,The following statement contains a magic number: this.ScrollSpeed = Convert.ToInt32(attr.DynamicVisualDensity.Last() * 10);
Magic Number,RocksmithToolkitLib.DLCPackage,Arrangement,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Arrangement.cs,Arrangement,The following statement contains a magic number: if (attr.Tones == null) // RS2012              {                  this.ToneBase = attr.Tone_Base;                    if (attr.Tone_A != null || attr.Tone_B != null || attr.Tone_C != null || attr.Tone_D != null)                      throw new DataException("RS2012 CDLC has extraneous tone data.");              }              else // RS2014 or Converter RS2012              {                  // TODO: optimize using common Arrangment.cs method                  // verify the xml Tone_ exists in tone.manifest.json                  foreach (var jsonTone in attr.Tones)                  {                      if (jsonTone == null)                          continue;                        // fix for tone.id (may not be needed/used by game)                      Int32 toneId = 0;                        // cleanup the xml arrangement file too                      if (jsonTone.Name.ToLower() == attr.Tone_Base.ToLower())                          this.ToneBase = song.ToneBase = attr.Tone_Base;                      if (attr.Tone_A != null && jsonTone.Name.ToLower() == attr.Tone_A.ToLower())                          this.ToneA = song.ToneA = attr.Tone_A;                      if (attr.Tone_B != null && jsonTone.Name.ToLower() == attr.Tone_B.ToLower())                      {                          this.ToneB = song.ToneB = attr.Tone_B;                          toneId = 1;                      }                      if (attr.Tone_C != null && jsonTone.Name.ToLower() == attr.Tone_C.ToLower())                      {                          this.ToneC = song.ToneC = attr.Tone_C;                          toneId = 2;                      }                      if (attr.Tone_D != null && jsonTone.Name.ToLower() == attr.Tone_D.ToLower())                      {                          this.ToneD = song.ToneD = attr.Tone_D;                          toneId = 3;                      }                        // update EOF tone name and set tone id                      if (song.Tones != null)                          foreach (var xmlTone in song.Tones)                          {                              // fix some old toolkit behavior                              if (xmlTone.Name == "ToneA")                                  xmlTone.Name = attr.Tone_A;                              if (xmlTone.Name == "ToneB")                                  xmlTone.Name = attr.Tone_B;                              if (xmlTone.Name == "ToneC")                                  xmlTone.Name = attr.Tone_C;                              if (xmlTone.Name == "ToneD")                                  xmlTone.Name = attr.Tone_D;                                if (xmlTone.Name.ToLower() == jsonTone.Name.ToLower() || jsonTone.Name.ToLower().EndsWith(xmlTone.Name.ToLower())) //todo: SAMENAME tone fix?                              {                                  xmlTone.Name = jsonTone.Name;                                  xmlTone.Id = toneId;                              }                          }                          // song.Tones => id' name' time to apply tone is missing when song.Tones == null                      if (song.Tones == null && toneId > 0)                      {                          // convert the corrupt multitone to a single tone instead of throwing exception                          if (fixMultiTone)                          {                              song.Tones = new SongTone2014[0]; // => song.Tones.Length == 0                              isDirty = true;                          }                          else                              throw new InvalidDataException("Tone data is missing in CDLC and multitones will not change properly in game." + Environment.NewLine + "Please re-author XML arrangements in EOF and repair multitones name and time changes.");                      }                  }                    // convert corrupt multitone to single tone and/or cleanup/repair old toolkit single tone                  // ToneA in single tone ODLC is null/empty                  if ((song.Tones == null || song.Tones.Length == 0) && !String.IsNullOrEmpty(song.ToneA))                  {                      song.ToneA = song.ToneB = song.ToneC = String.Empty;                      song.ToneBase = attr.Tone_Base;                      this.ToneBase = attr.Tone_Base;                      this.ToneA = this.ToneB = this.ToneC = String.Empty;                      isDirty = true;                  }                    // set to standard tuning if no tuning exists                  if (song.Tuning == null)                  {                      song.Tuning = new TuningStrings { String0 = 0' String1 = 0' String2 = 0' String3 = 0' String4 = 0' String5 = 0 };                      isDirty = true;                  }                    this.TuningStrings = song.Tuning;                    // NOTE: any serializing coverts abridged xml to standard xml arrangement                  // so only serialize if necessary to fix errors                  if (isDirty)                  {                      using (var stream = File.Open(xmlSongFile' FileMode.Create))                          song.Serialize(stream' true);                        // write comments back to xml now so they are available for debugging (used for Guitar and Bass)                      Song2014.WriteXmlComments(xmlSongFile' XmlComments' writeNewVers: false);                  }                    // do a quick check/repair of low bass tuning' only for RS2014 bass arrangements                  if (fixLowBass && song.Version == "7" && this.ArrangementType == ArrangementType.Bass)                      if (attr.Tuning.String0 < -4 && attr.CentOffset != -1200.0)                          if (TuningFrequency.ApplyBassFix(this' fixLowBass))                          {                              attr.CentOffset = -1200.0; // Force 220Hz                              song.Tuning = Song2014.LoadFromFile(xmlSongFile).Tuning;                          }              }
Magic Number,RocksmithToolkitLib.DLCPackage,Arrangement,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Arrangement.cs,Arrangement,The following statement contains a magic number: if (attr.Tones == null) // RS2012              {                  this.ToneBase = attr.Tone_Base;                    if (attr.Tone_A != null || attr.Tone_B != null || attr.Tone_C != null || attr.Tone_D != null)                      throw new DataException("RS2012 CDLC has extraneous tone data.");              }              else // RS2014 or Converter RS2012              {                  // TODO: optimize using common Arrangment.cs method                  // verify the xml Tone_ exists in tone.manifest.json                  foreach (var jsonTone in attr.Tones)                  {                      if (jsonTone == null)                          continue;                        // fix for tone.id (may not be needed/used by game)                      Int32 toneId = 0;                        // cleanup the xml arrangement file too                      if (jsonTone.Name.ToLower() == attr.Tone_Base.ToLower())                          this.ToneBase = song.ToneBase = attr.Tone_Base;                      if (attr.Tone_A != null && jsonTone.Name.ToLower() == attr.Tone_A.ToLower())                          this.ToneA = song.ToneA = attr.Tone_A;                      if (attr.Tone_B != null && jsonTone.Name.ToLower() == attr.Tone_B.ToLower())                      {                          this.ToneB = song.ToneB = attr.Tone_B;                          toneId = 1;                      }                      if (attr.Tone_C != null && jsonTone.Name.ToLower() == attr.Tone_C.ToLower())                      {                          this.ToneC = song.ToneC = attr.Tone_C;                          toneId = 2;                      }                      if (attr.Tone_D != null && jsonTone.Name.ToLower() == attr.Tone_D.ToLower())                      {                          this.ToneD = song.ToneD = attr.Tone_D;                          toneId = 3;                      }                        // update EOF tone name and set tone id                      if (song.Tones != null)                          foreach (var xmlTone in song.Tones)                          {                              // fix some old toolkit behavior                              if (xmlTone.Name == "ToneA")                                  xmlTone.Name = attr.Tone_A;                              if (xmlTone.Name == "ToneB")                                  xmlTone.Name = attr.Tone_B;                              if (xmlTone.Name == "ToneC")                                  xmlTone.Name = attr.Tone_C;                              if (xmlTone.Name == "ToneD")                                  xmlTone.Name = attr.Tone_D;                                if (xmlTone.Name.ToLower() == jsonTone.Name.ToLower() || jsonTone.Name.ToLower().EndsWith(xmlTone.Name.ToLower())) //todo: SAMENAME tone fix?                              {                                  xmlTone.Name = jsonTone.Name;                                  xmlTone.Id = toneId;                              }                          }                          // song.Tones => id' name' time to apply tone is missing when song.Tones == null                      if (song.Tones == null && toneId > 0)                      {                          // convert the corrupt multitone to a single tone instead of throwing exception                          if (fixMultiTone)                          {                              song.Tones = new SongTone2014[0]; // => song.Tones.Length == 0                              isDirty = true;                          }                          else                              throw new InvalidDataException("Tone data is missing in CDLC and multitones will not change properly in game." + Environment.NewLine + "Please re-author XML arrangements in EOF and repair multitones name and time changes.");                      }                  }                    // convert corrupt multitone to single tone and/or cleanup/repair old toolkit single tone                  // ToneA in single tone ODLC is null/empty                  if ((song.Tones == null || song.Tones.Length == 0) && !String.IsNullOrEmpty(song.ToneA))                  {                      song.ToneA = song.ToneB = song.ToneC = String.Empty;                      song.ToneBase = attr.Tone_Base;                      this.ToneBase = attr.Tone_Base;                      this.ToneA = this.ToneB = this.ToneC = String.Empty;                      isDirty = true;                  }                    // set to standard tuning if no tuning exists                  if (song.Tuning == null)                  {                      song.Tuning = new TuningStrings { String0 = 0' String1 = 0' String2 = 0' String3 = 0' String4 = 0' String5 = 0 };                      isDirty = true;                  }                    this.TuningStrings = song.Tuning;                    // NOTE: any serializing coverts abridged xml to standard xml arrangement                  // so only serialize if necessary to fix errors                  if (isDirty)                  {                      using (var stream = File.Open(xmlSongFile' FileMode.Create))                          song.Serialize(stream' true);                        // write comments back to xml now so they are available for debugging (used for Guitar and Bass)                      Song2014.WriteXmlComments(xmlSongFile' XmlComments' writeNewVers: false);                  }                    // do a quick check/repair of low bass tuning' only for RS2014 bass arrangements                  if (fixLowBass && song.Version == "7" && this.ArrangementType == ArrangementType.Bass)                      if (attr.Tuning.String0 < -4 && attr.CentOffset != -1200.0)                          if (TuningFrequency.ApplyBassFix(this' fixLowBass))                          {                              attr.CentOffset = -1200.0; // Force 220Hz                              song.Tuning = Song2014.LoadFromFile(xmlSongFile).Tuning;                          }              }
Magic Number,RocksmithToolkitLib.DLCPackage,Arrangement,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Arrangement.cs,Arrangement,The following statement contains a magic number: if (attr.Tones == null) // RS2012              {                  this.ToneBase = attr.Tone_Base;                    if (attr.Tone_A != null || attr.Tone_B != null || attr.Tone_C != null || attr.Tone_D != null)                      throw new DataException("RS2012 CDLC has extraneous tone data.");              }              else // RS2014 or Converter RS2012              {                  // TODO: optimize using common Arrangment.cs method                  // verify the xml Tone_ exists in tone.manifest.json                  foreach (var jsonTone in attr.Tones)                  {                      if (jsonTone == null)                          continue;                        // fix for tone.id (may not be needed/used by game)                      Int32 toneId = 0;                        // cleanup the xml arrangement file too                      if (jsonTone.Name.ToLower() == attr.Tone_Base.ToLower())                          this.ToneBase = song.ToneBase = attr.Tone_Base;                      if (attr.Tone_A != null && jsonTone.Name.ToLower() == attr.Tone_A.ToLower())                          this.ToneA = song.ToneA = attr.Tone_A;                      if (attr.Tone_B != null && jsonTone.Name.ToLower() == attr.Tone_B.ToLower())                      {                          this.ToneB = song.ToneB = attr.Tone_B;                          toneId = 1;                      }                      if (attr.Tone_C != null && jsonTone.Name.ToLower() == attr.Tone_C.ToLower())                      {                          this.ToneC = song.ToneC = attr.Tone_C;                          toneId = 2;                      }                      if (attr.Tone_D != null && jsonTone.Name.ToLower() == attr.Tone_D.ToLower())                      {                          this.ToneD = song.ToneD = attr.Tone_D;                          toneId = 3;                      }                        // update EOF tone name and set tone id                      if (song.Tones != null)                          foreach (var xmlTone in song.Tones)                          {                              // fix some old toolkit behavior                              if (xmlTone.Name == "ToneA")                                  xmlTone.Name = attr.Tone_A;                              if (xmlTone.Name == "ToneB")                                  xmlTone.Name = attr.Tone_B;                              if (xmlTone.Name == "ToneC")                                  xmlTone.Name = attr.Tone_C;                              if (xmlTone.Name == "ToneD")                                  xmlTone.Name = attr.Tone_D;                                if (xmlTone.Name.ToLower() == jsonTone.Name.ToLower() || jsonTone.Name.ToLower().EndsWith(xmlTone.Name.ToLower())) //todo: SAMENAME tone fix?                              {                                  xmlTone.Name = jsonTone.Name;                                  xmlTone.Id = toneId;                              }                          }                          // song.Tones => id' name' time to apply tone is missing when song.Tones == null                      if (song.Tones == null && toneId > 0)                      {                          // convert the corrupt multitone to a single tone instead of throwing exception                          if (fixMultiTone)                          {                              song.Tones = new SongTone2014[0]; // => song.Tones.Length == 0                              isDirty = true;                          }                          else                              throw new InvalidDataException("Tone data is missing in CDLC and multitones will not change properly in game." + Environment.NewLine + "Please re-author XML arrangements in EOF and repair multitones name and time changes.");                      }                  }                    // convert corrupt multitone to single tone and/or cleanup/repair old toolkit single tone                  // ToneA in single tone ODLC is null/empty                  if ((song.Tones == null || song.Tones.Length == 0) && !String.IsNullOrEmpty(song.ToneA))                  {                      song.ToneA = song.ToneB = song.ToneC = String.Empty;                      song.ToneBase = attr.Tone_Base;                      this.ToneBase = attr.Tone_Base;                      this.ToneA = this.ToneB = this.ToneC = String.Empty;                      isDirty = true;                  }                    // set to standard tuning if no tuning exists                  if (song.Tuning == null)                  {                      song.Tuning = new TuningStrings { String0 = 0' String1 = 0' String2 = 0' String3 = 0' String4 = 0' String5 = 0 };                      isDirty = true;                  }                    this.TuningStrings = song.Tuning;                    // NOTE: any serializing coverts abridged xml to standard xml arrangement                  // so only serialize if necessary to fix errors                  if (isDirty)                  {                      using (var stream = File.Open(xmlSongFile' FileMode.Create))                          song.Serialize(stream' true);                        // write comments back to xml now so they are available for debugging (used for Guitar and Bass)                      Song2014.WriteXmlComments(xmlSongFile' XmlComments' writeNewVers: false);                  }                    // do a quick check/repair of low bass tuning' only for RS2014 bass arrangements                  if (fixLowBass && song.Version == "7" && this.ArrangementType == ArrangementType.Bass)                      if (attr.Tuning.String0 < -4 && attr.CentOffset != -1200.0)                          if (TuningFrequency.ApplyBassFix(this' fixLowBass))                          {                              attr.CentOffset = -1200.0; // Force 220Hz                              song.Tuning = Song2014.LoadFromFile(xmlSongFile).Tuning;                          }              }
Magic Number,RocksmithToolkitLib.DLCPackage,Arrangement,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Arrangement.cs,Arrangement,The following statement contains a magic number: if (attr.Tones == null) // RS2012              {                  this.ToneBase = attr.Tone_Base;                    if (attr.Tone_A != null || attr.Tone_B != null || attr.Tone_C != null || attr.Tone_D != null)                      throw new DataException("RS2012 CDLC has extraneous tone data.");              }              else // RS2014 or Converter RS2012              {                  // TODO: optimize using common Arrangment.cs method                  // verify the xml Tone_ exists in tone.manifest.json                  foreach (var jsonTone in attr.Tones)                  {                      if (jsonTone == null)                          continue;                        // fix for tone.id (may not be needed/used by game)                      Int32 toneId = 0;                        // cleanup the xml arrangement file too                      if (jsonTone.Name.ToLower() == attr.Tone_Base.ToLower())                          this.ToneBase = song.ToneBase = attr.Tone_Base;                      if (attr.Tone_A != null && jsonTone.Name.ToLower() == attr.Tone_A.ToLower())                          this.ToneA = song.ToneA = attr.Tone_A;                      if (attr.Tone_B != null && jsonTone.Name.ToLower() == attr.Tone_B.ToLower())                      {                          this.ToneB = song.ToneB = attr.Tone_B;                          toneId = 1;                      }                      if (attr.Tone_C != null && jsonTone.Name.ToLower() == attr.Tone_C.ToLower())                      {                          this.ToneC = song.ToneC = attr.Tone_C;                          toneId = 2;                      }                      if (attr.Tone_D != null && jsonTone.Name.ToLower() == attr.Tone_D.ToLower())                      {                          this.ToneD = song.ToneD = attr.Tone_D;                          toneId = 3;                      }                        // update EOF tone name and set tone id                      if (song.Tones != null)                          foreach (var xmlTone in song.Tones)                          {                              // fix some old toolkit behavior                              if (xmlTone.Name == "ToneA")                                  xmlTone.Name = attr.Tone_A;                              if (xmlTone.Name == "ToneB")                                  xmlTone.Name = attr.Tone_B;                              if (xmlTone.Name == "ToneC")                                  xmlTone.Name = attr.Tone_C;                              if (xmlTone.Name == "ToneD")                                  xmlTone.Name = attr.Tone_D;                                if (xmlTone.Name.ToLower() == jsonTone.Name.ToLower() || jsonTone.Name.ToLower().EndsWith(xmlTone.Name.ToLower())) //todo: SAMENAME tone fix?                              {                                  xmlTone.Name = jsonTone.Name;                                  xmlTone.Id = toneId;                              }                          }                          // song.Tones => id' name' time to apply tone is missing when song.Tones == null                      if (song.Tones == null && toneId > 0)                      {                          // convert the corrupt multitone to a single tone instead of throwing exception                          if (fixMultiTone)                          {                              song.Tones = new SongTone2014[0]; // => song.Tones.Length == 0                              isDirty = true;                          }                          else                              throw new InvalidDataException("Tone data is missing in CDLC and multitones will not change properly in game." + Environment.NewLine + "Please re-author XML arrangements in EOF and repair multitones name and time changes.");                      }                  }                    // convert corrupt multitone to single tone and/or cleanup/repair old toolkit single tone                  // ToneA in single tone ODLC is null/empty                  if ((song.Tones == null || song.Tones.Length == 0) && !String.IsNullOrEmpty(song.ToneA))                  {                      song.ToneA = song.ToneB = song.ToneC = String.Empty;                      song.ToneBase = attr.Tone_Base;                      this.ToneBase = attr.Tone_Base;                      this.ToneA = this.ToneB = this.ToneC = String.Empty;                      isDirty = true;                  }                    // set to standard tuning if no tuning exists                  if (song.Tuning == null)                  {                      song.Tuning = new TuningStrings { String0 = 0' String1 = 0' String2 = 0' String3 = 0' String4 = 0' String5 = 0 };                      isDirty = true;                  }                    this.TuningStrings = song.Tuning;                    // NOTE: any serializing coverts abridged xml to standard xml arrangement                  // so only serialize if necessary to fix errors                  if (isDirty)                  {                      using (var stream = File.Open(xmlSongFile' FileMode.Create))                          song.Serialize(stream' true);                        // write comments back to xml now so they are available for debugging (used for Guitar and Bass)                      Song2014.WriteXmlComments(xmlSongFile' XmlComments' writeNewVers: false);                  }                    // do a quick check/repair of low bass tuning' only for RS2014 bass arrangements                  if (fixLowBass && song.Version == "7" && this.ArrangementType == ArrangementType.Bass)                      if (attr.Tuning.String0 < -4 && attr.CentOffset != -1200.0)                          if (TuningFrequency.ApplyBassFix(this' fixLowBass))                          {                              attr.CentOffset = -1200.0; // Force 220Hz                              song.Tuning = Song2014.LoadFromFile(xmlSongFile).Tuning;                          }              }
Magic Number,RocksmithToolkitLib.DLCPackage,Arrangement,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Arrangement.cs,Arrangement,The following statement contains a magic number: if (attr.Tones == null) // RS2012              {                  this.ToneBase = attr.Tone_Base;                    if (attr.Tone_A != null || attr.Tone_B != null || attr.Tone_C != null || attr.Tone_D != null)                      throw new DataException("RS2012 CDLC has extraneous tone data.");              }              else // RS2014 or Converter RS2012              {                  // TODO: optimize using common Arrangment.cs method                  // verify the xml Tone_ exists in tone.manifest.json                  foreach (var jsonTone in attr.Tones)                  {                      if (jsonTone == null)                          continue;                        // fix for tone.id (may not be needed/used by game)                      Int32 toneId = 0;                        // cleanup the xml arrangement file too                      if (jsonTone.Name.ToLower() == attr.Tone_Base.ToLower())                          this.ToneBase = song.ToneBase = attr.Tone_Base;                      if (attr.Tone_A != null && jsonTone.Name.ToLower() == attr.Tone_A.ToLower())                          this.ToneA = song.ToneA = attr.Tone_A;                      if (attr.Tone_B != null && jsonTone.Name.ToLower() == attr.Tone_B.ToLower())                      {                          this.ToneB = song.ToneB = attr.Tone_B;                          toneId = 1;                      }                      if (attr.Tone_C != null && jsonTone.Name.ToLower() == attr.Tone_C.ToLower())                      {                          this.ToneC = song.ToneC = attr.Tone_C;                          toneId = 2;                      }                      if (attr.Tone_D != null && jsonTone.Name.ToLower() == attr.Tone_D.ToLower())                      {                          this.ToneD = song.ToneD = attr.Tone_D;                          toneId = 3;                      }                        // update EOF tone name and set tone id                      if (song.Tones != null)                          foreach (var xmlTone in song.Tones)                          {                              // fix some old toolkit behavior                              if (xmlTone.Name == "ToneA")                                  xmlTone.Name = attr.Tone_A;                              if (xmlTone.Name == "ToneB")                                  xmlTone.Name = attr.Tone_B;                              if (xmlTone.Name == "ToneC")                                  xmlTone.Name = attr.Tone_C;                              if (xmlTone.Name == "ToneD")                                  xmlTone.Name = attr.Tone_D;                                if (xmlTone.Name.ToLower() == jsonTone.Name.ToLower() || jsonTone.Name.ToLower().EndsWith(xmlTone.Name.ToLower())) //todo: SAMENAME tone fix?                              {                                  xmlTone.Name = jsonTone.Name;                                  xmlTone.Id = toneId;                              }                          }                          // song.Tones => id' name' time to apply tone is missing when song.Tones == null                      if (song.Tones == null && toneId > 0)                      {                          // convert the corrupt multitone to a single tone instead of throwing exception                          if (fixMultiTone)                          {                              song.Tones = new SongTone2014[0]; // => song.Tones.Length == 0                              isDirty = true;                          }                          else                              throw new InvalidDataException("Tone data is missing in CDLC and multitones will not change properly in game." + Environment.NewLine + "Please re-author XML arrangements in EOF and repair multitones name and time changes.");                      }                  }                    // convert corrupt multitone to single tone and/or cleanup/repair old toolkit single tone                  // ToneA in single tone ODLC is null/empty                  if ((song.Tones == null || song.Tones.Length == 0) && !String.IsNullOrEmpty(song.ToneA))                  {                      song.ToneA = song.ToneB = song.ToneC = String.Empty;                      song.ToneBase = attr.Tone_Base;                      this.ToneBase = attr.Tone_Base;                      this.ToneA = this.ToneB = this.ToneC = String.Empty;                      isDirty = true;                  }                    // set to standard tuning if no tuning exists                  if (song.Tuning == null)                  {                      song.Tuning = new TuningStrings { String0 = 0' String1 = 0' String2 = 0' String3 = 0' String4 = 0' String5 = 0 };                      isDirty = true;                  }                    this.TuningStrings = song.Tuning;                    // NOTE: any serializing coverts abridged xml to standard xml arrangement                  // so only serialize if necessary to fix errors                  if (isDirty)                  {                      using (var stream = File.Open(xmlSongFile' FileMode.Create))                          song.Serialize(stream' true);                        // write comments back to xml now so they are available for debugging (used for Guitar and Bass)                      Song2014.WriteXmlComments(xmlSongFile' XmlComments' writeNewVers: false);                  }                    // do a quick check/repair of low bass tuning' only for RS2014 bass arrangements                  if (fixLowBass && song.Version == "7" && this.ArrangementType == ArrangementType.Bass)                      if (attr.Tuning.String0 < -4 && attr.CentOffset != -1200.0)                          if (TuningFrequency.ApplyBassFix(this' fixLowBass))                          {                              attr.CentOffset = -1200.0; // Force 220Hz                              song.Tuning = Song2014.LoadFromFile(xmlSongFile).Tuning;                          }              }
Magic Number,RocksmithToolkitLib.DLCPackage,Arrangement,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Arrangement.cs,ToString,The following statement contains a magic number: if (TuningPitch > 0 && !TuningPitch.Equals(440.0))                  pitchInfo = String.Format(": A{0}"' TuningPitch);
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,Generate,The following statement contains a magic number: using (var packPsarcStream = new MemoryStream())              {                  switch (platform.version)                  {                      case GameVersion.RS2014:                          switch (dlcType)                          {                              case DLCPackageType.Song:                                  GenerateRS2014SongPsarc(packPsarcStream' info' platform' pnum);                                  break;                              case DLCPackageType.Lesson:                                  throw new NotImplementedException("Lesson package type not implemented yet :(");                              case DLCPackageType.Inlay:                                  GenerateRS2014InlayPsarc(packPsarcStream' info' platform);                                  break;                          }                          break;                      case GameVersion.RS2012:                          GeneratePsarcsForRS1(packPsarcStream' info' platform);                          break;                      case GameVersion.None:                          throw new InvalidOperationException("Unexpected game version value");                  }                    var packageName = Path.GetFileNameWithoutExtension(packagePath).StripPlatformEndName();                  var songFileName = String.Format("{0}{1}"' Path.Combine(Path.GetDirectoryName(packagePath)' packageName)' platform.GetPathName()[2]);                    // SAVE PACKAGE                  switch (platform.platform)                  {                      case GamePlatform.Pc:                      case GamePlatform.Mac:                          switch (platform.version)                          {                              case GameVersion.RS2014:                                  using (var fl = File.Create(songFileName + ".psarc"))                                      packPsarcStream.CopyTo(fl);                                  break;                              case GameVersion.RS2012:                                  using (var fl = File.Create(songFileName + ".dat"))                                      RijndaelEncryptor.EncryptFile(packPsarcStream' fl' RijndaelEncryptor.DLCKey);                                  break;                              default:                                  throw new InvalidOperationException("Unexpected game version value");                          }                          break;                      case GamePlatform.XBox360:                          BuildXBox360Package(songFileName' info' FILES_XBOX' platform.version' dlcType);                          break;                      case GamePlatform.PS3:                          EncryptPS3EdatFiles(songFileName + ".psarc"' platform);                          break;                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GetSTFSHeader,The following statement contains a magic number: switch (gameVersion)              {                  case GameVersion.RS2012:                      hd.Title_Package = "Rocksmith";                      hd.TitleID = 1431505011; //55530873 in HEXA for RS1                      hd.PackageImageBinary = Resources.XBox360_DLC_image;                      break;                  case GameVersion.RS2014:                      hd.Title_Package = "Rocksmith 2014";                      hd.TitleID = 1431505088; //555308C0 in HEXA for RS2014                      hd.PackageImageBinary = Resources.XBox360_DLC_image2014;                      break;              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GetSTFSHeader,The following statement contains a magic number: switch (gameVersion)              {                  case GameVersion.RS2012:                      hd.Title_Package = "Rocksmith";                      hd.TitleID = 1431505011; //55530873 in HEXA for RS1                      hd.PackageImageBinary = Resources.XBox360_DLC_image;                      break;                  case GameVersion.RS2014:                      hd.Title_Package = "Rocksmith 2014";                      hd.TitleID = 1431505088; //555308C0 in HEXA for RS2014                      hd.PackageImageBinary = Resources.XBox360_DLC_image2014;                      break;              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The following statement contains a magic number: try              {                  // ALBUM ART                  if (info.ArtFiles == null)                  {                      //Try to get spreserved files                      string d256' d128' d64;                      if (File.Exists(info.AlbumArtPath))                      {                          d256 = info.AlbumArtPath;                          d128 = d256.Remove(d256.Length - 7) + "128.dds";                          d64 = d256.Remove(d256.Length - 7) + "64.dds";                          if (File.Exists(d64) && File.Exists(d128))                          {                              var _found = new List<DDSConvertedFile>                              {                                  new DDSConvertedFile() { sizeX = 64' destinationFile = d64 }'                                  new DDSConvertedFile() { sizeX = 128' destinationFile = d128 }'                                  new DDSConvertedFile() { sizeX = 256' destinationFile = d256 }                              };                              info.ArtFiles = _found;                          }                      }                  }                  if (info.ArtFiles == null)                  {                      //Generate art files                      string albumArtPath;                      var ddsfiles = info.ArtFiles;                      if (File.Exists(info.AlbumArtPath))                      {                          albumArtPath = info.AlbumArtPath;                      }                      else                      {                          using (var albumArtStream = new MemoryStream(Resources.albumart2014_256))                          {                              albumArtPath = GeneralExtensions.GetTempFileName(".dds");                              albumArtStream.WriteFile(albumArtPath);                              TMPFILES_ART.Add(albumArtPath);                          }                      }                        ddsfiles = new List<DDSConvertedFile>                      {                          new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }'                          new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }'                          new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }                      };                        // Convert to DDS                      ToDDS(ddsfiles);                        // Save for reuse                      info.ArtFiles = ddsfiles;                  }                    foreach (var dds in info.ArtFiles)                  {                      packPsarc.AddEntry(String.Format("gfxassets/album_art/album_{0}_{1}.dds"' dlcName' dds.sizeX)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                      if (dds.sizeY != 0)                      {                          TMPFILES_ART.Add(dds.destinationFile);                      }                  }                    // Lyric Art Texture                  if (File.Exists(info.LyricArtPath))                      packPsarc.AddEntry(String.Format("assets/ui/lyrics/{0}/lyrics_{0}.dds"' dlcName)' new FileStream(info.LyricArtPath' FileMode.Open' FileAccess.Read' FileShare.Read));                    // AUDIO                  var audioFile = info.OggPath;                  if (File.Exists(audioFile))                      if (platform.IsConsole != audioFile.GetAudioPlatform().IsConsole)                          soundStream = OggFile.ConvertAudioPlatform(audioFile);                      else                          soundStream = File.OpenRead(audioFile);                  else                      throw new InvalidOperationException(String.Format("Audio file '{0}' not found."' audioFile));                    // AUDIO PREVIEW                  var previewAudioFile = info.OggPreviewPath;                  if (File.Exists(previewAudioFile))                      if (platform.IsConsole != previewAudioFile.GetAudioPlatform().IsConsole)                          soundPreviewStream = OggFile.ConvertAudioPlatform(previewAudioFile);                      else                          soundPreviewStream = File.OpenRead(previewAudioFile);                  else                      soundPreviewStream = soundStream;                    // FLAT MODEL                  rsenumerableRootStream = new MemoryStream(Resources.rsenumerable_root);                  packPsarc.AddEntry("flatmodels/rs/rsenumerable_root.flat"' rsenumerableRootStream);                  rsenumerableSongStream = new MemoryStream(Resources.rsenumerable_song);                  packPsarc.AddEntry("flatmodels/rs/rsenumerable_song.flat"' rsenumerableSongStream);                    using (var toolkitVersionStream = new MemoryStream())                  using (var appIdStream = new MemoryStream())                  using (var packageListStream = new MemoryStream())                  using (var soundbankStream = new MemoryStream())                  using (var soundbankPreviewStream = new MemoryStream())                  using (var aggregateGraphStream = new MemoryStream())                  using (var manifestHeaderHSANStream = new MemoryStream())                  using (var manifestHeaderHSONStreamList = new DisposableCollection<Stream>())                  using (var manifestStreamList = new DisposableCollection<Stream>())                  using (var arrangementStream = new DisposableCollection<Stream>())                  using (var showlightStream = new MemoryStream())                  using (var xblockStream = new MemoryStream())                  {                      // TOOLKIT VERSION                      var stopHere = info;                      GenerateToolkitVersion(toolkitVersionStream' info.ToolkitInfo.PackageAuthor' info.ToolkitInfo.PackageVersion' info.ToolkitInfo.PackageComment);                      packPsarc.AddEntry("toolkit.version"' toolkitVersionStream);                        // APP ID                      if (!platform.IsConsole)                      {                          GenerateAppId(appIdStream' info.AppId' platform);                          packPsarc.AddEntry("appid.appid"' appIdStream);                      }                        if (platform.platform == GamePlatform.XBox360)                      {                          var packageListWriter = new StreamWriter(packageListStream);                          packageListWriter.Write(dlcName);                          packageListWriter.Flush();                          packageListStream.Seek(0' SeekOrigin.Begin);                          packageListStream.WriteTmpFile("PackageList.txt"' platform);                      }                        // SOUNDBANK                      var soundbankFileName = String.Format("song_{0}"' dlcName);                      var audioFileNameId = SoundBankGenerator2014.GenerateSoundBank(info.Name' soundStream' soundbankStream' info.Volume' platform);                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.bnk"' platform.GetPathName()[0].ToLower()' soundbankFileName)' soundbankStream);                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.wem"' platform.GetPathName()[0].ToLower()' audioFileNameId)' soundStream);                        // SOUNDBANK PREVIEW                      var soundbankPreviewFileName = String.Format("song_{0}_preview"' dlcName);                      dynamic audioPreviewFileNameId;                      var previewVolume = info.PreviewVolume ?? info.Volume;                      audioPreviewFileNameId = SoundBankGenerator2014.GenerateSoundBank(info.Name + "_Preview"' soundPreviewStream' soundbankPreviewStream' previewVolume' platform' true' !(File.Exists(previewAudioFile)));                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.bnk"' platform.GetPathName()[0].ToLower()' soundbankPreviewFileName)' soundbankPreviewStream);                      if (!soundPreviewStream.Equals(soundStream)) packPsarc.AddEntry(String.Format("audio/{0}/{1}.wem"' platform.GetPathName()[0].ToLower()' audioPreviewFileNameId)' soundPreviewStream);                        // AGGREGATE GRAPH                      var aggregateGraphFileName = String.Format("{0}_aggregategraph.nt"' dlcName);                      var aggregateGraph = new AggregateGraph2014.AggregateGraph2014(info' platform);                      aggregateGraph.Serialize(aggregateGraphStream);                      aggregateGraphStream.Flush();                      aggregateGraphStream.Seek(0' SeekOrigin.Begin);                      packPsarc.AddEntry(aggregateGraphFileName' aggregateGraphStream);                        var manifestHeader = new ManifestHeader2014<AttributesHeader2014>(platform);                      var songPartition = new SongPartition();                      var songPartitionCount = new SongPartition();                        foreach (var arrangement in info.Arrangements)                      {                          if (arrangement.ArrangementType == ArrangementType.ShowLight)                              continue;                            var arrangementFileName = songPartition.GetArrangementFileName(arrangement.Name' arrangement.ArrangementType).ToLower();                            // GAME SONG (SNG)                          UpdateToneDescriptors(info);                          GenerateSNG(arrangement' platform);                          var sngSongFile = File.OpenRead(arrangement.SongFile.File);                          arrangementStream.Add(sngSongFile);                          packPsarc.AddEntry(String.Format("songs/bin/{0}/{1}_{2}.sng"' platform.GetPathName()[1].ToLower()' dlcName' arrangementFileName)' sngSongFile);                            // XML SONG                          var xmlSongFile = File.OpenRead(arrangement.SongXml.File);                          arrangementStream.Add(xmlSongFile);                          packPsarc.AddEntry(String.Format("songs/arr/{0}_{1}.xml"' dlcName' arrangementFileName)' xmlSongFile);                            // MANIFEST                          var manifest = new Manifest2014<Attributes2014>();                          var attribute = new Attributes2014(arrangementFileName' arrangement' info' platform);                          if (arrangement.ArrangementType == ArrangementType.Bass || arrangement.ArrangementType == ArrangementType.Guitar)                          {                              // TODO: monitor this new code for bugs                              // represent is set to "1" by default' if there is a bonus then set represent to "0"                              attribute.Representative = arrangement.BonusArr ? 0 : 1;                              attribute.ArrangementProperties.Represent = arrangement.BonusArr ? 0 : 1;                                attribute.SongPartition = songPartitionCount.GetSongPartition(arrangement.Name' arrangement.ArrangementType);                              if (attribute.SongPartition > 1 && !arrangement.BonusArr)                              {                                  // for alternate arrangement then both represent and bonus are set to "0"                                  attribute.Representative = 0;                                  attribute.ArrangementProperties.Represent = 0;                              }                          }                            var attributeDictionary = new Dictionary<string' Attributes2014> { { "Attributes"' attribute } };                          manifest.Entries.Add(attribute.PersistentID' attributeDictionary);                          var manifestStream = new MemoryStream();                          manifestStreamList.Add(manifestStream);                          manifest.Serialize(manifestStream);                          manifestStream.Seek(0' SeekOrigin.Begin);                            const string jsonPathPC = "manifests/songs_dlc_{0}/{0}_{1}.json";                          const string jsonPathConsole = "manifests/songs_dlc/{0}_{1}.json";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? jsonPathConsole : jsonPathPC)' dlcName' arrangementFileName)' manifestStream);                            // MANIFEST HEADER                          var attributeHeaderDictionary = new Dictionary<string' AttributesHeader2014> { { "Attributes"' new AttributesHeader2014(attribute) } };                            if (platform.IsConsole)                          {                              // One for each arrangements (Xbox360/PS3)                              manifestHeader = new ManifestHeader2014<AttributesHeader2014>(platform);                              manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                              var manifestHeaderStream = new MemoryStream();                              manifestHeaderHSONStreamList.Add(manifestHeaderStream);                              manifestHeader.Serialize(manifestHeaderStream);                              manifestStream.Seek(0' SeekOrigin.Begin);                              packPsarc.AddEntry(String.Format("manifests/songs_dlc/{0}_{1}.hson"' dlcName' arrangementFileName)' manifestHeaderStream);                          }                          else                          {                              // One for all arrangements (PC/Mac)                              manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                          }                      }                        if (!platform.IsConsole)                      {                          manifestHeader.Serialize(manifestHeaderHSANStream);                          manifestHeaderHSANStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("manifests/songs_dlc_{0}/songs_dlc_{0}.hsan"' dlcName)' manifestHeaderHSANStream);                      }                        // XML SHOWLIGHTS                      var shlArr = info.Arrangements.FirstOrDefault(ar => ar.ArrangementType == ArrangementType.ShowLight);                      if (shlArr != null && shlArr.SongXml.File != null)                      {                          using (var fs = File.OpenRead(shlArr.SongXml.File))                              fs.CopyTo(showlightStream);                      }                      else                      {                          // Generate Showlights 'cst_showlights.xml'                          var showlight = new Showlights();                          showlight.CreateShowlights(info);                          // check for required minimum number of showlight elements                          if (showlight.ShowlightList.Count > 1)                          {                              showlight.Serialize(showlightStream);                              string shlFilePath = Path.Combine(Path.GetDirectoryName(info.Arrangements[0].SongXml.File)' String.Format("{0}_showlights.xml"' "cst"));                              using (FileStream file = new FileStream(shlFilePath' FileMode.Create' FileAccess.Write))                                  showlightStream.WriteTo(file);                                // write xml comments                              Song2014.WriteXmlComments(shlFilePath);                                // reload stream                              using (var fs = File.OpenRead(shlFilePath))                                  fs.CopyTo(showlightStream);                          }                          else                          {                              // insufficient showlight changes may crash game                              throw new InvalidOperationException("<ERROR> Insufficient showlight changes will crash game: " + showlight.ShowlightList.Count);                          }                      }                        if (showlightStream.CanRead && showlightStream.Length > 0)                          packPsarc.AddEntry(String.Format("songs/arr/{0}_showlights.xml"' dlcName)' showlightStream);                        // XBLOCK                      var game = GameXblock<Entity2014>.Generate2014(info' platform);                      game.SerializeXml(xblockStream);                      xblockStream.Flush();                      xblockStream.Seek(0' SeekOrigin.Begin);                      packPsarc.AddEntry(String.Format("gamexblocks/nsongs/{0}.xblock"' dlcName)' xblockStream);                        // WRITE PACKAGE                      packPsarc.Write(output' !platform.IsConsole);                      output.WriteTmpFile(String.Format("{0}.psarc"' dlcName)' platform);                  }              }              finally              {                  // Dispose all objects                  if (soundStream != null)                      soundStream.Dispose();                  if (soundPreviewStream != null)                      soundPreviewStream.Dispose();                  if (rsenumerableRootStream != null)                      rsenumerableRootStream.Dispose();                  if (rsenumerableSongStream != null)                      rsenumerableSongStream.Dispose();                  if (pnum <= 1)                      DeleteTmpFiles(TMPFILES_ART);                  DeleteTmpFiles(TMPFILES_SNG);              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The following statement contains a magic number: try              {                  // ALBUM ART                  if (info.ArtFiles == null)                  {                      //Try to get spreserved files                      string d256' d128' d64;                      if (File.Exists(info.AlbumArtPath))                      {                          d256 = info.AlbumArtPath;                          d128 = d256.Remove(d256.Length - 7) + "128.dds";                          d64 = d256.Remove(d256.Length - 7) + "64.dds";                          if (File.Exists(d64) && File.Exists(d128))                          {                              var _found = new List<DDSConvertedFile>                              {                                  new DDSConvertedFile() { sizeX = 64' destinationFile = d64 }'                                  new DDSConvertedFile() { sizeX = 128' destinationFile = d128 }'                                  new DDSConvertedFile() { sizeX = 256' destinationFile = d256 }                              };                              info.ArtFiles = _found;                          }                      }                  }                  if (info.ArtFiles == null)                  {                      //Generate art files                      string albumArtPath;                      var ddsfiles = info.ArtFiles;                      if (File.Exists(info.AlbumArtPath))                      {                          albumArtPath = info.AlbumArtPath;                      }                      else                      {                          using (var albumArtStream = new MemoryStream(Resources.albumart2014_256))                          {                              albumArtPath = GeneralExtensions.GetTempFileName(".dds");                              albumArtStream.WriteFile(albumArtPath);                              TMPFILES_ART.Add(albumArtPath);                          }                      }                        ddsfiles = new List<DDSConvertedFile>                      {                          new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }'                          new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }'                          new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }                      };                        // Convert to DDS                      ToDDS(ddsfiles);                        // Save for reuse                      info.ArtFiles = ddsfiles;                  }                    foreach (var dds in info.ArtFiles)                  {                      packPsarc.AddEntry(String.Format("gfxassets/album_art/album_{0}_{1}.dds"' dlcName' dds.sizeX)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                      if (dds.sizeY != 0)                      {                          TMPFILES_ART.Add(dds.destinationFile);                      }                  }                    // Lyric Art Texture                  if (File.Exists(info.LyricArtPath))                      packPsarc.AddEntry(String.Format("assets/ui/lyrics/{0}/lyrics_{0}.dds"' dlcName)' new FileStream(info.LyricArtPath' FileMode.Open' FileAccess.Read' FileShare.Read));                    // AUDIO                  var audioFile = info.OggPath;                  if (File.Exists(audioFile))                      if (platform.IsConsole != audioFile.GetAudioPlatform().IsConsole)                          soundStream = OggFile.ConvertAudioPlatform(audioFile);                      else                          soundStream = File.OpenRead(audioFile);                  else                      throw new InvalidOperationException(String.Format("Audio file '{0}' not found."' audioFile));                    // AUDIO PREVIEW                  var previewAudioFile = info.OggPreviewPath;                  if (File.Exists(previewAudioFile))                      if (platform.IsConsole != previewAudioFile.GetAudioPlatform().IsConsole)                          soundPreviewStream = OggFile.ConvertAudioPlatform(previewAudioFile);                      else                          soundPreviewStream = File.OpenRead(previewAudioFile);                  else                      soundPreviewStream = soundStream;                    // FLAT MODEL                  rsenumerableRootStream = new MemoryStream(Resources.rsenumerable_root);                  packPsarc.AddEntry("flatmodels/rs/rsenumerable_root.flat"' rsenumerableRootStream);                  rsenumerableSongStream = new MemoryStream(Resources.rsenumerable_song);                  packPsarc.AddEntry("flatmodels/rs/rsenumerable_song.flat"' rsenumerableSongStream);                    using (var toolkitVersionStream = new MemoryStream())                  using (var appIdStream = new MemoryStream())                  using (var packageListStream = new MemoryStream())                  using (var soundbankStream = new MemoryStream())                  using (var soundbankPreviewStream = new MemoryStream())                  using (var aggregateGraphStream = new MemoryStream())                  using (var manifestHeaderHSANStream = new MemoryStream())                  using (var manifestHeaderHSONStreamList = new DisposableCollection<Stream>())                  using (var manifestStreamList = new DisposableCollection<Stream>())                  using (var arrangementStream = new DisposableCollection<Stream>())                  using (var showlightStream = new MemoryStream())                  using (var xblockStream = new MemoryStream())                  {                      // TOOLKIT VERSION                      var stopHere = info;                      GenerateToolkitVersion(toolkitVersionStream' info.ToolkitInfo.PackageAuthor' info.ToolkitInfo.PackageVersion' info.ToolkitInfo.PackageComment);                      packPsarc.AddEntry("toolkit.version"' toolkitVersionStream);                        // APP ID                      if (!platform.IsConsole)                      {                          GenerateAppId(appIdStream' info.AppId' platform);                          packPsarc.AddEntry("appid.appid"' appIdStream);                      }                        if (platform.platform == GamePlatform.XBox360)                      {                          var packageListWriter = new StreamWriter(packageListStream);                          packageListWriter.Write(dlcName);                          packageListWriter.Flush();                          packageListStream.Seek(0' SeekOrigin.Begin);                          packageListStream.WriteTmpFile("PackageList.txt"' platform);                      }                        // SOUNDBANK                      var soundbankFileName = String.Format("song_{0}"' dlcName);                      var audioFileNameId = SoundBankGenerator2014.GenerateSoundBank(info.Name' soundStream' soundbankStream' info.Volume' platform);                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.bnk"' platform.GetPathName()[0].ToLower()' soundbankFileName)' soundbankStream);                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.wem"' platform.GetPathName()[0].ToLower()' audioFileNameId)' soundStream);                        // SOUNDBANK PREVIEW                      var soundbankPreviewFileName = String.Format("song_{0}_preview"' dlcName);                      dynamic audioPreviewFileNameId;                      var previewVolume = info.PreviewVolume ?? info.Volume;                      audioPreviewFileNameId = SoundBankGenerator2014.GenerateSoundBank(info.Name + "_Preview"' soundPreviewStream' soundbankPreviewStream' previewVolume' platform' true' !(File.Exists(previewAudioFile)));                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.bnk"' platform.GetPathName()[0].ToLower()' soundbankPreviewFileName)' soundbankPreviewStream);                      if (!soundPreviewStream.Equals(soundStream)) packPsarc.AddEntry(String.Format("audio/{0}/{1}.wem"' platform.GetPathName()[0].ToLower()' audioPreviewFileNameId)' soundPreviewStream);                        // AGGREGATE GRAPH                      var aggregateGraphFileName = String.Format("{0}_aggregategraph.nt"' dlcName);                      var aggregateGraph = new AggregateGraph2014.AggregateGraph2014(info' platform);                      aggregateGraph.Serialize(aggregateGraphStream);                      aggregateGraphStream.Flush();                      aggregateGraphStream.Seek(0' SeekOrigin.Begin);                      packPsarc.AddEntry(aggregateGraphFileName' aggregateGraphStream);                        var manifestHeader = new ManifestHeader2014<AttributesHeader2014>(platform);                      var songPartition = new SongPartition();                      var songPartitionCount = new SongPartition();                        foreach (var arrangement in info.Arrangements)                      {                          if (arrangement.ArrangementType == ArrangementType.ShowLight)                              continue;                            var arrangementFileName = songPartition.GetArrangementFileName(arrangement.Name' arrangement.ArrangementType).ToLower();                            // GAME SONG (SNG)                          UpdateToneDescriptors(info);                          GenerateSNG(arrangement' platform);                          var sngSongFile = File.OpenRead(arrangement.SongFile.File);                          arrangementStream.Add(sngSongFile);                          packPsarc.AddEntry(String.Format("songs/bin/{0}/{1}_{2}.sng"' platform.GetPathName()[1].ToLower()' dlcName' arrangementFileName)' sngSongFile);                            // XML SONG                          var xmlSongFile = File.OpenRead(arrangement.SongXml.File);                          arrangementStream.Add(xmlSongFile);                          packPsarc.AddEntry(String.Format("songs/arr/{0}_{1}.xml"' dlcName' arrangementFileName)' xmlSongFile);                            // MANIFEST                          var manifest = new Manifest2014<Attributes2014>();                          var attribute = new Attributes2014(arrangementFileName' arrangement' info' platform);                          if (arrangement.ArrangementType == ArrangementType.Bass || arrangement.ArrangementType == ArrangementType.Guitar)                          {                              // TODO: monitor this new code for bugs                              // represent is set to "1" by default' if there is a bonus then set represent to "0"                              attribute.Representative = arrangement.BonusArr ? 0 : 1;                              attribute.ArrangementProperties.Represent = arrangement.BonusArr ? 0 : 1;                                attribute.SongPartition = songPartitionCount.GetSongPartition(arrangement.Name' arrangement.ArrangementType);                              if (attribute.SongPartition > 1 && !arrangement.BonusArr)                              {                                  // for alternate arrangement then both represent and bonus are set to "0"                                  attribute.Representative = 0;                                  attribute.ArrangementProperties.Represent = 0;                              }                          }                            var attributeDictionary = new Dictionary<string' Attributes2014> { { "Attributes"' attribute } };                          manifest.Entries.Add(attribute.PersistentID' attributeDictionary);                          var manifestStream = new MemoryStream();                          manifestStreamList.Add(manifestStream);                          manifest.Serialize(manifestStream);                          manifestStream.Seek(0' SeekOrigin.Begin);                            const string jsonPathPC = "manifests/songs_dlc_{0}/{0}_{1}.json";                          const string jsonPathConsole = "manifests/songs_dlc/{0}_{1}.json";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? jsonPathConsole : jsonPathPC)' dlcName' arrangementFileName)' manifestStream);                            // MANIFEST HEADER                          var attributeHeaderDictionary = new Dictionary<string' AttributesHeader2014> { { "Attributes"' new AttributesHeader2014(attribute) } };                            if (platform.IsConsole)                          {                              // One for each arrangements (Xbox360/PS3)                              manifestHeader = new ManifestHeader2014<AttributesHeader2014>(platform);                              manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                              var manifestHeaderStream = new MemoryStream();                              manifestHeaderHSONStreamList.Add(manifestHeaderStream);                              manifestHeader.Serialize(manifestHeaderStream);                              manifestStream.Seek(0' SeekOrigin.Begin);                              packPsarc.AddEntry(String.Format("manifests/songs_dlc/{0}_{1}.hson"' dlcName' arrangementFileName)' manifestHeaderStream);                          }                          else                          {                              // One for all arrangements (PC/Mac)                              manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                          }                      }                        if (!platform.IsConsole)                      {                          manifestHeader.Serialize(manifestHeaderHSANStream);                          manifestHeaderHSANStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("manifests/songs_dlc_{0}/songs_dlc_{0}.hsan"' dlcName)' manifestHeaderHSANStream);                      }                        // XML SHOWLIGHTS                      var shlArr = info.Arrangements.FirstOrDefault(ar => ar.ArrangementType == ArrangementType.ShowLight);                      if (shlArr != null && shlArr.SongXml.File != null)                      {                          using (var fs = File.OpenRead(shlArr.SongXml.File))                              fs.CopyTo(showlightStream);                      }                      else                      {                          // Generate Showlights 'cst_showlights.xml'                          var showlight = new Showlights();                          showlight.CreateShowlights(info);                          // check for required minimum number of showlight elements                          if (showlight.ShowlightList.Count > 1)                          {                              showlight.Serialize(showlightStream);                              string shlFilePath = Path.Combine(Path.GetDirectoryName(info.Arrangements[0].SongXml.File)' String.Format("{0}_showlights.xml"' "cst"));                              using (FileStream file = new FileStream(shlFilePath' FileMode.Create' FileAccess.Write))                                  showlightStream.WriteTo(file);                                // write xml comments                              Song2014.WriteXmlComments(shlFilePath);                                // reload stream                              using (var fs = File.OpenRead(shlFilePath))                                  fs.CopyTo(showlightStream);                          }                          else                          {                              // insufficient showlight changes may crash game                              throw new InvalidOperationException("<ERROR> Insufficient showlight changes will crash game: " + showlight.ShowlightList.Count);                          }                      }                        if (showlightStream.CanRead && showlightStream.Length > 0)                          packPsarc.AddEntry(String.Format("songs/arr/{0}_showlights.xml"' dlcName)' showlightStream);                        // XBLOCK                      var game = GameXblock<Entity2014>.Generate2014(info' platform);                      game.SerializeXml(xblockStream);                      xblockStream.Flush();                      xblockStream.Seek(0' SeekOrigin.Begin);                      packPsarc.AddEntry(String.Format("gamexblocks/nsongs/{0}.xblock"' dlcName)' xblockStream);                        // WRITE PACKAGE                      packPsarc.Write(output' !platform.IsConsole);                      output.WriteTmpFile(String.Format("{0}.psarc"' dlcName)' platform);                  }              }              finally              {                  // Dispose all objects                  if (soundStream != null)                      soundStream.Dispose();                  if (soundPreviewStream != null)                      soundPreviewStream.Dispose();                  if (rsenumerableRootStream != null)                      rsenumerableRootStream.Dispose();                  if (rsenumerableSongStream != null)                      rsenumerableSongStream.Dispose();                  if (pnum <= 1)                      DeleteTmpFiles(TMPFILES_ART);                  DeleteTmpFiles(TMPFILES_SNG);              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The following statement contains a magic number: try              {                  // ALBUM ART                  if (info.ArtFiles == null)                  {                      //Try to get spreserved files                      string d256' d128' d64;                      if (File.Exists(info.AlbumArtPath))                      {                          d256 = info.AlbumArtPath;                          d128 = d256.Remove(d256.Length - 7) + "128.dds";                          d64 = d256.Remove(d256.Length - 7) + "64.dds";                          if (File.Exists(d64) && File.Exists(d128))                          {                              var _found = new List<DDSConvertedFile>                              {                                  new DDSConvertedFile() { sizeX = 64' destinationFile = d64 }'                                  new DDSConvertedFile() { sizeX = 128' destinationFile = d128 }'                                  new DDSConvertedFile() { sizeX = 256' destinationFile = d256 }                              };                              info.ArtFiles = _found;                          }                      }                  }                  if (info.ArtFiles == null)                  {                      //Generate art files                      string albumArtPath;                      var ddsfiles = info.ArtFiles;                      if (File.Exists(info.AlbumArtPath))                      {                          albumArtPath = info.AlbumArtPath;                      }                      else                      {                          using (var albumArtStream = new MemoryStream(Resources.albumart2014_256))                          {                              albumArtPath = GeneralExtensions.GetTempFileName(".dds");                              albumArtStream.WriteFile(albumArtPath);                              TMPFILES_ART.Add(albumArtPath);                          }                      }                        ddsfiles = new List<DDSConvertedFile>                      {                          new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }'                          new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }'                          new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }                      };                        // Convert to DDS                      ToDDS(ddsfiles);                        // Save for reuse                      info.ArtFiles = ddsfiles;                  }                    foreach (var dds in info.ArtFiles)                  {                      packPsarc.AddEntry(String.Format("gfxassets/album_art/album_{0}_{1}.dds"' dlcName' dds.sizeX)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                      if (dds.sizeY != 0)                      {                          TMPFILES_ART.Add(dds.destinationFile);                      }                  }                    // Lyric Art Texture                  if (File.Exists(info.LyricArtPath))                      packPsarc.AddEntry(String.Format("assets/ui/lyrics/{0}/lyrics_{0}.dds"' dlcName)' new FileStream(info.LyricArtPath' FileMode.Open' FileAccess.Read' FileShare.Read));                    // AUDIO                  var audioFile = info.OggPath;                  if (File.Exists(audioFile))                      if (platform.IsConsole != audioFile.GetAudioPlatform().IsConsole)                          soundStream = OggFile.ConvertAudioPlatform(audioFile);                      else                          soundStream = File.OpenRead(audioFile);                  else                      throw new InvalidOperationException(String.Format("Audio file '{0}' not found."' audioFile));                    // AUDIO PREVIEW                  var previewAudioFile = info.OggPreviewPath;                  if (File.Exists(previewAudioFile))                      if (platform.IsConsole != previewAudioFile.GetAudioPlatform().IsConsole)                          soundPreviewStream = OggFile.ConvertAudioPlatform(previewAudioFile);                      else                          soundPreviewStream = File.OpenRead(previewAudioFile);                  else                      soundPreviewStream = soundStream;                    // FLAT MODEL                  rsenumerableRootStream = new MemoryStream(Resources.rsenumerable_root);                  packPsarc.AddEntry("flatmodels/rs/rsenumerable_root.flat"' rsenumerableRootStream);                  rsenumerableSongStream = new MemoryStream(Resources.rsenumerable_song);                  packPsarc.AddEntry("flatmodels/rs/rsenumerable_song.flat"' rsenumerableSongStream);                    using (var toolkitVersionStream = new MemoryStream())                  using (var appIdStream = new MemoryStream())                  using (var packageListStream = new MemoryStream())                  using (var soundbankStream = new MemoryStream())                  using (var soundbankPreviewStream = new MemoryStream())                  using (var aggregateGraphStream = new MemoryStream())                  using (var manifestHeaderHSANStream = new MemoryStream())                  using (var manifestHeaderHSONStreamList = new DisposableCollection<Stream>())                  using (var manifestStreamList = new DisposableCollection<Stream>())                  using (var arrangementStream = new DisposableCollection<Stream>())                  using (var showlightStream = new MemoryStream())                  using (var xblockStream = new MemoryStream())                  {                      // TOOLKIT VERSION                      var stopHere = info;                      GenerateToolkitVersion(toolkitVersionStream' info.ToolkitInfo.PackageAuthor' info.ToolkitInfo.PackageVersion' info.ToolkitInfo.PackageComment);                      packPsarc.AddEntry("toolkit.version"' toolkitVersionStream);                        // APP ID                      if (!platform.IsConsole)                      {                          GenerateAppId(appIdStream' info.AppId' platform);                          packPsarc.AddEntry("appid.appid"' appIdStream);                      }                        if (platform.platform == GamePlatform.XBox360)                      {                          var packageListWriter = new StreamWriter(packageListStream);                          packageListWriter.Write(dlcName);                          packageListWriter.Flush();                          packageListStream.Seek(0' SeekOrigin.Begin);                          packageListStream.WriteTmpFile("PackageList.txt"' platform);                      }                        // SOUNDBANK                      var soundbankFileName = String.Format("song_{0}"' dlcName);                      var audioFileNameId = SoundBankGenerator2014.GenerateSoundBank(info.Name' soundStream' soundbankStream' info.Volume' platform);                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.bnk"' platform.GetPathName()[0].ToLower()' soundbankFileName)' soundbankStream);                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.wem"' platform.GetPathName()[0].ToLower()' audioFileNameId)' soundStream);                        // SOUNDBANK PREVIEW                      var soundbankPreviewFileName = String.Format("song_{0}_preview"' dlcName);                      dynamic audioPreviewFileNameId;                      var previewVolume = info.PreviewVolume ?? info.Volume;                      audioPreviewFileNameId = SoundBankGenerator2014.GenerateSoundBank(info.Name + "_Preview"' soundPreviewStream' soundbankPreviewStream' previewVolume' platform' true' !(File.Exists(previewAudioFile)));                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.bnk"' platform.GetPathName()[0].ToLower()' soundbankPreviewFileName)' soundbankPreviewStream);                      if (!soundPreviewStream.Equals(soundStream)) packPsarc.AddEntry(String.Format("audio/{0}/{1}.wem"' platform.GetPathName()[0].ToLower()' audioPreviewFileNameId)' soundPreviewStream);                        // AGGREGATE GRAPH                      var aggregateGraphFileName = String.Format("{0}_aggregategraph.nt"' dlcName);                      var aggregateGraph = new AggregateGraph2014.AggregateGraph2014(info' platform);                      aggregateGraph.Serialize(aggregateGraphStream);                      aggregateGraphStream.Flush();                      aggregateGraphStream.Seek(0' SeekOrigin.Begin);                      packPsarc.AddEntry(aggregateGraphFileName' aggregateGraphStream);                        var manifestHeader = new ManifestHeader2014<AttributesHeader2014>(platform);                      var songPartition = new SongPartition();                      var songPartitionCount = new SongPartition();                        foreach (var arrangement in info.Arrangements)                      {                          if (arrangement.ArrangementType == ArrangementType.ShowLight)                              continue;                            var arrangementFileName = songPartition.GetArrangementFileName(arrangement.Name' arrangement.ArrangementType).ToLower();                            // GAME SONG (SNG)                          UpdateToneDescriptors(info);                          GenerateSNG(arrangement' platform);                          var sngSongFile = File.OpenRead(arrangement.SongFile.File);                          arrangementStream.Add(sngSongFile);                          packPsarc.AddEntry(String.Format("songs/bin/{0}/{1}_{2}.sng"' platform.GetPathName()[1].ToLower()' dlcName' arrangementFileName)' sngSongFile);                            // XML SONG                          var xmlSongFile = File.OpenRead(arrangement.SongXml.File);                          arrangementStream.Add(xmlSongFile);                          packPsarc.AddEntry(String.Format("songs/arr/{0}_{1}.xml"' dlcName' arrangementFileName)' xmlSongFile);                            // MANIFEST                          var manifest = new Manifest2014<Attributes2014>();                          var attribute = new Attributes2014(arrangementFileName' arrangement' info' platform);                          if (arrangement.ArrangementType == ArrangementType.Bass || arrangement.ArrangementType == ArrangementType.Guitar)                          {                              // TODO: monitor this new code for bugs                              // represent is set to "1" by default' if there is a bonus then set represent to "0"                              attribute.Representative = arrangement.BonusArr ? 0 : 1;                              attribute.ArrangementProperties.Represent = arrangement.BonusArr ? 0 : 1;                                attribute.SongPartition = songPartitionCount.GetSongPartition(arrangement.Name' arrangement.ArrangementType);                              if (attribute.SongPartition > 1 && !arrangement.BonusArr)                              {                                  // for alternate arrangement then both represent and bonus are set to "0"                                  attribute.Representative = 0;                                  attribute.ArrangementProperties.Represent = 0;                              }                          }                            var attributeDictionary = new Dictionary<string' Attributes2014> { { "Attributes"' attribute } };                          manifest.Entries.Add(attribute.PersistentID' attributeDictionary);                          var manifestStream = new MemoryStream();                          manifestStreamList.Add(manifestStream);                          manifest.Serialize(manifestStream);                          manifestStream.Seek(0' SeekOrigin.Begin);                            const string jsonPathPC = "manifests/songs_dlc_{0}/{0}_{1}.json";                          const string jsonPathConsole = "manifests/songs_dlc/{0}_{1}.json";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? jsonPathConsole : jsonPathPC)' dlcName' arrangementFileName)' manifestStream);                            // MANIFEST HEADER                          var attributeHeaderDictionary = new Dictionary<string' AttributesHeader2014> { { "Attributes"' new AttributesHeader2014(attribute) } };                            if (platform.IsConsole)                          {                              // One for each arrangements (Xbox360/PS3)                              manifestHeader = new ManifestHeader2014<AttributesHeader2014>(platform);                              manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                              var manifestHeaderStream = new MemoryStream();                              manifestHeaderHSONStreamList.Add(manifestHeaderStream);                              manifestHeader.Serialize(manifestHeaderStream);                              manifestStream.Seek(0' SeekOrigin.Begin);                              packPsarc.AddEntry(String.Format("manifests/songs_dlc/{0}_{1}.hson"' dlcName' arrangementFileName)' manifestHeaderStream);                          }                          else                          {                              // One for all arrangements (PC/Mac)                              manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                          }                      }                        if (!platform.IsConsole)                      {                          manifestHeader.Serialize(manifestHeaderHSANStream);                          manifestHeaderHSANStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("manifests/songs_dlc_{0}/songs_dlc_{0}.hsan"' dlcName)' manifestHeaderHSANStream);                      }                        // XML SHOWLIGHTS                      var shlArr = info.Arrangements.FirstOrDefault(ar => ar.ArrangementType == ArrangementType.ShowLight);                      if (shlArr != null && shlArr.SongXml.File != null)                      {                          using (var fs = File.OpenRead(shlArr.SongXml.File))                              fs.CopyTo(showlightStream);                      }                      else                      {                          // Generate Showlights 'cst_showlights.xml'                          var showlight = new Showlights();                          showlight.CreateShowlights(info);                          // check for required minimum number of showlight elements                          if (showlight.ShowlightList.Count > 1)                          {                              showlight.Serialize(showlightStream);                              string shlFilePath = Path.Combine(Path.GetDirectoryName(info.Arrangements[0].SongXml.File)' String.Format("{0}_showlights.xml"' "cst"));                              using (FileStream file = new FileStream(shlFilePath' FileMode.Create' FileAccess.Write))                                  showlightStream.WriteTo(file);                                // write xml comments                              Song2014.WriteXmlComments(shlFilePath);                                // reload stream                              using (var fs = File.OpenRead(shlFilePath))                                  fs.CopyTo(showlightStream);                          }                          else                          {                              // insufficient showlight changes may crash game                              throw new InvalidOperationException("<ERROR> Insufficient showlight changes will crash game: " + showlight.ShowlightList.Count);                          }                      }                        if (showlightStream.CanRead && showlightStream.Length > 0)                          packPsarc.AddEntry(String.Format("songs/arr/{0}_showlights.xml"' dlcName)' showlightStream);                        // XBLOCK                      var game = GameXblock<Entity2014>.Generate2014(info' platform);                      game.SerializeXml(xblockStream);                      xblockStream.Flush();                      xblockStream.Seek(0' SeekOrigin.Begin);                      packPsarc.AddEntry(String.Format("gamexblocks/nsongs/{0}.xblock"' dlcName)' xblockStream);                        // WRITE PACKAGE                      packPsarc.Write(output' !platform.IsConsole);                      output.WriteTmpFile(String.Format("{0}.psarc"' dlcName)' platform);                  }              }              finally              {                  // Dispose all objects                  if (soundStream != null)                      soundStream.Dispose();                  if (soundPreviewStream != null)                      soundPreviewStream.Dispose();                  if (rsenumerableRootStream != null)                      rsenumerableRootStream.Dispose();                  if (rsenumerableSongStream != null)                      rsenumerableSongStream.Dispose();                  if (pnum <= 1)                      DeleteTmpFiles(TMPFILES_ART);                  DeleteTmpFiles(TMPFILES_SNG);              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The following statement contains a magic number: try              {                  // ALBUM ART                  if (info.ArtFiles == null)                  {                      //Try to get spreserved files                      string d256' d128' d64;                      if (File.Exists(info.AlbumArtPath))                      {                          d256 = info.AlbumArtPath;                          d128 = d256.Remove(d256.Length - 7) + "128.dds";                          d64 = d256.Remove(d256.Length - 7) + "64.dds";                          if (File.Exists(d64) && File.Exists(d128))                          {                              var _found = new List<DDSConvertedFile>                              {                                  new DDSConvertedFile() { sizeX = 64' destinationFile = d64 }'                                  new DDSConvertedFile() { sizeX = 128' destinationFile = d128 }'                                  new DDSConvertedFile() { sizeX = 256' destinationFile = d256 }                              };                              info.ArtFiles = _found;                          }                      }                  }                  if (info.ArtFiles == null)                  {                      //Generate art files                      string albumArtPath;                      var ddsfiles = info.ArtFiles;                      if (File.Exists(info.AlbumArtPath))                      {                          albumArtPath = info.AlbumArtPath;                      }                      else                      {                          using (var albumArtStream = new MemoryStream(Resources.albumart2014_256))                          {                              albumArtPath = GeneralExtensions.GetTempFileName(".dds");                              albumArtStream.WriteFile(albumArtPath);                              TMPFILES_ART.Add(albumArtPath);                          }                      }                        ddsfiles = new List<DDSConvertedFile>                      {                          new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }'                          new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }'                          new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }                      };                        // Convert to DDS                      ToDDS(ddsfiles);                        // Save for reuse                      info.ArtFiles = ddsfiles;                  }                    foreach (var dds in info.ArtFiles)                  {                      packPsarc.AddEntry(String.Format("gfxassets/album_art/album_{0}_{1}.dds"' dlcName' dds.sizeX)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                      if (dds.sizeY != 0)                      {                          TMPFILES_ART.Add(dds.destinationFile);                      }                  }                    // Lyric Art Texture                  if (File.Exists(info.LyricArtPath))                      packPsarc.AddEntry(String.Format("assets/ui/lyrics/{0}/lyrics_{0}.dds"' dlcName)' new FileStream(info.LyricArtPath' FileMode.Open' FileAccess.Read' FileShare.Read));                    // AUDIO                  var audioFile = info.OggPath;                  if (File.Exists(audioFile))                      if (platform.IsConsole != audioFile.GetAudioPlatform().IsConsole)                          soundStream = OggFile.ConvertAudioPlatform(audioFile);                      else                          soundStream = File.OpenRead(audioFile);                  else                      throw new InvalidOperationException(String.Format("Audio file '{0}' not found."' audioFile));                    // AUDIO PREVIEW                  var previewAudioFile = info.OggPreviewPath;                  if (File.Exists(previewAudioFile))                      if (platform.IsConsole != previewAudioFile.GetAudioPlatform().IsConsole)                          soundPreviewStream = OggFile.ConvertAudioPlatform(previewAudioFile);                      else                          soundPreviewStream = File.OpenRead(previewAudioFile);                  else                      soundPreviewStream = soundStream;                    // FLAT MODEL                  rsenumerableRootStream = new MemoryStream(Resources.rsenumerable_root);                  packPsarc.AddEntry("flatmodels/rs/rsenumerable_root.flat"' rsenumerableRootStream);                  rsenumerableSongStream = new MemoryStream(Resources.rsenumerable_song);                  packPsarc.AddEntry("flatmodels/rs/rsenumerable_song.flat"' rsenumerableSongStream);                    using (var toolkitVersionStream = new MemoryStream())                  using (var appIdStream = new MemoryStream())                  using (var packageListStream = new MemoryStream())                  using (var soundbankStream = new MemoryStream())                  using (var soundbankPreviewStream = new MemoryStream())                  using (var aggregateGraphStream = new MemoryStream())                  using (var manifestHeaderHSANStream = new MemoryStream())                  using (var manifestHeaderHSONStreamList = new DisposableCollection<Stream>())                  using (var manifestStreamList = new DisposableCollection<Stream>())                  using (var arrangementStream = new DisposableCollection<Stream>())                  using (var showlightStream = new MemoryStream())                  using (var xblockStream = new MemoryStream())                  {                      // TOOLKIT VERSION                      var stopHere = info;                      GenerateToolkitVersion(toolkitVersionStream' info.ToolkitInfo.PackageAuthor' info.ToolkitInfo.PackageVersion' info.ToolkitInfo.PackageComment);                      packPsarc.AddEntry("toolkit.version"' toolkitVersionStream);                        // APP ID                      if (!platform.IsConsole)                      {                          GenerateAppId(appIdStream' info.AppId' platform);                          packPsarc.AddEntry("appid.appid"' appIdStream);                      }                        if (platform.platform == GamePlatform.XBox360)                      {                          var packageListWriter = new StreamWriter(packageListStream);                          packageListWriter.Write(dlcName);                          packageListWriter.Flush();                          packageListStream.Seek(0' SeekOrigin.Begin);                          packageListStream.WriteTmpFile("PackageList.txt"' platform);                      }                        // SOUNDBANK                      var soundbankFileName = String.Format("song_{0}"' dlcName);                      var audioFileNameId = SoundBankGenerator2014.GenerateSoundBank(info.Name' soundStream' soundbankStream' info.Volume' platform);                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.bnk"' platform.GetPathName()[0].ToLower()' soundbankFileName)' soundbankStream);                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.wem"' platform.GetPathName()[0].ToLower()' audioFileNameId)' soundStream);                        // SOUNDBANK PREVIEW                      var soundbankPreviewFileName = String.Format("song_{0}_preview"' dlcName);                      dynamic audioPreviewFileNameId;                      var previewVolume = info.PreviewVolume ?? info.Volume;                      audioPreviewFileNameId = SoundBankGenerator2014.GenerateSoundBank(info.Name + "_Preview"' soundPreviewStream' soundbankPreviewStream' previewVolume' platform' true' !(File.Exists(previewAudioFile)));                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.bnk"' platform.GetPathName()[0].ToLower()' soundbankPreviewFileName)' soundbankPreviewStream);                      if (!soundPreviewStream.Equals(soundStream)) packPsarc.AddEntry(String.Format("audio/{0}/{1}.wem"' platform.GetPathName()[0].ToLower()' audioPreviewFileNameId)' soundPreviewStream);                        // AGGREGATE GRAPH                      var aggregateGraphFileName = String.Format("{0}_aggregategraph.nt"' dlcName);                      var aggregateGraph = new AggregateGraph2014.AggregateGraph2014(info' platform);                      aggregateGraph.Serialize(aggregateGraphStream);                      aggregateGraphStream.Flush();                      aggregateGraphStream.Seek(0' SeekOrigin.Begin);                      packPsarc.AddEntry(aggregateGraphFileName' aggregateGraphStream);                        var manifestHeader = new ManifestHeader2014<AttributesHeader2014>(platform);                      var songPartition = new SongPartition();                      var songPartitionCount = new SongPartition();                        foreach (var arrangement in info.Arrangements)                      {                          if (arrangement.ArrangementType == ArrangementType.ShowLight)                              continue;                            var arrangementFileName = songPartition.GetArrangementFileName(arrangement.Name' arrangement.ArrangementType).ToLower();                            // GAME SONG (SNG)                          UpdateToneDescriptors(info);                          GenerateSNG(arrangement' platform);                          var sngSongFile = File.OpenRead(arrangement.SongFile.File);                          arrangementStream.Add(sngSongFile);                          packPsarc.AddEntry(String.Format("songs/bin/{0}/{1}_{2}.sng"' platform.GetPathName()[1].ToLower()' dlcName' arrangementFileName)' sngSongFile);                            // XML SONG                          var xmlSongFile = File.OpenRead(arrangement.SongXml.File);                          arrangementStream.Add(xmlSongFile);                          packPsarc.AddEntry(String.Format("songs/arr/{0}_{1}.xml"' dlcName' arrangementFileName)' xmlSongFile);                            // MANIFEST                          var manifest = new Manifest2014<Attributes2014>();                          var attribute = new Attributes2014(arrangementFileName' arrangement' info' platform);                          if (arrangement.ArrangementType == ArrangementType.Bass || arrangement.ArrangementType == ArrangementType.Guitar)                          {                              // TODO: monitor this new code for bugs                              // represent is set to "1" by default' if there is a bonus then set represent to "0"                              attribute.Representative = arrangement.BonusArr ? 0 : 1;                              attribute.ArrangementProperties.Represent = arrangement.BonusArr ? 0 : 1;                                attribute.SongPartition = songPartitionCount.GetSongPartition(arrangement.Name' arrangement.ArrangementType);                              if (attribute.SongPartition > 1 && !arrangement.BonusArr)                              {                                  // for alternate arrangement then both represent and bonus are set to "0"                                  attribute.Representative = 0;                                  attribute.ArrangementProperties.Represent = 0;                              }                          }                            var attributeDictionary = new Dictionary<string' Attributes2014> { { "Attributes"' attribute } };                          manifest.Entries.Add(attribute.PersistentID' attributeDictionary);                          var manifestStream = new MemoryStream();                          manifestStreamList.Add(manifestStream);                          manifest.Serialize(manifestStream);                          manifestStream.Seek(0' SeekOrigin.Begin);                            const string jsonPathPC = "manifests/songs_dlc_{0}/{0}_{1}.json";                          const string jsonPathConsole = "manifests/songs_dlc/{0}_{1}.json";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? jsonPathConsole : jsonPathPC)' dlcName' arrangementFileName)' manifestStream);                            // MANIFEST HEADER                          var attributeHeaderDictionary = new Dictionary<string' AttributesHeader2014> { { "Attributes"' new AttributesHeader2014(attribute) } };                            if (platform.IsConsole)                          {                              // One for each arrangements (Xbox360/PS3)                              manifestHeader = new ManifestHeader2014<AttributesHeader2014>(platform);                              manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                              var manifestHeaderStream = new MemoryStream();                              manifestHeaderHSONStreamList.Add(manifestHeaderStream);                              manifestHeader.Serialize(manifestHeaderStream);                              manifestStream.Seek(0' SeekOrigin.Begin);                              packPsarc.AddEntry(String.Format("manifests/songs_dlc/{0}_{1}.hson"' dlcName' arrangementFileName)' manifestHeaderStream);                          }                          else                          {                              // One for all arrangements (PC/Mac)                              manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                          }                      }                        if (!platform.IsConsole)                      {                          manifestHeader.Serialize(manifestHeaderHSANStream);                          manifestHeaderHSANStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("manifests/songs_dlc_{0}/songs_dlc_{0}.hsan"' dlcName)' manifestHeaderHSANStream);                      }                        // XML SHOWLIGHTS                      var shlArr = info.Arrangements.FirstOrDefault(ar => ar.ArrangementType == ArrangementType.ShowLight);                      if (shlArr != null && shlArr.SongXml.File != null)                      {                          using (var fs = File.OpenRead(shlArr.SongXml.File))                              fs.CopyTo(showlightStream);                      }                      else                      {                          // Generate Showlights 'cst_showlights.xml'                          var showlight = new Showlights();                          showlight.CreateShowlights(info);                          // check for required minimum number of showlight elements                          if (showlight.ShowlightList.Count > 1)                          {                              showlight.Serialize(showlightStream);                              string shlFilePath = Path.Combine(Path.GetDirectoryName(info.Arrangements[0].SongXml.File)' String.Format("{0}_showlights.xml"' "cst"));                              using (FileStream file = new FileStream(shlFilePath' FileMode.Create' FileAccess.Write))                                  showlightStream.WriteTo(file);                                // write xml comments                              Song2014.WriteXmlComments(shlFilePath);                                // reload stream                              using (var fs = File.OpenRead(shlFilePath))                                  fs.CopyTo(showlightStream);                          }                          else                          {                              // insufficient showlight changes may crash game                              throw new InvalidOperationException("<ERROR> Insufficient showlight changes will crash game: " + showlight.ShowlightList.Count);                          }                      }                        if (showlightStream.CanRead && showlightStream.Length > 0)                          packPsarc.AddEntry(String.Format("songs/arr/{0}_showlights.xml"' dlcName)' showlightStream);                        // XBLOCK                      var game = GameXblock<Entity2014>.Generate2014(info' platform);                      game.SerializeXml(xblockStream);                      xblockStream.Flush();                      xblockStream.Seek(0' SeekOrigin.Begin);                      packPsarc.AddEntry(String.Format("gamexblocks/nsongs/{0}.xblock"' dlcName)' xblockStream);                        // WRITE PACKAGE                      packPsarc.Write(output' !platform.IsConsole);                      output.WriteTmpFile(String.Format("{0}.psarc"' dlcName)' platform);                  }              }              finally              {                  // Dispose all objects                  if (soundStream != null)                      soundStream.Dispose();                  if (soundPreviewStream != null)                      soundPreviewStream.Dispose();                  if (rsenumerableRootStream != null)                      rsenumerableRootStream.Dispose();                  if (rsenumerableSongStream != null)                      rsenumerableSongStream.Dispose();                  if (pnum <= 1)                      DeleteTmpFiles(TMPFILES_ART);                  DeleteTmpFiles(TMPFILES_SNG);              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The following statement contains a magic number: try              {                  // ALBUM ART                  if (info.ArtFiles == null)                  {                      //Try to get spreserved files                      string d256' d128' d64;                      if (File.Exists(info.AlbumArtPath))                      {                          d256 = info.AlbumArtPath;                          d128 = d256.Remove(d256.Length - 7) + "128.dds";                          d64 = d256.Remove(d256.Length - 7) + "64.dds";                          if (File.Exists(d64) && File.Exists(d128))                          {                              var _found = new List<DDSConvertedFile>                              {                                  new DDSConvertedFile() { sizeX = 64' destinationFile = d64 }'                                  new DDSConvertedFile() { sizeX = 128' destinationFile = d128 }'                                  new DDSConvertedFile() { sizeX = 256' destinationFile = d256 }                              };                              info.ArtFiles = _found;                          }                      }                  }                  if (info.ArtFiles == null)                  {                      //Generate art files                      string albumArtPath;                      var ddsfiles = info.ArtFiles;                      if (File.Exists(info.AlbumArtPath))                      {                          albumArtPath = info.AlbumArtPath;                      }                      else                      {                          using (var albumArtStream = new MemoryStream(Resources.albumart2014_256))                          {                              albumArtPath = GeneralExtensions.GetTempFileName(".dds");                              albumArtStream.WriteFile(albumArtPath);                              TMPFILES_ART.Add(albumArtPath);                          }                      }                        ddsfiles = new List<DDSConvertedFile>                      {                          new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }'                          new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }'                          new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }                      };                        // Convert to DDS                      ToDDS(ddsfiles);                        // Save for reuse                      info.ArtFiles = ddsfiles;                  }                    foreach (var dds in info.ArtFiles)                  {                      packPsarc.AddEntry(String.Format("gfxassets/album_art/album_{0}_{1}.dds"' dlcName' dds.sizeX)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                      if (dds.sizeY != 0)                      {                          TMPFILES_ART.Add(dds.destinationFile);                      }                  }                    // Lyric Art Texture                  if (File.Exists(info.LyricArtPath))                      packPsarc.AddEntry(String.Format("assets/ui/lyrics/{0}/lyrics_{0}.dds"' dlcName)' new FileStream(info.LyricArtPath' FileMode.Open' FileAccess.Read' FileShare.Read));                    // AUDIO                  var audioFile = info.OggPath;                  if (File.Exists(audioFile))                      if (platform.IsConsole != audioFile.GetAudioPlatform().IsConsole)                          soundStream = OggFile.ConvertAudioPlatform(audioFile);                      else                          soundStream = File.OpenRead(audioFile);                  else                      throw new InvalidOperationException(String.Format("Audio file '{0}' not found."' audioFile));                    // AUDIO PREVIEW                  var previewAudioFile = info.OggPreviewPath;                  if (File.Exists(previewAudioFile))                      if (platform.IsConsole != previewAudioFile.GetAudioPlatform().IsConsole)                          soundPreviewStream = OggFile.ConvertAudioPlatform(previewAudioFile);                      else                          soundPreviewStream = File.OpenRead(previewAudioFile);                  else                      soundPreviewStream = soundStream;                    // FLAT MODEL                  rsenumerableRootStream = new MemoryStream(Resources.rsenumerable_root);                  packPsarc.AddEntry("flatmodels/rs/rsenumerable_root.flat"' rsenumerableRootStream);                  rsenumerableSongStream = new MemoryStream(Resources.rsenumerable_song);                  packPsarc.AddEntry("flatmodels/rs/rsenumerable_song.flat"' rsenumerableSongStream);                    using (var toolkitVersionStream = new MemoryStream())                  using (var appIdStream = new MemoryStream())                  using (var packageListStream = new MemoryStream())                  using (var soundbankStream = new MemoryStream())                  using (var soundbankPreviewStream = new MemoryStream())                  using (var aggregateGraphStream = new MemoryStream())                  using (var manifestHeaderHSANStream = new MemoryStream())                  using (var manifestHeaderHSONStreamList = new DisposableCollection<Stream>())                  using (var manifestStreamList = new DisposableCollection<Stream>())                  using (var arrangementStream = new DisposableCollection<Stream>())                  using (var showlightStream = new MemoryStream())                  using (var xblockStream = new MemoryStream())                  {                      // TOOLKIT VERSION                      var stopHere = info;                      GenerateToolkitVersion(toolkitVersionStream' info.ToolkitInfo.PackageAuthor' info.ToolkitInfo.PackageVersion' info.ToolkitInfo.PackageComment);                      packPsarc.AddEntry("toolkit.version"' toolkitVersionStream);                        // APP ID                      if (!platform.IsConsole)                      {                          GenerateAppId(appIdStream' info.AppId' platform);                          packPsarc.AddEntry("appid.appid"' appIdStream);                      }                        if (platform.platform == GamePlatform.XBox360)                      {                          var packageListWriter = new StreamWriter(packageListStream);                          packageListWriter.Write(dlcName);                          packageListWriter.Flush();                          packageListStream.Seek(0' SeekOrigin.Begin);                          packageListStream.WriteTmpFile("PackageList.txt"' platform);                      }                        // SOUNDBANK                      var soundbankFileName = String.Format("song_{0}"' dlcName);                      var audioFileNameId = SoundBankGenerator2014.GenerateSoundBank(info.Name' soundStream' soundbankStream' info.Volume' platform);                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.bnk"' platform.GetPathName()[0].ToLower()' soundbankFileName)' soundbankStream);                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.wem"' platform.GetPathName()[0].ToLower()' audioFileNameId)' soundStream);                        // SOUNDBANK PREVIEW                      var soundbankPreviewFileName = String.Format("song_{0}_preview"' dlcName);                      dynamic audioPreviewFileNameId;                      var previewVolume = info.PreviewVolume ?? info.Volume;                      audioPreviewFileNameId = SoundBankGenerator2014.GenerateSoundBank(info.Name + "_Preview"' soundPreviewStream' soundbankPreviewStream' previewVolume' platform' true' !(File.Exists(previewAudioFile)));                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.bnk"' platform.GetPathName()[0].ToLower()' soundbankPreviewFileName)' soundbankPreviewStream);                      if (!soundPreviewStream.Equals(soundStream)) packPsarc.AddEntry(String.Format("audio/{0}/{1}.wem"' platform.GetPathName()[0].ToLower()' audioPreviewFileNameId)' soundPreviewStream);                        // AGGREGATE GRAPH                      var aggregateGraphFileName = String.Format("{0}_aggregategraph.nt"' dlcName);                      var aggregateGraph = new AggregateGraph2014.AggregateGraph2014(info' platform);                      aggregateGraph.Serialize(aggregateGraphStream);                      aggregateGraphStream.Flush();                      aggregateGraphStream.Seek(0' SeekOrigin.Begin);                      packPsarc.AddEntry(aggregateGraphFileName' aggregateGraphStream);                        var manifestHeader = new ManifestHeader2014<AttributesHeader2014>(platform);                      var songPartition = new SongPartition();                      var songPartitionCount = new SongPartition();                        foreach (var arrangement in info.Arrangements)                      {                          if (arrangement.ArrangementType == ArrangementType.ShowLight)                              continue;                            var arrangementFileName = songPartition.GetArrangementFileName(arrangement.Name' arrangement.ArrangementType).ToLower();                            // GAME SONG (SNG)                          UpdateToneDescriptors(info);                          GenerateSNG(arrangement' platform);                          var sngSongFile = File.OpenRead(arrangement.SongFile.File);                          arrangementStream.Add(sngSongFile);                          packPsarc.AddEntry(String.Format("songs/bin/{0}/{1}_{2}.sng"' platform.GetPathName()[1].ToLower()' dlcName' arrangementFileName)' sngSongFile);                            // XML SONG                          var xmlSongFile = File.OpenRead(arrangement.SongXml.File);                          arrangementStream.Add(xmlSongFile);                          packPsarc.AddEntry(String.Format("songs/arr/{0}_{1}.xml"' dlcName' arrangementFileName)' xmlSongFile);                            // MANIFEST                          var manifest = new Manifest2014<Attributes2014>();                          var attribute = new Attributes2014(arrangementFileName' arrangement' info' platform);                          if (arrangement.ArrangementType == ArrangementType.Bass || arrangement.ArrangementType == ArrangementType.Guitar)                          {                              // TODO: monitor this new code for bugs                              // represent is set to "1" by default' if there is a bonus then set represent to "0"                              attribute.Representative = arrangement.BonusArr ? 0 : 1;                              attribute.ArrangementProperties.Represent = arrangement.BonusArr ? 0 : 1;                                attribute.SongPartition = songPartitionCount.GetSongPartition(arrangement.Name' arrangement.ArrangementType);                              if (attribute.SongPartition > 1 && !arrangement.BonusArr)                              {                                  // for alternate arrangement then both represent and bonus are set to "0"                                  attribute.Representative = 0;                                  attribute.ArrangementProperties.Represent = 0;                              }                          }                            var attributeDictionary = new Dictionary<string' Attributes2014> { { "Attributes"' attribute } };                          manifest.Entries.Add(attribute.PersistentID' attributeDictionary);                          var manifestStream = new MemoryStream();                          manifestStreamList.Add(manifestStream);                          manifest.Serialize(manifestStream);                          manifestStream.Seek(0' SeekOrigin.Begin);                            const string jsonPathPC = "manifests/songs_dlc_{0}/{0}_{1}.json";                          const string jsonPathConsole = "manifests/songs_dlc/{0}_{1}.json";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? jsonPathConsole : jsonPathPC)' dlcName' arrangementFileName)' manifestStream);                            // MANIFEST HEADER                          var attributeHeaderDictionary = new Dictionary<string' AttributesHeader2014> { { "Attributes"' new AttributesHeader2014(attribute) } };                            if (platform.IsConsole)                          {                              // One for each arrangements (Xbox360/PS3)                              manifestHeader = new ManifestHeader2014<AttributesHeader2014>(platform);                              manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                              var manifestHeaderStream = new MemoryStream();                              manifestHeaderHSONStreamList.Add(manifestHeaderStream);                              manifestHeader.Serialize(manifestHeaderStream);                              manifestStream.Seek(0' SeekOrigin.Begin);                              packPsarc.AddEntry(String.Format("manifests/songs_dlc/{0}_{1}.hson"' dlcName' arrangementFileName)' manifestHeaderStream);                          }                          else                          {                              // One for all arrangements (PC/Mac)                              manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                          }                      }                        if (!platform.IsConsole)                      {                          manifestHeader.Serialize(manifestHeaderHSANStream);                          manifestHeaderHSANStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("manifests/songs_dlc_{0}/songs_dlc_{0}.hsan"' dlcName)' manifestHeaderHSANStream);                      }                        // XML SHOWLIGHTS                      var shlArr = info.Arrangements.FirstOrDefault(ar => ar.ArrangementType == ArrangementType.ShowLight);                      if (shlArr != null && shlArr.SongXml.File != null)                      {                          using (var fs = File.OpenRead(shlArr.SongXml.File))                              fs.CopyTo(showlightStream);                      }                      else                      {                          // Generate Showlights 'cst_showlights.xml'                          var showlight = new Showlights();                          showlight.CreateShowlights(info);                          // check for required minimum number of showlight elements                          if (showlight.ShowlightList.Count > 1)                          {                              showlight.Serialize(showlightStream);                              string shlFilePath = Path.Combine(Path.GetDirectoryName(info.Arrangements[0].SongXml.File)' String.Format("{0}_showlights.xml"' "cst"));                              using (FileStream file = new FileStream(shlFilePath' FileMode.Create' FileAccess.Write))                                  showlightStream.WriteTo(file);                                // write xml comments                              Song2014.WriteXmlComments(shlFilePath);                                // reload stream                              using (var fs = File.OpenRead(shlFilePath))                                  fs.CopyTo(showlightStream);                          }                          else                          {                              // insufficient showlight changes may crash game                              throw new InvalidOperationException("<ERROR> Insufficient showlight changes will crash game: " + showlight.ShowlightList.Count);                          }                      }                        if (showlightStream.CanRead && showlightStream.Length > 0)                          packPsarc.AddEntry(String.Format("songs/arr/{0}_showlights.xml"' dlcName)' showlightStream);                        // XBLOCK                      var game = GameXblock<Entity2014>.Generate2014(info' platform);                      game.SerializeXml(xblockStream);                      xblockStream.Flush();                      xblockStream.Seek(0' SeekOrigin.Begin);                      packPsarc.AddEntry(String.Format("gamexblocks/nsongs/{0}.xblock"' dlcName)' xblockStream);                        // WRITE PACKAGE                      packPsarc.Write(output' !platform.IsConsole);                      output.WriteTmpFile(String.Format("{0}.psarc"' dlcName)' platform);                  }              }              finally              {                  // Dispose all objects                  if (soundStream != null)                      soundStream.Dispose();                  if (soundPreviewStream != null)                      soundPreviewStream.Dispose();                  if (rsenumerableRootStream != null)                      rsenumerableRootStream.Dispose();                  if (rsenumerableSongStream != null)                      rsenumerableSongStream.Dispose();                  if (pnum <= 1)                      DeleteTmpFiles(TMPFILES_ART);                  DeleteTmpFiles(TMPFILES_SNG);              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The following statement contains a magic number: try              {                  // ALBUM ART                  if (info.ArtFiles == null)                  {                      //Try to get spreserved files                      string d256' d128' d64;                      if (File.Exists(info.AlbumArtPath))                      {                          d256 = info.AlbumArtPath;                          d128 = d256.Remove(d256.Length - 7) + "128.dds";                          d64 = d256.Remove(d256.Length - 7) + "64.dds";                          if (File.Exists(d64) && File.Exists(d128))                          {                              var _found = new List<DDSConvertedFile>                              {                                  new DDSConvertedFile() { sizeX = 64' destinationFile = d64 }'                                  new DDSConvertedFile() { sizeX = 128' destinationFile = d128 }'                                  new DDSConvertedFile() { sizeX = 256' destinationFile = d256 }                              };                              info.ArtFiles = _found;                          }                      }                  }                  if (info.ArtFiles == null)                  {                      //Generate art files                      string albumArtPath;                      var ddsfiles = info.ArtFiles;                      if (File.Exists(info.AlbumArtPath))                      {                          albumArtPath = info.AlbumArtPath;                      }                      else                      {                          using (var albumArtStream = new MemoryStream(Resources.albumart2014_256))                          {                              albumArtPath = GeneralExtensions.GetTempFileName(".dds");                              albumArtStream.WriteFile(albumArtPath);                              TMPFILES_ART.Add(albumArtPath);                          }                      }                        ddsfiles = new List<DDSConvertedFile>                      {                          new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }'                          new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }'                          new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }                      };                        // Convert to DDS                      ToDDS(ddsfiles);                        // Save for reuse                      info.ArtFiles = ddsfiles;                  }                    foreach (var dds in info.ArtFiles)                  {                      packPsarc.AddEntry(String.Format("gfxassets/album_art/album_{0}_{1}.dds"' dlcName' dds.sizeX)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                      if (dds.sizeY != 0)                      {                          TMPFILES_ART.Add(dds.destinationFile);                      }                  }                    // Lyric Art Texture                  if (File.Exists(info.LyricArtPath))                      packPsarc.AddEntry(String.Format("assets/ui/lyrics/{0}/lyrics_{0}.dds"' dlcName)' new FileStream(info.LyricArtPath' FileMode.Open' FileAccess.Read' FileShare.Read));                    // AUDIO                  var audioFile = info.OggPath;                  if (File.Exists(audioFile))                      if (platform.IsConsole != audioFile.GetAudioPlatform().IsConsole)                          soundStream = OggFile.ConvertAudioPlatform(audioFile);                      else                          soundStream = File.OpenRead(audioFile);                  else                      throw new InvalidOperationException(String.Format("Audio file '{0}' not found."' audioFile));                    // AUDIO PREVIEW                  var previewAudioFile = info.OggPreviewPath;                  if (File.Exists(previewAudioFile))                      if (platform.IsConsole != previewAudioFile.GetAudioPlatform().IsConsole)                          soundPreviewStream = OggFile.ConvertAudioPlatform(previewAudioFile);                      else                          soundPreviewStream = File.OpenRead(previewAudioFile);                  else                      soundPreviewStream = soundStream;                    // FLAT MODEL                  rsenumerableRootStream = new MemoryStream(Resources.rsenumerable_root);                  packPsarc.AddEntry("flatmodels/rs/rsenumerable_root.flat"' rsenumerableRootStream);                  rsenumerableSongStream = new MemoryStream(Resources.rsenumerable_song);                  packPsarc.AddEntry("flatmodels/rs/rsenumerable_song.flat"' rsenumerableSongStream);                    using (var toolkitVersionStream = new MemoryStream())                  using (var appIdStream = new MemoryStream())                  using (var packageListStream = new MemoryStream())                  using (var soundbankStream = new MemoryStream())                  using (var soundbankPreviewStream = new MemoryStream())                  using (var aggregateGraphStream = new MemoryStream())                  using (var manifestHeaderHSANStream = new MemoryStream())                  using (var manifestHeaderHSONStreamList = new DisposableCollection<Stream>())                  using (var manifestStreamList = new DisposableCollection<Stream>())                  using (var arrangementStream = new DisposableCollection<Stream>())                  using (var showlightStream = new MemoryStream())                  using (var xblockStream = new MemoryStream())                  {                      // TOOLKIT VERSION                      var stopHere = info;                      GenerateToolkitVersion(toolkitVersionStream' info.ToolkitInfo.PackageAuthor' info.ToolkitInfo.PackageVersion' info.ToolkitInfo.PackageComment);                      packPsarc.AddEntry("toolkit.version"' toolkitVersionStream);                        // APP ID                      if (!platform.IsConsole)                      {                          GenerateAppId(appIdStream' info.AppId' platform);                          packPsarc.AddEntry("appid.appid"' appIdStream);                      }                        if (platform.platform == GamePlatform.XBox360)                      {                          var packageListWriter = new StreamWriter(packageListStream);                          packageListWriter.Write(dlcName);                          packageListWriter.Flush();                          packageListStream.Seek(0' SeekOrigin.Begin);                          packageListStream.WriteTmpFile("PackageList.txt"' platform);                      }                        // SOUNDBANK                      var soundbankFileName = String.Format("song_{0}"' dlcName);                      var audioFileNameId = SoundBankGenerator2014.GenerateSoundBank(info.Name' soundStream' soundbankStream' info.Volume' platform);                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.bnk"' platform.GetPathName()[0].ToLower()' soundbankFileName)' soundbankStream);                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.wem"' platform.GetPathName()[0].ToLower()' audioFileNameId)' soundStream);                        // SOUNDBANK PREVIEW                      var soundbankPreviewFileName = String.Format("song_{0}_preview"' dlcName);                      dynamic audioPreviewFileNameId;                      var previewVolume = info.PreviewVolume ?? info.Volume;                      audioPreviewFileNameId = SoundBankGenerator2014.GenerateSoundBank(info.Name + "_Preview"' soundPreviewStream' soundbankPreviewStream' previewVolume' platform' true' !(File.Exists(previewAudioFile)));                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.bnk"' platform.GetPathName()[0].ToLower()' soundbankPreviewFileName)' soundbankPreviewStream);                      if (!soundPreviewStream.Equals(soundStream)) packPsarc.AddEntry(String.Format("audio/{0}/{1}.wem"' platform.GetPathName()[0].ToLower()' audioPreviewFileNameId)' soundPreviewStream);                        // AGGREGATE GRAPH                      var aggregateGraphFileName = String.Format("{0}_aggregategraph.nt"' dlcName);                      var aggregateGraph = new AggregateGraph2014.AggregateGraph2014(info' platform);                      aggregateGraph.Serialize(aggregateGraphStream);                      aggregateGraphStream.Flush();                      aggregateGraphStream.Seek(0' SeekOrigin.Begin);                      packPsarc.AddEntry(aggregateGraphFileName' aggregateGraphStream);                        var manifestHeader = new ManifestHeader2014<AttributesHeader2014>(platform);                      var songPartition = new SongPartition();                      var songPartitionCount = new SongPartition();                        foreach (var arrangement in info.Arrangements)                      {                          if (arrangement.ArrangementType == ArrangementType.ShowLight)                              continue;                            var arrangementFileName = songPartition.GetArrangementFileName(arrangement.Name' arrangement.ArrangementType).ToLower();                            // GAME SONG (SNG)                          UpdateToneDescriptors(info);                          GenerateSNG(arrangement' platform);                          var sngSongFile = File.OpenRead(arrangement.SongFile.File);                          arrangementStream.Add(sngSongFile);                          packPsarc.AddEntry(String.Format("songs/bin/{0}/{1}_{2}.sng"' platform.GetPathName()[1].ToLower()' dlcName' arrangementFileName)' sngSongFile);                            // XML SONG                          var xmlSongFile = File.OpenRead(arrangement.SongXml.File);                          arrangementStream.Add(xmlSongFile);                          packPsarc.AddEntry(String.Format("songs/arr/{0}_{1}.xml"' dlcName' arrangementFileName)' xmlSongFile);                            // MANIFEST                          var manifest = new Manifest2014<Attributes2014>();                          var attribute = new Attributes2014(arrangementFileName' arrangement' info' platform);                          if (arrangement.ArrangementType == ArrangementType.Bass || arrangement.ArrangementType == ArrangementType.Guitar)                          {                              // TODO: monitor this new code for bugs                              // represent is set to "1" by default' if there is a bonus then set represent to "0"                              attribute.Representative = arrangement.BonusArr ? 0 : 1;                              attribute.ArrangementProperties.Represent = arrangement.BonusArr ? 0 : 1;                                attribute.SongPartition = songPartitionCount.GetSongPartition(arrangement.Name' arrangement.ArrangementType);                              if (attribute.SongPartition > 1 && !arrangement.BonusArr)                              {                                  // for alternate arrangement then both represent and bonus are set to "0"                                  attribute.Representative = 0;                                  attribute.ArrangementProperties.Represent = 0;                              }                          }                            var attributeDictionary = new Dictionary<string' Attributes2014> { { "Attributes"' attribute } };                          manifest.Entries.Add(attribute.PersistentID' attributeDictionary);                          var manifestStream = new MemoryStream();                          manifestStreamList.Add(manifestStream);                          manifest.Serialize(manifestStream);                          manifestStream.Seek(0' SeekOrigin.Begin);                            const string jsonPathPC = "manifests/songs_dlc_{0}/{0}_{1}.json";                          const string jsonPathConsole = "manifests/songs_dlc/{0}_{1}.json";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? jsonPathConsole : jsonPathPC)' dlcName' arrangementFileName)' manifestStream);                            // MANIFEST HEADER                          var attributeHeaderDictionary = new Dictionary<string' AttributesHeader2014> { { "Attributes"' new AttributesHeader2014(attribute) } };                            if (platform.IsConsole)                          {                              // One for each arrangements (Xbox360/PS3)                              manifestHeader = new ManifestHeader2014<AttributesHeader2014>(platform);                              manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                              var manifestHeaderStream = new MemoryStream();                              manifestHeaderHSONStreamList.Add(manifestHeaderStream);                              manifestHeader.Serialize(manifestHeaderStream);                              manifestStream.Seek(0' SeekOrigin.Begin);                              packPsarc.AddEntry(String.Format("manifests/songs_dlc/{0}_{1}.hson"' dlcName' arrangementFileName)' manifestHeaderStream);                          }                          else                          {                              // One for all arrangements (PC/Mac)                              manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                          }                      }                        if (!platform.IsConsole)                      {                          manifestHeader.Serialize(manifestHeaderHSANStream);                          manifestHeaderHSANStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("manifests/songs_dlc_{0}/songs_dlc_{0}.hsan"' dlcName)' manifestHeaderHSANStream);                      }                        // XML SHOWLIGHTS                      var shlArr = info.Arrangements.FirstOrDefault(ar => ar.ArrangementType == ArrangementType.ShowLight);                      if (shlArr != null && shlArr.SongXml.File != null)                      {                          using (var fs = File.OpenRead(shlArr.SongXml.File))                              fs.CopyTo(showlightStream);                      }                      else                      {                          // Generate Showlights 'cst_showlights.xml'                          var showlight = new Showlights();                          showlight.CreateShowlights(info);                          // check for required minimum number of showlight elements                          if (showlight.ShowlightList.Count > 1)                          {                              showlight.Serialize(showlightStream);                              string shlFilePath = Path.Combine(Path.GetDirectoryName(info.Arrangements[0].SongXml.File)' String.Format("{0}_showlights.xml"' "cst"));                              using (FileStream file = new FileStream(shlFilePath' FileMode.Create' FileAccess.Write))                                  showlightStream.WriteTo(file);                                // write xml comments                              Song2014.WriteXmlComments(shlFilePath);                                // reload stream                              using (var fs = File.OpenRead(shlFilePath))                                  fs.CopyTo(showlightStream);                          }                          else                          {                              // insufficient showlight changes may crash game                              throw new InvalidOperationException("<ERROR> Insufficient showlight changes will crash game: " + showlight.ShowlightList.Count);                          }                      }                        if (showlightStream.CanRead && showlightStream.Length > 0)                          packPsarc.AddEntry(String.Format("songs/arr/{0}_showlights.xml"' dlcName)' showlightStream);                        // XBLOCK                      var game = GameXblock<Entity2014>.Generate2014(info' platform);                      game.SerializeXml(xblockStream);                      xblockStream.Flush();                      xblockStream.Seek(0' SeekOrigin.Begin);                      packPsarc.AddEntry(String.Format("gamexblocks/nsongs/{0}.xblock"' dlcName)' xblockStream);                        // WRITE PACKAGE                      packPsarc.Write(output' !platform.IsConsole);                      output.WriteTmpFile(String.Format("{0}.psarc"' dlcName)' platform);                  }              }              finally              {                  // Dispose all objects                  if (soundStream != null)                      soundStream.Dispose();                  if (soundPreviewStream != null)                      soundPreviewStream.Dispose();                  if (rsenumerableRootStream != null)                      rsenumerableRootStream.Dispose();                  if (rsenumerableSongStream != null)                      rsenumerableSongStream.Dispose();                  if (pnum <= 1)                      DeleteTmpFiles(TMPFILES_ART);                  DeleteTmpFiles(TMPFILES_SNG);              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The following statement contains a magic number: try              {                  // ALBUM ART                  if (info.ArtFiles == null)                  {                      //Try to get spreserved files                      string d256' d128' d64;                      if (File.Exists(info.AlbumArtPath))                      {                          d256 = info.AlbumArtPath;                          d128 = d256.Remove(d256.Length - 7) + "128.dds";                          d64 = d256.Remove(d256.Length - 7) + "64.dds";                          if (File.Exists(d64) && File.Exists(d128))                          {                              var _found = new List<DDSConvertedFile>                              {                                  new DDSConvertedFile() { sizeX = 64' destinationFile = d64 }'                                  new DDSConvertedFile() { sizeX = 128' destinationFile = d128 }'                                  new DDSConvertedFile() { sizeX = 256' destinationFile = d256 }                              };                              info.ArtFiles = _found;                          }                      }                  }                  if (info.ArtFiles == null)                  {                      //Generate art files                      string albumArtPath;                      var ddsfiles = info.ArtFiles;                      if (File.Exists(info.AlbumArtPath))                      {                          albumArtPath = info.AlbumArtPath;                      }                      else                      {                          using (var albumArtStream = new MemoryStream(Resources.albumart2014_256))                          {                              albumArtPath = GeneralExtensions.GetTempFileName(".dds");                              albumArtStream.WriteFile(albumArtPath);                              TMPFILES_ART.Add(albumArtPath);                          }                      }                        ddsfiles = new List<DDSConvertedFile>                      {                          new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }'                          new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }'                          new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }                      };                        // Convert to DDS                      ToDDS(ddsfiles);                        // Save for reuse                      info.ArtFiles = ddsfiles;                  }                    foreach (var dds in info.ArtFiles)                  {                      packPsarc.AddEntry(String.Format("gfxassets/album_art/album_{0}_{1}.dds"' dlcName' dds.sizeX)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                      if (dds.sizeY != 0)                      {                          TMPFILES_ART.Add(dds.destinationFile);                      }                  }                    // Lyric Art Texture                  if (File.Exists(info.LyricArtPath))                      packPsarc.AddEntry(String.Format("assets/ui/lyrics/{0}/lyrics_{0}.dds"' dlcName)' new FileStream(info.LyricArtPath' FileMode.Open' FileAccess.Read' FileShare.Read));                    // AUDIO                  var audioFile = info.OggPath;                  if (File.Exists(audioFile))                      if (platform.IsConsole != audioFile.GetAudioPlatform().IsConsole)                          soundStream = OggFile.ConvertAudioPlatform(audioFile);                      else                          soundStream = File.OpenRead(audioFile);                  else                      throw new InvalidOperationException(String.Format("Audio file '{0}' not found."' audioFile));                    // AUDIO PREVIEW                  var previewAudioFile = info.OggPreviewPath;                  if (File.Exists(previewAudioFile))                      if (platform.IsConsole != previewAudioFile.GetAudioPlatform().IsConsole)                          soundPreviewStream = OggFile.ConvertAudioPlatform(previewAudioFile);                      else                          soundPreviewStream = File.OpenRead(previewAudioFile);                  else                      soundPreviewStream = soundStream;                    // FLAT MODEL                  rsenumerableRootStream = new MemoryStream(Resources.rsenumerable_root);                  packPsarc.AddEntry("flatmodels/rs/rsenumerable_root.flat"' rsenumerableRootStream);                  rsenumerableSongStream = new MemoryStream(Resources.rsenumerable_song);                  packPsarc.AddEntry("flatmodels/rs/rsenumerable_song.flat"' rsenumerableSongStream);                    using (var toolkitVersionStream = new MemoryStream())                  using (var appIdStream = new MemoryStream())                  using (var packageListStream = new MemoryStream())                  using (var soundbankStream = new MemoryStream())                  using (var soundbankPreviewStream = new MemoryStream())                  using (var aggregateGraphStream = new MemoryStream())                  using (var manifestHeaderHSANStream = new MemoryStream())                  using (var manifestHeaderHSONStreamList = new DisposableCollection<Stream>())                  using (var manifestStreamList = new DisposableCollection<Stream>())                  using (var arrangementStream = new DisposableCollection<Stream>())                  using (var showlightStream = new MemoryStream())                  using (var xblockStream = new MemoryStream())                  {                      // TOOLKIT VERSION                      var stopHere = info;                      GenerateToolkitVersion(toolkitVersionStream' info.ToolkitInfo.PackageAuthor' info.ToolkitInfo.PackageVersion' info.ToolkitInfo.PackageComment);                      packPsarc.AddEntry("toolkit.version"' toolkitVersionStream);                        // APP ID                      if (!platform.IsConsole)                      {                          GenerateAppId(appIdStream' info.AppId' platform);                          packPsarc.AddEntry("appid.appid"' appIdStream);                      }                        if (platform.platform == GamePlatform.XBox360)                      {                          var packageListWriter = new StreamWriter(packageListStream);                          packageListWriter.Write(dlcName);                          packageListWriter.Flush();                          packageListStream.Seek(0' SeekOrigin.Begin);                          packageListStream.WriteTmpFile("PackageList.txt"' platform);                      }                        // SOUNDBANK                      var soundbankFileName = String.Format("song_{0}"' dlcName);                      var audioFileNameId = SoundBankGenerator2014.GenerateSoundBank(info.Name' soundStream' soundbankStream' info.Volume' platform);                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.bnk"' platform.GetPathName()[0].ToLower()' soundbankFileName)' soundbankStream);                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.wem"' platform.GetPathName()[0].ToLower()' audioFileNameId)' soundStream);                        // SOUNDBANK PREVIEW                      var soundbankPreviewFileName = String.Format("song_{0}_preview"' dlcName);                      dynamic audioPreviewFileNameId;                      var previewVolume = info.PreviewVolume ?? info.Volume;                      audioPreviewFileNameId = SoundBankGenerator2014.GenerateSoundBank(info.Name + "_Preview"' soundPreviewStream' soundbankPreviewStream' previewVolume' platform' true' !(File.Exists(previewAudioFile)));                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.bnk"' platform.GetPathName()[0].ToLower()' soundbankPreviewFileName)' soundbankPreviewStream);                      if (!soundPreviewStream.Equals(soundStream)) packPsarc.AddEntry(String.Format("audio/{0}/{1}.wem"' platform.GetPathName()[0].ToLower()' audioPreviewFileNameId)' soundPreviewStream);                        // AGGREGATE GRAPH                      var aggregateGraphFileName = String.Format("{0}_aggregategraph.nt"' dlcName);                      var aggregateGraph = new AggregateGraph2014.AggregateGraph2014(info' platform);                      aggregateGraph.Serialize(aggregateGraphStream);                      aggregateGraphStream.Flush();                      aggregateGraphStream.Seek(0' SeekOrigin.Begin);                      packPsarc.AddEntry(aggregateGraphFileName' aggregateGraphStream);                        var manifestHeader = new ManifestHeader2014<AttributesHeader2014>(platform);                      var songPartition = new SongPartition();                      var songPartitionCount = new SongPartition();                        foreach (var arrangement in info.Arrangements)                      {                          if (arrangement.ArrangementType == ArrangementType.ShowLight)                              continue;                            var arrangementFileName = songPartition.GetArrangementFileName(arrangement.Name' arrangement.ArrangementType).ToLower();                            // GAME SONG (SNG)                          UpdateToneDescriptors(info);                          GenerateSNG(arrangement' platform);                          var sngSongFile = File.OpenRead(arrangement.SongFile.File);                          arrangementStream.Add(sngSongFile);                          packPsarc.AddEntry(String.Format("songs/bin/{0}/{1}_{2}.sng"' platform.GetPathName()[1].ToLower()' dlcName' arrangementFileName)' sngSongFile);                            // XML SONG                          var xmlSongFile = File.OpenRead(arrangement.SongXml.File);                          arrangementStream.Add(xmlSongFile);                          packPsarc.AddEntry(String.Format("songs/arr/{0}_{1}.xml"' dlcName' arrangementFileName)' xmlSongFile);                            // MANIFEST                          var manifest = new Manifest2014<Attributes2014>();                          var attribute = new Attributes2014(arrangementFileName' arrangement' info' platform);                          if (arrangement.ArrangementType == ArrangementType.Bass || arrangement.ArrangementType == ArrangementType.Guitar)                          {                              // TODO: monitor this new code for bugs                              // represent is set to "1" by default' if there is a bonus then set represent to "0"                              attribute.Representative = arrangement.BonusArr ? 0 : 1;                              attribute.ArrangementProperties.Represent = arrangement.BonusArr ? 0 : 1;                                attribute.SongPartition = songPartitionCount.GetSongPartition(arrangement.Name' arrangement.ArrangementType);                              if (attribute.SongPartition > 1 && !arrangement.BonusArr)                              {                                  // for alternate arrangement then both represent and bonus are set to "0"                                  attribute.Representative = 0;                                  attribute.ArrangementProperties.Represent = 0;                              }                          }                            var attributeDictionary = new Dictionary<string' Attributes2014> { { "Attributes"' attribute } };                          manifest.Entries.Add(attribute.PersistentID' attributeDictionary);                          var manifestStream = new MemoryStream();                          manifestStreamList.Add(manifestStream);                          manifest.Serialize(manifestStream);                          manifestStream.Seek(0' SeekOrigin.Begin);                            const string jsonPathPC = "manifests/songs_dlc_{0}/{0}_{1}.json";                          const string jsonPathConsole = "manifests/songs_dlc/{0}_{1}.json";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? jsonPathConsole : jsonPathPC)' dlcName' arrangementFileName)' manifestStream);                            // MANIFEST HEADER                          var attributeHeaderDictionary = new Dictionary<string' AttributesHeader2014> { { "Attributes"' new AttributesHeader2014(attribute) } };                            if (platform.IsConsole)                          {                              // One for each arrangements (Xbox360/PS3)                              manifestHeader = new ManifestHeader2014<AttributesHeader2014>(platform);                              manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                              var manifestHeaderStream = new MemoryStream();                              manifestHeaderHSONStreamList.Add(manifestHeaderStream);                              manifestHeader.Serialize(manifestHeaderStream);                              manifestStream.Seek(0' SeekOrigin.Begin);                              packPsarc.AddEntry(String.Format("manifests/songs_dlc/{0}_{1}.hson"' dlcName' arrangementFileName)' manifestHeaderStream);                          }                          else                          {                              // One for all arrangements (PC/Mac)                              manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                          }                      }                        if (!platform.IsConsole)                      {                          manifestHeader.Serialize(manifestHeaderHSANStream);                          manifestHeaderHSANStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("manifests/songs_dlc_{0}/songs_dlc_{0}.hsan"' dlcName)' manifestHeaderHSANStream);                      }                        // XML SHOWLIGHTS                      var shlArr = info.Arrangements.FirstOrDefault(ar => ar.ArrangementType == ArrangementType.ShowLight);                      if (shlArr != null && shlArr.SongXml.File != null)                      {                          using (var fs = File.OpenRead(shlArr.SongXml.File))                              fs.CopyTo(showlightStream);                      }                      else                      {                          // Generate Showlights 'cst_showlights.xml'                          var showlight = new Showlights();                          showlight.CreateShowlights(info);                          // check for required minimum number of showlight elements                          if (showlight.ShowlightList.Count > 1)                          {                              showlight.Serialize(showlightStream);                              string shlFilePath = Path.Combine(Path.GetDirectoryName(info.Arrangements[0].SongXml.File)' String.Format("{0}_showlights.xml"' "cst"));                              using (FileStream file = new FileStream(shlFilePath' FileMode.Create' FileAccess.Write))                                  showlightStream.WriteTo(file);                                // write xml comments                              Song2014.WriteXmlComments(shlFilePath);                                // reload stream                              using (var fs = File.OpenRead(shlFilePath))                                  fs.CopyTo(showlightStream);                          }                          else                          {                              // insufficient showlight changes may crash game                              throw new InvalidOperationException("<ERROR> Insufficient showlight changes will crash game: " + showlight.ShowlightList.Count);                          }                      }                        if (showlightStream.CanRead && showlightStream.Length > 0)                          packPsarc.AddEntry(String.Format("songs/arr/{0}_showlights.xml"' dlcName)' showlightStream);                        // XBLOCK                      var game = GameXblock<Entity2014>.Generate2014(info' platform);                      game.SerializeXml(xblockStream);                      xblockStream.Flush();                      xblockStream.Seek(0' SeekOrigin.Begin);                      packPsarc.AddEntry(String.Format("gamexblocks/nsongs/{0}.xblock"' dlcName)' xblockStream);                        // WRITE PACKAGE                      packPsarc.Write(output' !platform.IsConsole);                      output.WriteTmpFile(String.Format("{0}.psarc"' dlcName)' platform);                  }              }              finally              {                  // Dispose all objects                  if (soundStream != null)                      soundStream.Dispose();                  if (soundPreviewStream != null)                      soundPreviewStream.Dispose();                  if (rsenumerableRootStream != null)                      rsenumerableRootStream.Dispose();                  if (rsenumerableSongStream != null)                      rsenumerableSongStream.Dispose();                  if (pnum <= 1)                      DeleteTmpFiles(TMPFILES_ART);                  DeleteTmpFiles(TMPFILES_SNG);              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The following statement contains a magic number: try              {                  // ALBUM ART                  if (info.ArtFiles == null)                  {                      //Try to get spreserved files                      string d256' d128' d64;                      if (File.Exists(info.AlbumArtPath))                      {                          d256 = info.AlbumArtPath;                          d128 = d256.Remove(d256.Length - 7) + "128.dds";                          d64 = d256.Remove(d256.Length - 7) + "64.dds";                          if (File.Exists(d64) && File.Exists(d128))                          {                              var _found = new List<DDSConvertedFile>                              {                                  new DDSConvertedFile() { sizeX = 64' destinationFile = d64 }'                                  new DDSConvertedFile() { sizeX = 128' destinationFile = d128 }'                                  new DDSConvertedFile() { sizeX = 256' destinationFile = d256 }                              };                              info.ArtFiles = _found;                          }                      }                  }                  if (info.ArtFiles == null)                  {                      //Generate art files                      string albumArtPath;                      var ddsfiles = info.ArtFiles;                      if (File.Exists(info.AlbumArtPath))                      {                          albumArtPath = info.AlbumArtPath;                      }                      else                      {                          using (var albumArtStream = new MemoryStream(Resources.albumart2014_256))                          {                              albumArtPath = GeneralExtensions.GetTempFileName(".dds");                              albumArtStream.WriteFile(albumArtPath);                              TMPFILES_ART.Add(albumArtPath);                          }                      }                        ddsfiles = new List<DDSConvertedFile>                      {                          new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }'                          new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }'                          new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }                      };                        // Convert to DDS                      ToDDS(ddsfiles);                        // Save for reuse                      info.ArtFiles = ddsfiles;                  }                    foreach (var dds in info.ArtFiles)                  {                      packPsarc.AddEntry(String.Format("gfxassets/album_art/album_{0}_{1}.dds"' dlcName' dds.sizeX)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                      if (dds.sizeY != 0)                      {                          TMPFILES_ART.Add(dds.destinationFile);                      }                  }                    // Lyric Art Texture                  if (File.Exists(info.LyricArtPath))                      packPsarc.AddEntry(String.Format("assets/ui/lyrics/{0}/lyrics_{0}.dds"' dlcName)' new FileStream(info.LyricArtPath' FileMode.Open' FileAccess.Read' FileShare.Read));                    // AUDIO                  var audioFile = info.OggPath;                  if (File.Exists(audioFile))                      if (platform.IsConsole != audioFile.GetAudioPlatform().IsConsole)                          soundStream = OggFile.ConvertAudioPlatform(audioFile);                      else                          soundStream = File.OpenRead(audioFile);                  else                      throw new InvalidOperationException(String.Format("Audio file '{0}' not found."' audioFile));                    // AUDIO PREVIEW                  var previewAudioFile = info.OggPreviewPath;                  if (File.Exists(previewAudioFile))                      if (platform.IsConsole != previewAudioFile.GetAudioPlatform().IsConsole)                          soundPreviewStream = OggFile.ConvertAudioPlatform(previewAudioFile);                      else                          soundPreviewStream = File.OpenRead(previewAudioFile);                  else                      soundPreviewStream = soundStream;                    // FLAT MODEL                  rsenumerableRootStream = new MemoryStream(Resources.rsenumerable_root);                  packPsarc.AddEntry("flatmodels/rs/rsenumerable_root.flat"' rsenumerableRootStream);                  rsenumerableSongStream = new MemoryStream(Resources.rsenumerable_song);                  packPsarc.AddEntry("flatmodels/rs/rsenumerable_song.flat"' rsenumerableSongStream);                    using (var toolkitVersionStream = new MemoryStream())                  using (var appIdStream = new MemoryStream())                  using (var packageListStream = new MemoryStream())                  using (var soundbankStream = new MemoryStream())                  using (var soundbankPreviewStream = new MemoryStream())                  using (var aggregateGraphStream = new MemoryStream())                  using (var manifestHeaderHSANStream = new MemoryStream())                  using (var manifestHeaderHSONStreamList = new DisposableCollection<Stream>())                  using (var manifestStreamList = new DisposableCollection<Stream>())                  using (var arrangementStream = new DisposableCollection<Stream>())                  using (var showlightStream = new MemoryStream())                  using (var xblockStream = new MemoryStream())                  {                      // TOOLKIT VERSION                      var stopHere = info;                      GenerateToolkitVersion(toolkitVersionStream' info.ToolkitInfo.PackageAuthor' info.ToolkitInfo.PackageVersion' info.ToolkitInfo.PackageComment);                      packPsarc.AddEntry("toolkit.version"' toolkitVersionStream);                        // APP ID                      if (!platform.IsConsole)                      {                          GenerateAppId(appIdStream' info.AppId' platform);                          packPsarc.AddEntry("appid.appid"' appIdStream);                      }                        if (platform.platform == GamePlatform.XBox360)                      {                          var packageListWriter = new StreamWriter(packageListStream);                          packageListWriter.Write(dlcName);                          packageListWriter.Flush();                          packageListStream.Seek(0' SeekOrigin.Begin);                          packageListStream.WriteTmpFile("PackageList.txt"' platform);                      }                        // SOUNDBANK                      var soundbankFileName = String.Format("song_{0}"' dlcName);                      var audioFileNameId = SoundBankGenerator2014.GenerateSoundBank(info.Name' soundStream' soundbankStream' info.Volume' platform);                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.bnk"' platform.GetPathName()[0].ToLower()' soundbankFileName)' soundbankStream);                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.wem"' platform.GetPathName()[0].ToLower()' audioFileNameId)' soundStream);                        // SOUNDBANK PREVIEW                      var soundbankPreviewFileName = String.Format("song_{0}_preview"' dlcName);                      dynamic audioPreviewFileNameId;                      var previewVolume = info.PreviewVolume ?? info.Volume;                      audioPreviewFileNameId = SoundBankGenerator2014.GenerateSoundBank(info.Name + "_Preview"' soundPreviewStream' soundbankPreviewStream' previewVolume' platform' true' !(File.Exists(previewAudioFile)));                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.bnk"' platform.GetPathName()[0].ToLower()' soundbankPreviewFileName)' soundbankPreviewStream);                      if (!soundPreviewStream.Equals(soundStream)) packPsarc.AddEntry(String.Format("audio/{0}/{1}.wem"' platform.GetPathName()[0].ToLower()' audioPreviewFileNameId)' soundPreviewStream);                        // AGGREGATE GRAPH                      var aggregateGraphFileName = String.Format("{0}_aggregategraph.nt"' dlcName);                      var aggregateGraph = new AggregateGraph2014.AggregateGraph2014(info' platform);                      aggregateGraph.Serialize(aggregateGraphStream);                      aggregateGraphStream.Flush();                      aggregateGraphStream.Seek(0' SeekOrigin.Begin);                      packPsarc.AddEntry(aggregateGraphFileName' aggregateGraphStream);                        var manifestHeader = new ManifestHeader2014<AttributesHeader2014>(platform);                      var songPartition = new SongPartition();                      var songPartitionCount = new SongPartition();                        foreach (var arrangement in info.Arrangements)                      {                          if (arrangement.ArrangementType == ArrangementType.ShowLight)                              continue;                            var arrangementFileName = songPartition.GetArrangementFileName(arrangement.Name' arrangement.ArrangementType).ToLower();                            // GAME SONG (SNG)                          UpdateToneDescriptors(info);                          GenerateSNG(arrangement' platform);                          var sngSongFile = File.OpenRead(arrangement.SongFile.File);                          arrangementStream.Add(sngSongFile);                          packPsarc.AddEntry(String.Format("songs/bin/{0}/{1}_{2}.sng"' platform.GetPathName()[1].ToLower()' dlcName' arrangementFileName)' sngSongFile);                            // XML SONG                          var xmlSongFile = File.OpenRead(arrangement.SongXml.File);                          arrangementStream.Add(xmlSongFile);                          packPsarc.AddEntry(String.Format("songs/arr/{0}_{1}.xml"' dlcName' arrangementFileName)' xmlSongFile);                            // MANIFEST                          var manifest = new Manifest2014<Attributes2014>();                          var attribute = new Attributes2014(arrangementFileName' arrangement' info' platform);                          if (arrangement.ArrangementType == ArrangementType.Bass || arrangement.ArrangementType == ArrangementType.Guitar)                          {                              // TODO: monitor this new code for bugs                              // represent is set to "1" by default' if there is a bonus then set represent to "0"                              attribute.Representative = arrangement.BonusArr ? 0 : 1;                              attribute.ArrangementProperties.Represent = arrangement.BonusArr ? 0 : 1;                                attribute.SongPartition = songPartitionCount.GetSongPartition(arrangement.Name' arrangement.ArrangementType);                              if (attribute.SongPartition > 1 && !arrangement.BonusArr)                              {                                  // for alternate arrangement then both represent and bonus are set to "0"                                  attribute.Representative = 0;                                  attribute.ArrangementProperties.Represent = 0;                              }                          }                            var attributeDictionary = new Dictionary<string' Attributes2014> { { "Attributes"' attribute } };                          manifest.Entries.Add(attribute.PersistentID' attributeDictionary);                          var manifestStream = new MemoryStream();                          manifestStreamList.Add(manifestStream);                          manifest.Serialize(manifestStream);                          manifestStream.Seek(0' SeekOrigin.Begin);                            const string jsonPathPC = "manifests/songs_dlc_{0}/{0}_{1}.json";                          const string jsonPathConsole = "manifests/songs_dlc/{0}_{1}.json";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? jsonPathConsole : jsonPathPC)' dlcName' arrangementFileName)' manifestStream);                            // MANIFEST HEADER                          var attributeHeaderDictionary = new Dictionary<string' AttributesHeader2014> { { "Attributes"' new AttributesHeader2014(attribute) } };                            if (platform.IsConsole)                          {                              // One for each arrangements (Xbox360/PS3)                              manifestHeader = new ManifestHeader2014<AttributesHeader2014>(platform);                              manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                              var manifestHeaderStream = new MemoryStream();                              manifestHeaderHSONStreamList.Add(manifestHeaderStream);                              manifestHeader.Serialize(manifestHeaderStream);                              manifestStream.Seek(0' SeekOrigin.Begin);                              packPsarc.AddEntry(String.Format("manifests/songs_dlc/{0}_{1}.hson"' dlcName' arrangementFileName)' manifestHeaderStream);                          }                          else                          {                              // One for all arrangements (PC/Mac)                              manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                          }                      }                        if (!platform.IsConsole)                      {                          manifestHeader.Serialize(manifestHeaderHSANStream);                          manifestHeaderHSANStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("manifests/songs_dlc_{0}/songs_dlc_{0}.hsan"' dlcName)' manifestHeaderHSANStream);                      }                        // XML SHOWLIGHTS                      var shlArr = info.Arrangements.FirstOrDefault(ar => ar.ArrangementType == ArrangementType.ShowLight);                      if (shlArr != null && shlArr.SongXml.File != null)                      {                          using (var fs = File.OpenRead(shlArr.SongXml.File))                              fs.CopyTo(showlightStream);                      }                      else                      {                          // Generate Showlights 'cst_showlights.xml'                          var showlight = new Showlights();                          showlight.CreateShowlights(info);                          // check for required minimum number of showlight elements                          if (showlight.ShowlightList.Count > 1)                          {                              showlight.Serialize(showlightStream);                              string shlFilePath = Path.Combine(Path.GetDirectoryName(info.Arrangements[0].SongXml.File)' String.Format("{0}_showlights.xml"' "cst"));                              using (FileStream file = new FileStream(shlFilePath' FileMode.Create' FileAccess.Write))                                  showlightStream.WriteTo(file);                                // write xml comments                              Song2014.WriteXmlComments(shlFilePath);                                // reload stream                              using (var fs = File.OpenRead(shlFilePath))                                  fs.CopyTo(showlightStream);                          }                          else                          {                              // insufficient showlight changes may crash game                              throw new InvalidOperationException("<ERROR> Insufficient showlight changes will crash game: " + showlight.ShowlightList.Count);                          }                      }                        if (showlightStream.CanRead && showlightStream.Length > 0)                          packPsarc.AddEntry(String.Format("songs/arr/{0}_showlights.xml"' dlcName)' showlightStream);                        // XBLOCK                      var game = GameXblock<Entity2014>.Generate2014(info' platform);                      game.SerializeXml(xblockStream);                      xblockStream.Flush();                      xblockStream.Seek(0' SeekOrigin.Begin);                      packPsarc.AddEntry(String.Format("gamexblocks/nsongs/{0}.xblock"' dlcName)' xblockStream);                        // WRITE PACKAGE                      packPsarc.Write(output' !platform.IsConsole);                      output.WriteTmpFile(String.Format("{0}.psarc"' dlcName)' platform);                  }              }              finally              {                  // Dispose all objects                  if (soundStream != null)                      soundStream.Dispose();                  if (soundPreviewStream != null)                      soundPreviewStream.Dispose();                  if (rsenumerableRootStream != null)                      rsenumerableRootStream.Dispose();                  if (rsenumerableSongStream != null)                      rsenumerableSongStream.Dispose();                  if (pnum <= 1)                      DeleteTmpFiles(TMPFILES_ART);                  DeleteTmpFiles(TMPFILES_SNG);              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The following statement contains a magic number: try              {                  // ALBUM ART                  if (info.ArtFiles == null)                  {                      //Try to get spreserved files                      string d256' d128' d64;                      if (File.Exists(info.AlbumArtPath))                      {                          d256 = info.AlbumArtPath;                          d128 = d256.Remove(d256.Length - 7) + "128.dds";                          d64 = d256.Remove(d256.Length - 7) + "64.dds";                          if (File.Exists(d64) && File.Exists(d128))                          {                              var _found = new List<DDSConvertedFile>                              {                                  new DDSConvertedFile() { sizeX = 64' destinationFile = d64 }'                                  new DDSConvertedFile() { sizeX = 128' destinationFile = d128 }'                                  new DDSConvertedFile() { sizeX = 256' destinationFile = d256 }                              };                              info.ArtFiles = _found;                          }                      }                  }                  if (info.ArtFiles == null)                  {                      //Generate art files                      string albumArtPath;                      var ddsfiles = info.ArtFiles;                      if (File.Exists(info.AlbumArtPath))                      {                          albumArtPath = info.AlbumArtPath;                      }                      else                      {                          using (var albumArtStream = new MemoryStream(Resources.albumart2014_256))                          {                              albumArtPath = GeneralExtensions.GetTempFileName(".dds");                              albumArtStream.WriteFile(albumArtPath);                              TMPFILES_ART.Add(albumArtPath);                          }                      }                        ddsfiles = new List<DDSConvertedFile>                      {                          new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }'                          new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }'                          new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }                      };                        // Convert to DDS                      ToDDS(ddsfiles);                        // Save for reuse                      info.ArtFiles = ddsfiles;                  }                    foreach (var dds in info.ArtFiles)                  {                      packPsarc.AddEntry(String.Format("gfxassets/album_art/album_{0}_{1}.dds"' dlcName' dds.sizeX)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                      if (dds.sizeY != 0)                      {                          TMPFILES_ART.Add(dds.destinationFile);                      }                  }                    // Lyric Art Texture                  if (File.Exists(info.LyricArtPath))                      packPsarc.AddEntry(String.Format("assets/ui/lyrics/{0}/lyrics_{0}.dds"' dlcName)' new FileStream(info.LyricArtPath' FileMode.Open' FileAccess.Read' FileShare.Read));                    // AUDIO                  var audioFile = info.OggPath;                  if (File.Exists(audioFile))                      if (platform.IsConsole != audioFile.GetAudioPlatform().IsConsole)                          soundStream = OggFile.ConvertAudioPlatform(audioFile);                      else                          soundStream = File.OpenRead(audioFile);                  else                      throw new InvalidOperationException(String.Format("Audio file '{0}' not found."' audioFile));                    // AUDIO PREVIEW                  var previewAudioFile = info.OggPreviewPath;                  if (File.Exists(previewAudioFile))                      if (platform.IsConsole != previewAudioFile.GetAudioPlatform().IsConsole)                          soundPreviewStream = OggFile.ConvertAudioPlatform(previewAudioFile);                      else                          soundPreviewStream = File.OpenRead(previewAudioFile);                  else                      soundPreviewStream = soundStream;                    // FLAT MODEL                  rsenumerableRootStream = new MemoryStream(Resources.rsenumerable_root);                  packPsarc.AddEntry("flatmodels/rs/rsenumerable_root.flat"' rsenumerableRootStream);                  rsenumerableSongStream = new MemoryStream(Resources.rsenumerable_song);                  packPsarc.AddEntry("flatmodels/rs/rsenumerable_song.flat"' rsenumerableSongStream);                    using (var toolkitVersionStream = new MemoryStream())                  using (var appIdStream = new MemoryStream())                  using (var packageListStream = new MemoryStream())                  using (var soundbankStream = new MemoryStream())                  using (var soundbankPreviewStream = new MemoryStream())                  using (var aggregateGraphStream = new MemoryStream())                  using (var manifestHeaderHSANStream = new MemoryStream())                  using (var manifestHeaderHSONStreamList = new DisposableCollection<Stream>())                  using (var manifestStreamList = new DisposableCollection<Stream>())                  using (var arrangementStream = new DisposableCollection<Stream>())                  using (var showlightStream = new MemoryStream())                  using (var xblockStream = new MemoryStream())                  {                      // TOOLKIT VERSION                      var stopHere = info;                      GenerateToolkitVersion(toolkitVersionStream' info.ToolkitInfo.PackageAuthor' info.ToolkitInfo.PackageVersion' info.ToolkitInfo.PackageComment);                      packPsarc.AddEntry("toolkit.version"' toolkitVersionStream);                        // APP ID                      if (!platform.IsConsole)                      {                          GenerateAppId(appIdStream' info.AppId' platform);                          packPsarc.AddEntry("appid.appid"' appIdStream);                      }                        if (platform.platform == GamePlatform.XBox360)                      {                          var packageListWriter = new StreamWriter(packageListStream);                          packageListWriter.Write(dlcName);                          packageListWriter.Flush();                          packageListStream.Seek(0' SeekOrigin.Begin);                          packageListStream.WriteTmpFile("PackageList.txt"' platform);                      }                        // SOUNDBANK                      var soundbankFileName = String.Format("song_{0}"' dlcName);                      var audioFileNameId = SoundBankGenerator2014.GenerateSoundBank(info.Name' soundStream' soundbankStream' info.Volume' platform);                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.bnk"' platform.GetPathName()[0].ToLower()' soundbankFileName)' soundbankStream);                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.wem"' platform.GetPathName()[0].ToLower()' audioFileNameId)' soundStream);                        // SOUNDBANK PREVIEW                      var soundbankPreviewFileName = String.Format("song_{0}_preview"' dlcName);                      dynamic audioPreviewFileNameId;                      var previewVolume = info.PreviewVolume ?? info.Volume;                      audioPreviewFileNameId = SoundBankGenerator2014.GenerateSoundBank(info.Name + "_Preview"' soundPreviewStream' soundbankPreviewStream' previewVolume' platform' true' !(File.Exists(previewAudioFile)));                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.bnk"' platform.GetPathName()[0].ToLower()' soundbankPreviewFileName)' soundbankPreviewStream);                      if (!soundPreviewStream.Equals(soundStream)) packPsarc.AddEntry(String.Format("audio/{0}/{1}.wem"' platform.GetPathName()[0].ToLower()' audioPreviewFileNameId)' soundPreviewStream);                        // AGGREGATE GRAPH                      var aggregateGraphFileName = String.Format("{0}_aggregategraph.nt"' dlcName);                      var aggregateGraph = new AggregateGraph2014.AggregateGraph2014(info' platform);                      aggregateGraph.Serialize(aggregateGraphStream);                      aggregateGraphStream.Flush();                      aggregateGraphStream.Seek(0' SeekOrigin.Begin);                      packPsarc.AddEntry(aggregateGraphFileName' aggregateGraphStream);                        var manifestHeader = new ManifestHeader2014<AttributesHeader2014>(platform);                      var songPartition = new SongPartition();                      var songPartitionCount = new SongPartition();                        foreach (var arrangement in info.Arrangements)                      {                          if (arrangement.ArrangementType == ArrangementType.ShowLight)                              continue;                            var arrangementFileName = songPartition.GetArrangementFileName(arrangement.Name' arrangement.ArrangementType).ToLower();                            // GAME SONG (SNG)                          UpdateToneDescriptors(info);                          GenerateSNG(arrangement' platform);                          var sngSongFile = File.OpenRead(arrangement.SongFile.File);                          arrangementStream.Add(sngSongFile);                          packPsarc.AddEntry(String.Format("songs/bin/{0}/{1}_{2}.sng"' platform.GetPathName()[1].ToLower()' dlcName' arrangementFileName)' sngSongFile);                            // XML SONG                          var xmlSongFile = File.OpenRead(arrangement.SongXml.File);                          arrangementStream.Add(xmlSongFile);                          packPsarc.AddEntry(String.Format("songs/arr/{0}_{1}.xml"' dlcName' arrangementFileName)' xmlSongFile);                            // MANIFEST                          var manifest = new Manifest2014<Attributes2014>();                          var attribute = new Attributes2014(arrangementFileName' arrangement' info' platform);                          if (arrangement.ArrangementType == ArrangementType.Bass || arrangement.ArrangementType == ArrangementType.Guitar)                          {                              // TODO: monitor this new code for bugs                              // represent is set to "1" by default' if there is a bonus then set represent to "0"                              attribute.Representative = arrangement.BonusArr ? 0 : 1;                              attribute.ArrangementProperties.Represent = arrangement.BonusArr ? 0 : 1;                                attribute.SongPartition = songPartitionCount.GetSongPartition(arrangement.Name' arrangement.ArrangementType);                              if (attribute.SongPartition > 1 && !arrangement.BonusArr)                              {                                  // for alternate arrangement then both represent and bonus are set to "0"                                  attribute.Representative = 0;                                  attribute.ArrangementProperties.Represent = 0;                              }                          }                            var attributeDictionary = new Dictionary<string' Attributes2014> { { "Attributes"' attribute } };                          manifest.Entries.Add(attribute.PersistentID' attributeDictionary);                          var manifestStream = new MemoryStream();                          manifestStreamList.Add(manifestStream);                          manifest.Serialize(manifestStream);                          manifestStream.Seek(0' SeekOrigin.Begin);                            const string jsonPathPC = "manifests/songs_dlc_{0}/{0}_{1}.json";                          const string jsonPathConsole = "manifests/songs_dlc/{0}_{1}.json";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? jsonPathConsole : jsonPathPC)' dlcName' arrangementFileName)' manifestStream);                            // MANIFEST HEADER                          var attributeHeaderDictionary = new Dictionary<string' AttributesHeader2014> { { "Attributes"' new AttributesHeader2014(attribute) } };                            if (platform.IsConsole)                          {                              // One for each arrangements (Xbox360/PS3)                              manifestHeader = new ManifestHeader2014<AttributesHeader2014>(platform);                              manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                              var manifestHeaderStream = new MemoryStream();                              manifestHeaderHSONStreamList.Add(manifestHeaderStream);                              manifestHeader.Serialize(manifestHeaderStream);                              manifestStream.Seek(0' SeekOrigin.Begin);                              packPsarc.AddEntry(String.Format("manifests/songs_dlc/{0}_{1}.hson"' dlcName' arrangementFileName)' manifestHeaderStream);                          }                          else                          {                              // One for all arrangements (PC/Mac)                              manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                          }                      }                        if (!platform.IsConsole)                      {                          manifestHeader.Serialize(manifestHeaderHSANStream);                          manifestHeaderHSANStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("manifests/songs_dlc_{0}/songs_dlc_{0}.hsan"' dlcName)' manifestHeaderHSANStream);                      }                        // XML SHOWLIGHTS                      var shlArr = info.Arrangements.FirstOrDefault(ar => ar.ArrangementType == ArrangementType.ShowLight);                      if (shlArr != null && shlArr.SongXml.File != null)                      {                          using (var fs = File.OpenRead(shlArr.SongXml.File))                              fs.CopyTo(showlightStream);                      }                      else                      {                          // Generate Showlights 'cst_showlights.xml'                          var showlight = new Showlights();                          showlight.CreateShowlights(info);                          // check for required minimum number of showlight elements                          if (showlight.ShowlightList.Count > 1)                          {                              showlight.Serialize(showlightStream);                              string shlFilePath = Path.Combine(Path.GetDirectoryName(info.Arrangements[0].SongXml.File)' String.Format("{0}_showlights.xml"' "cst"));                              using (FileStream file = new FileStream(shlFilePath' FileMode.Create' FileAccess.Write))                                  showlightStream.WriteTo(file);                                // write xml comments                              Song2014.WriteXmlComments(shlFilePath);                                // reload stream                              using (var fs = File.OpenRead(shlFilePath))                                  fs.CopyTo(showlightStream);                          }                          else                          {                              // insufficient showlight changes may crash game                              throw new InvalidOperationException("<ERROR> Insufficient showlight changes will crash game: " + showlight.ShowlightList.Count);                          }                      }                        if (showlightStream.CanRead && showlightStream.Length > 0)                          packPsarc.AddEntry(String.Format("songs/arr/{0}_showlights.xml"' dlcName)' showlightStream);                        // XBLOCK                      var game = GameXblock<Entity2014>.Generate2014(info' platform);                      game.SerializeXml(xblockStream);                      xblockStream.Flush();                      xblockStream.Seek(0' SeekOrigin.Begin);                      packPsarc.AddEntry(String.Format("gamexblocks/nsongs/{0}.xblock"' dlcName)' xblockStream);                        // WRITE PACKAGE                      packPsarc.Write(output' !platform.IsConsole);                      output.WriteTmpFile(String.Format("{0}.psarc"' dlcName)' platform);                  }              }              finally              {                  // Dispose all objects                  if (soundStream != null)                      soundStream.Dispose();                  if (soundPreviewStream != null)                      soundPreviewStream.Dispose();                  if (rsenumerableRootStream != null)                      rsenumerableRootStream.Dispose();                  if (rsenumerableSongStream != null)                      rsenumerableSongStream.Dispose();                  if (pnum <= 1)                      DeleteTmpFiles(TMPFILES_ART);                  DeleteTmpFiles(TMPFILES_SNG);              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The following statement contains a magic number: try              {                  // ALBUM ART                  if (info.ArtFiles == null)                  {                      //Try to get spreserved files                      string d256' d128' d64;                      if (File.Exists(info.AlbumArtPath))                      {                          d256 = info.AlbumArtPath;                          d128 = d256.Remove(d256.Length - 7) + "128.dds";                          d64 = d256.Remove(d256.Length - 7) + "64.dds";                          if (File.Exists(d64) && File.Exists(d128))                          {                              var _found = new List<DDSConvertedFile>                              {                                  new DDSConvertedFile() { sizeX = 64' destinationFile = d64 }'                                  new DDSConvertedFile() { sizeX = 128' destinationFile = d128 }'                                  new DDSConvertedFile() { sizeX = 256' destinationFile = d256 }                              };                              info.ArtFiles = _found;                          }                      }                  }                  if (info.ArtFiles == null)                  {                      //Generate art files                      string albumArtPath;                      var ddsfiles = info.ArtFiles;                      if (File.Exists(info.AlbumArtPath))                      {                          albumArtPath = info.AlbumArtPath;                      }                      else                      {                          using (var albumArtStream = new MemoryStream(Resources.albumart2014_256))                          {                              albumArtPath = GeneralExtensions.GetTempFileName(".dds");                              albumArtStream.WriteFile(albumArtPath);                              TMPFILES_ART.Add(albumArtPath);                          }                      }                        ddsfiles = new List<DDSConvertedFile>                      {                          new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }'                          new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }'                          new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }                      };                        // Convert to DDS                      ToDDS(ddsfiles);                        // Save for reuse                      info.ArtFiles = ddsfiles;                  }                    foreach (var dds in info.ArtFiles)                  {                      packPsarc.AddEntry(String.Format("gfxassets/album_art/album_{0}_{1}.dds"' dlcName' dds.sizeX)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                      if (dds.sizeY != 0)                      {                          TMPFILES_ART.Add(dds.destinationFile);                      }                  }                    // Lyric Art Texture                  if (File.Exists(info.LyricArtPath))                      packPsarc.AddEntry(String.Format("assets/ui/lyrics/{0}/lyrics_{0}.dds"' dlcName)' new FileStream(info.LyricArtPath' FileMode.Open' FileAccess.Read' FileShare.Read));                    // AUDIO                  var audioFile = info.OggPath;                  if (File.Exists(audioFile))                      if (platform.IsConsole != audioFile.GetAudioPlatform().IsConsole)                          soundStream = OggFile.ConvertAudioPlatform(audioFile);                      else                          soundStream = File.OpenRead(audioFile);                  else                      throw new InvalidOperationException(String.Format("Audio file '{0}' not found."' audioFile));                    // AUDIO PREVIEW                  var previewAudioFile = info.OggPreviewPath;                  if (File.Exists(previewAudioFile))                      if (platform.IsConsole != previewAudioFile.GetAudioPlatform().IsConsole)                          soundPreviewStream = OggFile.ConvertAudioPlatform(previewAudioFile);                      else                          soundPreviewStream = File.OpenRead(previewAudioFile);                  else                      soundPreviewStream = soundStream;                    // FLAT MODEL                  rsenumerableRootStream = new MemoryStream(Resources.rsenumerable_root);                  packPsarc.AddEntry("flatmodels/rs/rsenumerable_root.flat"' rsenumerableRootStream);                  rsenumerableSongStream = new MemoryStream(Resources.rsenumerable_song);                  packPsarc.AddEntry("flatmodels/rs/rsenumerable_song.flat"' rsenumerableSongStream);                    using (var toolkitVersionStream = new MemoryStream())                  using (var appIdStream = new MemoryStream())                  using (var packageListStream = new MemoryStream())                  using (var soundbankStream = new MemoryStream())                  using (var soundbankPreviewStream = new MemoryStream())                  using (var aggregateGraphStream = new MemoryStream())                  using (var manifestHeaderHSANStream = new MemoryStream())                  using (var manifestHeaderHSONStreamList = new DisposableCollection<Stream>())                  using (var manifestStreamList = new DisposableCollection<Stream>())                  using (var arrangementStream = new DisposableCollection<Stream>())                  using (var showlightStream = new MemoryStream())                  using (var xblockStream = new MemoryStream())                  {                      // TOOLKIT VERSION                      var stopHere = info;                      GenerateToolkitVersion(toolkitVersionStream' info.ToolkitInfo.PackageAuthor' info.ToolkitInfo.PackageVersion' info.ToolkitInfo.PackageComment);                      packPsarc.AddEntry("toolkit.version"' toolkitVersionStream);                        // APP ID                      if (!platform.IsConsole)                      {                          GenerateAppId(appIdStream' info.AppId' platform);                          packPsarc.AddEntry("appid.appid"' appIdStream);                      }                        if (platform.platform == GamePlatform.XBox360)                      {                          var packageListWriter = new StreamWriter(packageListStream);                          packageListWriter.Write(dlcName);                          packageListWriter.Flush();                          packageListStream.Seek(0' SeekOrigin.Begin);                          packageListStream.WriteTmpFile("PackageList.txt"' platform);                      }                        // SOUNDBANK                      var soundbankFileName = String.Format("song_{0}"' dlcName);                      var audioFileNameId = SoundBankGenerator2014.GenerateSoundBank(info.Name' soundStream' soundbankStream' info.Volume' platform);                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.bnk"' platform.GetPathName()[0].ToLower()' soundbankFileName)' soundbankStream);                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.wem"' platform.GetPathName()[0].ToLower()' audioFileNameId)' soundStream);                        // SOUNDBANK PREVIEW                      var soundbankPreviewFileName = String.Format("song_{0}_preview"' dlcName);                      dynamic audioPreviewFileNameId;                      var previewVolume = info.PreviewVolume ?? info.Volume;                      audioPreviewFileNameId = SoundBankGenerator2014.GenerateSoundBank(info.Name + "_Preview"' soundPreviewStream' soundbankPreviewStream' previewVolume' platform' true' !(File.Exists(previewAudioFile)));                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.bnk"' platform.GetPathName()[0].ToLower()' soundbankPreviewFileName)' soundbankPreviewStream);                      if (!soundPreviewStream.Equals(soundStream)) packPsarc.AddEntry(String.Format("audio/{0}/{1}.wem"' platform.GetPathName()[0].ToLower()' audioPreviewFileNameId)' soundPreviewStream);                        // AGGREGATE GRAPH                      var aggregateGraphFileName = String.Format("{0}_aggregategraph.nt"' dlcName);                      var aggregateGraph = new AggregateGraph2014.AggregateGraph2014(info' platform);                      aggregateGraph.Serialize(aggregateGraphStream);                      aggregateGraphStream.Flush();                      aggregateGraphStream.Seek(0' SeekOrigin.Begin);                      packPsarc.AddEntry(aggregateGraphFileName' aggregateGraphStream);                        var manifestHeader = new ManifestHeader2014<AttributesHeader2014>(platform);                      var songPartition = new SongPartition();                      var songPartitionCount = new SongPartition();                        foreach (var arrangement in info.Arrangements)                      {                          if (arrangement.ArrangementType == ArrangementType.ShowLight)                              continue;                            var arrangementFileName = songPartition.GetArrangementFileName(arrangement.Name' arrangement.ArrangementType).ToLower();                            // GAME SONG (SNG)                          UpdateToneDescriptors(info);                          GenerateSNG(arrangement' platform);                          var sngSongFile = File.OpenRead(arrangement.SongFile.File);                          arrangementStream.Add(sngSongFile);                          packPsarc.AddEntry(String.Format("songs/bin/{0}/{1}_{2}.sng"' platform.GetPathName()[1].ToLower()' dlcName' arrangementFileName)' sngSongFile);                            // XML SONG                          var xmlSongFile = File.OpenRead(arrangement.SongXml.File);                          arrangementStream.Add(xmlSongFile);                          packPsarc.AddEntry(String.Format("songs/arr/{0}_{1}.xml"' dlcName' arrangementFileName)' xmlSongFile);                            // MANIFEST                          var manifest = new Manifest2014<Attributes2014>();                          var attribute = new Attributes2014(arrangementFileName' arrangement' info' platform);                          if (arrangement.ArrangementType == ArrangementType.Bass || arrangement.ArrangementType == ArrangementType.Guitar)                          {                              // TODO: monitor this new code for bugs                              // represent is set to "1" by default' if there is a bonus then set represent to "0"                              attribute.Representative = arrangement.BonusArr ? 0 : 1;                              attribute.ArrangementProperties.Represent = arrangement.BonusArr ? 0 : 1;                                attribute.SongPartition = songPartitionCount.GetSongPartition(arrangement.Name' arrangement.ArrangementType);                              if (attribute.SongPartition > 1 && !arrangement.BonusArr)                              {                                  // for alternate arrangement then both represent and bonus are set to "0"                                  attribute.Representative = 0;                                  attribute.ArrangementProperties.Represent = 0;                              }                          }                            var attributeDictionary = new Dictionary<string' Attributes2014> { { "Attributes"' attribute } };                          manifest.Entries.Add(attribute.PersistentID' attributeDictionary);                          var manifestStream = new MemoryStream();                          manifestStreamList.Add(manifestStream);                          manifest.Serialize(manifestStream);                          manifestStream.Seek(0' SeekOrigin.Begin);                            const string jsonPathPC = "manifests/songs_dlc_{0}/{0}_{1}.json";                          const string jsonPathConsole = "manifests/songs_dlc/{0}_{1}.json";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? jsonPathConsole : jsonPathPC)' dlcName' arrangementFileName)' manifestStream);                            // MANIFEST HEADER                          var attributeHeaderDictionary = new Dictionary<string' AttributesHeader2014> { { "Attributes"' new AttributesHeader2014(attribute) } };                            if (platform.IsConsole)                          {                              // One for each arrangements (Xbox360/PS3)                              manifestHeader = new ManifestHeader2014<AttributesHeader2014>(platform);                              manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                              var manifestHeaderStream = new MemoryStream();                              manifestHeaderHSONStreamList.Add(manifestHeaderStream);                              manifestHeader.Serialize(manifestHeaderStream);                              manifestStream.Seek(0' SeekOrigin.Begin);                              packPsarc.AddEntry(String.Format("manifests/songs_dlc/{0}_{1}.hson"' dlcName' arrangementFileName)' manifestHeaderStream);                          }                          else                          {                              // One for all arrangements (PC/Mac)                              manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                          }                      }                        if (!platform.IsConsole)                      {                          manifestHeader.Serialize(manifestHeaderHSANStream);                          manifestHeaderHSANStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("manifests/songs_dlc_{0}/songs_dlc_{0}.hsan"' dlcName)' manifestHeaderHSANStream);                      }                        // XML SHOWLIGHTS                      var shlArr = info.Arrangements.FirstOrDefault(ar => ar.ArrangementType == ArrangementType.ShowLight);                      if (shlArr != null && shlArr.SongXml.File != null)                      {                          using (var fs = File.OpenRead(shlArr.SongXml.File))                              fs.CopyTo(showlightStream);                      }                      else                      {                          // Generate Showlights 'cst_showlights.xml'                          var showlight = new Showlights();                          showlight.CreateShowlights(info);                          // check for required minimum number of showlight elements                          if (showlight.ShowlightList.Count > 1)                          {                              showlight.Serialize(showlightStream);                              string shlFilePath = Path.Combine(Path.GetDirectoryName(info.Arrangements[0].SongXml.File)' String.Format("{0}_showlights.xml"' "cst"));                              using (FileStream file = new FileStream(shlFilePath' FileMode.Create' FileAccess.Write))                                  showlightStream.WriteTo(file);                                // write xml comments                              Song2014.WriteXmlComments(shlFilePath);                                // reload stream                              using (var fs = File.OpenRead(shlFilePath))                                  fs.CopyTo(showlightStream);                          }                          else                          {                              // insufficient showlight changes may crash game                              throw new InvalidOperationException("<ERROR> Insufficient showlight changes will crash game: " + showlight.ShowlightList.Count);                          }                      }                        if (showlightStream.CanRead && showlightStream.Length > 0)                          packPsarc.AddEntry(String.Format("songs/arr/{0}_showlights.xml"' dlcName)' showlightStream);                        // XBLOCK                      var game = GameXblock<Entity2014>.Generate2014(info' platform);                      game.SerializeXml(xblockStream);                      xblockStream.Flush();                      xblockStream.Seek(0' SeekOrigin.Begin);                      packPsarc.AddEntry(String.Format("gamexblocks/nsongs/{0}.xblock"' dlcName)' xblockStream);                        // WRITE PACKAGE                      packPsarc.Write(output' !platform.IsConsole);                      output.WriteTmpFile(String.Format("{0}.psarc"' dlcName)' platform);                  }              }              finally              {                  // Dispose all objects                  if (soundStream != null)                      soundStream.Dispose();                  if (soundPreviewStream != null)                      soundPreviewStream.Dispose();                  if (rsenumerableRootStream != null)                      rsenumerableRootStream.Dispose();                  if (rsenumerableSongStream != null)                      rsenumerableSongStream.Dispose();                  if (pnum <= 1)                      DeleteTmpFiles(TMPFILES_ART);                  DeleteTmpFiles(TMPFILES_SNG);              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014SongPsarc,The following statement contains a magic number: try              {                  // ALBUM ART                  if (info.ArtFiles == null)                  {                      //Try to get spreserved files                      string d256' d128' d64;                      if (File.Exists(info.AlbumArtPath))                      {                          d256 = info.AlbumArtPath;                          d128 = d256.Remove(d256.Length - 7) + "128.dds";                          d64 = d256.Remove(d256.Length - 7) + "64.dds";                          if (File.Exists(d64) && File.Exists(d128))                          {                              var _found = new List<DDSConvertedFile>                              {                                  new DDSConvertedFile() { sizeX = 64' destinationFile = d64 }'                                  new DDSConvertedFile() { sizeX = 128' destinationFile = d128 }'                                  new DDSConvertedFile() { sizeX = 256' destinationFile = d256 }                              };                              info.ArtFiles = _found;                          }                      }                  }                  if (info.ArtFiles == null)                  {                      //Generate art files                      string albumArtPath;                      var ddsfiles = info.ArtFiles;                      if (File.Exists(info.AlbumArtPath))                      {                          albumArtPath = info.AlbumArtPath;                      }                      else                      {                          using (var albumArtStream = new MemoryStream(Resources.albumart2014_256))                          {                              albumArtPath = GeneralExtensions.GetTempFileName(".dds");                              albumArtStream.WriteFile(albumArtPath);                              TMPFILES_ART.Add(albumArtPath);                          }                      }                        ddsfiles = new List<DDSConvertedFile>                      {                          new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }'                          new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }'                          new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") }                      };                        // Convert to DDS                      ToDDS(ddsfiles);                        // Save for reuse                      info.ArtFiles = ddsfiles;                  }                    foreach (var dds in info.ArtFiles)                  {                      packPsarc.AddEntry(String.Format("gfxassets/album_art/album_{0}_{1}.dds"' dlcName' dds.sizeX)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                      if (dds.sizeY != 0)                      {                          TMPFILES_ART.Add(dds.destinationFile);                      }                  }                    // Lyric Art Texture                  if (File.Exists(info.LyricArtPath))                      packPsarc.AddEntry(String.Format("assets/ui/lyrics/{0}/lyrics_{0}.dds"' dlcName)' new FileStream(info.LyricArtPath' FileMode.Open' FileAccess.Read' FileShare.Read));                    // AUDIO                  var audioFile = info.OggPath;                  if (File.Exists(audioFile))                      if (platform.IsConsole != audioFile.GetAudioPlatform().IsConsole)                          soundStream = OggFile.ConvertAudioPlatform(audioFile);                      else                          soundStream = File.OpenRead(audioFile);                  else                      throw new InvalidOperationException(String.Format("Audio file '{0}' not found."' audioFile));                    // AUDIO PREVIEW                  var previewAudioFile = info.OggPreviewPath;                  if (File.Exists(previewAudioFile))                      if (platform.IsConsole != previewAudioFile.GetAudioPlatform().IsConsole)                          soundPreviewStream = OggFile.ConvertAudioPlatform(previewAudioFile);                      else                          soundPreviewStream = File.OpenRead(previewAudioFile);                  else                      soundPreviewStream = soundStream;                    // FLAT MODEL                  rsenumerableRootStream = new MemoryStream(Resources.rsenumerable_root);                  packPsarc.AddEntry("flatmodels/rs/rsenumerable_root.flat"' rsenumerableRootStream);                  rsenumerableSongStream = new MemoryStream(Resources.rsenumerable_song);                  packPsarc.AddEntry("flatmodels/rs/rsenumerable_song.flat"' rsenumerableSongStream);                    using (var toolkitVersionStream = new MemoryStream())                  using (var appIdStream = new MemoryStream())                  using (var packageListStream = new MemoryStream())                  using (var soundbankStream = new MemoryStream())                  using (var soundbankPreviewStream = new MemoryStream())                  using (var aggregateGraphStream = new MemoryStream())                  using (var manifestHeaderHSANStream = new MemoryStream())                  using (var manifestHeaderHSONStreamList = new DisposableCollection<Stream>())                  using (var manifestStreamList = new DisposableCollection<Stream>())                  using (var arrangementStream = new DisposableCollection<Stream>())                  using (var showlightStream = new MemoryStream())                  using (var xblockStream = new MemoryStream())                  {                      // TOOLKIT VERSION                      var stopHere = info;                      GenerateToolkitVersion(toolkitVersionStream' info.ToolkitInfo.PackageAuthor' info.ToolkitInfo.PackageVersion' info.ToolkitInfo.PackageComment);                      packPsarc.AddEntry("toolkit.version"' toolkitVersionStream);                        // APP ID                      if (!platform.IsConsole)                      {                          GenerateAppId(appIdStream' info.AppId' platform);                          packPsarc.AddEntry("appid.appid"' appIdStream);                      }                        if (platform.platform == GamePlatform.XBox360)                      {                          var packageListWriter = new StreamWriter(packageListStream);                          packageListWriter.Write(dlcName);                          packageListWriter.Flush();                          packageListStream.Seek(0' SeekOrigin.Begin);                          packageListStream.WriteTmpFile("PackageList.txt"' platform);                      }                        // SOUNDBANK                      var soundbankFileName = String.Format("song_{0}"' dlcName);                      var audioFileNameId = SoundBankGenerator2014.GenerateSoundBank(info.Name' soundStream' soundbankStream' info.Volume' platform);                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.bnk"' platform.GetPathName()[0].ToLower()' soundbankFileName)' soundbankStream);                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.wem"' platform.GetPathName()[0].ToLower()' audioFileNameId)' soundStream);                        // SOUNDBANK PREVIEW                      var soundbankPreviewFileName = String.Format("song_{0}_preview"' dlcName);                      dynamic audioPreviewFileNameId;                      var previewVolume = info.PreviewVolume ?? info.Volume;                      audioPreviewFileNameId = SoundBankGenerator2014.GenerateSoundBank(info.Name + "_Preview"' soundPreviewStream' soundbankPreviewStream' previewVolume' platform' true' !(File.Exists(previewAudioFile)));                      packPsarc.AddEntry(String.Format("audio/{0}/{1}.bnk"' platform.GetPathName()[0].ToLower()' soundbankPreviewFileName)' soundbankPreviewStream);                      if (!soundPreviewStream.Equals(soundStream)) packPsarc.AddEntry(String.Format("audio/{0}/{1}.wem"' platform.GetPathName()[0].ToLower()' audioPreviewFileNameId)' soundPreviewStream);                        // AGGREGATE GRAPH                      var aggregateGraphFileName = String.Format("{0}_aggregategraph.nt"' dlcName);                      var aggregateGraph = new AggregateGraph2014.AggregateGraph2014(info' platform);                      aggregateGraph.Serialize(aggregateGraphStream);                      aggregateGraphStream.Flush();                      aggregateGraphStream.Seek(0' SeekOrigin.Begin);                      packPsarc.AddEntry(aggregateGraphFileName' aggregateGraphStream);                        var manifestHeader = new ManifestHeader2014<AttributesHeader2014>(platform);                      var songPartition = new SongPartition();                      var songPartitionCount = new SongPartition();                        foreach (var arrangement in info.Arrangements)                      {                          if (arrangement.ArrangementType == ArrangementType.ShowLight)                              continue;                            var arrangementFileName = songPartition.GetArrangementFileName(arrangement.Name' arrangement.ArrangementType).ToLower();                            // GAME SONG (SNG)                          UpdateToneDescriptors(info);                          GenerateSNG(arrangement' platform);                          var sngSongFile = File.OpenRead(arrangement.SongFile.File);                          arrangementStream.Add(sngSongFile);                          packPsarc.AddEntry(String.Format("songs/bin/{0}/{1}_{2}.sng"' platform.GetPathName()[1].ToLower()' dlcName' arrangementFileName)' sngSongFile);                            // XML SONG                          var xmlSongFile = File.OpenRead(arrangement.SongXml.File);                          arrangementStream.Add(xmlSongFile);                          packPsarc.AddEntry(String.Format("songs/arr/{0}_{1}.xml"' dlcName' arrangementFileName)' xmlSongFile);                            // MANIFEST                          var manifest = new Manifest2014<Attributes2014>();                          var attribute = new Attributes2014(arrangementFileName' arrangement' info' platform);                          if (arrangement.ArrangementType == ArrangementType.Bass || arrangement.ArrangementType == ArrangementType.Guitar)                          {                              // TODO: monitor this new code for bugs                              // represent is set to "1" by default' if there is a bonus then set represent to "0"                              attribute.Representative = arrangement.BonusArr ? 0 : 1;                              attribute.ArrangementProperties.Represent = arrangement.BonusArr ? 0 : 1;                                attribute.SongPartition = songPartitionCount.GetSongPartition(arrangement.Name' arrangement.ArrangementType);                              if (attribute.SongPartition > 1 && !arrangement.BonusArr)                              {                                  // for alternate arrangement then both represent and bonus are set to "0"                                  attribute.Representative = 0;                                  attribute.ArrangementProperties.Represent = 0;                              }                          }                            var attributeDictionary = new Dictionary<string' Attributes2014> { { "Attributes"' attribute } };                          manifest.Entries.Add(attribute.PersistentID' attributeDictionary);                          var manifestStream = new MemoryStream();                          manifestStreamList.Add(manifestStream);                          manifest.Serialize(manifestStream);                          manifestStream.Seek(0' SeekOrigin.Begin);                            const string jsonPathPC = "manifests/songs_dlc_{0}/{0}_{1}.json";                          const string jsonPathConsole = "manifests/songs_dlc/{0}_{1}.json";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? jsonPathConsole : jsonPathPC)' dlcName' arrangementFileName)' manifestStream);                            // MANIFEST HEADER                          var attributeHeaderDictionary = new Dictionary<string' AttributesHeader2014> { { "Attributes"' new AttributesHeader2014(attribute) } };                            if (platform.IsConsole)                          {                              // One for each arrangements (Xbox360/PS3)                              manifestHeader = new ManifestHeader2014<AttributesHeader2014>(platform);                              manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                              var manifestHeaderStream = new MemoryStream();                              manifestHeaderHSONStreamList.Add(manifestHeaderStream);                              manifestHeader.Serialize(manifestHeaderStream);                              manifestStream.Seek(0' SeekOrigin.Begin);                              packPsarc.AddEntry(String.Format("manifests/songs_dlc/{0}_{1}.hson"' dlcName' arrangementFileName)' manifestHeaderStream);                          }                          else                          {                              // One for all arrangements (PC/Mac)                              manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                          }                      }                        if (!platform.IsConsole)                      {                          manifestHeader.Serialize(manifestHeaderHSANStream);                          manifestHeaderHSANStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("manifests/songs_dlc_{0}/songs_dlc_{0}.hsan"' dlcName)' manifestHeaderHSANStream);                      }                        // XML SHOWLIGHTS                      var shlArr = info.Arrangements.FirstOrDefault(ar => ar.ArrangementType == ArrangementType.ShowLight);                      if (shlArr != null && shlArr.SongXml.File != null)                      {                          using (var fs = File.OpenRead(shlArr.SongXml.File))                              fs.CopyTo(showlightStream);                      }                      else                      {                          // Generate Showlights 'cst_showlights.xml'                          var showlight = new Showlights();                          showlight.CreateShowlights(info);                          // check for required minimum number of showlight elements                          if (showlight.ShowlightList.Count > 1)                          {                              showlight.Serialize(showlightStream);                              string shlFilePath = Path.Combine(Path.GetDirectoryName(info.Arrangements[0].SongXml.File)' String.Format("{0}_showlights.xml"' "cst"));                              using (FileStream file = new FileStream(shlFilePath' FileMode.Create' FileAccess.Write))                                  showlightStream.WriteTo(file);                                // write xml comments                              Song2014.WriteXmlComments(shlFilePath);                                // reload stream                              using (var fs = File.OpenRead(shlFilePath))                                  fs.CopyTo(showlightStream);                          }                          else                          {                              // insufficient showlight changes may crash game                              throw new InvalidOperationException("<ERROR> Insufficient showlight changes will crash game: " + showlight.ShowlightList.Count);                          }                      }                        if (showlightStream.CanRead && showlightStream.Length > 0)                          packPsarc.AddEntry(String.Format("songs/arr/{0}_showlights.xml"' dlcName)' showlightStream);                        // XBLOCK                      var game = GameXblock<Entity2014>.Generate2014(info' platform);                      game.SerializeXml(xblockStream);                      xblockStream.Flush();                      xblockStream.Seek(0' SeekOrigin.Begin);                      packPsarc.AddEntry(String.Format("gamexblocks/nsongs/{0}.xblock"' dlcName)' xblockStream);                        // WRITE PACKAGE                      packPsarc.Write(output' !platform.IsConsole);                      output.WriteTmpFile(String.Format("{0}.psarc"' dlcName)' platform);                  }              }              finally              {                  // Dispose all objects                  if (soundStream != null)                      soundStream.Dispose();                  if (soundPreviewStream != null)                      soundPreviewStream.Dispose();                  if (rsenumerableRootStream != null)                      rsenumerableRootStream.Dispose();                  if (rsenumerableSongStream != null)                      rsenumerableSongStream.Dispose();                  if (pnum <= 1)                      DeleteTmpFiles(TMPFILES_ART);                  DeleteTmpFiles(TMPFILES_SNG);              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014InlayPsarc,The following statement contains a magic number: {                  packPsarc = new PSARC.PSARC();                    // Stream objects                  Stream rsenumerableRootStream = null'                         rsenumerableGuitarStream = null;                    try                  {                      // ICON/INLAY FILES                      var ddsfiles = info.ArtFiles;                        if (ddsfiles == null)                      {                          string iconPath;                          if (File.Exists(info.Inlay.IconPath))                          {                              iconPath = info.Inlay.IconPath;                          }                          else                          {                              using (var iconStream = new MemoryStream(Resources.cgm_default_icon))                              {                                  iconPath = Path.ChangeExtension(Path.GetTempFileName()' ".png");                                  iconStream.WriteFile(iconPath);                                  TMPFILES_ART.Add(iconPath);                              }                          }                            string inlayPath;                          if (File.Exists(info.Inlay.InlayPath))                          {                              inlayPath = info.Inlay.InlayPath;                          }                          else                          {                              using (var inlayStream = new MemoryStream(Resources.cgm_default_inlay))                              {                                  inlayPath = GeneralExtensions.GetTempFileName(".png");                                  inlayStream.WriteFile(inlayPath);                                  TMPFILES_ART.Add(inlayPath);                              }                          }                            ddsfiles = new List<DDSConvertedFile>();                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 512' sizeY = 512' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 1024' sizeY = 512' sourceFile = inlayPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                            // Convert to DDS                          ToDDS(ddsfiles' DLCPackageType.Inlay);                            // Save for reuse                          info.ArtFiles = ddsfiles;                      }                        foreach (var dds in info.ArtFiles)                          if (dds.sizeX == 1024)                              packPsarc.AddEntry(String.Format("assets/gameplay/inlay/inlay_{0}.dds"' dlcName)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                          else                              packPsarc.AddEntry(String.Format("gfxassets/rewards/guitar_inlays/reward_inlay_{0}_{1}.dds"' dlcName' dds.sizeX)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                        // FLAT MODEL                      rsenumerableRootStream = new MemoryStream(Resources.rsenumerable_root);                      packPsarc.AddEntry("flatmodels/rs/rsenumerable_root.flat"' rsenumerableRootStream);                      rsenumerableGuitarStream = new MemoryStream(Resources.rsenumerable_guitar);                      packPsarc.AddEntry("flatmodels/rs/rsenumerable_guitars.flat"' rsenumerableGuitarStream);                        using (var toolkitVersionStream = new MemoryStream())                      using (var appIdStream = new MemoryStream())                      using (var packageListStream = new MemoryStream())                      using (var aggregateGraphStream = new MemoryStream())                      using (var manifestStreamList = new DisposableCollection<Stream>())                      using (var manifestHeaderStream = new MemoryStream())                      using (var nifStream = new MemoryStream())                      using (var xblockStream = new MemoryStream())                      {                          // TOOLKIT VERSION                          GenerateToolkitVersion(toolkitVersionStream);                          packPsarc.AddEntry("toolkit.version"' toolkitVersionStream);                            // APP ID                          if (!platform.IsConsole)                          {                              GenerateAppId(appIdStream' info.AppId' platform);                              packPsarc.AddEntry("appid.appid"' appIdStream);                          }                            if (platform.platform == GamePlatform.XBox360)                          {                              var packageListWriter = new StreamWriter(packageListStream);                              packageListWriter.Write(dlcName);                              packageListWriter.Flush();                              packageListStream.Seek(0' SeekOrigin.Begin);                              const string packageList = "PackageList.txt";                              packageListStream.WriteTmpFile(packageList' platform);                          }                            // AGGREGATE GRAPH                          var aggregateGraphFileName = String.Format("{0}_aggregategraph.nt"' dlcName);                          var aggregateGraph = new AggregateGraph2014.AggregateGraph2014(info' platform' DLCPackageType.Inlay);                          aggregateGraph.Serialize(aggregateGraphStream);                          aggregateGraphStream.Flush();                          aggregateGraphStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(aggregateGraphFileName' aggregateGraphStream);                            // MANIFEST                          var attribute = new InlayAttributes2014(info);                          var attributeDictionary = new Dictionary<string' InlayAttributes2014> { { "Attributes"' attribute } };                          var manifest = new Manifest2014<InlayAttributes2014>(DLCPackageType.Inlay);                          manifest.Entries.Add(attribute.PersistentID' attributeDictionary);                          var manifestStream = new MemoryStream();                          manifestStreamList.Add(manifestStream);                          manifest.Serialize(manifestStream);                          manifestStream.Seek(0' SeekOrigin.Begin);                          const string jsonPathPC = "manifests/songs_dlc_{0}/dlc_guitar_{0}.json";                          const string jsonPathConsole = "manifests/songs_dlc/dlc_guitar_{0}.json";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? jsonPathConsole : jsonPathPC)' dlcName)' manifestStream);                            // MANIFEST HEADER                          var attributeHeaderDictionary = new Dictionary<string' InlayAttributes2014> { { "Attributes"' attribute } };                          var manifestHeader = new ManifestHeader2014<InlayAttributes2014>(platform' DLCPackageType.Inlay);                          manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                          manifestHeader.Serialize(manifestHeaderStream);                          manifestHeaderStream.Seek(0' SeekOrigin.Begin);                          const string hsanPathPC = "manifests/songs_dlc_{0}/dlc_{0}.hsan";                          const string hsonPathConsole = "manifests/songs_dlc/dlc_{0}.hson";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? hsonPathConsole : hsanPathPC)' dlcName)' manifestHeaderStream);                            // XBLOCK                          GameXblock<Entity2014> game = GameXblock<Entity2014>.Generate2014(info' platform' DLCPackageType.Inlay);                          game.SerializeXml(xblockStream);                          xblockStream.Flush();                          xblockStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("gamexblocks/nguitars/guitar_{0}.xblock"' dlcName)' xblockStream);                            // INLAY NIF                          InlayNif nif = new InlayNif(info);                          nif.Serialize(nifStream);                          nifStream.Flush();                          nifStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("assets/gameplay/inlay/{0}.nif"' dlcName)' nifStream);                            // WRITE PACKAGE                          packPsarc.Write(output' !platform.IsConsole);                          output.WriteTmpFile(String.Format("{0}.psarc"' dlcName)' platform);                      }                  }                  catch (Exception)                  {                      throw;                  }                  finally                  {                      // Dispose all objects                      if (rsenumerableRootStream != null)                          rsenumerableRootStream.Dispose();                      if (rsenumerableGuitarStream != null)                          rsenumerableGuitarStream.Dispose();                      DeleteTmpFiles(TMPFILES_ART);                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014InlayPsarc,The following statement contains a magic number: {                  packPsarc = new PSARC.PSARC();                    // Stream objects                  Stream rsenumerableRootStream = null'                         rsenumerableGuitarStream = null;                    try                  {                      // ICON/INLAY FILES                      var ddsfiles = info.ArtFiles;                        if (ddsfiles == null)                      {                          string iconPath;                          if (File.Exists(info.Inlay.IconPath))                          {                              iconPath = info.Inlay.IconPath;                          }                          else                          {                              using (var iconStream = new MemoryStream(Resources.cgm_default_icon))                              {                                  iconPath = Path.ChangeExtension(Path.GetTempFileName()' ".png");                                  iconStream.WriteFile(iconPath);                                  TMPFILES_ART.Add(iconPath);                              }                          }                            string inlayPath;                          if (File.Exists(info.Inlay.InlayPath))                          {                              inlayPath = info.Inlay.InlayPath;                          }                          else                          {                              using (var inlayStream = new MemoryStream(Resources.cgm_default_inlay))                              {                                  inlayPath = GeneralExtensions.GetTempFileName(".png");                                  inlayStream.WriteFile(inlayPath);                                  TMPFILES_ART.Add(inlayPath);                              }                          }                            ddsfiles = new List<DDSConvertedFile>();                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 512' sizeY = 512' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 1024' sizeY = 512' sourceFile = inlayPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                            // Convert to DDS                          ToDDS(ddsfiles' DLCPackageType.Inlay);                            // Save for reuse                          info.ArtFiles = ddsfiles;                      }                        foreach (var dds in info.ArtFiles)                          if (dds.sizeX == 1024)                              packPsarc.AddEntry(String.Format("assets/gameplay/inlay/inlay_{0}.dds"' dlcName)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                          else                              packPsarc.AddEntry(String.Format("gfxassets/rewards/guitar_inlays/reward_inlay_{0}_{1}.dds"' dlcName' dds.sizeX)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                        // FLAT MODEL                      rsenumerableRootStream = new MemoryStream(Resources.rsenumerable_root);                      packPsarc.AddEntry("flatmodels/rs/rsenumerable_root.flat"' rsenumerableRootStream);                      rsenumerableGuitarStream = new MemoryStream(Resources.rsenumerable_guitar);                      packPsarc.AddEntry("flatmodels/rs/rsenumerable_guitars.flat"' rsenumerableGuitarStream);                        using (var toolkitVersionStream = new MemoryStream())                      using (var appIdStream = new MemoryStream())                      using (var packageListStream = new MemoryStream())                      using (var aggregateGraphStream = new MemoryStream())                      using (var manifestStreamList = new DisposableCollection<Stream>())                      using (var manifestHeaderStream = new MemoryStream())                      using (var nifStream = new MemoryStream())                      using (var xblockStream = new MemoryStream())                      {                          // TOOLKIT VERSION                          GenerateToolkitVersion(toolkitVersionStream);                          packPsarc.AddEntry("toolkit.version"' toolkitVersionStream);                            // APP ID                          if (!platform.IsConsole)                          {                              GenerateAppId(appIdStream' info.AppId' platform);                              packPsarc.AddEntry("appid.appid"' appIdStream);                          }                            if (platform.platform == GamePlatform.XBox360)                          {                              var packageListWriter = new StreamWriter(packageListStream);                              packageListWriter.Write(dlcName);                              packageListWriter.Flush();                              packageListStream.Seek(0' SeekOrigin.Begin);                              const string packageList = "PackageList.txt";                              packageListStream.WriteTmpFile(packageList' platform);                          }                            // AGGREGATE GRAPH                          var aggregateGraphFileName = String.Format("{0}_aggregategraph.nt"' dlcName);                          var aggregateGraph = new AggregateGraph2014.AggregateGraph2014(info' platform' DLCPackageType.Inlay);                          aggregateGraph.Serialize(aggregateGraphStream);                          aggregateGraphStream.Flush();                          aggregateGraphStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(aggregateGraphFileName' aggregateGraphStream);                            // MANIFEST                          var attribute = new InlayAttributes2014(info);                          var attributeDictionary = new Dictionary<string' InlayAttributes2014> { { "Attributes"' attribute } };                          var manifest = new Manifest2014<InlayAttributes2014>(DLCPackageType.Inlay);                          manifest.Entries.Add(attribute.PersistentID' attributeDictionary);                          var manifestStream = new MemoryStream();                          manifestStreamList.Add(manifestStream);                          manifest.Serialize(manifestStream);                          manifestStream.Seek(0' SeekOrigin.Begin);                          const string jsonPathPC = "manifests/songs_dlc_{0}/dlc_guitar_{0}.json";                          const string jsonPathConsole = "manifests/songs_dlc/dlc_guitar_{0}.json";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? jsonPathConsole : jsonPathPC)' dlcName)' manifestStream);                            // MANIFEST HEADER                          var attributeHeaderDictionary = new Dictionary<string' InlayAttributes2014> { { "Attributes"' attribute } };                          var manifestHeader = new ManifestHeader2014<InlayAttributes2014>(platform' DLCPackageType.Inlay);                          manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                          manifestHeader.Serialize(manifestHeaderStream);                          manifestHeaderStream.Seek(0' SeekOrigin.Begin);                          const string hsanPathPC = "manifests/songs_dlc_{0}/dlc_{0}.hsan";                          const string hsonPathConsole = "manifests/songs_dlc/dlc_{0}.hson";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? hsonPathConsole : hsanPathPC)' dlcName)' manifestHeaderStream);                            // XBLOCK                          GameXblock<Entity2014> game = GameXblock<Entity2014>.Generate2014(info' platform' DLCPackageType.Inlay);                          game.SerializeXml(xblockStream);                          xblockStream.Flush();                          xblockStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("gamexblocks/nguitars/guitar_{0}.xblock"' dlcName)' xblockStream);                            // INLAY NIF                          InlayNif nif = new InlayNif(info);                          nif.Serialize(nifStream);                          nifStream.Flush();                          nifStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("assets/gameplay/inlay/{0}.nif"' dlcName)' nifStream);                            // WRITE PACKAGE                          packPsarc.Write(output' !platform.IsConsole);                          output.WriteTmpFile(String.Format("{0}.psarc"' dlcName)' platform);                      }                  }                  catch (Exception)                  {                      throw;                  }                  finally                  {                      // Dispose all objects                      if (rsenumerableRootStream != null)                          rsenumerableRootStream.Dispose();                      if (rsenumerableGuitarStream != null)                          rsenumerableGuitarStream.Dispose();                      DeleteTmpFiles(TMPFILES_ART);                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014InlayPsarc,The following statement contains a magic number: {                  packPsarc = new PSARC.PSARC();                    // Stream objects                  Stream rsenumerableRootStream = null'                         rsenumerableGuitarStream = null;                    try                  {                      // ICON/INLAY FILES                      var ddsfiles = info.ArtFiles;                        if (ddsfiles == null)                      {                          string iconPath;                          if (File.Exists(info.Inlay.IconPath))                          {                              iconPath = info.Inlay.IconPath;                          }                          else                          {                              using (var iconStream = new MemoryStream(Resources.cgm_default_icon))                              {                                  iconPath = Path.ChangeExtension(Path.GetTempFileName()' ".png");                                  iconStream.WriteFile(iconPath);                                  TMPFILES_ART.Add(iconPath);                              }                          }                            string inlayPath;                          if (File.Exists(info.Inlay.InlayPath))                          {                              inlayPath = info.Inlay.InlayPath;                          }                          else                          {                              using (var inlayStream = new MemoryStream(Resources.cgm_default_inlay))                              {                                  inlayPath = GeneralExtensions.GetTempFileName(".png");                                  inlayStream.WriteFile(inlayPath);                                  TMPFILES_ART.Add(inlayPath);                              }                          }                            ddsfiles = new List<DDSConvertedFile>();                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 512' sizeY = 512' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 1024' sizeY = 512' sourceFile = inlayPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                            // Convert to DDS                          ToDDS(ddsfiles' DLCPackageType.Inlay);                            // Save for reuse                          info.ArtFiles = ddsfiles;                      }                        foreach (var dds in info.ArtFiles)                          if (dds.sizeX == 1024)                              packPsarc.AddEntry(String.Format("assets/gameplay/inlay/inlay_{0}.dds"' dlcName)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                          else                              packPsarc.AddEntry(String.Format("gfxassets/rewards/guitar_inlays/reward_inlay_{0}_{1}.dds"' dlcName' dds.sizeX)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                        // FLAT MODEL                      rsenumerableRootStream = new MemoryStream(Resources.rsenumerable_root);                      packPsarc.AddEntry("flatmodels/rs/rsenumerable_root.flat"' rsenumerableRootStream);                      rsenumerableGuitarStream = new MemoryStream(Resources.rsenumerable_guitar);                      packPsarc.AddEntry("flatmodels/rs/rsenumerable_guitars.flat"' rsenumerableGuitarStream);                        using (var toolkitVersionStream = new MemoryStream())                      using (var appIdStream = new MemoryStream())                      using (var packageListStream = new MemoryStream())                      using (var aggregateGraphStream = new MemoryStream())                      using (var manifestStreamList = new DisposableCollection<Stream>())                      using (var manifestHeaderStream = new MemoryStream())                      using (var nifStream = new MemoryStream())                      using (var xblockStream = new MemoryStream())                      {                          // TOOLKIT VERSION                          GenerateToolkitVersion(toolkitVersionStream);                          packPsarc.AddEntry("toolkit.version"' toolkitVersionStream);                            // APP ID                          if (!platform.IsConsole)                          {                              GenerateAppId(appIdStream' info.AppId' platform);                              packPsarc.AddEntry("appid.appid"' appIdStream);                          }                            if (platform.platform == GamePlatform.XBox360)                          {                              var packageListWriter = new StreamWriter(packageListStream);                              packageListWriter.Write(dlcName);                              packageListWriter.Flush();                              packageListStream.Seek(0' SeekOrigin.Begin);                              const string packageList = "PackageList.txt";                              packageListStream.WriteTmpFile(packageList' platform);                          }                            // AGGREGATE GRAPH                          var aggregateGraphFileName = String.Format("{0}_aggregategraph.nt"' dlcName);                          var aggregateGraph = new AggregateGraph2014.AggregateGraph2014(info' platform' DLCPackageType.Inlay);                          aggregateGraph.Serialize(aggregateGraphStream);                          aggregateGraphStream.Flush();                          aggregateGraphStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(aggregateGraphFileName' aggregateGraphStream);                            // MANIFEST                          var attribute = new InlayAttributes2014(info);                          var attributeDictionary = new Dictionary<string' InlayAttributes2014> { { "Attributes"' attribute } };                          var manifest = new Manifest2014<InlayAttributes2014>(DLCPackageType.Inlay);                          manifest.Entries.Add(attribute.PersistentID' attributeDictionary);                          var manifestStream = new MemoryStream();                          manifestStreamList.Add(manifestStream);                          manifest.Serialize(manifestStream);                          manifestStream.Seek(0' SeekOrigin.Begin);                          const string jsonPathPC = "manifests/songs_dlc_{0}/dlc_guitar_{0}.json";                          const string jsonPathConsole = "manifests/songs_dlc/dlc_guitar_{0}.json";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? jsonPathConsole : jsonPathPC)' dlcName)' manifestStream);                            // MANIFEST HEADER                          var attributeHeaderDictionary = new Dictionary<string' InlayAttributes2014> { { "Attributes"' attribute } };                          var manifestHeader = new ManifestHeader2014<InlayAttributes2014>(platform' DLCPackageType.Inlay);                          manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                          manifestHeader.Serialize(manifestHeaderStream);                          manifestHeaderStream.Seek(0' SeekOrigin.Begin);                          const string hsanPathPC = "manifests/songs_dlc_{0}/dlc_{0}.hsan";                          const string hsonPathConsole = "manifests/songs_dlc/dlc_{0}.hson";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? hsonPathConsole : hsanPathPC)' dlcName)' manifestHeaderStream);                            // XBLOCK                          GameXblock<Entity2014> game = GameXblock<Entity2014>.Generate2014(info' platform' DLCPackageType.Inlay);                          game.SerializeXml(xblockStream);                          xblockStream.Flush();                          xblockStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("gamexblocks/nguitars/guitar_{0}.xblock"' dlcName)' xblockStream);                            // INLAY NIF                          InlayNif nif = new InlayNif(info);                          nif.Serialize(nifStream);                          nifStream.Flush();                          nifStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("assets/gameplay/inlay/{0}.nif"' dlcName)' nifStream);                            // WRITE PACKAGE                          packPsarc.Write(output' !platform.IsConsole);                          output.WriteTmpFile(String.Format("{0}.psarc"' dlcName)' platform);                      }                  }                  catch (Exception)                  {                      throw;                  }                  finally                  {                      // Dispose all objects                      if (rsenumerableRootStream != null)                          rsenumerableRootStream.Dispose();                      if (rsenumerableGuitarStream != null)                          rsenumerableGuitarStream.Dispose();                      DeleteTmpFiles(TMPFILES_ART);                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014InlayPsarc,The following statement contains a magic number: {                  packPsarc = new PSARC.PSARC();                    // Stream objects                  Stream rsenumerableRootStream = null'                         rsenumerableGuitarStream = null;                    try                  {                      // ICON/INLAY FILES                      var ddsfiles = info.ArtFiles;                        if (ddsfiles == null)                      {                          string iconPath;                          if (File.Exists(info.Inlay.IconPath))                          {                              iconPath = info.Inlay.IconPath;                          }                          else                          {                              using (var iconStream = new MemoryStream(Resources.cgm_default_icon))                              {                                  iconPath = Path.ChangeExtension(Path.GetTempFileName()' ".png");                                  iconStream.WriteFile(iconPath);                                  TMPFILES_ART.Add(iconPath);                              }                          }                            string inlayPath;                          if (File.Exists(info.Inlay.InlayPath))                          {                              inlayPath = info.Inlay.InlayPath;                          }                          else                          {                              using (var inlayStream = new MemoryStream(Resources.cgm_default_inlay))                              {                                  inlayPath = GeneralExtensions.GetTempFileName(".png");                                  inlayStream.WriteFile(inlayPath);                                  TMPFILES_ART.Add(inlayPath);                              }                          }                            ddsfiles = new List<DDSConvertedFile>();                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 512' sizeY = 512' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 1024' sizeY = 512' sourceFile = inlayPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                            // Convert to DDS                          ToDDS(ddsfiles' DLCPackageType.Inlay);                            // Save for reuse                          info.ArtFiles = ddsfiles;                      }                        foreach (var dds in info.ArtFiles)                          if (dds.sizeX == 1024)                              packPsarc.AddEntry(String.Format("assets/gameplay/inlay/inlay_{0}.dds"' dlcName)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                          else                              packPsarc.AddEntry(String.Format("gfxassets/rewards/guitar_inlays/reward_inlay_{0}_{1}.dds"' dlcName' dds.sizeX)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                        // FLAT MODEL                      rsenumerableRootStream = new MemoryStream(Resources.rsenumerable_root);                      packPsarc.AddEntry("flatmodels/rs/rsenumerable_root.flat"' rsenumerableRootStream);                      rsenumerableGuitarStream = new MemoryStream(Resources.rsenumerable_guitar);                      packPsarc.AddEntry("flatmodels/rs/rsenumerable_guitars.flat"' rsenumerableGuitarStream);                        using (var toolkitVersionStream = new MemoryStream())                      using (var appIdStream = new MemoryStream())                      using (var packageListStream = new MemoryStream())                      using (var aggregateGraphStream = new MemoryStream())                      using (var manifestStreamList = new DisposableCollection<Stream>())                      using (var manifestHeaderStream = new MemoryStream())                      using (var nifStream = new MemoryStream())                      using (var xblockStream = new MemoryStream())                      {                          // TOOLKIT VERSION                          GenerateToolkitVersion(toolkitVersionStream);                          packPsarc.AddEntry("toolkit.version"' toolkitVersionStream);                            // APP ID                          if (!platform.IsConsole)                          {                              GenerateAppId(appIdStream' info.AppId' platform);                              packPsarc.AddEntry("appid.appid"' appIdStream);                          }                            if (platform.platform == GamePlatform.XBox360)                          {                              var packageListWriter = new StreamWriter(packageListStream);                              packageListWriter.Write(dlcName);                              packageListWriter.Flush();                              packageListStream.Seek(0' SeekOrigin.Begin);                              const string packageList = "PackageList.txt";                              packageListStream.WriteTmpFile(packageList' platform);                          }                            // AGGREGATE GRAPH                          var aggregateGraphFileName = String.Format("{0}_aggregategraph.nt"' dlcName);                          var aggregateGraph = new AggregateGraph2014.AggregateGraph2014(info' platform' DLCPackageType.Inlay);                          aggregateGraph.Serialize(aggregateGraphStream);                          aggregateGraphStream.Flush();                          aggregateGraphStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(aggregateGraphFileName' aggregateGraphStream);                            // MANIFEST                          var attribute = new InlayAttributes2014(info);                          var attributeDictionary = new Dictionary<string' InlayAttributes2014> { { "Attributes"' attribute } };                          var manifest = new Manifest2014<InlayAttributes2014>(DLCPackageType.Inlay);                          manifest.Entries.Add(attribute.PersistentID' attributeDictionary);                          var manifestStream = new MemoryStream();                          manifestStreamList.Add(manifestStream);                          manifest.Serialize(manifestStream);                          manifestStream.Seek(0' SeekOrigin.Begin);                          const string jsonPathPC = "manifests/songs_dlc_{0}/dlc_guitar_{0}.json";                          const string jsonPathConsole = "manifests/songs_dlc/dlc_guitar_{0}.json";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? jsonPathConsole : jsonPathPC)' dlcName)' manifestStream);                            // MANIFEST HEADER                          var attributeHeaderDictionary = new Dictionary<string' InlayAttributes2014> { { "Attributes"' attribute } };                          var manifestHeader = new ManifestHeader2014<InlayAttributes2014>(platform' DLCPackageType.Inlay);                          manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                          manifestHeader.Serialize(manifestHeaderStream);                          manifestHeaderStream.Seek(0' SeekOrigin.Begin);                          const string hsanPathPC = "manifests/songs_dlc_{0}/dlc_{0}.hsan";                          const string hsonPathConsole = "manifests/songs_dlc/dlc_{0}.hson";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? hsonPathConsole : hsanPathPC)' dlcName)' manifestHeaderStream);                            // XBLOCK                          GameXblock<Entity2014> game = GameXblock<Entity2014>.Generate2014(info' platform' DLCPackageType.Inlay);                          game.SerializeXml(xblockStream);                          xblockStream.Flush();                          xblockStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("gamexblocks/nguitars/guitar_{0}.xblock"' dlcName)' xblockStream);                            // INLAY NIF                          InlayNif nif = new InlayNif(info);                          nif.Serialize(nifStream);                          nifStream.Flush();                          nifStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("assets/gameplay/inlay/{0}.nif"' dlcName)' nifStream);                            // WRITE PACKAGE                          packPsarc.Write(output' !platform.IsConsole);                          output.WriteTmpFile(String.Format("{0}.psarc"' dlcName)' platform);                      }                  }                  catch (Exception)                  {                      throw;                  }                  finally                  {                      // Dispose all objects                      if (rsenumerableRootStream != null)                          rsenumerableRootStream.Dispose();                      if (rsenumerableGuitarStream != null)                          rsenumerableGuitarStream.Dispose();                      DeleteTmpFiles(TMPFILES_ART);                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014InlayPsarc,The following statement contains a magic number: {                  packPsarc = new PSARC.PSARC();                    // Stream objects                  Stream rsenumerableRootStream = null'                         rsenumerableGuitarStream = null;                    try                  {                      // ICON/INLAY FILES                      var ddsfiles = info.ArtFiles;                        if (ddsfiles == null)                      {                          string iconPath;                          if (File.Exists(info.Inlay.IconPath))                          {                              iconPath = info.Inlay.IconPath;                          }                          else                          {                              using (var iconStream = new MemoryStream(Resources.cgm_default_icon))                              {                                  iconPath = Path.ChangeExtension(Path.GetTempFileName()' ".png");                                  iconStream.WriteFile(iconPath);                                  TMPFILES_ART.Add(iconPath);                              }                          }                            string inlayPath;                          if (File.Exists(info.Inlay.InlayPath))                          {                              inlayPath = info.Inlay.InlayPath;                          }                          else                          {                              using (var inlayStream = new MemoryStream(Resources.cgm_default_inlay))                              {                                  inlayPath = GeneralExtensions.GetTempFileName(".png");                                  inlayStream.WriteFile(inlayPath);                                  TMPFILES_ART.Add(inlayPath);                              }                          }                            ddsfiles = new List<DDSConvertedFile>();                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 512' sizeY = 512' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 1024' sizeY = 512' sourceFile = inlayPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                            // Convert to DDS                          ToDDS(ddsfiles' DLCPackageType.Inlay);                            // Save for reuse                          info.ArtFiles = ddsfiles;                      }                        foreach (var dds in info.ArtFiles)                          if (dds.sizeX == 1024)                              packPsarc.AddEntry(String.Format("assets/gameplay/inlay/inlay_{0}.dds"' dlcName)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                          else                              packPsarc.AddEntry(String.Format("gfxassets/rewards/guitar_inlays/reward_inlay_{0}_{1}.dds"' dlcName' dds.sizeX)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                        // FLAT MODEL                      rsenumerableRootStream = new MemoryStream(Resources.rsenumerable_root);                      packPsarc.AddEntry("flatmodels/rs/rsenumerable_root.flat"' rsenumerableRootStream);                      rsenumerableGuitarStream = new MemoryStream(Resources.rsenumerable_guitar);                      packPsarc.AddEntry("flatmodels/rs/rsenumerable_guitars.flat"' rsenumerableGuitarStream);                        using (var toolkitVersionStream = new MemoryStream())                      using (var appIdStream = new MemoryStream())                      using (var packageListStream = new MemoryStream())                      using (var aggregateGraphStream = new MemoryStream())                      using (var manifestStreamList = new DisposableCollection<Stream>())                      using (var manifestHeaderStream = new MemoryStream())                      using (var nifStream = new MemoryStream())                      using (var xblockStream = new MemoryStream())                      {                          // TOOLKIT VERSION                          GenerateToolkitVersion(toolkitVersionStream);                          packPsarc.AddEntry("toolkit.version"' toolkitVersionStream);                            // APP ID                          if (!platform.IsConsole)                          {                              GenerateAppId(appIdStream' info.AppId' platform);                              packPsarc.AddEntry("appid.appid"' appIdStream);                          }                            if (platform.platform == GamePlatform.XBox360)                          {                              var packageListWriter = new StreamWriter(packageListStream);                              packageListWriter.Write(dlcName);                              packageListWriter.Flush();                              packageListStream.Seek(0' SeekOrigin.Begin);                              const string packageList = "PackageList.txt";                              packageListStream.WriteTmpFile(packageList' platform);                          }                            // AGGREGATE GRAPH                          var aggregateGraphFileName = String.Format("{0}_aggregategraph.nt"' dlcName);                          var aggregateGraph = new AggregateGraph2014.AggregateGraph2014(info' platform' DLCPackageType.Inlay);                          aggregateGraph.Serialize(aggregateGraphStream);                          aggregateGraphStream.Flush();                          aggregateGraphStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(aggregateGraphFileName' aggregateGraphStream);                            // MANIFEST                          var attribute = new InlayAttributes2014(info);                          var attributeDictionary = new Dictionary<string' InlayAttributes2014> { { "Attributes"' attribute } };                          var manifest = new Manifest2014<InlayAttributes2014>(DLCPackageType.Inlay);                          manifest.Entries.Add(attribute.PersistentID' attributeDictionary);                          var manifestStream = new MemoryStream();                          manifestStreamList.Add(manifestStream);                          manifest.Serialize(manifestStream);                          manifestStream.Seek(0' SeekOrigin.Begin);                          const string jsonPathPC = "manifests/songs_dlc_{0}/dlc_guitar_{0}.json";                          const string jsonPathConsole = "manifests/songs_dlc/dlc_guitar_{0}.json";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? jsonPathConsole : jsonPathPC)' dlcName)' manifestStream);                            // MANIFEST HEADER                          var attributeHeaderDictionary = new Dictionary<string' InlayAttributes2014> { { "Attributes"' attribute } };                          var manifestHeader = new ManifestHeader2014<InlayAttributes2014>(platform' DLCPackageType.Inlay);                          manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                          manifestHeader.Serialize(manifestHeaderStream);                          manifestHeaderStream.Seek(0' SeekOrigin.Begin);                          const string hsanPathPC = "manifests/songs_dlc_{0}/dlc_{0}.hsan";                          const string hsonPathConsole = "manifests/songs_dlc/dlc_{0}.hson";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? hsonPathConsole : hsanPathPC)' dlcName)' manifestHeaderStream);                            // XBLOCK                          GameXblock<Entity2014> game = GameXblock<Entity2014>.Generate2014(info' platform' DLCPackageType.Inlay);                          game.SerializeXml(xblockStream);                          xblockStream.Flush();                          xblockStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("gamexblocks/nguitars/guitar_{0}.xblock"' dlcName)' xblockStream);                            // INLAY NIF                          InlayNif nif = new InlayNif(info);                          nif.Serialize(nifStream);                          nifStream.Flush();                          nifStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("assets/gameplay/inlay/{0}.nif"' dlcName)' nifStream);                            // WRITE PACKAGE                          packPsarc.Write(output' !platform.IsConsole);                          output.WriteTmpFile(String.Format("{0}.psarc"' dlcName)' platform);                      }                  }                  catch (Exception)                  {                      throw;                  }                  finally                  {                      // Dispose all objects                      if (rsenumerableRootStream != null)                          rsenumerableRootStream.Dispose();                      if (rsenumerableGuitarStream != null)                          rsenumerableGuitarStream.Dispose();                      DeleteTmpFiles(TMPFILES_ART);                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014InlayPsarc,The following statement contains a magic number: {                  packPsarc = new PSARC.PSARC();                    // Stream objects                  Stream rsenumerableRootStream = null'                         rsenumerableGuitarStream = null;                    try                  {                      // ICON/INLAY FILES                      var ddsfiles = info.ArtFiles;                        if (ddsfiles == null)                      {                          string iconPath;                          if (File.Exists(info.Inlay.IconPath))                          {                              iconPath = info.Inlay.IconPath;                          }                          else                          {                              using (var iconStream = new MemoryStream(Resources.cgm_default_icon))                              {                                  iconPath = Path.ChangeExtension(Path.GetTempFileName()' ".png");                                  iconStream.WriteFile(iconPath);                                  TMPFILES_ART.Add(iconPath);                              }                          }                            string inlayPath;                          if (File.Exists(info.Inlay.InlayPath))                          {                              inlayPath = info.Inlay.InlayPath;                          }                          else                          {                              using (var inlayStream = new MemoryStream(Resources.cgm_default_inlay))                              {                                  inlayPath = GeneralExtensions.GetTempFileName(".png");                                  inlayStream.WriteFile(inlayPath);                                  TMPFILES_ART.Add(inlayPath);                              }                          }                            ddsfiles = new List<DDSConvertedFile>();                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 512' sizeY = 512' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 1024' sizeY = 512' sourceFile = inlayPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                            // Convert to DDS                          ToDDS(ddsfiles' DLCPackageType.Inlay);                            // Save for reuse                          info.ArtFiles = ddsfiles;                      }                        foreach (var dds in info.ArtFiles)                          if (dds.sizeX == 1024)                              packPsarc.AddEntry(String.Format("assets/gameplay/inlay/inlay_{0}.dds"' dlcName)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                          else                              packPsarc.AddEntry(String.Format("gfxassets/rewards/guitar_inlays/reward_inlay_{0}_{1}.dds"' dlcName' dds.sizeX)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                        // FLAT MODEL                      rsenumerableRootStream = new MemoryStream(Resources.rsenumerable_root);                      packPsarc.AddEntry("flatmodels/rs/rsenumerable_root.flat"' rsenumerableRootStream);                      rsenumerableGuitarStream = new MemoryStream(Resources.rsenumerable_guitar);                      packPsarc.AddEntry("flatmodels/rs/rsenumerable_guitars.flat"' rsenumerableGuitarStream);                        using (var toolkitVersionStream = new MemoryStream())                      using (var appIdStream = new MemoryStream())                      using (var packageListStream = new MemoryStream())                      using (var aggregateGraphStream = new MemoryStream())                      using (var manifestStreamList = new DisposableCollection<Stream>())                      using (var manifestHeaderStream = new MemoryStream())                      using (var nifStream = new MemoryStream())                      using (var xblockStream = new MemoryStream())                      {                          // TOOLKIT VERSION                          GenerateToolkitVersion(toolkitVersionStream);                          packPsarc.AddEntry("toolkit.version"' toolkitVersionStream);                            // APP ID                          if (!platform.IsConsole)                          {                              GenerateAppId(appIdStream' info.AppId' platform);                              packPsarc.AddEntry("appid.appid"' appIdStream);                          }                            if (platform.platform == GamePlatform.XBox360)                          {                              var packageListWriter = new StreamWriter(packageListStream);                              packageListWriter.Write(dlcName);                              packageListWriter.Flush();                              packageListStream.Seek(0' SeekOrigin.Begin);                              const string packageList = "PackageList.txt";                              packageListStream.WriteTmpFile(packageList' platform);                          }                            // AGGREGATE GRAPH                          var aggregateGraphFileName = String.Format("{0}_aggregategraph.nt"' dlcName);                          var aggregateGraph = new AggregateGraph2014.AggregateGraph2014(info' platform' DLCPackageType.Inlay);                          aggregateGraph.Serialize(aggregateGraphStream);                          aggregateGraphStream.Flush();                          aggregateGraphStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(aggregateGraphFileName' aggregateGraphStream);                            // MANIFEST                          var attribute = new InlayAttributes2014(info);                          var attributeDictionary = new Dictionary<string' InlayAttributes2014> { { "Attributes"' attribute } };                          var manifest = new Manifest2014<InlayAttributes2014>(DLCPackageType.Inlay);                          manifest.Entries.Add(attribute.PersistentID' attributeDictionary);                          var manifestStream = new MemoryStream();                          manifestStreamList.Add(manifestStream);                          manifest.Serialize(manifestStream);                          manifestStream.Seek(0' SeekOrigin.Begin);                          const string jsonPathPC = "manifests/songs_dlc_{0}/dlc_guitar_{0}.json";                          const string jsonPathConsole = "manifests/songs_dlc/dlc_guitar_{0}.json";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? jsonPathConsole : jsonPathPC)' dlcName)' manifestStream);                            // MANIFEST HEADER                          var attributeHeaderDictionary = new Dictionary<string' InlayAttributes2014> { { "Attributes"' attribute } };                          var manifestHeader = new ManifestHeader2014<InlayAttributes2014>(platform' DLCPackageType.Inlay);                          manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                          manifestHeader.Serialize(manifestHeaderStream);                          manifestHeaderStream.Seek(0' SeekOrigin.Begin);                          const string hsanPathPC = "manifests/songs_dlc_{0}/dlc_{0}.hsan";                          const string hsonPathConsole = "manifests/songs_dlc/dlc_{0}.hson";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? hsonPathConsole : hsanPathPC)' dlcName)' manifestHeaderStream);                            // XBLOCK                          GameXblock<Entity2014> game = GameXblock<Entity2014>.Generate2014(info' platform' DLCPackageType.Inlay);                          game.SerializeXml(xblockStream);                          xblockStream.Flush();                          xblockStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("gamexblocks/nguitars/guitar_{0}.xblock"' dlcName)' xblockStream);                            // INLAY NIF                          InlayNif nif = new InlayNif(info);                          nif.Serialize(nifStream);                          nifStream.Flush();                          nifStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("assets/gameplay/inlay/{0}.nif"' dlcName)' nifStream);                            // WRITE PACKAGE                          packPsarc.Write(output' !platform.IsConsole);                          output.WriteTmpFile(String.Format("{0}.psarc"' dlcName)' platform);                      }                  }                  catch (Exception)                  {                      throw;                  }                  finally                  {                      // Dispose all objects                      if (rsenumerableRootStream != null)                          rsenumerableRootStream.Dispose();                      if (rsenumerableGuitarStream != null)                          rsenumerableGuitarStream.Dispose();                      DeleteTmpFiles(TMPFILES_ART);                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014InlayPsarc,The following statement contains a magic number: {                  packPsarc = new PSARC.PSARC();                    // Stream objects                  Stream rsenumerableRootStream = null'                         rsenumerableGuitarStream = null;                    try                  {                      // ICON/INLAY FILES                      var ddsfiles = info.ArtFiles;                        if (ddsfiles == null)                      {                          string iconPath;                          if (File.Exists(info.Inlay.IconPath))                          {                              iconPath = info.Inlay.IconPath;                          }                          else                          {                              using (var iconStream = new MemoryStream(Resources.cgm_default_icon))                              {                                  iconPath = Path.ChangeExtension(Path.GetTempFileName()' ".png");                                  iconStream.WriteFile(iconPath);                                  TMPFILES_ART.Add(iconPath);                              }                          }                            string inlayPath;                          if (File.Exists(info.Inlay.InlayPath))                          {                              inlayPath = info.Inlay.InlayPath;                          }                          else                          {                              using (var inlayStream = new MemoryStream(Resources.cgm_default_inlay))                              {                                  inlayPath = GeneralExtensions.GetTempFileName(".png");                                  inlayStream.WriteFile(inlayPath);                                  TMPFILES_ART.Add(inlayPath);                              }                          }                            ddsfiles = new List<DDSConvertedFile>();                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 512' sizeY = 512' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 1024' sizeY = 512' sourceFile = inlayPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                            // Convert to DDS                          ToDDS(ddsfiles' DLCPackageType.Inlay);                            // Save for reuse                          info.ArtFiles = ddsfiles;                      }                        foreach (var dds in info.ArtFiles)                          if (dds.sizeX == 1024)                              packPsarc.AddEntry(String.Format("assets/gameplay/inlay/inlay_{0}.dds"' dlcName)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                          else                              packPsarc.AddEntry(String.Format("gfxassets/rewards/guitar_inlays/reward_inlay_{0}_{1}.dds"' dlcName' dds.sizeX)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                        // FLAT MODEL                      rsenumerableRootStream = new MemoryStream(Resources.rsenumerable_root);                      packPsarc.AddEntry("flatmodels/rs/rsenumerable_root.flat"' rsenumerableRootStream);                      rsenumerableGuitarStream = new MemoryStream(Resources.rsenumerable_guitar);                      packPsarc.AddEntry("flatmodels/rs/rsenumerable_guitars.flat"' rsenumerableGuitarStream);                        using (var toolkitVersionStream = new MemoryStream())                      using (var appIdStream = new MemoryStream())                      using (var packageListStream = new MemoryStream())                      using (var aggregateGraphStream = new MemoryStream())                      using (var manifestStreamList = new DisposableCollection<Stream>())                      using (var manifestHeaderStream = new MemoryStream())                      using (var nifStream = new MemoryStream())                      using (var xblockStream = new MemoryStream())                      {                          // TOOLKIT VERSION                          GenerateToolkitVersion(toolkitVersionStream);                          packPsarc.AddEntry("toolkit.version"' toolkitVersionStream);                            // APP ID                          if (!platform.IsConsole)                          {                              GenerateAppId(appIdStream' info.AppId' platform);                              packPsarc.AddEntry("appid.appid"' appIdStream);                          }                            if (platform.platform == GamePlatform.XBox360)                          {                              var packageListWriter = new StreamWriter(packageListStream);                              packageListWriter.Write(dlcName);                              packageListWriter.Flush();                              packageListStream.Seek(0' SeekOrigin.Begin);                              const string packageList = "PackageList.txt";                              packageListStream.WriteTmpFile(packageList' platform);                          }                            // AGGREGATE GRAPH                          var aggregateGraphFileName = String.Format("{0}_aggregategraph.nt"' dlcName);                          var aggregateGraph = new AggregateGraph2014.AggregateGraph2014(info' platform' DLCPackageType.Inlay);                          aggregateGraph.Serialize(aggregateGraphStream);                          aggregateGraphStream.Flush();                          aggregateGraphStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(aggregateGraphFileName' aggregateGraphStream);                            // MANIFEST                          var attribute = new InlayAttributes2014(info);                          var attributeDictionary = new Dictionary<string' InlayAttributes2014> { { "Attributes"' attribute } };                          var manifest = new Manifest2014<InlayAttributes2014>(DLCPackageType.Inlay);                          manifest.Entries.Add(attribute.PersistentID' attributeDictionary);                          var manifestStream = new MemoryStream();                          manifestStreamList.Add(manifestStream);                          manifest.Serialize(manifestStream);                          manifestStream.Seek(0' SeekOrigin.Begin);                          const string jsonPathPC = "manifests/songs_dlc_{0}/dlc_guitar_{0}.json";                          const string jsonPathConsole = "manifests/songs_dlc/dlc_guitar_{0}.json";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? jsonPathConsole : jsonPathPC)' dlcName)' manifestStream);                            // MANIFEST HEADER                          var attributeHeaderDictionary = new Dictionary<string' InlayAttributes2014> { { "Attributes"' attribute } };                          var manifestHeader = new ManifestHeader2014<InlayAttributes2014>(platform' DLCPackageType.Inlay);                          manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                          manifestHeader.Serialize(manifestHeaderStream);                          manifestHeaderStream.Seek(0' SeekOrigin.Begin);                          const string hsanPathPC = "manifests/songs_dlc_{0}/dlc_{0}.hsan";                          const string hsonPathConsole = "manifests/songs_dlc/dlc_{0}.hson";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? hsonPathConsole : hsanPathPC)' dlcName)' manifestHeaderStream);                            // XBLOCK                          GameXblock<Entity2014> game = GameXblock<Entity2014>.Generate2014(info' platform' DLCPackageType.Inlay);                          game.SerializeXml(xblockStream);                          xblockStream.Flush();                          xblockStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("gamexblocks/nguitars/guitar_{0}.xblock"' dlcName)' xblockStream);                            // INLAY NIF                          InlayNif nif = new InlayNif(info);                          nif.Serialize(nifStream);                          nifStream.Flush();                          nifStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("assets/gameplay/inlay/{0}.nif"' dlcName)' nifStream);                            // WRITE PACKAGE                          packPsarc.Write(output' !platform.IsConsole);                          output.WriteTmpFile(String.Format("{0}.psarc"' dlcName)' platform);                      }                  }                  catch (Exception)                  {                      throw;                  }                  finally                  {                      // Dispose all objects                      if (rsenumerableRootStream != null)                          rsenumerableRootStream.Dispose();                      if (rsenumerableGuitarStream != null)                          rsenumerableGuitarStream.Dispose();                      DeleteTmpFiles(TMPFILES_ART);                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014InlayPsarc,The following statement contains a magic number: {                  packPsarc = new PSARC.PSARC();                    // Stream objects                  Stream rsenumerableRootStream = null'                         rsenumerableGuitarStream = null;                    try                  {                      // ICON/INLAY FILES                      var ddsfiles = info.ArtFiles;                        if (ddsfiles == null)                      {                          string iconPath;                          if (File.Exists(info.Inlay.IconPath))                          {                              iconPath = info.Inlay.IconPath;                          }                          else                          {                              using (var iconStream = new MemoryStream(Resources.cgm_default_icon))                              {                                  iconPath = Path.ChangeExtension(Path.GetTempFileName()' ".png");                                  iconStream.WriteFile(iconPath);                                  TMPFILES_ART.Add(iconPath);                              }                          }                            string inlayPath;                          if (File.Exists(info.Inlay.InlayPath))                          {                              inlayPath = info.Inlay.InlayPath;                          }                          else                          {                              using (var inlayStream = new MemoryStream(Resources.cgm_default_inlay))                              {                                  inlayPath = GeneralExtensions.GetTempFileName(".png");                                  inlayStream.WriteFile(inlayPath);                                  TMPFILES_ART.Add(inlayPath);                              }                          }                            ddsfiles = new List<DDSConvertedFile>();                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 512' sizeY = 512' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 1024' sizeY = 512' sourceFile = inlayPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                            // Convert to DDS                          ToDDS(ddsfiles' DLCPackageType.Inlay);                            // Save for reuse                          info.ArtFiles = ddsfiles;                      }                        foreach (var dds in info.ArtFiles)                          if (dds.sizeX == 1024)                              packPsarc.AddEntry(String.Format("assets/gameplay/inlay/inlay_{0}.dds"' dlcName)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                          else                              packPsarc.AddEntry(String.Format("gfxassets/rewards/guitar_inlays/reward_inlay_{0}_{1}.dds"' dlcName' dds.sizeX)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                        // FLAT MODEL                      rsenumerableRootStream = new MemoryStream(Resources.rsenumerable_root);                      packPsarc.AddEntry("flatmodels/rs/rsenumerable_root.flat"' rsenumerableRootStream);                      rsenumerableGuitarStream = new MemoryStream(Resources.rsenumerable_guitar);                      packPsarc.AddEntry("flatmodels/rs/rsenumerable_guitars.flat"' rsenumerableGuitarStream);                        using (var toolkitVersionStream = new MemoryStream())                      using (var appIdStream = new MemoryStream())                      using (var packageListStream = new MemoryStream())                      using (var aggregateGraphStream = new MemoryStream())                      using (var manifestStreamList = new DisposableCollection<Stream>())                      using (var manifestHeaderStream = new MemoryStream())                      using (var nifStream = new MemoryStream())                      using (var xblockStream = new MemoryStream())                      {                          // TOOLKIT VERSION                          GenerateToolkitVersion(toolkitVersionStream);                          packPsarc.AddEntry("toolkit.version"' toolkitVersionStream);                            // APP ID                          if (!platform.IsConsole)                          {                              GenerateAppId(appIdStream' info.AppId' platform);                              packPsarc.AddEntry("appid.appid"' appIdStream);                          }                            if (platform.platform == GamePlatform.XBox360)                          {                              var packageListWriter = new StreamWriter(packageListStream);                              packageListWriter.Write(dlcName);                              packageListWriter.Flush();                              packageListStream.Seek(0' SeekOrigin.Begin);                              const string packageList = "PackageList.txt";                              packageListStream.WriteTmpFile(packageList' platform);                          }                            // AGGREGATE GRAPH                          var aggregateGraphFileName = String.Format("{0}_aggregategraph.nt"' dlcName);                          var aggregateGraph = new AggregateGraph2014.AggregateGraph2014(info' platform' DLCPackageType.Inlay);                          aggregateGraph.Serialize(aggregateGraphStream);                          aggregateGraphStream.Flush();                          aggregateGraphStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(aggregateGraphFileName' aggregateGraphStream);                            // MANIFEST                          var attribute = new InlayAttributes2014(info);                          var attributeDictionary = new Dictionary<string' InlayAttributes2014> { { "Attributes"' attribute } };                          var manifest = new Manifest2014<InlayAttributes2014>(DLCPackageType.Inlay);                          manifest.Entries.Add(attribute.PersistentID' attributeDictionary);                          var manifestStream = new MemoryStream();                          manifestStreamList.Add(manifestStream);                          manifest.Serialize(manifestStream);                          manifestStream.Seek(0' SeekOrigin.Begin);                          const string jsonPathPC = "manifests/songs_dlc_{0}/dlc_guitar_{0}.json";                          const string jsonPathConsole = "manifests/songs_dlc/dlc_guitar_{0}.json";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? jsonPathConsole : jsonPathPC)' dlcName)' manifestStream);                            // MANIFEST HEADER                          var attributeHeaderDictionary = new Dictionary<string' InlayAttributes2014> { { "Attributes"' attribute } };                          var manifestHeader = new ManifestHeader2014<InlayAttributes2014>(platform' DLCPackageType.Inlay);                          manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                          manifestHeader.Serialize(manifestHeaderStream);                          manifestHeaderStream.Seek(0' SeekOrigin.Begin);                          const string hsanPathPC = "manifests/songs_dlc_{0}/dlc_{0}.hsan";                          const string hsonPathConsole = "manifests/songs_dlc/dlc_{0}.hson";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? hsonPathConsole : hsanPathPC)' dlcName)' manifestHeaderStream);                            // XBLOCK                          GameXblock<Entity2014> game = GameXblock<Entity2014>.Generate2014(info' platform' DLCPackageType.Inlay);                          game.SerializeXml(xblockStream);                          xblockStream.Flush();                          xblockStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("gamexblocks/nguitars/guitar_{0}.xblock"' dlcName)' xblockStream);                            // INLAY NIF                          InlayNif nif = new InlayNif(info);                          nif.Serialize(nifStream);                          nifStream.Flush();                          nifStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("assets/gameplay/inlay/{0}.nif"' dlcName)' nifStream);                            // WRITE PACKAGE                          packPsarc.Write(output' !platform.IsConsole);                          output.WriteTmpFile(String.Format("{0}.psarc"' dlcName)' platform);                      }                  }                  catch (Exception)                  {                      throw;                  }                  finally                  {                      // Dispose all objects                      if (rsenumerableRootStream != null)                          rsenumerableRootStream.Dispose();                      if (rsenumerableGuitarStream != null)                          rsenumerableGuitarStream.Dispose();                      DeleteTmpFiles(TMPFILES_ART);                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014InlayPsarc,The following statement contains a magic number: {                  packPsarc = new PSARC.PSARC();                    // Stream objects                  Stream rsenumerableRootStream = null'                         rsenumerableGuitarStream = null;                    try                  {                      // ICON/INLAY FILES                      var ddsfiles = info.ArtFiles;                        if (ddsfiles == null)                      {                          string iconPath;                          if (File.Exists(info.Inlay.IconPath))                          {                              iconPath = info.Inlay.IconPath;                          }                          else                          {                              using (var iconStream = new MemoryStream(Resources.cgm_default_icon))                              {                                  iconPath = Path.ChangeExtension(Path.GetTempFileName()' ".png");                                  iconStream.WriteFile(iconPath);                                  TMPFILES_ART.Add(iconPath);                              }                          }                            string inlayPath;                          if (File.Exists(info.Inlay.InlayPath))                          {                              inlayPath = info.Inlay.InlayPath;                          }                          else                          {                              using (var inlayStream = new MemoryStream(Resources.cgm_default_inlay))                              {                                  inlayPath = GeneralExtensions.GetTempFileName(".png");                                  inlayStream.WriteFile(inlayPath);                                  TMPFILES_ART.Add(inlayPath);                              }                          }                            ddsfiles = new List<DDSConvertedFile>();                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 512' sizeY = 512' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 1024' sizeY = 512' sourceFile = inlayPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                            // Convert to DDS                          ToDDS(ddsfiles' DLCPackageType.Inlay);                            // Save for reuse                          info.ArtFiles = ddsfiles;                      }                        foreach (var dds in info.ArtFiles)                          if (dds.sizeX == 1024)                              packPsarc.AddEntry(String.Format("assets/gameplay/inlay/inlay_{0}.dds"' dlcName)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                          else                              packPsarc.AddEntry(String.Format("gfxassets/rewards/guitar_inlays/reward_inlay_{0}_{1}.dds"' dlcName' dds.sizeX)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                        // FLAT MODEL                      rsenumerableRootStream = new MemoryStream(Resources.rsenumerable_root);                      packPsarc.AddEntry("flatmodels/rs/rsenumerable_root.flat"' rsenumerableRootStream);                      rsenumerableGuitarStream = new MemoryStream(Resources.rsenumerable_guitar);                      packPsarc.AddEntry("flatmodels/rs/rsenumerable_guitars.flat"' rsenumerableGuitarStream);                        using (var toolkitVersionStream = new MemoryStream())                      using (var appIdStream = new MemoryStream())                      using (var packageListStream = new MemoryStream())                      using (var aggregateGraphStream = new MemoryStream())                      using (var manifestStreamList = new DisposableCollection<Stream>())                      using (var manifestHeaderStream = new MemoryStream())                      using (var nifStream = new MemoryStream())                      using (var xblockStream = new MemoryStream())                      {                          // TOOLKIT VERSION                          GenerateToolkitVersion(toolkitVersionStream);                          packPsarc.AddEntry("toolkit.version"' toolkitVersionStream);                            // APP ID                          if (!platform.IsConsole)                          {                              GenerateAppId(appIdStream' info.AppId' platform);                              packPsarc.AddEntry("appid.appid"' appIdStream);                          }                            if (platform.platform == GamePlatform.XBox360)                          {                              var packageListWriter = new StreamWriter(packageListStream);                              packageListWriter.Write(dlcName);                              packageListWriter.Flush();                              packageListStream.Seek(0' SeekOrigin.Begin);                              const string packageList = "PackageList.txt";                              packageListStream.WriteTmpFile(packageList' platform);                          }                            // AGGREGATE GRAPH                          var aggregateGraphFileName = String.Format("{0}_aggregategraph.nt"' dlcName);                          var aggregateGraph = new AggregateGraph2014.AggregateGraph2014(info' platform' DLCPackageType.Inlay);                          aggregateGraph.Serialize(aggregateGraphStream);                          aggregateGraphStream.Flush();                          aggregateGraphStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(aggregateGraphFileName' aggregateGraphStream);                            // MANIFEST                          var attribute = new InlayAttributes2014(info);                          var attributeDictionary = new Dictionary<string' InlayAttributes2014> { { "Attributes"' attribute } };                          var manifest = new Manifest2014<InlayAttributes2014>(DLCPackageType.Inlay);                          manifest.Entries.Add(attribute.PersistentID' attributeDictionary);                          var manifestStream = new MemoryStream();                          manifestStreamList.Add(manifestStream);                          manifest.Serialize(manifestStream);                          manifestStream.Seek(0' SeekOrigin.Begin);                          const string jsonPathPC = "manifests/songs_dlc_{0}/dlc_guitar_{0}.json";                          const string jsonPathConsole = "manifests/songs_dlc/dlc_guitar_{0}.json";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? jsonPathConsole : jsonPathPC)' dlcName)' manifestStream);                            // MANIFEST HEADER                          var attributeHeaderDictionary = new Dictionary<string' InlayAttributes2014> { { "Attributes"' attribute } };                          var manifestHeader = new ManifestHeader2014<InlayAttributes2014>(platform' DLCPackageType.Inlay);                          manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                          manifestHeader.Serialize(manifestHeaderStream);                          manifestHeaderStream.Seek(0' SeekOrigin.Begin);                          const string hsanPathPC = "manifests/songs_dlc_{0}/dlc_{0}.hsan";                          const string hsonPathConsole = "manifests/songs_dlc/dlc_{0}.hson";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? hsonPathConsole : hsanPathPC)' dlcName)' manifestHeaderStream);                            // XBLOCK                          GameXblock<Entity2014> game = GameXblock<Entity2014>.Generate2014(info' platform' DLCPackageType.Inlay);                          game.SerializeXml(xblockStream);                          xblockStream.Flush();                          xblockStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("gamexblocks/nguitars/guitar_{0}.xblock"' dlcName)' xblockStream);                            // INLAY NIF                          InlayNif nif = new InlayNif(info);                          nif.Serialize(nifStream);                          nifStream.Flush();                          nifStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("assets/gameplay/inlay/{0}.nif"' dlcName)' nifStream);                            // WRITE PACKAGE                          packPsarc.Write(output' !platform.IsConsole);                          output.WriteTmpFile(String.Format("{0}.psarc"' dlcName)' platform);                      }                  }                  catch (Exception)                  {                      throw;                  }                  finally                  {                      // Dispose all objects                      if (rsenumerableRootStream != null)                          rsenumerableRootStream.Dispose();                      if (rsenumerableGuitarStream != null)                          rsenumerableGuitarStream.Dispose();                      DeleteTmpFiles(TMPFILES_ART);                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014InlayPsarc,The following statement contains a magic number: {                  packPsarc = new PSARC.PSARC();                    // Stream objects                  Stream rsenumerableRootStream = null'                         rsenumerableGuitarStream = null;                    try                  {                      // ICON/INLAY FILES                      var ddsfiles = info.ArtFiles;                        if (ddsfiles == null)                      {                          string iconPath;                          if (File.Exists(info.Inlay.IconPath))                          {                              iconPath = info.Inlay.IconPath;                          }                          else                          {                              using (var iconStream = new MemoryStream(Resources.cgm_default_icon))                              {                                  iconPath = Path.ChangeExtension(Path.GetTempFileName()' ".png");                                  iconStream.WriteFile(iconPath);                                  TMPFILES_ART.Add(iconPath);                              }                          }                            string inlayPath;                          if (File.Exists(info.Inlay.InlayPath))                          {                              inlayPath = info.Inlay.InlayPath;                          }                          else                          {                              using (var inlayStream = new MemoryStream(Resources.cgm_default_inlay))                              {                                  inlayPath = GeneralExtensions.GetTempFileName(".png");                                  inlayStream.WriteFile(inlayPath);                                  TMPFILES_ART.Add(inlayPath);                              }                          }                            ddsfiles = new List<DDSConvertedFile>();                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 512' sizeY = 512' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 1024' sizeY = 512' sourceFile = inlayPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                            // Convert to DDS                          ToDDS(ddsfiles' DLCPackageType.Inlay);                            // Save for reuse                          info.ArtFiles = ddsfiles;                      }                        foreach (var dds in info.ArtFiles)                          if (dds.sizeX == 1024)                              packPsarc.AddEntry(String.Format("assets/gameplay/inlay/inlay_{0}.dds"' dlcName)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                          else                              packPsarc.AddEntry(String.Format("gfxassets/rewards/guitar_inlays/reward_inlay_{0}_{1}.dds"' dlcName' dds.sizeX)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                        // FLAT MODEL                      rsenumerableRootStream = new MemoryStream(Resources.rsenumerable_root);                      packPsarc.AddEntry("flatmodels/rs/rsenumerable_root.flat"' rsenumerableRootStream);                      rsenumerableGuitarStream = new MemoryStream(Resources.rsenumerable_guitar);                      packPsarc.AddEntry("flatmodels/rs/rsenumerable_guitars.flat"' rsenumerableGuitarStream);                        using (var toolkitVersionStream = new MemoryStream())                      using (var appIdStream = new MemoryStream())                      using (var packageListStream = new MemoryStream())                      using (var aggregateGraphStream = new MemoryStream())                      using (var manifestStreamList = new DisposableCollection<Stream>())                      using (var manifestHeaderStream = new MemoryStream())                      using (var nifStream = new MemoryStream())                      using (var xblockStream = new MemoryStream())                      {                          // TOOLKIT VERSION                          GenerateToolkitVersion(toolkitVersionStream);                          packPsarc.AddEntry("toolkit.version"' toolkitVersionStream);                            // APP ID                          if (!platform.IsConsole)                          {                              GenerateAppId(appIdStream' info.AppId' platform);                              packPsarc.AddEntry("appid.appid"' appIdStream);                          }                            if (platform.platform == GamePlatform.XBox360)                          {                              var packageListWriter = new StreamWriter(packageListStream);                              packageListWriter.Write(dlcName);                              packageListWriter.Flush();                              packageListStream.Seek(0' SeekOrigin.Begin);                              const string packageList = "PackageList.txt";                              packageListStream.WriteTmpFile(packageList' platform);                          }                            // AGGREGATE GRAPH                          var aggregateGraphFileName = String.Format("{0}_aggregategraph.nt"' dlcName);                          var aggregateGraph = new AggregateGraph2014.AggregateGraph2014(info' platform' DLCPackageType.Inlay);                          aggregateGraph.Serialize(aggregateGraphStream);                          aggregateGraphStream.Flush();                          aggregateGraphStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(aggregateGraphFileName' aggregateGraphStream);                            // MANIFEST                          var attribute = new InlayAttributes2014(info);                          var attributeDictionary = new Dictionary<string' InlayAttributes2014> { { "Attributes"' attribute } };                          var manifest = new Manifest2014<InlayAttributes2014>(DLCPackageType.Inlay);                          manifest.Entries.Add(attribute.PersistentID' attributeDictionary);                          var manifestStream = new MemoryStream();                          manifestStreamList.Add(manifestStream);                          manifest.Serialize(manifestStream);                          manifestStream.Seek(0' SeekOrigin.Begin);                          const string jsonPathPC = "manifests/songs_dlc_{0}/dlc_guitar_{0}.json";                          const string jsonPathConsole = "manifests/songs_dlc/dlc_guitar_{0}.json";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? jsonPathConsole : jsonPathPC)' dlcName)' manifestStream);                            // MANIFEST HEADER                          var attributeHeaderDictionary = new Dictionary<string' InlayAttributes2014> { { "Attributes"' attribute } };                          var manifestHeader = new ManifestHeader2014<InlayAttributes2014>(platform' DLCPackageType.Inlay);                          manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                          manifestHeader.Serialize(manifestHeaderStream);                          manifestHeaderStream.Seek(0' SeekOrigin.Begin);                          const string hsanPathPC = "manifests/songs_dlc_{0}/dlc_{0}.hsan";                          const string hsonPathConsole = "manifests/songs_dlc/dlc_{0}.hson";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? hsonPathConsole : hsanPathPC)' dlcName)' manifestHeaderStream);                            // XBLOCK                          GameXblock<Entity2014> game = GameXblock<Entity2014>.Generate2014(info' platform' DLCPackageType.Inlay);                          game.SerializeXml(xblockStream);                          xblockStream.Flush();                          xblockStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("gamexblocks/nguitars/guitar_{0}.xblock"' dlcName)' xblockStream);                            // INLAY NIF                          InlayNif nif = new InlayNif(info);                          nif.Serialize(nifStream);                          nifStream.Flush();                          nifStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("assets/gameplay/inlay/{0}.nif"' dlcName)' nifStream);                            // WRITE PACKAGE                          packPsarc.Write(output' !platform.IsConsole);                          output.WriteTmpFile(String.Format("{0}.psarc"' dlcName)' platform);                      }                  }                  catch (Exception)                  {                      throw;                  }                  finally                  {                      // Dispose all objects                      if (rsenumerableRootStream != null)                          rsenumerableRootStream.Dispose();                      if (rsenumerableGuitarStream != null)                          rsenumerableGuitarStream.Dispose();                      DeleteTmpFiles(TMPFILES_ART);                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateRS2014InlayPsarc,The following statement contains a magic number: {                  packPsarc = new PSARC.PSARC();                    // Stream objects                  Stream rsenumerableRootStream = null'                         rsenumerableGuitarStream = null;                    try                  {                      // ICON/INLAY FILES                      var ddsfiles = info.ArtFiles;                        if (ddsfiles == null)                      {                          string iconPath;                          if (File.Exists(info.Inlay.IconPath))                          {                              iconPath = info.Inlay.IconPath;                          }                          else                          {                              using (var iconStream = new MemoryStream(Resources.cgm_default_icon))                              {                                  iconPath = Path.ChangeExtension(Path.GetTempFileName()' ".png");                                  iconStream.WriteFile(iconPath);                                  TMPFILES_ART.Add(iconPath);                              }                          }                            string inlayPath;                          if (File.Exists(info.Inlay.InlayPath))                          {                              inlayPath = info.Inlay.InlayPath;                          }                          else                          {                              using (var inlayStream = new MemoryStream(Resources.cgm_default_inlay))                              {                                  inlayPath = GeneralExtensions.GetTempFileName(".png");                                  inlayStream.WriteFile(inlayPath);                                  TMPFILES_ART.Add(inlayPath);                              }                          }                            ddsfiles = new List<DDSConvertedFile>();                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 512' sizeY = 512' sourceFile = iconPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                          ddsfiles.Add(new DDSConvertedFile() { sizeX = 1024' sizeY = 512' sourceFile = inlayPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                            // Convert to DDS                          ToDDS(ddsfiles' DLCPackageType.Inlay);                            // Save for reuse                          info.ArtFiles = ddsfiles;                      }                        foreach (var dds in info.ArtFiles)                          if (dds.sizeX == 1024)                              packPsarc.AddEntry(String.Format("assets/gameplay/inlay/inlay_{0}.dds"' dlcName)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                          else                              packPsarc.AddEntry(String.Format("gfxassets/rewards/guitar_inlays/reward_inlay_{0}_{1}.dds"' dlcName' dds.sizeX)' new FileStream(dds.destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read));                        // FLAT MODEL                      rsenumerableRootStream = new MemoryStream(Resources.rsenumerable_root);                      packPsarc.AddEntry("flatmodels/rs/rsenumerable_root.flat"' rsenumerableRootStream);                      rsenumerableGuitarStream = new MemoryStream(Resources.rsenumerable_guitar);                      packPsarc.AddEntry("flatmodels/rs/rsenumerable_guitars.flat"' rsenumerableGuitarStream);                        using (var toolkitVersionStream = new MemoryStream())                      using (var appIdStream = new MemoryStream())                      using (var packageListStream = new MemoryStream())                      using (var aggregateGraphStream = new MemoryStream())                      using (var manifestStreamList = new DisposableCollection<Stream>())                      using (var manifestHeaderStream = new MemoryStream())                      using (var nifStream = new MemoryStream())                      using (var xblockStream = new MemoryStream())                      {                          // TOOLKIT VERSION                          GenerateToolkitVersion(toolkitVersionStream);                          packPsarc.AddEntry("toolkit.version"' toolkitVersionStream);                            // APP ID                          if (!platform.IsConsole)                          {                              GenerateAppId(appIdStream' info.AppId' platform);                              packPsarc.AddEntry("appid.appid"' appIdStream);                          }                            if (platform.platform == GamePlatform.XBox360)                          {                              var packageListWriter = new StreamWriter(packageListStream);                              packageListWriter.Write(dlcName);                              packageListWriter.Flush();                              packageListStream.Seek(0' SeekOrigin.Begin);                              const string packageList = "PackageList.txt";                              packageListStream.WriteTmpFile(packageList' platform);                          }                            // AGGREGATE GRAPH                          var aggregateGraphFileName = String.Format("{0}_aggregategraph.nt"' dlcName);                          var aggregateGraph = new AggregateGraph2014.AggregateGraph2014(info' platform' DLCPackageType.Inlay);                          aggregateGraph.Serialize(aggregateGraphStream);                          aggregateGraphStream.Flush();                          aggregateGraphStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(aggregateGraphFileName' aggregateGraphStream);                            // MANIFEST                          var attribute = new InlayAttributes2014(info);                          var attributeDictionary = new Dictionary<string' InlayAttributes2014> { { "Attributes"' attribute } };                          var manifest = new Manifest2014<InlayAttributes2014>(DLCPackageType.Inlay);                          manifest.Entries.Add(attribute.PersistentID' attributeDictionary);                          var manifestStream = new MemoryStream();                          manifestStreamList.Add(manifestStream);                          manifest.Serialize(manifestStream);                          manifestStream.Seek(0' SeekOrigin.Begin);                          const string jsonPathPC = "manifests/songs_dlc_{0}/dlc_guitar_{0}.json";                          const string jsonPathConsole = "manifests/songs_dlc/dlc_guitar_{0}.json";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? jsonPathConsole : jsonPathPC)' dlcName)' manifestStream);                            // MANIFEST HEADER                          var attributeHeaderDictionary = new Dictionary<string' InlayAttributes2014> { { "Attributes"' attribute } };                          var manifestHeader = new ManifestHeader2014<InlayAttributes2014>(platform' DLCPackageType.Inlay);                          manifestHeader.Entries.Add(attribute.PersistentID' attributeHeaderDictionary);                          manifestHeader.Serialize(manifestHeaderStream);                          manifestHeaderStream.Seek(0' SeekOrigin.Begin);                          const string hsanPathPC = "manifests/songs_dlc_{0}/dlc_{0}.hsan";                          const string hsonPathConsole = "manifests/songs_dlc/dlc_{0}.hson";                          packPsarc.AddEntry(String.Format((platform.IsConsole ? hsonPathConsole : hsanPathPC)' dlcName)' manifestHeaderStream);                            // XBLOCK                          GameXblock<Entity2014> game = GameXblock<Entity2014>.Generate2014(info' platform' DLCPackageType.Inlay);                          game.SerializeXml(xblockStream);                          xblockStream.Flush();                          xblockStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("gamexblocks/nguitars/guitar_{0}.xblock"' dlcName)' xblockStream);                            // INLAY NIF                          InlayNif nif = new InlayNif(info);                          nif.Serialize(nifStream);                          nifStream.Flush();                          nifStream.Seek(0' SeekOrigin.Begin);                          packPsarc.AddEntry(String.Format("assets/gameplay/inlay/{0}.nif"' dlcName)' nifStream);                            // WRITE PACKAGE                          packPsarc.Write(output' !platform.IsConsole);                          output.WriteTmpFile(String.Format("{0}.psarc"' dlcName)' platform);                      }                  }                  catch (Exception)                  {                      throw;                  }                  finally                  {                      // Dispose all objects                      if (rsenumerableRootStream != null)                          rsenumerableRootStream.Dispose();                      if (rsenumerableGuitarStream != null)                          rsenumerableGuitarStream.Dispose();                      DeleteTmpFiles(TMPFILES_ART);                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateSongPsarcRS1,The following statement contains a magic number: try              {                  Stream albumArtStream = null'                         audioStream = null;                    string albumArtPath;                  if (File.Exists(info.AlbumArtPath))                  {                      albumArtPath = info.AlbumArtPath;                  }                  else                  {                      using (var defaultArtStream = new MemoryStream(Resources.albumart))                      {                          albumArtPath = GeneralExtensions.GetTempFileName(".dds");                          defaultArtStream.WriteFile(albumArtPath);                          defaultArtStream.Dispose();                          TMPFILES_ART.Add(albumArtPath);                      }                  }                    var ddsfiles = info.ArtFiles;                  if (ddsfiles == null)                  {                      ddsfiles = new List<DDSConvertedFile>();                      ddsfiles.Add(new DDSConvertedFile() { sizeX = 512' sizeY = 512' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                      ToDDS(ddsfiles);                        // Save for reuse                      info.ArtFiles = ddsfiles;                  }                    albumArtStream = new FileStream(info.ArtFiles[0].destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read);                    // AUDIO                  var audioFile = info.OggPath;                  if (File.Exists(audioFile))                      if (platform.IsConsole != audioFile.GetAudioPlatform().IsConsole)                          audioStream = OggFile.ConvertAudioPlatform(audioFile);                      else                          audioStream = File.OpenRead(audioFile);                  else                      throw new InvalidOperationException(String.Format("Audio file '{0}' not found."' audioFile));                    using (var aggregateGraphStream = new MemoryStream())                  using (var manifestStream = new MemoryStream())                  using (var xblockStream = new MemoryStream())                  using (var soundbankStream = new MemoryStream())                  using (var packageIdStream = new MemoryStream())                  using (var soundStream = OggFile.ConvertOgg(audioStream))                  using (var arrangementFiles = new DisposableCollection<Stream>())                  {                      var manifestBuilder = new ManifestBuilder                      {                          AggregateGraph = new AggregateGraph.AggregateGraph                          {                              SoundBank = new SoundBank { File = soundBankName + ".bnk" }'                              AlbumArt = new AlbumArt { File = info.AlbumArtPath }                          }                      };                        foreach (var x in info.Arrangements)                      {                          //Generate sng file in execution time                          GenerateSNG(x' platform);                            manifestBuilder.AggregateGraph.SongFiles.Add(x.SongFile);                          manifestBuilder.AggregateGraph.SongXMLs.Add(x.SongXml);                      }                      manifestBuilder.AggregateGraph.XBlock = new XBlockFile { File = info.Name + ".xblock" };                      manifestBuilder.AggregateGraph.Write(info.Name' platform.GetPathName()' platform' aggregateGraphStream);                      aggregateGraphStream.Flush();                      aggregateGraphStream.Seek(0' SeekOrigin.Begin);                        {                          var manifestData = manifestBuilder.GenerateManifest(info.Name' info.Arrangements' info.SongInfo' platform);                          var writer = new StreamWriter(manifestStream);                          writer.Write(manifestData);                          writer.Flush();                          manifestStream.Seek(0' SeekOrigin.Begin);                      }                        GameXblock<Entity>.Generate(info.Name' manifestBuilder.Manifest' manifestBuilder.AggregateGraph' xblockStream);                      xblockStream.Flush();                      xblockStream.Seek(0' SeekOrigin.Begin);                        var soundFileName = SoundBankGenerator.GenerateSoundBank(info.Name' soundStream' soundbankStream' info.Volume' platform);                      soundbankStream.Flush();                      soundbankStream.Seek(0' SeekOrigin.Begin);                        GenerateSongPackageId(packageIdStream' info.Name);                        var songPsarc = new PSARC.PSARC();                      songPsarc.AddEntry("PACKAGE_ID"' packageIdStream);                      songPsarc.AddEntry("AggregateGraph.nt"' aggregateGraphStream);                      songPsarc.AddEntry("Manifests/songs.manifest.json"' manifestStream);                      songPsarc.AddEntry(String.Format("Exports/Songs/{0}.xblock"' info.Name)' xblockStream);                      songPsarc.AddEntry(String.Format("Audio/{0}/{1}.bnk"' platform.GetPathName()[0]' soundBankName)' soundbankStream);                      songPsarc.AddEntry(String.Format("Audio/{0}/{1}.ogg"' platform.GetPathName()[0]' soundFileName)' soundStream);                      songPsarc.AddEntry(String.Format("GRAssets/AlbumArt/{0}.dds"' manifestBuilder.AggregateGraph.AlbumArt.Name)' albumArtStream);                        foreach (var x in info.Arrangements)                      {                          var xmlFile = File.OpenRead(x.SongXml.File);                          arrangementFiles.Add(xmlFile);                          var sngFile = File.OpenRead(x.SongFile.File);                          arrangementFiles.Add(sngFile);                          songPsarc.AddEntry(String.Format("GR/Behaviors/Songs/{0}.xml"' Path.GetFileNameWithoutExtension(x.SongXml.File))' xmlFile);                          songPsarc.AddEntry(String.Format("GRExports/{0}/{1}.sng"' platform.GetPathName()[1]' Path.GetFileNameWithoutExtension(x.SongFile.File))' sngFile);                      }                      songPsarc.Write(output' false);                  }              }              finally              {              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GenerateSongPsarcRS1,The following statement contains a magic number: try              {                  Stream albumArtStream = null'                         audioStream = null;                    string albumArtPath;                  if (File.Exists(info.AlbumArtPath))                  {                      albumArtPath = info.AlbumArtPath;                  }                  else                  {                      using (var defaultArtStream = new MemoryStream(Resources.albumart))                      {                          albumArtPath = GeneralExtensions.GetTempFileName(".dds");                          defaultArtStream.WriteFile(albumArtPath);                          defaultArtStream.Dispose();                          TMPFILES_ART.Add(albumArtPath);                      }                  }                    var ddsfiles = info.ArtFiles;                  if (ddsfiles == null)                  {                      ddsfiles = new List<DDSConvertedFile>();                      ddsfiles.Add(new DDSConvertedFile() { sizeX = 512' sizeY = 512' sourceFile = albumArtPath' destinationFile = GeneralExtensions.GetTempFileName(".dds") });                      ToDDS(ddsfiles);                        // Save for reuse                      info.ArtFiles = ddsfiles;                  }                    albumArtStream = new FileStream(info.ArtFiles[0].destinationFile' FileMode.Open' FileAccess.Read' FileShare.Read);                    // AUDIO                  var audioFile = info.OggPath;                  if (File.Exists(audioFile))                      if (platform.IsConsole != audioFile.GetAudioPlatform().IsConsole)                          audioStream = OggFile.ConvertAudioPlatform(audioFile);                      else                          audioStream = File.OpenRead(audioFile);                  else                      throw new InvalidOperationException(String.Format("Audio file '{0}' not found."' audioFile));                    using (var aggregateGraphStream = new MemoryStream())                  using (var manifestStream = new MemoryStream())                  using (var xblockStream = new MemoryStream())                  using (var soundbankStream = new MemoryStream())                  using (var packageIdStream = new MemoryStream())                  using (var soundStream = OggFile.ConvertOgg(audioStream))                  using (var arrangementFiles = new DisposableCollection<Stream>())                  {                      var manifestBuilder = new ManifestBuilder                      {                          AggregateGraph = new AggregateGraph.AggregateGraph                          {                              SoundBank = new SoundBank { File = soundBankName + ".bnk" }'                              AlbumArt = new AlbumArt { File = info.AlbumArtPath }                          }                      };                        foreach (var x in info.Arrangements)                      {                          //Generate sng file in execution time                          GenerateSNG(x' platform);                            manifestBuilder.AggregateGraph.SongFiles.Add(x.SongFile);                          manifestBuilder.AggregateGraph.SongXMLs.Add(x.SongXml);                      }                      manifestBuilder.AggregateGraph.XBlock = new XBlockFile { File = info.Name + ".xblock" };                      manifestBuilder.AggregateGraph.Write(info.Name' platform.GetPathName()' platform' aggregateGraphStream);                      aggregateGraphStream.Flush();                      aggregateGraphStream.Seek(0' SeekOrigin.Begin);                        {                          var manifestData = manifestBuilder.GenerateManifest(info.Name' info.Arrangements' info.SongInfo' platform);                          var writer = new StreamWriter(manifestStream);                          writer.Write(manifestData);                          writer.Flush();                          manifestStream.Seek(0' SeekOrigin.Begin);                      }                        GameXblock<Entity>.Generate(info.Name' manifestBuilder.Manifest' manifestBuilder.AggregateGraph' xblockStream);                      xblockStream.Flush();                      xblockStream.Seek(0' SeekOrigin.Begin);                        var soundFileName = SoundBankGenerator.GenerateSoundBank(info.Name' soundStream' soundbankStream' info.Volume' platform);                      soundbankStream.Flush();                      soundbankStream.Seek(0' SeekOrigin.Begin);                        GenerateSongPackageId(packageIdStream' info.Name);                        var songPsarc = new PSARC.PSARC();                      songPsarc.AddEntry("PACKAGE_ID"' packageIdStream);                      songPsarc.AddEntry("AggregateGraph.nt"' aggregateGraphStream);                      songPsarc.AddEntry("Manifests/songs.manifest.json"' manifestStream);                      songPsarc.AddEntry(String.Format("Exports/Songs/{0}.xblock"' info.Name)' xblockStream);                      songPsarc.AddEntry(String.Format("Audio/{0}/{1}.bnk"' platform.GetPathName()[0]' soundBankName)' soundbankStream);                      songPsarc.AddEntry(String.Format("Audio/{0}/{1}.ogg"' platform.GetPathName()[0]' soundFileName)' soundStream);                      songPsarc.AddEntry(String.Format("GRAssets/AlbumArt/{0}.dds"' manifestBuilder.AggregateGraph.AlbumArt.Name)' albumArtStream);                        foreach (var x in info.Arrangements)                      {                          var xmlFile = File.OpenRead(x.SongXml.File);                          arrangementFiles.Add(xmlFile);                          var sngFile = File.OpenRead(x.SongFile.File);                          arrangementFiles.Add(sngFile);                          songPsarc.AddEntry(String.Format("GR/Behaviors/Songs/{0}.xml"' Path.GetFileNameWithoutExtension(x.SongXml.File))' xmlFile);                          songPsarc.AddEntry(String.Format("GRExports/{0}/{1}.sng"' platform.GetPathName()[1]' Path.GetFileNameWithoutExtension(x.SongFile.File))' sngFile);                      }                      songPsarc.Write(output' false);                  }              }              finally              {              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageConverter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageConverter.cs,Convert,The following statement contains a magic number: var targetFileName = String.Format(nameTemplate' Path.Combine(Path.GetDirectoryName(sourcePackage)' packageName)' targetPlatform.GetPathName()[2]);
Magic Number,RocksmithToolkitLib.DLCPackage,SongPartition,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SongPartition.cs,GetSongPartition,The following statement contains a magic number: switch (arrangementType)              {                  case ArrangementType.Bass:                      songPartitionCount[3]++;                      return songPartitionCount[3];                  default:                      switch (arrangementName)                      {                          case ArrangementName.Lead:                              songPartitionCount[1]++;                              return songPartitionCount[1];                          case ArrangementName.Rhythm:                              songPartitionCount[2]++;                              return songPartitionCount[2];                          default: //Combo                              songPartitionCount[0]++;                              return songPartitionCount[0];                      }              }
Magic Number,RocksmithToolkitLib.DLCPackage,SongPartition,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SongPartition.cs,GetSongPartition,The following statement contains a magic number: switch (arrangementType)              {                  case ArrangementType.Bass:                      songPartitionCount[3]++;                      return songPartitionCount[3];                  default:                      switch (arrangementName)                      {                          case ArrangementName.Lead:                              songPartitionCount[1]++;                              return songPartitionCount[1];                          case ArrangementName.Rhythm:                              songPartitionCount[2]++;                              return songPartitionCount[2];                          default: //Combo                              songPartitionCount[0]++;                              return songPartitionCount[0];                      }              }
Magic Number,RocksmithToolkitLib.DLCPackage,SongPartition,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SongPartition.cs,GetSongPartition,The following statement contains a magic number: switch (arrangementType)              {                  case ArrangementType.Bass:                      songPartitionCount[3]++;                      return songPartitionCount[3];                  default:                      switch (arrangementName)                      {                          case ArrangementName.Lead:                              songPartitionCount[1]++;                              return songPartitionCount[1];                          case ArrangementName.Rhythm:                              songPartitionCount[2]++;                              return songPartitionCount[2];                          default: //Combo                              songPartitionCount[0]++;                              return songPartitionCount[0];                      }              }
Magic Number,RocksmithToolkitLib.DLCPackage,SongPartition,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SongPartition.cs,GetSongPartition,The following statement contains a magic number: switch (arrangementType)              {                  case ArrangementType.Bass:                      songPartitionCount[3]++;                      return songPartitionCount[3];                  default:                      switch (arrangementName)                      {                          case ArrangementName.Lead:                              songPartitionCount[1]++;                              return songPartitionCount[1];                          case ArrangementName.Rhythm:                              songPartitionCount[2]++;                              return songPartitionCount[2];                          default: //Combo                              songPartitionCount[0]++;                              return songPartitionCount[0];                      }              }
Magic Number,RocksmithToolkitLib.DLCPackage,Crc32,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Crc32.cs,InitializeTable,The following statement contains a magic number: var createTable = new UInt32[256];
Magic Number,RocksmithToolkitLib.DLCPackage,Crc32,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Crc32.cs,InitializeTable,The following statement contains a magic number: for (var i = 0; i < 256; i++)              {                  var entry = (UInt32)i;                  for (var j = 0; j < 8; j++)                      if ((entry & 1) == 1)                          entry = (entry >> 1) ^ polynomial;                      else                          entry = entry >> 1;                  createTable[i] = entry;              }
Magic Number,RocksmithToolkitLib.DLCPackage,Crc32,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Crc32.cs,InitializeTable,The following statement contains a magic number: for (var i = 0; i < 256; i++)              {                  var entry = (UInt32)i;                  for (var j = 0; j < 8; j++)                      if ((entry & 1) == 1)                          entry = (entry >> 1) ^ polynomial;                      else                          entry = entry >> 1;                  createTable[i] = entry;              }
Magic Number,RocksmithToolkitLib.DLCPackage,Crc32,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Crc32.cs,CalculateHash,The following statement contains a magic number: for (var i = start; i < size - start; i++)                  crc = (crc >> 8) ^ table[buffer[i] ^ crc & 0xff];
Magic Number,RocksmithToolkitLib.DLCPackage,TuningFrequency,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\TuningFrequency.cs,Ratio2Cents,The following statement contains a magic number: return CentsInOctave * Math.Log(ratio) / Math.Log(2);
Magic Number,RocksmithToolkitLib.DLCPackage,TuningFrequency,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\TuningFrequency.cs,Cents2Frequency,The following statement contains a magic number: return Math.Round(A440 * Math.Pow(Math.Pow(2' 1D / 1200D)' cents)' 2);
Magic Number,RocksmithToolkitLib.DLCPackage,TuningFrequency,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\TuningFrequency.cs,Cents2Frequency,The following statement contains a magic number: return Math.Round(A440 * Math.Pow(Math.Pow(2' 1D / 1200D)' cents)' 2);
Magic Number,RocksmithToolkitLib.DLCPackage,TuningFrequency,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\TuningFrequency.cs,Frequency2Note,The following statement contains a magic number: var lnote = (Math.Log(frequency) - Math.Log(261.626)) / Math.Log(2) + 4.0;
Magic Number,RocksmithToolkitLib.DLCPackage,TuningFrequency,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\TuningFrequency.cs,Frequency2Note,The following statement contains a magic number: var lnote = (Math.Log(frequency) - Math.Log(261.626)) / Math.Log(2) + 4.0;
Magic Number,RocksmithToolkitLib.DLCPackage,TuningFrequency,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\TuningFrequency.cs,Frequency2Note,The following statement contains a magic number: var lnote = (Math.Log(frequency) - Math.Log(261.626)) / Math.Log(2) + 4.0;
Magic Number,RocksmithToolkitLib.DLCPackage,TuningFrequency,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\TuningFrequency.cs,Frequency2Note,The following statement contains a magic number: if (cents < 50)              {                  noteName = "C";              }              else if (cents >= 1150)              {                  noteName = "C";                  cents -= CentsInOctave;                  oct++;              }              else              {                  var offset = 50.0;                  for (var j = 1; j <= 11; j++)                  {                      if (cents >= offset && cents < (offset + 100))                      {                          noteName = noteTable[j];                          cents -= (j * 100);                          break;                      }                      offset += 100;                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,TuningFrequency,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\TuningFrequency.cs,Frequency2Note,The following statement contains a magic number: if (cents < 50)              {                  noteName = "C";              }              else if (cents >= 1150)              {                  noteName = "C";                  cents -= CentsInOctave;                  oct++;              }              else              {                  var offset = 50.0;                  for (var j = 1; j <= 11; j++)                  {                      if (cents >= offset && cents < (offset + 100))                      {                          noteName = noteTable[j];                          cents -= (j * 100);                          break;                      }                      offset += 100;                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,TuningFrequency,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\TuningFrequency.cs,Frequency2Note,The following statement contains a magic number: if (cents < 50)              {                  noteName = "C";              }              else if (cents >= 1150)              {                  noteName = "C";                  cents -= CentsInOctave;                  oct++;              }              else              {                  var offset = 50.0;                  for (var j = 1; j <= 11; j++)                  {                      if (cents >= offset && cents < (offset + 100))                      {                          noteName = noteTable[j];                          cents -= (j * 100);                          break;                      }                      offset += 100;                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,TuningFrequency,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\TuningFrequency.cs,Frequency2Note,The following statement contains a magic number: if (cents < 50)              {                  noteName = "C";              }              else if (cents >= 1150)              {                  noteName = "C";                  cents -= CentsInOctave;                  oct++;              }              else              {                  var offset = 50.0;                  for (var j = 1; j <= 11; j++)                  {                      if (cents >= offset && cents < (offset + 100))                      {                          noteName = noteTable[j];                          cents -= (j * 100);                          break;                      }                      offset += 100;                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,TuningFrequency,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\TuningFrequency.cs,Frequency2Note,The following statement contains a magic number: if (cents < 50)              {                  noteName = "C";              }              else if (cents >= 1150)              {                  noteName = "C";                  cents -= CentsInOctave;                  oct++;              }              else              {                  var offset = 50.0;                  for (var j = 1; j <= 11; j++)                  {                      if (cents >= offset && cents < (offset + 100))                      {                          noteName = noteTable[j];                          cents -= (j * 100);                          break;                      }                      offset += 100;                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,TuningFrequency,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\TuningFrequency.cs,Frequency2Note,The following statement contains a magic number: if (cents < 50)              {                  noteName = "C";              }              else if (cents >= 1150)              {                  noteName = "C";                  cents -= CentsInOctave;                  oct++;              }              else              {                  var offset = 50.0;                  for (var j = 1; j <= 11; j++)                  {                      if (cents >= offset && cents < (offset + 100))                      {                          noteName = noteTable[j];                          cents -= (j * 100);                          break;                      }                      offset += 100;                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,TuningFrequency,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\TuningFrequency.cs,Frequency2Note,The following statement contains a magic number: if (cents < 50)              {                  noteName = "C";              }              else if (cents >= 1150)              {                  noteName = "C";                  cents -= CentsInOctave;                  oct++;              }              else              {                  var offset = 50.0;                  for (var j = 1; j <= 11; j++)                  {                      if (cents >= offset && cents < (offset + 100))                      {                          noteName = noteTable[j];                          cents -= (j * 100);                          break;                      }                      offset += 100;                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,TuningFrequency,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\TuningFrequency.cs,ApplyBassFix,The following statement contains a magic number: var isBassFixed = xmlComments.Any(xComment => xComment.ToString().Contains("Low Bass Tuning Fixed")) || arr.TuningPitch.Equals(220.0);
Magic Number,RocksmithToolkitLib.DLCPackage,TuningFrequency,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\TuningFrequency.cs,ApplyBassFix,The following statement contains a magic number: for (int s = 0; s < strings.Length; s++)              {                  if (strings[s] < 0)                      strings[s] += 12;              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,RS1LoadFromFolder,The following statement contains a magic number: data.Volume = -7;
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,RS1LoadFromFolder,The following statement contains a magic number: data.SongInfo.SongYear = (attr.FirstOrDefault().SongYear == 0 ? 2012 : attr.FirstOrDefault().SongYear);
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,RS1LoadFromFolder,The following statement contains a magic number: foreach (var xmlFile in xmlFiles)              {                  if (xmlFile.ToLower().Contains("metadata"))                      continue;                    // some poorly formed RS1 CDLC use just "vocal"                  if (xmlFile.ToLower().Contains("vocal"))                  {                      // Add Vocal Arrangement                      data.Arrangements.Add(new Arrangement                      {                          Name = ArrangementName.Vocals'                          ArrangementType = ArrangementType.Vocal'                          ScrollSpeed = 20'                          SongXml = new SongXML { File = xmlFile }'                          SongFile = new SongFile { File = "" }'                          CustomFont = false                      });                  }                  else                  {                      var attr2014 = new Attributes2014();                      var rsSong = new Song();                      var rsSong2014 = new Song2014();                        // optimized tone matching effort using project mapping algo                      var result = projectMap.First(m => String.Equals(Path.GetFileName(m.SongXmlPath)' Path.GetFileName(xmlFile)' StringComparison.CurrentCultureIgnoreCase));                      if (result.Tones.Count != 1)                          throw new DataException("Invalid RS1 CDLC Tones Data");                        var arrangement = attr.First(s => s.SongXml.ToLower().Contains(result.LLID));//FIXME: Sequence contains no matching element issue                      var tone = tones.First(t => t.Key == result.Tones[0]);                        using (var obj1 = new Rs1Converter())                      {                          rsSong = obj1.XmlToSong(xmlFile);                          data.SongInfo.AverageTempo = (int)obj1.AverageBPM(rsSong);                      }                        if (arrangement.Tuning == "E Standard")                          rsSong.Tuning = new TuningStrings { String0 = 0' String1 = 0' String2 = 0' String3 = 0' String4 = 0' String5 = 0 };                      else if (arrangement.Tuning == "DropD")                          rsSong.Tuning = new TuningStrings { String0 = -2' String1 = 0' String2 = 0' String3 = 0' String4 = 0' String5 = 0 };                      else if (arrangement.Tuning == "OpenG")                          rsSong.Tuning = new TuningStrings { String0 = -2' String1 = -2' String2 = 0' String3 = 0' String4 = 0' String5 = -2 };                      else if (arrangement.Tuning == "EFlat")                          rsSong.Tuning = new TuningStrings { String0 = -1' String1 = -1' String2 = -1' String3 = -1' String4 = -1' String5 = -1 };                      else // default to standard tuning                      {                          arrangement.Tuning = "E Standard";                          rsSong.Tuning = new TuningStrings { String0 = 0' String1 = 0' String2 = 0' String3 = 0' String4 = 0' String5 = 0 };                      }                        // save/write the changes to xml file                      using (var obj1 = new Rs1Converter())                          obj1.SongToXml(rsSong' xmlFile' true);                        if (convert)                          using (var obj1 = new Rs1Converter())                              tones2014.Add(obj1.ToneToTone2014(tone' rsSong));                        // load attr2014 with RS1 mapped values for use by Arrangement()                      attr2014.Tone_Base = tone.Name;                      attr2014.ArrangementName = arrangement.ArrangementName;                      attr2014.CentOffset = 0;                      attr2014.DynamicVisualDensity = new List<float>() { 2 };                      attr2014.SongPartition = arrangement.SongPartition;                      attr2014.PersistentID = IdGenerator.Guid().ToString();                      attr2014.MasterID_RDV = RandomGenerator.NextInt();                      attr2014.ArrangementProperties = new SongArrangementProperties2014();                        // processing order is important - CAREFUL                      // RouteMask  None = 0' Lead = 1' Rhythm = 2' Any = 3' Bass = 4                      // XML file names are usually meaningless to arrangement determination                        if (arrangement.ArrangementName.ToLower().Contains("lead") ||                          rsSong.Arrangement.ToLower().Contains("lead"))                      {                          attr2014.ArrangementName = "Lead";                          attr2014.ArrangementType = (int)ArrangementType.Guitar;                          attr2014.ArrangementProperties.RouteMask = (int)RouteMask.Lead;                          attr2014.ArrangementProperties.PathLead = 1;                          attr2014.ArrangementProperties.PathRhythm = 0;                          attr2014.ArrangementProperties.PathBass = 0;                      }                      else if (arrangement.ArrangementName.ToLower().Contains("rhythm") ||                          rsSong.Arrangement.ToLower().Contains("rhythm"))                      // || rsSong.Arrangement.ToLower().Contains("guitar"))                      {                          attr2014.ArrangementName = "Rhythm";                          attr2014.ArrangementType = (int)ArrangementType.Guitar;                          attr2014.ArrangementProperties.RouteMask = (int)RouteMask.Rhythm;                          attr2014.ArrangementProperties.PathLead = 0;                          attr2014.ArrangementProperties.PathRhythm = 1;                          attr2014.ArrangementProperties.PathBass = 0;                      }                      else if (arrangement.ArrangementName.ToLower().Contains("combo") ||                          rsSong.Arrangement.ToLower().Contains("combo"))                      {                          attr2014.ArrangementName = "Combo";                          attr2014.ArrangementType = (int)ArrangementType.Guitar;                          attr2014.ArrangementProperties.RouteMask = arrangement.EffectChainName.ToLower().Contains("lead") ? (int)RouteMask.Lead : (int)RouteMask.Rhythm;                          attr2014.ArrangementProperties.PathLead = arrangement.EffectChainName.ToLower().Contains("lead") ? 1 : 0;                          attr2014.ArrangementProperties.PathRhythm = arrangement.EffectChainName.ToLower().Contains("lead") ? 0 : 1;                          attr2014.ArrangementProperties.PathBass = 0;                      }                      else if (arrangement.ArrangementName.ToLower().Contains("bass") ||                          rsSong.Arrangement.ToLower().Contains("bass"))                      {                          attr2014.ArrangementName = "Bass";                          attr2014.ArrangementType = (int)ArrangementType.Bass;                          attr2014.ArrangementProperties.RouteMask = (int)RouteMask.Bass;                          attr2014.ArrangementProperties.PathLead = 0;                          attr2014.ArrangementProperties.PathRhythm = 0;                          attr2014.ArrangementProperties.PathBass = 1;                      }                      else                      {                          // default to Lead arrangement                          attr2014.ArrangementName = "Lead";                          attr2014.ArrangementType = (int)ArrangementType.Guitar;                          attr2014.ArrangementProperties.RouteMask = (int)RouteMask.Lead;                          attr2014.ArrangementProperties.PathLead = 1;                          attr2014.ArrangementProperties.PathRhythm = 0;                          attr2014.ArrangementProperties.PathBass = 0;                            Console.WriteLine("RS1->RS2 CDLC Conversion defaulted to 'Lead' arrangement");                      }                        if (convert) // RS1 -> RS2 magic                      {                          using (var obj1 = new Rs1Converter())                              rsSong2014 = obj1.SongToSong2014(rsSong);                            // update ArrangementProperties                          rsSong2014.ArrangementProperties.RouteMask = attr2014.ArrangementProperties.RouteMask;                          rsSong2014.ArrangementProperties.PathLead = attr2014.ArrangementProperties.PathLead;                          rsSong2014.ArrangementProperties.PathRhythm = attr2014.ArrangementProperties.PathRhythm;                          rsSong2014.ArrangementProperties.PathBass = attr2014.ArrangementProperties.PathBass;                          rsSong2014.ArrangementProperties.StandardTuning = (arrangement.Tuning == "E Standard" ? 1 : 0);                            // <note time="58.366" linkNext="0" accent="0" bend="0" fret="7" hammerOn="0" harmonic="0" hopo="0" ignore="0" leftHand="-1" mute="0" palmMute="0" pluck="-1" pullOff="0" slap="-1" slideTo="-1" string="3" sustain="0.108" tremolo="0" harmonicPinch="0" pickDirection="0" rightHand="-1" slideUnpitchTo="-1" tap="0" vibrato="0" />                          if (rsSong2014.Levels.Any(sl => sl.Notes.Any(sln => sln.Bend != 0)))                              rsSong2014.ArrangementProperties.Bends = 1;                          if (rsSong2014.Levels.Any(sl => sl.Notes.Any(sln => sln.Hopo != 0)))                              rsSong2014.ArrangementProperties.Hopo = 1;                          if (rsSong2014.Levels.Any(sl => sl.Notes.Any(sln => sln.SlideTo != -1)))                              rsSong2014.ArrangementProperties.Slides = 1;                          if (rsSong2014.Levels.Any(sl => sl.Notes.Any(sln => sln.Sustain > 0)))                              rsSong2014.ArrangementProperties.Sustain = 1;                            // fixing times that are off                          var lastEbeatsTime = rsSong2014.Ebeats[rsSong2014.Ebeats.Length - 1].Time;                          var lastPhraseIterationsTime = rsSong2014.PhraseIterations[rsSong2014.PhraseIterations.Length - 1].Time;                            // tested ... not source of in game hangs                          // confirm last PhraseIterations time is less than last Ebeats time                          if (lastPhraseIterationsTime > lastEbeatsTime)                          {                              rsSong2014.PhraseIterations[rsSong2014.PhraseIterations.Length - 1].Time = lastEbeatsTime;                              rsSong2014.Sections[rsSong2014.Sections.Length - 1].StartTime = lastEbeatsTime;                          }                            // tested ... not source of in game hangs                          // confirm SongLength at least equals last Ebeats time                          if (rsSong2014.SongLength < lastEbeatsTime)                              rsSong2014.SongLength = lastEbeatsTime;                            using (var obj2 = new Rs2014Converter())                              obj2.Song2014ToXml(rsSong2014' xmlFile' true);                      }                        // Adding Song Arrangement                      try                      {                          data.Arrangements.Add(new Arrangement(attr2014' xmlFile));                      }                      catch (Exception ex)                      {                          // mainly for the benefit of convert2012 CLI users                          Console.WriteLine(@"This CDLC could not be auto converted." + Environment.NewLine + "You can still try manually adding the arrangements and assets." + Environment.NewLine + ex.Message);                      }                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,RS1LoadFromFolder,The following statement contains a magic number: foreach (var xmlFile in xmlFiles)              {                  if (xmlFile.ToLower().Contains("metadata"))                      continue;                    // some poorly formed RS1 CDLC use just "vocal"                  if (xmlFile.ToLower().Contains("vocal"))                  {                      // Add Vocal Arrangement                      data.Arrangements.Add(new Arrangement                      {                          Name = ArrangementName.Vocals'                          ArrangementType = ArrangementType.Vocal'                          ScrollSpeed = 20'                          SongXml = new SongXML { File = xmlFile }'                          SongFile = new SongFile { File = "" }'                          CustomFont = false                      });                  }                  else                  {                      var attr2014 = new Attributes2014();                      var rsSong = new Song();                      var rsSong2014 = new Song2014();                        // optimized tone matching effort using project mapping algo                      var result = projectMap.First(m => String.Equals(Path.GetFileName(m.SongXmlPath)' Path.GetFileName(xmlFile)' StringComparison.CurrentCultureIgnoreCase));                      if (result.Tones.Count != 1)                          throw new DataException("Invalid RS1 CDLC Tones Data");                        var arrangement = attr.First(s => s.SongXml.ToLower().Contains(result.LLID));//FIXME: Sequence contains no matching element issue                      var tone = tones.First(t => t.Key == result.Tones[0]);                        using (var obj1 = new Rs1Converter())                      {                          rsSong = obj1.XmlToSong(xmlFile);                          data.SongInfo.AverageTempo = (int)obj1.AverageBPM(rsSong);                      }                        if (arrangement.Tuning == "E Standard")                          rsSong.Tuning = new TuningStrings { String0 = 0' String1 = 0' String2 = 0' String3 = 0' String4 = 0' String5 = 0 };                      else if (arrangement.Tuning == "DropD")                          rsSong.Tuning = new TuningStrings { String0 = -2' String1 = 0' String2 = 0' String3 = 0' String4 = 0' String5 = 0 };                      else if (arrangement.Tuning == "OpenG")                          rsSong.Tuning = new TuningStrings { String0 = -2' String1 = -2' String2 = 0' String3 = 0' String4 = 0' String5 = -2 };                      else if (arrangement.Tuning == "EFlat")                          rsSong.Tuning = new TuningStrings { String0 = -1' String1 = -1' String2 = -1' String3 = -1' String4 = -1' String5 = -1 };                      else // default to standard tuning                      {                          arrangement.Tuning = "E Standard";                          rsSong.Tuning = new TuningStrings { String0 = 0' String1 = 0' String2 = 0' String3 = 0' String4 = 0' String5 = 0 };                      }                        // save/write the changes to xml file                      using (var obj1 = new Rs1Converter())                          obj1.SongToXml(rsSong' xmlFile' true);                        if (convert)                          using (var obj1 = new Rs1Converter())                              tones2014.Add(obj1.ToneToTone2014(tone' rsSong));                        // load attr2014 with RS1 mapped values for use by Arrangement()                      attr2014.Tone_Base = tone.Name;                      attr2014.ArrangementName = arrangement.ArrangementName;                      attr2014.CentOffset = 0;                      attr2014.DynamicVisualDensity = new List<float>() { 2 };                      attr2014.SongPartition = arrangement.SongPartition;                      attr2014.PersistentID = IdGenerator.Guid().ToString();                      attr2014.MasterID_RDV = RandomGenerator.NextInt();                      attr2014.ArrangementProperties = new SongArrangementProperties2014();                        // processing order is important - CAREFUL                      // RouteMask  None = 0' Lead = 1' Rhythm = 2' Any = 3' Bass = 4                      // XML file names are usually meaningless to arrangement determination                        if (arrangement.ArrangementName.ToLower().Contains("lead") ||                          rsSong.Arrangement.ToLower().Contains("lead"))                      {                          attr2014.ArrangementName = "Lead";                          attr2014.ArrangementType = (int)ArrangementType.Guitar;                          attr2014.ArrangementProperties.RouteMask = (int)RouteMask.Lead;                          attr2014.ArrangementProperties.PathLead = 1;                          attr2014.ArrangementProperties.PathRhythm = 0;                          attr2014.ArrangementProperties.PathBass = 0;                      }                      else if (arrangement.ArrangementName.ToLower().Contains("rhythm") ||                          rsSong.Arrangement.ToLower().Contains("rhythm"))                      // || rsSong.Arrangement.ToLower().Contains("guitar"))                      {                          attr2014.ArrangementName = "Rhythm";                          attr2014.ArrangementType = (int)ArrangementType.Guitar;                          attr2014.ArrangementProperties.RouteMask = (int)RouteMask.Rhythm;                          attr2014.ArrangementProperties.PathLead = 0;                          attr2014.ArrangementProperties.PathRhythm = 1;                          attr2014.ArrangementProperties.PathBass = 0;                      }                      else if (arrangement.ArrangementName.ToLower().Contains("combo") ||                          rsSong.Arrangement.ToLower().Contains("combo"))                      {                          attr2014.ArrangementName = "Combo";                          attr2014.ArrangementType = (int)ArrangementType.Guitar;                          attr2014.ArrangementProperties.RouteMask = arrangement.EffectChainName.ToLower().Contains("lead") ? (int)RouteMask.Lead : (int)RouteMask.Rhythm;                          attr2014.ArrangementProperties.PathLead = arrangement.EffectChainName.ToLower().Contains("lead") ? 1 : 0;                          attr2014.ArrangementProperties.PathRhythm = arrangement.EffectChainName.ToLower().Contains("lead") ? 0 : 1;                          attr2014.ArrangementProperties.PathBass = 0;                      }                      else if (arrangement.ArrangementName.ToLower().Contains("bass") ||                          rsSong.Arrangement.ToLower().Contains("bass"))                      {                          attr2014.ArrangementName = "Bass";                          attr2014.ArrangementType = (int)ArrangementType.Bass;                          attr2014.ArrangementProperties.RouteMask = (int)RouteMask.Bass;                          attr2014.ArrangementProperties.PathLead = 0;                          attr2014.ArrangementProperties.PathRhythm = 0;                          attr2014.ArrangementProperties.PathBass = 1;                      }                      else                      {                          // default to Lead arrangement                          attr2014.ArrangementName = "Lead";                          attr2014.ArrangementType = (int)ArrangementType.Guitar;                          attr2014.ArrangementProperties.RouteMask = (int)RouteMask.Lead;                          attr2014.ArrangementProperties.PathLead = 1;                          attr2014.ArrangementProperties.PathRhythm = 0;                          attr2014.ArrangementProperties.PathBass = 0;                            Console.WriteLine("RS1->RS2 CDLC Conversion defaulted to 'Lead' arrangement");                      }                        if (convert) // RS1 -> RS2 magic                      {                          using (var obj1 = new Rs1Converter())                              rsSong2014 = obj1.SongToSong2014(rsSong);                            // update ArrangementProperties                          rsSong2014.ArrangementProperties.RouteMask = attr2014.ArrangementProperties.RouteMask;                          rsSong2014.ArrangementProperties.PathLead = attr2014.ArrangementProperties.PathLead;                          rsSong2014.ArrangementProperties.PathRhythm = attr2014.ArrangementProperties.PathRhythm;                          rsSong2014.ArrangementProperties.PathBass = attr2014.ArrangementProperties.PathBass;                          rsSong2014.ArrangementProperties.StandardTuning = (arrangement.Tuning == "E Standard" ? 1 : 0);                            // <note time="58.366" linkNext="0" accent="0" bend="0" fret="7" hammerOn="0" harmonic="0" hopo="0" ignore="0" leftHand="-1" mute="0" palmMute="0" pluck="-1" pullOff="0" slap="-1" slideTo="-1" string="3" sustain="0.108" tremolo="0" harmonicPinch="0" pickDirection="0" rightHand="-1" slideUnpitchTo="-1" tap="0" vibrato="0" />                          if (rsSong2014.Levels.Any(sl => sl.Notes.Any(sln => sln.Bend != 0)))                              rsSong2014.ArrangementProperties.Bends = 1;                          if (rsSong2014.Levels.Any(sl => sl.Notes.Any(sln => sln.Hopo != 0)))                              rsSong2014.ArrangementProperties.Hopo = 1;                          if (rsSong2014.Levels.Any(sl => sl.Notes.Any(sln => sln.SlideTo != -1)))                              rsSong2014.ArrangementProperties.Slides = 1;                          if (rsSong2014.Levels.Any(sl => sl.Notes.Any(sln => sln.Sustain > 0)))                              rsSong2014.ArrangementProperties.Sustain = 1;                            // fixing times that are off                          var lastEbeatsTime = rsSong2014.Ebeats[rsSong2014.Ebeats.Length - 1].Time;                          var lastPhraseIterationsTime = rsSong2014.PhraseIterations[rsSong2014.PhraseIterations.Length - 1].Time;                            // tested ... not source of in game hangs                          // confirm last PhraseIterations time is less than last Ebeats time                          if (lastPhraseIterationsTime > lastEbeatsTime)                          {                              rsSong2014.PhraseIterations[rsSong2014.PhraseIterations.Length - 1].Time = lastEbeatsTime;                              rsSong2014.Sections[rsSong2014.Sections.Length - 1].StartTime = lastEbeatsTime;                          }                            // tested ... not source of in game hangs                          // confirm SongLength at least equals last Ebeats time                          if (rsSong2014.SongLength < lastEbeatsTime)                              rsSong2014.SongLength = lastEbeatsTime;                            using (var obj2 = new Rs2014Converter())                              obj2.Song2014ToXml(rsSong2014' xmlFile' true);                      }                        // Adding Song Arrangement                      try                      {                          data.Arrangements.Add(new Arrangement(attr2014' xmlFile));                      }                      catch (Exception ex)                      {                          // mainly for the benefit of convert2012 CLI users                          Console.WriteLine(@"This CDLC could not be auto converted." + Environment.NewLine + "You can still try manually adding the arrangements and assets." + Environment.NewLine + ex.Message);                      }                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,RS1LoadFromFolder,The following statement contains a magic number: foreach (var xmlFile in xmlFiles)              {                  if (xmlFile.ToLower().Contains("metadata"))                      continue;                    // some poorly formed RS1 CDLC use just "vocal"                  if (xmlFile.ToLower().Contains("vocal"))                  {                      // Add Vocal Arrangement                      data.Arrangements.Add(new Arrangement                      {                          Name = ArrangementName.Vocals'                          ArrangementType = ArrangementType.Vocal'                          ScrollSpeed = 20'                          SongXml = new SongXML { File = xmlFile }'                          SongFile = new SongFile { File = "" }'                          CustomFont = false                      });                  }                  else                  {                      var attr2014 = new Attributes2014();                      var rsSong = new Song();                      var rsSong2014 = new Song2014();                        // optimized tone matching effort using project mapping algo                      var result = projectMap.First(m => String.Equals(Path.GetFileName(m.SongXmlPath)' Path.GetFileName(xmlFile)' StringComparison.CurrentCultureIgnoreCase));                      if (result.Tones.Count != 1)                          throw new DataException("Invalid RS1 CDLC Tones Data");                        var arrangement = attr.First(s => s.SongXml.ToLower().Contains(result.LLID));//FIXME: Sequence contains no matching element issue                      var tone = tones.First(t => t.Key == result.Tones[0]);                        using (var obj1 = new Rs1Converter())                      {                          rsSong = obj1.XmlToSong(xmlFile);                          data.SongInfo.AverageTempo = (int)obj1.AverageBPM(rsSong);                      }                        if (arrangement.Tuning == "E Standard")                          rsSong.Tuning = new TuningStrings { String0 = 0' String1 = 0' String2 = 0' String3 = 0' String4 = 0' String5 = 0 };                      else if (arrangement.Tuning == "DropD")                          rsSong.Tuning = new TuningStrings { String0 = -2' String1 = 0' String2 = 0' String3 = 0' String4 = 0' String5 = 0 };                      else if (arrangement.Tuning == "OpenG")                          rsSong.Tuning = new TuningStrings { String0 = -2' String1 = -2' String2 = 0' String3 = 0' String4 = 0' String5 = -2 };                      else if (arrangement.Tuning == "EFlat")                          rsSong.Tuning = new TuningStrings { String0 = -1' String1 = -1' String2 = -1' String3 = -1' String4 = -1' String5 = -1 };                      else // default to standard tuning                      {                          arrangement.Tuning = "E Standard";                          rsSong.Tuning = new TuningStrings { String0 = 0' String1 = 0' String2 = 0' String3 = 0' String4 = 0' String5 = 0 };                      }                        // save/write the changes to xml file                      using (var obj1 = new Rs1Converter())                          obj1.SongToXml(rsSong' xmlFile' true);                        if (convert)                          using (var obj1 = new Rs1Converter())                              tones2014.Add(obj1.ToneToTone2014(tone' rsSong));                        // load attr2014 with RS1 mapped values for use by Arrangement()                      attr2014.Tone_Base = tone.Name;                      attr2014.ArrangementName = arrangement.ArrangementName;                      attr2014.CentOffset = 0;                      attr2014.DynamicVisualDensity = new List<float>() { 2 };                      attr2014.SongPartition = arrangement.SongPartition;                      attr2014.PersistentID = IdGenerator.Guid().ToString();                      attr2014.MasterID_RDV = RandomGenerator.NextInt();                      attr2014.ArrangementProperties = new SongArrangementProperties2014();                        // processing order is important - CAREFUL                      // RouteMask  None = 0' Lead = 1' Rhythm = 2' Any = 3' Bass = 4                      // XML file names are usually meaningless to arrangement determination                        if (arrangement.ArrangementName.ToLower().Contains("lead") ||                          rsSong.Arrangement.ToLower().Contains("lead"))                      {                          attr2014.ArrangementName = "Lead";                          attr2014.ArrangementType = (int)ArrangementType.Guitar;                          attr2014.ArrangementProperties.RouteMask = (int)RouteMask.Lead;                          attr2014.ArrangementProperties.PathLead = 1;                          attr2014.ArrangementProperties.PathRhythm = 0;                          attr2014.ArrangementProperties.PathBass = 0;                      }                      else if (arrangement.ArrangementName.ToLower().Contains("rhythm") ||                          rsSong.Arrangement.ToLower().Contains("rhythm"))                      // || rsSong.Arrangement.ToLower().Contains("guitar"))                      {                          attr2014.ArrangementName = "Rhythm";                          attr2014.ArrangementType = (int)ArrangementType.Guitar;                          attr2014.ArrangementProperties.RouteMask = (int)RouteMask.Rhythm;                          attr2014.ArrangementProperties.PathLead = 0;                          attr2014.ArrangementProperties.PathRhythm = 1;                          attr2014.ArrangementProperties.PathBass = 0;                      }                      else if (arrangement.ArrangementName.ToLower().Contains("combo") ||                          rsSong.Arrangement.ToLower().Contains("combo"))                      {                          attr2014.ArrangementName = "Combo";                          attr2014.ArrangementType = (int)ArrangementType.Guitar;                          attr2014.ArrangementProperties.RouteMask = arrangement.EffectChainName.ToLower().Contains("lead") ? (int)RouteMask.Lead : (int)RouteMask.Rhythm;                          attr2014.ArrangementProperties.PathLead = arrangement.EffectChainName.ToLower().Contains("lead") ? 1 : 0;                          attr2014.ArrangementProperties.PathRhythm = arrangement.EffectChainName.ToLower().Contains("lead") ? 0 : 1;                          attr2014.ArrangementProperties.PathBass = 0;                      }                      else if (arrangement.ArrangementName.ToLower().Contains("bass") ||                          rsSong.Arrangement.ToLower().Contains("bass"))                      {                          attr2014.ArrangementName = "Bass";                          attr2014.ArrangementType = (int)ArrangementType.Bass;                          attr2014.ArrangementProperties.RouteMask = (int)RouteMask.Bass;                          attr2014.ArrangementProperties.PathLead = 0;                          attr2014.ArrangementProperties.PathRhythm = 0;                          attr2014.ArrangementProperties.PathBass = 1;                      }                      else                      {                          // default to Lead arrangement                          attr2014.ArrangementName = "Lead";                          attr2014.ArrangementType = (int)ArrangementType.Guitar;                          attr2014.ArrangementProperties.RouteMask = (int)RouteMask.Lead;                          attr2014.ArrangementProperties.PathLead = 1;                          attr2014.ArrangementProperties.PathRhythm = 0;                          attr2014.ArrangementProperties.PathBass = 0;                            Console.WriteLine("RS1->RS2 CDLC Conversion defaulted to 'Lead' arrangement");                      }                        if (convert) // RS1 -> RS2 magic                      {                          using (var obj1 = new Rs1Converter())                              rsSong2014 = obj1.SongToSong2014(rsSong);                            // update ArrangementProperties                          rsSong2014.ArrangementProperties.RouteMask = attr2014.ArrangementProperties.RouteMask;                          rsSong2014.ArrangementProperties.PathLead = attr2014.ArrangementProperties.PathLead;                          rsSong2014.ArrangementProperties.PathRhythm = attr2014.ArrangementProperties.PathRhythm;                          rsSong2014.ArrangementProperties.PathBass = attr2014.ArrangementProperties.PathBass;                          rsSong2014.ArrangementProperties.StandardTuning = (arrangement.Tuning == "E Standard" ? 1 : 0);                            // <note time="58.366" linkNext="0" accent="0" bend="0" fret="7" hammerOn="0" harmonic="0" hopo="0" ignore="0" leftHand="-1" mute="0" palmMute="0" pluck="-1" pullOff="0" slap="-1" slideTo="-1" string="3" sustain="0.108" tremolo="0" harmonicPinch="0" pickDirection="0" rightHand="-1" slideUnpitchTo="-1" tap="0" vibrato="0" />                          if (rsSong2014.Levels.Any(sl => sl.Notes.Any(sln => sln.Bend != 0)))                              rsSong2014.ArrangementProperties.Bends = 1;                          if (rsSong2014.Levels.Any(sl => sl.Notes.Any(sln => sln.Hopo != 0)))                              rsSong2014.ArrangementProperties.Hopo = 1;                          if (rsSong2014.Levels.Any(sl => sl.Notes.Any(sln => sln.SlideTo != -1)))                              rsSong2014.ArrangementProperties.Slides = 1;                          if (rsSong2014.Levels.Any(sl => sl.Notes.Any(sln => sln.Sustain > 0)))                              rsSong2014.ArrangementProperties.Sustain = 1;                            // fixing times that are off                          var lastEbeatsTime = rsSong2014.Ebeats[rsSong2014.Ebeats.Length - 1].Time;                          var lastPhraseIterationsTime = rsSong2014.PhraseIterations[rsSong2014.PhraseIterations.Length - 1].Time;                            // tested ... not source of in game hangs                          // confirm last PhraseIterations time is less than last Ebeats time                          if (lastPhraseIterationsTime > lastEbeatsTime)                          {                              rsSong2014.PhraseIterations[rsSong2014.PhraseIterations.Length - 1].Time = lastEbeatsTime;                              rsSong2014.Sections[rsSong2014.Sections.Length - 1].StartTime = lastEbeatsTime;                          }                            // tested ... not source of in game hangs                          // confirm SongLength at least equals last Ebeats time                          if (rsSong2014.SongLength < lastEbeatsTime)                              rsSong2014.SongLength = lastEbeatsTime;                            using (var obj2 = new Rs2014Converter())                              obj2.Song2014ToXml(rsSong2014' xmlFile' true);                      }                        // Adding Song Arrangement                      try                      {                          data.Arrangements.Add(new Arrangement(attr2014' xmlFile));                      }                      catch (Exception ex)                      {                          // mainly for the benefit of convert2012 CLI users                          Console.WriteLine(@"This CDLC could not be auto converted." + Environment.NewLine + "You can still try manually adding the arrangements and assets." + Environment.NewLine + ex.Message);                      }                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,RS1LoadFromFolder,The following statement contains a magic number: foreach (var xmlFile in xmlFiles)              {                  if (xmlFile.ToLower().Contains("metadata"))                      continue;                    // some poorly formed RS1 CDLC use just "vocal"                  if (xmlFile.ToLower().Contains("vocal"))                  {                      // Add Vocal Arrangement                      data.Arrangements.Add(new Arrangement                      {                          Name = ArrangementName.Vocals'                          ArrangementType = ArrangementType.Vocal'                          ScrollSpeed = 20'                          SongXml = new SongXML { File = xmlFile }'                          SongFile = new SongFile { File = "" }'                          CustomFont = false                      });                  }                  else                  {                      var attr2014 = new Attributes2014();                      var rsSong = new Song();                      var rsSong2014 = new Song2014();                        // optimized tone matching effort using project mapping algo                      var result = projectMap.First(m => String.Equals(Path.GetFileName(m.SongXmlPath)' Path.GetFileName(xmlFile)' StringComparison.CurrentCultureIgnoreCase));                      if (result.Tones.Count != 1)                          throw new DataException("Invalid RS1 CDLC Tones Data");                        var arrangement = attr.First(s => s.SongXml.ToLower().Contains(result.LLID));//FIXME: Sequence contains no matching element issue                      var tone = tones.First(t => t.Key == result.Tones[0]);                        using (var obj1 = new Rs1Converter())                      {                          rsSong = obj1.XmlToSong(xmlFile);                          data.SongInfo.AverageTempo = (int)obj1.AverageBPM(rsSong);                      }                        if (arrangement.Tuning == "E Standard")                          rsSong.Tuning = new TuningStrings { String0 = 0' String1 = 0' String2 = 0' String3 = 0' String4 = 0' String5 = 0 };                      else if (arrangement.Tuning == "DropD")                          rsSong.Tuning = new TuningStrings { String0 = -2' String1 = 0' String2 = 0' String3 = 0' String4 = 0' String5 = 0 };                      else if (arrangement.Tuning == "OpenG")                          rsSong.Tuning = new TuningStrings { String0 = -2' String1 = -2' String2 = 0' String3 = 0' String4 = 0' String5 = -2 };                      else if (arrangement.Tuning == "EFlat")                          rsSong.Tuning = new TuningStrings { String0 = -1' String1 = -1' String2 = -1' String3 = -1' String4 = -1' String5 = -1 };                      else // default to standard tuning                      {                          arrangement.Tuning = "E Standard";                          rsSong.Tuning = new TuningStrings { String0 = 0' String1 = 0' String2 = 0' String3 = 0' String4 = 0' String5 = 0 };                      }                        // save/write the changes to xml file                      using (var obj1 = new Rs1Converter())                          obj1.SongToXml(rsSong' xmlFile' true);                        if (convert)                          using (var obj1 = new Rs1Converter())                              tones2014.Add(obj1.ToneToTone2014(tone' rsSong));                        // load attr2014 with RS1 mapped values for use by Arrangement()                      attr2014.Tone_Base = tone.Name;                      attr2014.ArrangementName = arrangement.ArrangementName;                      attr2014.CentOffset = 0;                      attr2014.DynamicVisualDensity = new List<float>() { 2 };                      attr2014.SongPartition = arrangement.SongPartition;                      attr2014.PersistentID = IdGenerator.Guid().ToString();                      attr2014.MasterID_RDV = RandomGenerator.NextInt();                      attr2014.ArrangementProperties = new SongArrangementProperties2014();                        // processing order is important - CAREFUL                      // RouteMask  None = 0' Lead = 1' Rhythm = 2' Any = 3' Bass = 4                      // XML file names are usually meaningless to arrangement determination                        if (arrangement.ArrangementName.ToLower().Contains("lead") ||                          rsSong.Arrangement.ToLower().Contains("lead"))                      {                          attr2014.ArrangementName = "Lead";                          attr2014.ArrangementType = (int)ArrangementType.Guitar;                          attr2014.ArrangementProperties.RouteMask = (int)RouteMask.Lead;                          attr2014.ArrangementProperties.PathLead = 1;                          attr2014.ArrangementProperties.PathRhythm = 0;                          attr2014.ArrangementProperties.PathBass = 0;                      }                      else if (arrangement.ArrangementName.ToLower().Contains("rhythm") ||                          rsSong.Arrangement.ToLower().Contains("rhythm"))                      // || rsSong.Arrangement.ToLower().Contains("guitar"))                      {                          attr2014.ArrangementName = "Rhythm";                          attr2014.ArrangementType = (int)ArrangementType.Guitar;                          attr2014.ArrangementProperties.RouteMask = (int)RouteMask.Rhythm;                          attr2014.ArrangementProperties.PathLead = 0;                          attr2014.ArrangementProperties.PathRhythm = 1;                          attr2014.ArrangementProperties.PathBass = 0;                      }                      else if (arrangement.ArrangementName.ToLower().Contains("combo") ||                          rsSong.Arrangement.ToLower().Contains("combo"))                      {                          attr2014.ArrangementName = "Combo";                          attr2014.ArrangementType = (int)ArrangementType.Guitar;                          attr2014.ArrangementProperties.RouteMask = arrangement.EffectChainName.ToLower().Contains("lead") ? (int)RouteMask.Lead : (int)RouteMask.Rhythm;                          attr2014.ArrangementProperties.PathLead = arrangement.EffectChainName.ToLower().Contains("lead") ? 1 : 0;                          attr2014.ArrangementProperties.PathRhythm = arrangement.EffectChainName.ToLower().Contains("lead") ? 0 : 1;                          attr2014.ArrangementProperties.PathBass = 0;                      }                      else if (arrangement.ArrangementName.ToLower().Contains("bass") ||                          rsSong.Arrangement.ToLower().Contains("bass"))                      {                          attr2014.ArrangementName = "Bass";                          attr2014.ArrangementType = (int)ArrangementType.Bass;                          attr2014.ArrangementProperties.RouteMask = (int)RouteMask.Bass;                          attr2014.ArrangementProperties.PathLead = 0;                          attr2014.ArrangementProperties.PathRhythm = 0;                          attr2014.ArrangementProperties.PathBass = 1;                      }                      else                      {                          // default to Lead arrangement                          attr2014.ArrangementName = "Lead";                          attr2014.ArrangementType = (int)ArrangementType.Guitar;                          attr2014.ArrangementProperties.RouteMask = (int)RouteMask.Lead;                          attr2014.ArrangementProperties.PathLead = 1;                          attr2014.ArrangementProperties.PathRhythm = 0;                          attr2014.ArrangementProperties.PathBass = 0;                            Console.WriteLine("RS1->RS2 CDLC Conversion defaulted to 'Lead' arrangement");                      }                        if (convert) // RS1 -> RS2 magic                      {                          using (var obj1 = new Rs1Converter())                              rsSong2014 = obj1.SongToSong2014(rsSong);                            // update ArrangementProperties                          rsSong2014.ArrangementProperties.RouteMask = attr2014.ArrangementProperties.RouteMask;                          rsSong2014.ArrangementProperties.PathLead = attr2014.ArrangementProperties.PathLead;                          rsSong2014.ArrangementProperties.PathRhythm = attr2014.ArrangementProperties.PathRhythm;                          rsSong2014.ArrangementProperties.PathBass = attr2014.ArrangementProperties.PathBass;                          rsSong2014.ArrangementProperties.StandardTuning = (arrangement.Tuning == "E Standard" ? 1 : 0);                            // <note time="58.366" linkNext="0" accent="0" bend="0" fret="7" hammerOn="0" harmonic="0" hopo="0" ignore="0" leftHand="-1" mute="0" palmMute="0" pluck="-1" pullOff="0" slap="-1" slideTo="-1" string="3" sustain="0.108" tremolo="0" harmonicPinch="0" pickDirection="0" rightHand="-1" slideUnpitchTo="-1" tap="0" vibrato="0" />                          if (rsSong2014.Levels.Any(sl => sl.Notes.Any(sln => sln.Bend != 0)))                              rsSong2014.ArrangementProperties.Bends = 1;                          if (rsSong2014.Levels.Any(sl => sl.Notes.Any(sln => sln.Hopo != 0)))                              rsSong2014.ArrangementProperties.Hopo = 1;                          if (rsSong2014.Levels.Any(sl => sl.Notes.Any(sln => sln.SlideTo != -1)))                              rsSong2014.ArrangementProperties.Slides = 1;                          if (rsSong2014.Levels.Any(sl => sl.Notes.Any(sln => sln.Sustain > 0)))                              rsSong2014.ArrangementProperties.Sustain = 1;                            // fixing times that are off                          var lastEbeatsTime = rsSong2014.Ebeats[rsSong2014.Ebeats.Length - 1].Time;                          var lastPhraseIterationsTime = rsSong2014.PhraseIterations[rsSong2014.PhraseIterations.Length - 1].Time;                            // tested ... not source of in game hangs                          // confirm last PhraseIterations time is less than last Ebeats time                          if (lastPhraseIterationsTime > lastEbeatsTime)                          {                              rsSong2014.PhraseIterations[rsSong2014.PhraseIterations.Length - 1].Time = lastEbeatsTime;                              rsSong2014.Sections[rsSong2014.Sections.Length - 1].StartTime = lastEbeatsTime;                          }                            // tested ... not source of in game hangs                          // confirm SongLength at least equals last Ebeats time                          if (rsSong2014.SongLength < lastEbeatsTime)                              rsSong2014.SongLength = lastEbeatsTime;                            using (var obj2 = new Rs2014Converter())                              obj2.Song2014ToXml(rsSong2014' xmlFile' true);                      }                        // Adding Song Arrangement                      try                      {                          data.Arrangements.Add(new Arrangement(attr2014' xmlFile));                      }                      catch (Exception ex)                      {                          // mainly for the benefit of convert2012 CLI users                          Console.WriteLine(@"This CDLC could not be auto converted." + Environment.NewLine + "You can still try manually adding the arrangements and assets." + Environment.NewLine + ex.Message);                      }                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,RS1LoadFromFolder,The following statement contains a magic number: foreach (var xmlFile in xmlFiles)              {                  if (xmlFile.ToLower().Contains("metadata"))                      continue;                    // some poorly formed RS1 CDLC use just "vocal"                  if (xmlFile.ToLower().Contains("vocal"))                  {                      // Add Vocal Arrangement                      data.Arrangements.Add(new Arrangement                      {                          Name = ArrangementName.Vocals'                          ArrangementType = ArrangementType.Vocal'                          ScrollSpeed = 20'                          SongXml = new SongXML { File = xmlFile }'                          SongFile = new SongFile { File = "" }'                          CustomFont = false                      });                  }                  else                  {                      var attr2014 = new Attributes2014();                      var rsSong = new Song();                      var rsSong2014 = new Song2014();                        // optimized tone matching effort using project mapping algo                      var result = projectMap.First(m => String.Equals(Path.GetFileName(m.SongXmlPath)' Path.GetFileName(xmlFile)' StringComparison.CurrentCultureIgnoreCase));                      if (result.Tones.Count != 1)                          throw new DataException("Invalid RS1 CDLC Tones Data");                        var arrangement = attr.First(s => s.SongXml.ToLower().Contains(result.LLID));//FIXME: Sequence contains no matching element issue                      var tone = tones.First(t => t.Key == result.Tones[0]);                        using (var obj1 = new Rs1Converter())                      {                          rsSong = obj1.XmlToSong(xmlFile);                          data.SongInfo.AverageTempo = (int)obj1.AverageBPM(rsSong);                      }                        if (arrangement.Tuning == "E Standard")                          rsSong.Tuning = new TuningStrings { String0 = 0' String1 = 0' String2 = 0' String3 = 0' String4 = 0' String5 = 0 };                      else if (arrangement.Tuning == "DropD")                          rsSong.Tuning = new TuningStrings { String0 = -2' String1 = 0' String2 = 0' String3 = 0' String4 = 0' String5 = 0 };                      else if (arrangement.Tuning == "OpenG")                          rsSong.Tuning = new TuningStrings { String0 = -2' String1 = -2' String2 = 0' String3 = 0' String4 = 0' String5 = -2 };                      else if (arrangement.Tuning == "EFlat")                          rsSong.Tuning = new TuningStrings { String0 = -1' String1 = -1' String2 = -1' String3 = -1' String4 = -1' String5 = -1 };                      else // default to standard tuning                      {                          arrangement.Tuning = "E Standard";                          rsSong.Tuning = new TuningStrings { String0 = 0' String1 = 0' String2 = 0' String3 = 0' String4 = 0' String5 = 0 };                      }                        // save/write the changes to xml file                      using (var obj1 = new Rs1Converter())                          obj1.SongToXml(rsSong' xmlFile' true);                        if (convert)                          using (var obj1 = new Rs1Converter())                              tones2014.Add(obj1.ToneToTone2014(tone' rsSong));                        // load attr2014 with RS1 mapped values for use by Arrangement()                      attr2014.Tone_Base = tone.Name;                      attr2014.ArrangementName = arrangement.ArrangementName;                      attr2014.CentOffset = 0;                      attr2014.DynamicVisualDensity = new List<float>() { 2 };                      attr2014.SongPartition = arrangement.SongPartition;                      attr2014.PersistentID = IdGenerator.Guid().ToString();                      attr2014.MasterID_RDV = RandomGenerator.NextInt();                      attr2014.ArrangementProperties = new SongArrangementProperties2014();                        // processing order is important - CAREFUL                      // RouteMask  None = 0' Lead = 1' Rhythm = 2' Any = 3' Bass = 4                      // XML file names are usually meaningless to arrangement determination                        if (arrangement.ArrangementName.ToLower().Contains("lead") ||                          rsSong.Arrangement.ToLower().Contains("lead"))                      {                          attr2014.ArrangementName = "Lead";                          attr2014.ArrangementType = (int)ArrangementType.Guitar;                          attr2014.ArrangementProperties.RouteMask = (int)RouteMask.Lead;                          attr2014.ArrangementProperties.PathLead = 1;                          attr2014.ArrangementProperties.PathRhythm = 0;                          attr2014.ArrangementProperties.PathBass = 0;                      }                      else if (arrangement.ArrangementName.ToLower().Contains("rhythm") ||                          rsSong.Arrangement.ToLower().Contains("rhythm"))                      // || rsSong.Arrangement.ToLower().Contains("guitar"))                      {                          attr2014.ArrangementName = "Rhythm";                          attr2014.ArrangementType = (int)ArrangementType.Guitar;                          attr2014.ArrangementProperties.RouteMask = (int)RouteMask.Rhythm;                          attr2014.ArrangementProperties.PathLead = 0;                          attr2014.ArrangementProperties.PathRhythm = 1;                          attr2014.ArrangementProperties.PathBass = 0;                      }                      else if (arrangement.ArrangementName.ToLower().Contains("combo") ||                          rsSong.Arrangement.ToLower().Contains("combo"))                      {                          attr2014.ArrangementName = "Combo";                          attr2014.ArrangementType = (int)ArrangementType.Guitar;                          attr2014.ArrangementProperties.RouteMask = arrangement.EffectChainName.ToLower().Contains("lead") ? (int)RouteMask.Lead : (int)RouteMask.Rhythm;                          attr2014.ArrangementProperties.PathLead = arrangement.EffectChainName.ToLower().Contains("lead") ? 1 : 0;                          attr2014.ArrangementProperties.PathRhythm = arrangement.EffectChainName.ToLower().Contains("lead") ? 0 : 1;                          attr2014.ArrangementProperties.PathBass = 0;                      }                      else if (arrangement.ArrangementName.ToLower().Contains("bass") ||                          rsSong.Arrangement.ToLower().Contains("bass"))                      {                          attr2014.ArrangementName = "Bass";                          attr2014.ArrangementType = (int)ArrangementType.Bass;                          attr2014.ArrangementProperties.RouteMask = (int)RouteMask.Bass;                          attr2014.ArrangementProperties.PathLead = 0;                          attr2014.ArrangementProperties.PathRhythm = 0;                          attr2014.ArrangementProperties.PathBass = 1;                      }                      else                      {                          // default to Lead arrangement                          attr2014.ArrangementName = "Lead";                          attr2014.ArrangementType = (int)ArrangementType.Guitar;                          attr2014.ArrangementProperties.RouteMask = (int)RouteMask.Lead;                          attr2014.ArrangementProperties.PathLead = 1;                          attr2014.ArrangementProperties.PathRhythm = 0;                          attr2014.ArrangementProperties.PathBass = 0;                            Console.WriteLine("RS1->RS2 CDLC Conversion defaulted to 'Lead' arrangement");                      }                        if (convert) // RS1 -> RS2 magic                      {                          using (var obj1 = new Rs1Converter())                              rsSong2014 = obj1.SongToSong2014(rsSong);                            // update ArrangementProperties                          rsSong2014.ArrangementProperties.RouteMask = attr2014.ArrangementProperties.RouteMask;                          rsSong2014.ArrangementProperties.PathLead = attr2014.ArrangementProperties.PathLead;                          rsSong2014.ArrangementProperties.PathRhythm = attr2014.ArrangementProperties.PathRhythm;                          rsSong2014.ArrangementProperties.PathBass = attr2014.ArrangementProperties.PathBass;                          rsSong2014.ArrangementProperties.StandardTuning = (arrangement.Tuning == "E Standard" ? 1 : 0);                            // <note time="58.366" linkNext="0" accent="0" bend="0" fret="7" hammerOn="0" harmonic="0" hopo="0" ignore="0" leftHand="-1" mute="0" palmMute="0" pluck="-1" pullOff="0" slap="-1" slideTo="-1" string="3" sustain="0.108" tremolo="0" harmonicPinch="0" pickDirection="0" rightHand="-1" slideUnpitchTo="-1" tap="0" vibrato="0" />                          if (rsSong2014.Levels.Any(sl => sl.Notes.Any(sln => sln.Bend != 0)))                              rsSong2014.ArrangementProperties.Bends = 1;                          if (rsSong2014.Levels.Any(sl => sl.Notes.Any(sln => sln.Hopo != 0)))                              rsSong2014.ArrangementProperties.Hopo = 1;                          if (rsSong2014.Levels.Any(sl => sl.Notes.Any(sln => sln.SlideTo != -1)))                              rsSong2014.ArrangementProperties.Slides = 1;                          if (rsSong2014.Levels.Any(sl => sl.Notes.Any(sln => sln.Sustain > 0)))                              rsSong2014.ArrangementProperties.Sustain = 1;                            // fixing times that are off                          var lastEbeatsTime = rsSong2014.Ebeats[rsSong2014.Ebeats.Length - 1].Time;                          var lastPhraseIterationsTime = rsSong2014.PhraseIterations[rsSong2014.PhraseIterations.Length - 1].Time;                            // tested ... not source of in game hangs                          // confirm last PhraseIterations time is less than last Ebeats time                          if (lastPhraseIterationsTime > lastEbeatsTime)                          {                              rsSong2014.PhraseIterations[rsSong2014.PhraseIterations.Length - 1].Time = lastEbeatsTime;                              rsSong2014.Sections[rsSong2014.Sections.Length - 1].StartTime = lastEbeatsTime;                          }                            // tested ... not source of in game hangs                          // confirm SongLength at least equals last Ebeats time                          if (rsSong2014.SongLength < lastEbeatsTime)                              rsSong2014.SongLength = lastEbeatsTime;                            using (var obj2 = new Rs2014Converter())                              obj2.Song2014ToXml(rsSong2014' xmlFile' true);                      }                        // Adding Song Arrangement                      try                      {                          data.Arrangements.Add(new Arrangement(attr2014' xmlFile));                      }                      catch (Exception ex)                      {                          // mainly for the benefit of convert2012 CLI users                          Console.WriteLine(@"This CDLC could not be auto converted." + Environment.NewLine + "You can still try manually adding the arrangements and assets." + Environment.NewLine + ex.Message);                      }                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,RS1LoadFromFolder,The following statement contains a magic number: foreach (var xmlFile in xmlFiles)              {                  if (xmlFile.ToLower().Contains("metadata"))                      continue;                    // some poorly formed RS1 CDLC use just "vocal"                  if (xmlFile.ToLower().Contains("vocal"))                  {                      // Add Vocal Arrangement                      data.Arrangements.Add(new Arrangement                      {                          Name = ArrangementName.Vocals'                          ArrangementType = ArrangementType.Vocal'                          ScrollSpeed = 20'                          SongXml = new SongXML { File = xmlFile }'                          SongFile = new SongFile { File = "" }'                          CustomFont = false                      });                  }                  else                  {                      var attr2014 = new Attributes2014();                      var rsSong = new Song();                      var rsSong2014 = new Song2014();                        // optimized tone matching effort using project mapping algo                      var result = projectMap.First(m => String.Equals(Path.GetFileName(m.SongXmlPath)' Path.GetFileName(xmlFile)' StringComparison.CurrentCultureIgnoreCase));                      if (result.Tones.Count != 1)                          throw new DataException("Invalid RS1 CDLC Tones Data");                        var arrangement = attr.First(s => s.SongXml.ToLower().Contains(result.LLID));//FIXME: Sequence contains no matching element issue                      var tone = tones.First(t => t.Key == result.Tones[0]);                        using (var obj1 = new Rs1Converter())                      {                          rsSong = obj1.XmlToSong(xmlFile);                          data.SongInfo.AverageTempo = (int)obj1.AverageBPM(rsSong);                      }                        if (arrangement.Tuning == "E Standard")                          rsSong.Tuning = new TuningStrings { String0 = 0' String1 = 0' String2 = 0' String3 = 0' String4 = 0' String5 = 0 };                      else if (arrangement.Tuning == "DropD")                          rsSong.Tuning = new TuningStrings { String0 = -2' String1 = 0' String2 = 0' String3 = 0' String4 = 0' String5 = 0 };                      else if (arrangement.Tuning == "OpenG")                          rsSong.Tuning = new TuningStrings { String0 = -2' String1 = -2' String2 = 0' String3 = 0' String4 = 0' String5 = -2 };                      else if (arrangement.Tuning == "EFlat")                          rsSong.Tuning = new TuningStrings { String0 = -1' String1 = -1' String2 = -1' String3 = -1' String4 = -1' String5 = -1 };                      else // default to standard tuning                      {                          arrangement.Tuning = "E Standard";                          rsSong.Tuning = new TuningStrings { String0 = 0' String1 = 0' String2 = 0' String3 = 0' String4 = 0' String5 = 0 };                      }                        // save/write the changes to xml file                      using (var obj1 = new Rs1Converter())                          obj1.SongToXml(rsSong' xmlFile' true);                        if (convert)                          using (var obj1 = new Rs1Converter())                              tones2014.Add(obj1.ToneToTone2014(tone' rsSong));                        // load attr2014 with RS1 mapped values for use by Arrangement()                      attr2014.Tone_Base = tone.Name;                      attr2014.ArrangementName = arrangement.ArrangementName;                      attr2014.CentOffset = 0;                      attr2014.DynamicVisualDensity = new List<float>() { 2 };                      attr2014.SongPartition = arrangement.SongPartition;                      attr2014.PersistentID = IdGenerator.Guid().ToString();                      attr2014.MasterID_RDV = RandomGenerator.NextInt();                      attr2014.ArrangementProperties = new SongArrangementProperties2014();                        // processing order is important - CAREFUL                      // RouteMask  None = 0' Lead = 1' Rhythm = 2' Any = 3' Bass = 4                      // XML file names are usually meaningless to arrangement determination                        if (arrangement.ArrangementName.ToLower().Contains("lead") ||                          rsSong.Arrangement.ToLower().Contains("lead"))                      {                          attr2014.ArrangementName = "Lead";                          attr2014.ArrangementType = (int)ArrangementType.Guitar;                          attr2014.ArrangementProperties.RouteMask = (int)RouteMask.Lead;                          attr2014.ArrangementProperties.PathLead = 1;                          attr2014.ArrangementProperties.PathRhythm = 0;                          attr2014.ArrangementProperties.PathBass = 0;                      }                      else if (arrangement.ArrangementName.ToLower().Contains("rhythm") ||                          rsSong.Arrangement.ToLower().Contains("rhythm"))                      // || rsSong.Arrangement.ToLower().Contains("guitar"))                      {                          attr2014.ArrangementName = "Rhythm";                          attr2014.ArrangementType = (int)ArrangementType.Guitar;                          attr2014.ArrangementProperties.RouteMask = (int)RouteMask.Rhythm;                          attr2014.ArrangementProperties.PathLead = 0;                          attr2014.ArrangementProperties.PathRhythm = 1;                          attr2014.ArrangementProperties.PathBass = 0;                      }                      else if (arrangement.ArrangementName.ToLower().Contains("combo") ||                          rsSong.Arrangement.ToLower().Contains("combo"))                      {                          attr2014.ArrangementName = "Combo";                          attr2014.ArrangementType = (int)ArrangementType.Guitar;                          attr2014.ArrangementProperties.RouteMask = arrangement.EffectChainName.ToLower().Contains("lead") ? (int)RouteMask.Lead : (int)RouteMask.Rhythm;                          attr2014.ArrangementProperties.PathLead = arrangement.EffectChainName.ToLower().Contains("lead") ? 1 : 0;                          attr2014.ArrangementProperties.PathRhythm = arrangement.EffectChainName.ToLower().Contains("lead") ? 0 : 1;                          attr2014.ArrangementProperties.PathBass = 0;                      }                      else if (arrangement.ArrangementName.ToLower().Contains("bass") ||                          rsSong.Arrangement.ToLower().Contains("bass"))                      {                          attr2014.ArrangementName = "Bass";                          attr2014.ArrangementType = (int)ArrangementType.Bass;                          attr2014.ArrangementProperties.RouteMask = (int)RouteMask.Bass;                          attr2014.ArrangementProperties.PathLead = 0;                          attr2014.ArrangementProperties.PathRhythm = 0;                          attr2014.ArrangementProperties.PathBass = 1;                      }                      else                      {                          // default to Lead arrangement                          attr2014.ArrangementName = "Lead";                          attr2014.ArrangementType = (int)ArrangementType.Guitar;                          attr2014.ArrangementProperties.RouteMask = (int)RouteMask.Lead;                          attr2014.ArrangementProperties.PathLead = 1;                          attr2014.ArrangementProperties.PathRhythm = 0;                          attr2014.ArrangementProperties.PathBass = 0;                            Console.WriteLine("RS1->RS2 CDLC Conversion defaulted to 'Lead' arrangement");                      }                        if (convert) // RS1 -> RS2 magic                      {                          using (var obj1 = new Rs1Converter())                              rsSong2014 = obj1.SongToSong2014(rsSong);                            // update ArrangementProperties                          rsSong2014.ArrangementProperties.RouteMask = attr2014.ArrangementProperties.RouteMask;                          rsSong2014.ArrangementProperties.PathLead = attr2014.ArrangementProperties.PathLead;                          rsSong2014.ArrangementProperties.PathRhythm = attr2014.ArrangementProperties.PathRhythm;                          rsSong2014.ArrangementProperties.PathBass = attr2014.ArrangementProperties.PathBass;                          rsSong2014.ArrangementProperties.StandardTuning = (arrangement.Tuning == "E Standard" ? 1 : 0);                            // <note time="58.366" linkNext="0" accent="0" bend="0" fret="7" hammerOn="0" harmonic="0" hopo="0" ignore="0" leftHand="-1" mute="0" palmMute="0" pluck="-1" pullOff="0" slap="-1" slideTo="-1" string="3" sustain="0.108" tremolo="0" harmonicPinch="0" pickDirection="0" rightHand="-1" slideUnpitchTo="-1" tap="0" vibrato="0" />                          if (rsSong2014.Levels.Any(sl => sl.Notes.Any(sln => sln.Bend != 0)))                              rsSong2014.ArrangementProperties.Bends = 1;                          if (rsSong2014.Levels.Any(sl => sl.Notes.Any(sln => sln.Hopo != 0)))                              rsSong2014.ArrangementProperties.Hopo = 1;                          if (rsSong2014.Levels.Any(sl => sl.Notes.Any(sln => sln.SlideTo != -1)))                              rsSong2014.ArrangementProperties.Slides = 1;                          if (rsSong2014.Levels.Any(sl => sl.Notes.Any(sln => sln.Sustain > 0)))                              rsSong2014.ArrangementProperties.Sustain = 1;                            // fixing times that are off                          var lastEbeatsTime = rsSong2014.Ebeats[rsSong2014.Ebeats.Length - 1].Time;                          var lastPhraseIterationsTime = rsSong2014.PhraseIterations[rsSong2014.PhraseIterations.Length - 1].Time;                            // tested ... not source of in game hangs                          // confirm last PhraseIterations time is less than last Ebeats time                          if (lastPhraseIterationsTime > lastEbeatsTime)                          {                              rsSong2014.PhraseIterations[rsSong2014.PhraseIterations.Length - 1].Time = lastEbeatsTime;                              rsSong2014.Sections[rsSong2014.Sections.Length - 1].StartTime = lastEbeatsTime;                          }                            // tested ... not source of in game hangs                          // confirm SongLength at least equals last Ebeats time                          if (rsSong2014.SongLength < lastEbeatsTime)                              rsSong2014.SongLength = lastEbeatsTime;                            using (var obj2 = new Rs2014Converter())                              obj2.Song2014ToXml(rsSong2014' xmlFile' true);                      }                        // Adding Song Arrangement                      try                      {                          data.Arrangements.Add(new Arrangement(attr2014' xmlFile));                      }                      catch (Exception ex)                      {                          // mainly for the benefit of convert2012 CLI users                          Console.WriteLine(@"This CDLC could not be auto converted." + Environment.NewLine + "You can still try manually adding the arrangements and assets." + Environment.NewLine + ex.Message);                      }                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,RS1LoadFromFolder,The following statement contains a magic number: targetArtFiles.Add(new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = artFiles[0]' destinationFile = artFiles[0].CopyToTempFile(".dds") });
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,RS1LoadFromFolder,The following statement contains a magic number: targetArtFiles.Add(new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = artFiles[0]' destinationFile = artFiles[0].CopyToTempFile(".dds") });
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,RS1LoadFromFolder,The following statement contains a magic number: if (audioFiles.Length > 2)                  throw new DataException("Too many Audio files found.");
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,LoadFromFolder,The following statement contains a magic number: foreach (var json in jsonFiles)              {                  var attr = Manifest2014<Attributes2014>.LoadFromFile(json).Entries.ToArray()[0].Value.ToArray()[0].Value;                  var xmlName = attr.SongXml.Split(':')[3];                  var xmlFile = Directory.EnumerateFiles(unpackedDir' xmlName + ".xml"' SearchOption.AllDirectories).FirstOrDefault();                    if (attr.Phrases != null)                  {                      if (data.SongInfo == null)                      {                          // Fill Package Data                          data.Name = attr.DLCKey;                            // Get song volume                          _volume = attr.SongVolume;                          _volume_preview = attr.PreviewVolume ?? _volume;                            // Fill SongInfo                          data.SongInfo = new SongInfo { SongDisplayName = attr.SongName' SongDisplayNameSort = attr.SongNameSort' Album = attr.AlbumName' AlbumSort = attr.AlbumNameSort' SongYear = attr.SongYear ?? 0' Artist = attr.ArtistName' ArtistSort = attr.ArtistNameSort' AverageTempo = (int)attr.SongAverageTempo };                      }                        // Adding Arrangement                      data.Arrangements.Add(new Arrangement(attr' xmlFile' fixMultiTone' fixLowBass));                        // make a list of tone names used in arrangements                      var toneNames = new List<string>();                      foreach (var arr in data.Arrangements)                      {                          if (!String.IsNullOrEmpty(arr.ToneA)) toneNames.Add(arr.ToneA);                          if (!String.IsNullOrEmpty(arr.ToneB)) toneNames.Add(arr.ToneB);                          if (!String.IsNullOrEmpty(arr.ToneC)) toneNames.Add(arr.ToneC);                          if (!String.IsNullOrEmpty(arr.ToneD)) toneNames.Add(arr.ToneD);                          if (!String.IsNullOrEmpty(arr.ToneBase)) toneNames.Add(arr.ToneBase);                      }                        // Adding Tones                      foreach (var jsonTone in attr.Tones)                      {                          if (jsonTone == null) continue;                          var key = jsonTone.Key;                          if (data.TonesRS2014.All(t => t.Key != key))                          {                              // fix tones names that do not have the correct alphacase for cross matching                              if (attr.Tone_Base.ToLower() == jsonTone.Name.ToLower() && attr.Tone_Base != jsonTone.Name)                                  jsonTone.Name = attr.Tone_Base;                              if (attr.Tone_A != null && attr.Tone_A.ToLower() == jsonTone.Name.ToLower() && attr.Tone_A != jsonTone.Name)                                  jsonTone.Name = attr.Tone_A;                              if (attr.Tone_B != null && attr.Tone_B.ToLower() == jsonTone.Name.ToLower() && attr.Tone_B != jsonTone.Name)                                  jsonTone.Name = attr.Tone_B;                              if (attr.Tone_C != null && attr.Tone_C.ToLower() == jsonTone.Name.ToLower() && attr.Tone_C != jsonTone.Name)                                  jsonTone.Name = attr.Tone_C;                              if (attr.Tone_D != null && attr.Tone_D.ToLower() == jsonTone.Name.ToLower() && attr.Tone_D != jsonTone.Name)                                  jsonTone.Name = attr.Tone_D;                                // this is part of multitone exception handling auto convert to single tone arrangment                              // make data.TonesRS2014 consistent with data.Arragment.Tones (toneNames)                              if (toneNames.Contains(jsonTone.Name))                                  data.TonesRS2014.Add(jsonTone);                          }                      }                  }                  else if (xmlFile.ToLower().Contains("vocals")) // detect both jvocals and vocals                  {                      //var debugMe = "Confirm XML comments were preserved.";                      var voc = new Arrangement                          {                              Name = attr.JapaneseVocal == true ? ArrangementName.JVocals : ArrangementName.Vocals'                              ArrangementType = ArrangementType.Vocal'                              ScrollSpeed = 20'                              SongXml = new SongXML { File = xmlFile }'                              SongFile = new SongFile { File = "" }'                              CustomFont = attr.JapaneseVocal == true'                              XmlComments = Song2014.ReadXmlComments(xmlFile)                          };                        // Get symbols stuff from vocals.xml                      var fontSng = Path.Combine(unpackedDir' xmlName + ".sng");                      var vocSng = Sng2014FileWriter.ReadVocals(xmlFile);                        // TODO: explain/confirm function/usage of this conditional check                      if (vocSng.IsCustomFont()) // always seems to be false' even for jvocals                      {                          voc.CustomFont = true;                          voc.FontSng = fontSng;                          vocSng.WriteChartData(fontSng' new Platform(GamePlatform.Pc' GameVersion.None));                          throw new Exception("<CRITICAL ERROR> vocSng.IsCustomFont: " + xmlFile + Environment.NewLine + "Please report this error to the toolkit developers along with the song that you are currently working on." + Environment.NewLine + "This is important!");                      }                        voc.Sng2014 = Sng2014File.ConvertXML(xmlFile' ArrangementType.Vocal' voc.FontSng);                        // Adding Arrangement                      data.Arrangements.Add(voc);                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,LoadFromFolder,The following statement contains a magic number: foreach (var json in jsonFiles)              {                  var attr = Manifest2014<Attributes2014>.LoadFromFile(json).Entries.ToArray()[0].Value.ToArray()[0].Value;                  var xmlName = attr.SongXml.Split(':')[3];                  var xmlFile = Directory.EnumerateFiles(unpackedDir' xmlName + ".xml"' SearchOption.AllDirectories).FirstOrDefault();                    if (attr.Phrases != null)                  {                      if (data.SongInfo == null)                      {                          // Fill Package Data                          data.Name = attr.DLCKey;                            // Get song volume                          _volume = attr.SongVolume;                          _volume_preview = attr.PreviewVolume ?? _volume;                            // Fill SongInfo                          data.SongInfo = new SongInfo { SongDisplayName = attr.SongName' SongDisplayNameSort = attr.SongNameSort' Album = attr.AlbumName' AlbumSort = attr.AlbumNameSort' SongYear = attr.SongYear ?? 0' Artist = attr.ArtistName' ArtistSort = attr.ArtistNameSort' AverageTempo = (int)attr.SongAverageTempo };                      }                        // Adding Arrangement                      data.Arrangements.Add(new Arrangement(attr' xmlFile' fixMultiTone' fixLowBass));                        // make a list of tone names used in arrangements                      var toneNames = new List<string>();                      foreach (var arr in data.Arrangements)                      {                          if (!String.IsNullOrEmpty(arr.ToneA)) toneNames.Add(arr.ToneA);                          if (!String.IsNullOrEmpty(arr.ToneB)) toneNames.Add(arr.ToneB);                          if (!String.IsNullOrEmpty(arr.ToneC)) toneNames.Add(arr.ToneC);                          if (!String.IsNullOrEmpty(arr.ToneD)) toneNames.Add(arr.ToneD);                          if (!String.IsNullOrEmpty(arr.ToneBase)) toneNames.Add(arr.ToneBase);                      }                        // Adding Tones                      foreach (var jsonTone in attr.Tones)                      {                          if (jsonTone == null) continue;                          var key = jsonTone.Key;                          if (data.TonesRS2014.All(t => t.Key != key))                          {                              // fix tones names that do not have the correct alphacase for cross matching                              if (attr.Tone_Base.ToLower() == jsonTone.Name.ToLower() && attr.Tone_Base != jsonTone.Name)                                  jsonTone.Name = attr.Tone_Base;                              if (attr.Tone_A != null && attr.Tone_A.ToLower() == jsonTone.Name.ToLower() && attr.Tone_A != jsonTone.Name)                                  jsonTone.Name = attr.Tone_A;                              if (attr.Tone_B != null && attr.Tone_B.ToLower() == jsonTone.Name.ToLower() && attr.Tone_B != jsonTone.Name)                                  jsonTone.Name = attr.Tone_B;                              if (attr.Tone_C != null && attr.Tone_C.ToLower() == jsonTone.Name.ToLower() && attr.Tone_C != jsonTone.Name)                                  jsonTone.Name = attr.Tone_C;                              if (attr.Tone_D != null && attr.Tone_D.ToLower() == jsonTone.Name.ToLower() && attr.Tone_D != jsonTone.Name)                                  jsonTone.Name = attr.Tone_D;                                // this is part of multitone exception handling auto convert to single tone arrangment                              // make data.TonesRS2014 consistent with data.Arragment.Tones (toneNames)                              if (toneNames.Contains(jsonTone.Name))                                  data.TonesRS2014.Add(jsonTone);                          }                      }                  }                  else if (xmlFile.ToLower().Contains("vocals")) // detect both jvocals and vocals                  {                      //var debugMe = "Confirm XML comments were preserved.";                      var voc = new Arrangement                          {                              Name = attr.JapaneseVocal == true ? ArrangementName.JVocals : ArrangementName.Vocals'                              ArrangementType = ArrangementType.Vocal'                              ScrollSpeed = 20'                              SongXml = new SongXML { File = xmlFile }'                              SongFile = new SongFile { File = "" }'                              CustomFont = attr.JapaneseVocal == true'                              XmlComments = Song2014.ReadXmlComments(xmlFile)                          };                        // Get symbols stuff from vocals.xml                      var fontSng = Path.Combine(unpackedDir' xmlName + ".sng");                      var vocSng = Sng2014FileWriter.ReadVocals(xmlFile);                        // TODO: explain/confirm function/usage of this conditional check                      if (vocSng.IsCustomFont()) // always seems to be false' even for jvocals                      {                          voc.CustomFont = true;                          voc.FontSng = fontSng;                          vocSng.WriteChartData(fontSng' new Platform(GamePlatform.Pc' GameVersion.None));                          throw new Exception("<CRITICAL ERROR> vocSng.IsCustomFont: " + xmlFile + Environment.NewLine + "Please report this error to the toolkit developers along with the song that you are currently working on." + Environment.NewLine + "This is important!");                      }                        voc.Sng2014 = Sng2014File.ConvertXML(xmlFile' ArrangementType.Vocal' voc.FontSng);                        // Adding Arrangement                      data.Arrangements.Add(voc);                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,LoadFromFolder,The following statement contains a magic number: if (ddsFiles.Any())              {                  var ddsFilesC = new List<DDSConvertedFile>();                  foreach (var file in ddsFiles)                      switch (Path.GetFileNameWithoutExtension(file).Split('_')[2])                      {                            case "256":                              data.AlbumArtPath = file;                              ddsFilesC.Add(new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = file' destinationFile = file.CopyToTempFile(".dds") });                              break;                          case "128":                              ddsFilesC.Add(new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = file' destinationFile = file.CopyToTempFile(".dds") });                              break;                          case "64":                              ddsFilesC.Add(new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = file' destinationFile = file.CopyToTempFile(".dds") });                              break;                      }                    data.ArtFiles = ddsFilesC;              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,LoadFromFolder,The following statement contains a magic number: if (ddsFiles.Any())              {                  var ddsFilesC = new List<DDSConvertedFile>();                  foreach (var file in ddsFiles)                      switch (Path.GetFileNameWithoutExtension(file).Split('_')[2])                      {                            case "256":                              data.AlbumArtPath = file;                              ddsFilesC.Add(new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = file' destinationFile = file.CopyToTempFile(".dds") });                              break;                          case "128":                              ddsFilesC.Add(new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = file' destinationFile = file.CopyToTempFile(".dds") });                              break;                          case "64":                              ddsFilesC.Add(new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = file' destinationFile = file.CopyToTempFile(".dds") });                              break;                      }                    data.ArtFiles = ddsFilesC;              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,LoadFromFolder,The following statement contains a magic number: if (ddsFiles.Any())              {                  var ddsFilesC = new List<DDSConvertedFile>();                  foreach (var file in ddsFiles)                      switch (Path.GetFileNameWithoutExtension(file).Split('_')[2])                      {                            case "256":                              data.AlbumArtPath = file;                              ddsFilesC.Add(new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = file' destinationFile = file.CopyToTempFile(".dds") });                              break;                          case "128":                              ddsFilesC.Add(new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = file' destinationFile = file.CopyToTempFile(".dds") });                              break;                          case "64":                              ddsFilesC.Add(new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = file' destinationFile = file.CopyToTempFile(".dds") });                              break;                      }                    data.ArtFiles = ddsFilesC;              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,LoadFromFolder,The following statement contains a magic number: if (ddsFiles.Any())              {                  var ddsFilesC = new List<DDSConvertedFile>();                  foreach (var file in ddsFiles)                      switch (Path.GetFileNameWithoutExtension(file).Split('_')[2])                      {                            case "256":                              data.AlbumArtPath = file;                              ddsFilesC.Add(new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = file' destinationFile = file.CopyToTempFile(".dds") });                              break;                          case "128":                              ddsFilesC.Add(new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = file' destinationFile = file.CopyToTempFile(".dds") });                              break;                          case "64":                              ddsFilesC.Add(new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = file' destinationFile = file.CopyToTempFile(".dds") });                              break;                      }                    data.ArtFiles = ddsFilesC;              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,LoadFromFolder,The following statement contains a magic number: if (ddsFiles.Any())              {                  var ddsFilesC = new List<DDSConvertedFile>();                  foreach (var file in ddsFiles)                      switch (Path.GetFileNameWithoutExtension(file).Split('_')[2])                      {                            case "256":                              data.AlbumArtPath = file;                              ddsFilesC.Add(new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = file' destinationFile = file.CopyToTempFile(".dds") });                              break;                          case "128":                              ddsFilesC.Add(new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = file' destinationFile = file.CopyToTempFile(".dds") });                              break;                          case "64":                              ddsFilesC.Add(new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = file' destinationFile = file.CopyToTempFile(".dds") });                              break;                      }                    data.ArtFiles = ddsFilesC;              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,LoadFromFolder,The following statement contains a magic number: if (ddsFiles.Any())              {                  var ddsFilesC = new List<DDSConvertedFile>();                  foreach (var file in ddsFiles)                      switch (Path.GetFileNameWithoutExtension(file).Split('_')[2])                      {                            case "256":                              data.AlbumArtPath = file;                              ddsFilesC.Add(new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = file' destinationFile = file.CopyToTempFile(".dds") });                              break;                          case "128":                              ddsFilesC.Add(new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = file' destinationFile = file.CopyToTempFile(".dds") });                              break;                          case "64":                              ddsFilesC.Add(new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = file' destinationFile = file.CopyToTempFile(".dds") });                              break;                      }                    data.ArtFiles = ddsFilesC;              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,LoadFromFolder,The following statement contains a magic number: if (ddsFiles.Any())              {                  var ddsFilesC = new List<DDSConvertedFile>();                  foreach (var file in ddsFiles)                      switch (Path.GetFileNameWithoutExtension(file).Split('_')[2])                      {                            case "256":                              data.AlbumArtPath = file;                              ddsFilesC.Add(new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = file' destinationFile = file.CopyToTempFile(".dds") });                              break;                          case "128":                              ddsFilesC.Add(new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = file' destinationFile = file.CopyToTempFile(".dds") });                              break;                          case "64":                              ddsFilesC.Add(new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = file' destinationFile = file.CopyToTempFile(".dds") });                              break;                      }                    data.ArtFiles = ddsFilesC;              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,LoadFromFolder,The following statement contains a magic number: if (bnkfiles.Length == 2)              {                  data.Volume = _volume ?? SoundBankGenerator2014.ReadBNKVolume(File.OpenRead(bnkfiles[0])' targetPlatform' GameVersion.RS2014);                  data.PreviewVolume = _volume_preview ?? SoundBankGenerator2014.ReadBNKVolume(File.OpenRead(bnkfiles[1])' targetPlatform' GameVersion.RS2014);              }              else              {                  data.Volume = _volume ?? -7F;                  data.PreviewVolume = _volume_preview ?? _volume;              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,LoadFromFolder,The following statement contains a magic number: if (targetAudioFiles.Count == 2)              {                  var b = new FileInfo(targetAudioFiles[1]);                    if (a.Length > b.Length)                  {                      audioPath = a.FullName;                      audioPreviewPath = b.FullName;                  }                  else                  {                      audioPath = b.FullName;                      audioPreviewPath = a.FullName;                  }              }              else                  audioPath = a.FullName;
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,DoLikeProject,The following statement contains a magic number: if (fileNameParts.Length > 3)                  songVersion = fileNameParts[2];
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,DoLikeProject,The following statement contains a magic number: if (fileNameParts.Length > 3)                  songVersion = fileNameParts[2];
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,DoLikeProject,The following statement contains a magic number: if (oggFiles.Any())              {                  // TODO: read names from bnk and rename.                  // TODO: FIX THIS ... not valid for short jingle/riff CDLC < 30 seconds                  // because the preview 30 seconds is larger than actual song                  // need to base preview decision on duration not size                  var a0 = new FileInfo(oggFiles[0]);                  if (oggFiles.Count() == 2)                  {                      var b0 = new FileInfo(oggFiles[1]);                        if (a0.Length > b0.Length)                      {                          File.Move(a0.FullName' Path.Combine(eofdir' SongName + ".ogg"));                          File.Move(b0.FullName' Path.Combine(eofdir' SongName + "_preview.ogg"));                      }                      else                      {                          File.Move(b0.FullName' Path.Combine(eofdir' SongName + ".ogg"));                          File.Move(a0.FullName' Path.Combine(eofdir' SongName + "_preview.ogg"));                      }                  }                  else                      File.Move(a0.FullName' Path.Combine(eofdir' SongName + ".ogg"));              }
Magic Number,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,DoLikeProject,The following statement contains a magic number: if (wemFiles.Count() == 2)              {                  var b1 = new FileInfo(wemFiles[1]);                    if (a1.Length > b1.Length)                  {                      File.Move(a1.FullName' Path.Combine(kitdir' SongName + ".wem"));                      File.Move(b1.FullName' Path.Combine(kitdir' SongName + "_preview.wem"));                  }                  else                  {                      File.Move(b1.FullName' Path.Combine(kitdir' SongName + ".wem"));                      File.Move(a1.FullName' Path.Combine(kitdir' SongName + "_preview.wem"));                  }              }              else                  File.Move(a1.FullName' Path.Combine(kitdir' SongName + ".wem"));
Magic Number,RocksmithToolkitLib.DLCPackage,IdGenerator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\IdGenerator.cs,GetHexRandomByte,The following statement contains a magic number: return RandomGenerator.NextByte().ToString("X").PadLeft(2' '0');
Magic Number,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,Unpack,The following statement contains a magic number: if (decodeAudio)              {                  GlobalExtension.ShowProgress("Decoding Audio ..."' 50);                  var audioFiles = Directory.EnumerateFiles(unpackedDir' "*.*"' SearchOption.AllDirectories).Where(s => s.EndsWith(".ogg") || s.EndsWith(".wem"));                  foreach (var file in audioFiles)                  {                      var outputAudioFileName = Path.Combine(Path.GetDirectoryName(file)' String.Format("{0}_fixed{1}"' Path.GetFileNameWithoutExtension(file)' ".ogg"));                      OggFile.Revorb(file' outputAudioFileName' Path.GetDirectoryName(Application.ExecutablePath)' Path.GetExtension(file).GetWwiseVersion());                  }                    //GlobalExtension.HideProgress();              }
Magic Number,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,Unpack,The following statement contains a magic number: if (platform.version == GameVersion.RS2014)              {                  var sngFiles = Directory.EnumerateFiles(unpackedDir' "*.sng"' SearchOption.AllDirectories).ToList();                  var step = Math.Round(1.0 / sngFiles.Count * 100' 3);                  double progress = 0;                  GlobalExtension.ShowProgress("Validating XML files ...");                    foreach (var sngFile in sngFiles)                  {                      var xmlEofFile = Path.Combine(Path.GetDirectoryName(sngFile)' String.Format("{0}.xml"' Path.GetFileNameWithoutExtension(sngFile)));                      xmlEofFile = xmlEofFile.Replace(String.Format("bin{0}{1}"' Path.DirectorySeparatorChar' platform.GetPathName()[1].ToLower())' "arr");                      var xmlSngFile = xmlEofFile.Replace(".xml"' ".sng.xml");                      var arrType = ArrangementType.Guitar;                        if (Path.GetFileName(xmlSngFile).ToLower().Contains("vocal"))                          arrType = ArrangementType.Vocal;                        Attributes2014 att = null;                      if (arrType != ArrangementType.Vocal)                      {                          // Some ODLC json files contain factory errors                          // Confirmed error in Chords (too many chords are reported in some difficulty levels)                          var jsonFiles = Directory.EnumerateFiles(unpackedDir' String.Format("{0}.json"' Path.GetFileNameWithoutExtension(sngFile))' SearchOption.AllDirectories).FirstOrDefault();                          if (!String.IsNullOrEmpty(jsonFiles) && jsonFiles.Any())                              att = Manifest2014<Attributes2014>.LoadFromFile(jsonFiles).Entries.ToArray()[0].Value.ToArray()[0].Value;                      }                        var sngContent = Sng2014File.LoadFromFile(sngFile' platform);                      using (var outputStream = new FileStream(xmlSngFile' FileMode.Create' FileAccess.ReadWrite))                      {                          dynamic xmlContent = null;                            if (arrType == ArrangementType.Vocal)                              xmlContent = new Vocals(sngContent);                          else                              xmlContent = new Song2014(sngContent' att);                            xmlContent.Serialize(outputStream);                      }                        // correct old toolkit/EOF xml (tuning) issues ... sync with SNG data                      if (File.Exists(xmlEofFile) && !overwriteSongXml && arrType != ArrangementType.Vocal)                      {                          var eofSong = Song2014.LoadFromFile(xmlEofFile);                          var sngSong = Song2014.LoadFromFile(xmlSngFile);                          if (eofSong.Tuning != sngSong.Tuning)                          {                              eofSong.Tuning = sngSong.Tuning;                              var xmlComments = Song2014.ReadXmlComments(xmlEofFile);                                using (var stream = File.Open(xmlEofFile' FileMode.Create))                                  eofSong.Serialize(stream' true);                                Song2014.WriteXmlComments(xmlEofFile' xmlComments' customComment: "Synced with SNG file");                              Console.WriteLine("Fixed Tuning Descrepancies: " + xmlEofFile);                              GlobalExtension.ShowProgress("Fixed tuning descepancies ...");                          }                      }                      else if (File.Exists(xmlEofFile) && !overwriteSongXml && arrType == ArrangementType.Vocal)                      {                          // preserves vocal xml comments                      }                      else                      {                          if (!isODLC)                              Song2014.WriteXmlComments(xmlSngFile' customComment: "Generated from SNG file");                            File.Copy(xmlSngFile' xmlEofFile' true);                      }                        if (File.Exists(xmlSngFile))                          File.Delete(xmlSngFile);                        progress += step;                      GlobalExtension.UpdateProgress.Value = (int)progress;                  }                    //GlobalExtension.HideProgress();              }
Magic Number,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,Unpack,The following statement contains a magic number: if (platform.version == GameVersion.RS2014)              {                  var sngFiles = Directory.EnumerateFiles(unpackedDir' "*.sng"' SearchOption.AllDirectories).ToList();                  var step = Math.Round(1.0 / sngFiles.Count * 100' 3);                  double progress = 0;                  GlobalExtension.ShowProgress("Validating XML files ...");                    foreach (var sngFile in sngFiles)                  {                      var xmlEofFile = Path.Combine(Path.GetDirectoryName(sngFile)' String.Format("{0}.xml"' Path.GetFileNameWithoutExtension(sngFile)));                      xmlEofFile = xmlEofFile.Replace(String.Format("bin{0}{1}"' Path.DirectorySeparatorChar' platform.GetPathName()[1].ToLower())' "arr");                      var xmlSngFile = xmlEofFile.Replace(".xml"' ".sng.xml");                      var arrType = ArrangementType.Guitar;                        if (Path.GetFileName(xmlSngFile).ToLower().Contains("vocal"))                          arrType = ArrangementType.Vocal;                        Attributes2014 att = null;                      if (arrType != ArrangementType.Vocal)                      {                          // Some ODLC json files contain factory errors                          // Confirmed error in Chords (too many chords are reported in some difficulty levels)                          var jsonFiles = Directory.EnumerateFiles(unpackedDir' String.Format("{0}.json"' Path.GetFileNameWithoutExtension(sngFile))' SearchOption.AllDirectories).FirstOrDefault();                          if (!String.IsNullOrEmpty(jsonFiles) && jsonFiles.Any())                              att = Manifest2014<Attributes2014>.LoadFromFile(jsonFiles).Entries.ToArray()[0].Value.ToArray()[0].Value;                      }                        var sngContent = Sng2014File.LoadFromFile(sngFile' platform);                      using (var outputStream = new FileStream(xmlSngFile' FileMode.Create' FileAccess.ReadWrite))                      {                          dynamic xmlContent = null;                            if (arrType == ArrangementType.Vocal)                              xmlContent = new Vocals(sngContent);                          else                              xmlContent = new Song2014(sngContent' att);                            xmlContent.Serialize(outputStream);                      }                        // correct old toolkit/EOF xml (tuning) issues ... sync with SNG data                      if (File.Exists(xmlEofFile) && !overwriteSongXml && arrType != ArrangementType.Vocal)                      {                          var eofSong = Song2014.LoadFromFile(xmlEofFile);                          var sngSong = Song2014.LoadFromFile(xmlSngFile);                          if (eofSong.Tuning != sngSong.Tuning)                          {                              eofSong.Tuning = sngSong.Tuning;                              var xmlComments = Song2014.ReadXmlComments(xmlEofFile);                                using (var stream = File.Open(xmlEofFile' FileMode.Create))                                  eofSong.Serialize(stream' true);                                Song2014.WriteXmlComments(xmlEofFile' xmlComments' customComment: "Synced with SNG file");                              Console.WriteLine("Fixed Tuning Descrepancies: " + xmlEofFile);                              GlobalExtension.ShowProgress("Fixed tuning descepancies ...");                          }                      }                      else if (File.Exists(xmlEofFile) && !overwriteSongXml && arrType == ArrangementType.Vocal)                      {                          // preserves vocal xml comments                      }                      else                      {                          if (!isODLC)                              Song2014.WriteXmlComments(xmlSngFile' customComment: "Generated from SNG file");                            File.Copy(xmlSngFile' xmlEofFile' true);                      }                        if (File.Exists(xmlSngFile))                          File.Delete(xmlSngFile);                        progress += step;                      GlobalExtension.UpdateProgress.Value = (int)progress;                  }                    //GlobalExtension.HideProgress();              }
Magic Number,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,PackXBox360,The following statement contains a magic number: if (xboxHeaderFiles.Count() == 1)              {                  foreach (var file in xboxHeaderFiles)                  {                      try                      {                          string[] xboxHeader = File.ReadAllLines(file);                          if (xboxHeader != null && xboxHeader.Length > 73)                          {                              if (xboxHeader[0].IndexOf("LIVE") > 0)                              {                                  songData.SignatureType = PackageMagic.LIVE;                                    for (int i = 2; i <= 48; i = i + 3)                                  {                                      long id = Convert.ToInt64(xboxHeader[i].GetHeaderValue()' 16);                                      int bit = Convert.ToInt32(xboxHeader[i + 1].GetHeaderValue());                                      int flag = Convert.ToInt32(xboxHeader[i + 2].GetHeaderValue());                                        if (id != 0)                                          songData.XBox360Licenses.Add(new XBox360License() { ID = id' Bit = bit' Flag = flag });                                  }                              }                                string songInfo = xboxHeader[74];                                int index = songInfo.IndexOf(" by ");                              string songTitle = (index > 0) ? songInfo.Substring(0' index) : songInfo;                              string songArtist = (index > 4) ? songInfo.Substring(index + 4) : songInfo;                                if (!String.IsNullOrEmpty(songInfo))                              {                                  songData.SongInfo = new SongInfo();                                  songData.SongInfo.SongDisplayName = songInfo;                                  songData.SongInfo.Artist = songInfo;                              }                          }                      }                      catch (Exception ex)                      {                          throw new InvalidDataException("XBox360 header file (.txt) not found or is invalid. " + Environment.NewLine +                                                         "The file is in the same level at 'Root' folder along with the files: 'Content image.png' and 'Package image.png' and no other file .txt can be here."' ex);                      }                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,PackXBox360,The following statement contains a magic number: if (xboxHeaderFiles.Count() == 1)              {                  foreach (var file in xboxHeaderFiles)                  {                      try                      {                          string[] xboxHeader = File.ReadAllLines(file);                          if (xboxHeader != null && xboxHeader.Length > 73)                          {                              if (xboxHeader[0].IndexOf("LIVE") > 0)                              {                                  songData.SignatureType = PackageMagic.LIVE;                                    for (int i = 2; i <= 48; i = i + 3)                                  {                                      long id = Convert.ToInt64(xboxHeader[i].GetHeaderValue()' 16);                                      int bit = Convert.ToInt32(xboxHeader[i + 1].GetHeaderValue());                                      int flag = Convert.ToInt32(xboxHeader[i + 2].GetHeaderValue());                                        if (id != 0)                                          songData.XBox360Licenses.Add(new XBox360License() { ID = id' Bit = bit' Flag = flag });                                  }                              }                                string songInfo = xboxHeader[74];                                int index = songInfo.IndexOf(" by ");                              string songTitle = (index > 0) ? songInfo.Substring(0' index) : songInfo;                              string songArtist = (index > 4) ? songInfo.Substring(index + 4) : songInfo;                                if (!String.IsNullOrEmpty(songInfo))                              {                                  songData.SongInfo = new SongInfo();                                  songData.SongInfo.SongDisplayName = songInfo;                                  songData.SongInfo.Artist = songInfo;                              }                          }                      }                      catch (Exception ex)                      {                          throw new InvalidDataException("XBox360 header file (.txt) not found or is invalid. " + Environment.NewLine +                                                         "The file is in the same level at 'Root' folder along with the files: 'Content image.png' and 'Package image.png' and no other file .txt can be here."' ex);                      }                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,PackXBox360,The following statement contains a magic number: if (xboxHeaderFiles.Count() == 1)              {                  foreach (var file in xboxHeaderFiles)                  {                      try                      {                          string[] xboxHeader = File.ReadAllLines(file);                          if (xboxHeader != null && xboxHeader.Length > 73)                          {                              if (xboxHeader[0].IndexOf("LIVE") > 0)                              {                                  songData.SignatureType = PackageMagic.LIVE;                                    for (int i = 2; i <= 48; i = i + 3)                                  {                                      long id = Convert.ToInt64(xboxHeader[i].GetHeaderValue()' 16);                                      int bit = Convert.ToInt32(xboxHeader[i + 1].GetHeaderValue());                                      int flag = Convert.ToInt32(xboxHeader[i + 2].GetHeaderValue());                                        if (id != 0)                                          songData.XBox360Licenses.Add(new XBox360License() { ID = id' Bit = bit' Flag = flag });                                  }                              }                                string songInfo = xboxHeader[74];                                int index = songInfo.IndexOf(" by ");                              string songTitle = (index > 0) ? songInfo.Substring(0' index) : songInfo;                              string songArtist = (index > 4) ? songInfo.Substring(index + 4) : songInfo;                                if (!String.IsNullOrEmpty(songInfo))                              {                                  songData.SongInfo = new SongInfo();                                  songData.SongInfo.SongDisplayName = songInfo;                                  songData.SongInfo.Artist = songInfo;                              }                          }                      }                      catch (Exception ex)                      {                          throw new InvalidDataException("XBox360 header file (.txt) not found or is invalid. " + Environment.NewLine +                                                         "The file is in the same level at 'Root' folder along with the files: 'Content image.png' and 'Package image.png' and no other file .txt can be here."' ex);                      }                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,PackXBox360,The following statement contains a magic number: if (xboxHeaderFiles.Count() == 1)              {                  foreach (var file in xboxHeaderFiles)                  {                      try                      {                          string[] xboxHeader = File.ReadAllLines(file);                          if (xboxHeader != null && xboxHeader.Length > 73)                          {                              if (xboxHeader[0].IndexOf("LIVE") > 0)                              {                                  songData.SignatureType = PackageMagic.LIVE;                                    for (int i = 2; i <= 48; i = i + 3)                                  {                                      long id = Convert.ToInt64(xboxHeader[i].GetHeaderValue()' 16);                                      int bit = Convert.ToInt32(xboxHeader[i + 1].GetHeaderValue());                                      int flag = Convert.ToInt32(xboxHeader[i + 2].GetHeaderValue());                                        if (id != 0)                                          songData.XBox360Licenses.Add(new XBox360License() { ID = id' Bit = bit' Flag = flag });                                  }                              }                                string songInfo = xboxHeader[74];                                int index = songInfo.IndexOf(" by ");                              string songTitle = (index > 0) ? songInfo.Substring(0' index) : songInfo;                              string songArtist = (index > 4) ? songInfo.Substring(index + 4) : songInfo;                                if (!String.IsNullOrEmpty(songInfo))                              {                                  songData.SongInfo = new SongInfo();                                  songData.SongInfo.SongDisplayName = songInfo;                                  songData.SongInfo.Artist = songInfo;                              }                          }                      }                      catch (Exception ex)                      {                          throw new InvalidDataException("XBox360 header file (.txt) not found or is invalid. " + Environment.NewLine +                                                         "The file is in the same level at 'Root' folder along with the files: 'Content image.png' and 'Package image.png' and no other file .txt can be here."' ex);                      }                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,PackXBox360,The following statement contains a magic number: if (xboxHeaderFiles.Count() == 1)              {                  foreach (var file in xboxHeaderFiles)                  {                      try                      {                          string[] xboxHeader = File.ReadAllLines(file);                          if (xboxHeader != null && xboxHeader.Length > 73)                          {                              if (xboxHeader[0].IndexOf("LIVE") > 0)                              {                                  songData.SignatureType = PackageMagic.LIVE;                                    for (int i = 2; i <= 48; i = i + 3)                                  {                                      long id = Convert.ToInt64(xboxHeader[i].GetHeaderValue()' 16);                                      int bit = Convert.ToInt32(xboxHeader[i + 1].GetHeaderValue());                                      int flag = Convert.ToInt32(xboxHeader[i + 2].GetHeaderValue());                                        if (id != 0)                                          songData.XBox360Licenses.Add(new XBox360License() { ID = id' Bit = bit' Flag = flag });                                  }                              }                                string songInfo = xboxHeader[74];                                int index = songInfo.IndexOf(" by ");                              string songTitle = (index > 0) ? songInfo.Substring(0' index) : songInfo;                              string songArtist = (index > 4) ? songInfo.Substring(index + 4) : songInfo;                                if (!String.IsNullOrEmpty(songInfo))                              {                                  songData.SongInfo = new SongInfo();                                  songData.SongInfo.SongDisplayName = songInfo;                                  songData.SongInfo.Artist = songInfo;                              }                          }                      }                      catch (Exception ex)                      {                          throw new InvalidDataException("XBox360 header file (.txt) not found or is invalid. " + Environment.NewLine +                                                         "The file is in the same level at 'Root' folder along with the files: 'Content image.png' and 'Package image.png' and no other file .txt can be here."' ex);                      }                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,PackXBox360,The following statement contains a magic number: if (xboxHeaderFiles.Count() == 1)              {                  foreach (var file in xboxHeaderFiles)                  {                      try                      {                          string[] xboxHeader = File.ReadAllLines(file);                          if (xboxHeader != null && xboxHeader.Length > 73)                          {                              if (xboxHeader[0].IndexOf("LIVE") > 0)                              {                                  songData.SignatureType = PackageMagic.LIVE;                                    for (int i = 2; i <= 48; i = i + 3)                                  {                                      long id = Convert.ToInt64(xboxHeader[i].GetHeaderValue()' 16);                                      int bit = Convert.ToInt32(xboxHeader[i + 1].GetHeaderValue());                                      int flag = Convert.ToInt32(xboxHeader[i + 2].GetHeaderValue());                                        if (id != 0)                                          songData.XBox360Licenses.Add(new XBox360License() { ID = id' Bit = bit' Flag = flag });                                  }                              }                                string songInfo = xboxHeader[74];                                int index = songInfo.IndexOf(" by ");                              string songTitle = (index > 0) ? songInfo.Substring(0' index) : songInfo;                              string songArtist = (index > 4) ? songInfo.Substring(index + 4) : songInfo;                                if (!String.IsNullOrEmpty(songInfo))                              {                                  songData.SongInfo = new SongInfo();                                  songData.SongInfo.SongDisplayName = songInfo;                                  songData.SongInfo.Artist = songInfo;                              }                          }                      }                      catch (Exception ex)                      {                          throw new InvalidDataException("XBox360 header file (.txt) not found or is invalid. " + Environment.NewLine +                                                         "The file is in the same level at 'Root' folder along with the files: 'Content image.png' and 'Package image.png' and no other file .txt can be here."' ex);                      }                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,PackXBox360,The following statement contains a magic number: if (xboxHeaderFiles.Count() == 1)              {                  foreach (var file in xboxHeaderFiles)                  {                      try                      {                          string[] xboxHeader = File.ReadAllLines(file);                          if (xboxHeader != null && xboxHeader.Length > 73)                          {                              if (xboxHeader[0].IndexOf("LIVE") > 0)                              {                                  songData.SignatureType = PackageMagic.LIVE;                                    for (int i = 2; i <= 48; i = i + 3)                                  {                                      long id = Convert.ToInt64(xboxHeader[i].GetHeaderValue()' 16);                                      int bit = Convert.ToInt32(xboxHeader[i + 1].GetHeaderValue());                                      int flag = Convert.ToInt32(xboxHeader[i + 2].GetHeaderValue());                                        if (id != 0)                                          songData.XBox360Licenses.Add(new XBox360License() { ID = id' Bit = bit' Flag = flag });                                  }                              }                                string songInfo = xboxHeader[74];                                int index = songInfo.IndexOf(" by ");                              string songTitle = (index > 0) ? songInfo.Substring(0' index) : songInfo;                              string songArtist = (index > 4) ? songInfo.Substring(index + 4) : songInfo;                                if (!String.IsNullOrEmpty(songInfo))                              {                                  songData.SongInfo = new SongInfo();                                  songData.SongInfo.SongDisplayName = songInfo;                                  songData.SongInfo.Artist = songInfo;                              }                          }                      }                      catch (Exception ex)                      {                          throw new InvalidDataException("XBox360 header file (.txt) not found or is invalid. " + Environment.NewLine +                                                         "The file is in the same level at 'Root' folder along with the files: 'Content image.png' and 'Package image.png' and no other file .txt can be here."' ex);                      }                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,PackXBox360,The following statement contains a magic number: if (xboxHeaderFiles.Count() == 1)              {                  foreach (var file in xboxHeaderFiles)                  {                      try                      {                          string[] xboxHeader = File.ReadAllLines(file);                          if (xboxHeader != null && xboxHeader.Length > 73)                          {                              if (xboxHeader[0].IndexOf("LIVE") > 0)                              {                                  songData.SignatureType = PackageMagic.LIVE;                                    for (int i = 2; i <= 48; i = i + 3)                                  {                                      long id = Convert.ToInt64(xboxHeader[i].GetHeaderValue()' 16);                                      int bit = Convert.ToInt32(xboxHeader[i + 1].GetHeaderValue());                                      int flag = Convert.ToInt32(xboxHeader[i + 2].GetHeaderValue());                                        if (id != 0)                                          songData.XBox360Licenses.Add(new XBox360License() { ID = id' Bit = bit' Flag = flag });                                  }                              }                                string songInfo = xboxHeader[74];                                int index = songInfo.IndexOf(" by ");                              string songTitle = (index > 0) ? songInfo.Substring(0' index) : songInfo;                              string songArtist = (index > 4) ? songInfo.Substring(index + 4) : songInfo;                                if (!String.IsNullOrEmpty(songInfo))                              {                                  songData.SongInfo = new SongInfo();                                  songData.SongInfo.SongDisplayName = songInfo;                                  songData.SongInfo.Artist = songInfo;                              }                          }                      }                      catch (Exception ex)                      {                          throw new InvalidDataException("XBox360 header file (.txt) not found or is invalid. " + Environment.NewLine +                                                         "The file is in the same level at 'Root' folder along with the files: 'Content image.png' and 'Package image.png' and no other file .txt can be here."' ex);                      }                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,PackXBox360,The following statement contains a magic number: if (xboxHeaderFiles.Count() == 1)              {                  foreach (var file in xboxHeaderFiles)                  {                      try                      {                          string[] xboxHeader = File.ReadAllLines(file);                          if (xboxHeader != null && xboxHeader.Length > 73)                          {                              if (xboxHeader[0].IndexOf("LIVE") > 0)                              {                                  songData.SignatureType = PackageMagic.LIVE;                                    for (int i = 2; i <= 48; i = i + 3)                                  {                                      long id = Convert.ToInt64(xboxHeader[i].GetHeaderValue()' 16);                                      int bit = Convert.ToInt32(xboxHeader[i + 1].GetHeaderValue());                                      int flag = Convert.ToInt32(xboxHeader[i + 2].GetHeaderValue());                                        if (id != 0)                                          songData.XBox360Licenses.Add(new XBox360License() { ID = id' Bit = bit' Flag = flag });                                  }                              }                                string songInfo = xboxHeader[74];                                int index = songInfo.IndexOf(" by ");                              string songTitle = (index > 0) ? songInfo.Substring(0' index) : songInfo;                              string songArtist = (index > 4) ? songInfo.Substring(index + 4) : songInfo;                                if (!String.IsNullOrEmpty(songInfo))                              {                                  songData.SongInfo = new SongInfo();                                  songData.SongInfo.SongDisplayName = songInfo;                                  songData.SongInfo.Artist = songInfo;                              }                          }                      }                      catch (Exception ex)                      {                          throw new InvalidDataException("XBox360 header file (.txt) not found or is invalid. " + Environment.NewLine +                                                         "The file is in the same level at 'Root' folder along with the files: 'Content image.png' and 'Package image.png' and no other file .txt can be here."' ex);                      }                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,GetHeaderValue,The following statement contains a magic number: return value.Substring(value.IndexOf(":") + 2);
Magic Number,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,GetPlatform,The following statement contains a magic number: if (File.Exists(fullPath))              {                  // Get PLATFORM by Extension + Get PLATFORM by pkg EndName                  switch (Path.GetExtension(fullPath))                  {                      case ".dat":                          return new Platform(GamePlatform.Pc' GameVersion.RS2012);                      case "":                          // old method was failing for RS2014 xbox so revised to read file header                          // return new Platform(GamePlatform.XBox360' GameVersion.RS2012);                          const int HEADER_SIZE = 4;                          byte[] bytesFile = new byte[HEADER_SIZE];                          using (var fs = File.Open(fullPath' FileMode.Open))                          {                              fs.Read(bytesFile' 0' HEADER_SIZE);                              fs.Close();                          }                            // along with a little bit of belt and suspenders works nicely                          if (Encoding.UTF8.GetString(bytesFile) == "CON ")                              if (TryGetPlatformByEndName(fullPath).Equals(new Platform(GamePlatform.XBox360' GameVersion.RS2014)))                                  return new Platform(GamePlatform.XBox360' GameVersion.RS2014);                            return new Platform(GamePlatform.XBox360' GameVersion.RS2012);                      case ".edat":                          // must get game version from UserControl GUI                          return new Platform(GamePlatform.PS3' GameVersion.None);                      case ".psarc":                          var debugMe = TryGetPlatformByEndName(fullPath);                          return TryGetPlatformByEndName(fullPath);                      default:                          return new Platform(GamePlatform.None' GameVersion.None);                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,ExtractPSARC,The following statement contains a magic number: var step = Math.Round(1.0 / (psarc.TOC.Count + 2) * 100' 3);
Magic Number,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,ExtractPSARC,The following statement contains a magic number: var step = Math.Round(1.0 / (psarc.TOC.Count + 2) * 100' 3);
Magic Number,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,ExtractPSARC,The following statement contains a magic number: var step = Math.Round(1.0 / (psarc.TOC.Count + 2) * 100' 3);
Magic Number,RocksmithToolkitLib.DLCPackage,RandomGenerator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\RandomGenerator.cs,NextByte,The following statement contains a magic number: return (byte)Instance.Next(256);
Magic Number,RocksmithToolkitLib.DLCPackage,RijndaelEncryptor,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\RijndaelEncryptor.cs,Unzip,The following statement contains a magic number: var buffer = new byte[65536];
Magic Number,RocksmithToolkitLib.DLCPackage,RijndaelEncryptor,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\RijndaelEncryptor.cs,Zip,The following statement contains a magic number: var buffer = new byte[65536];
Magic Number,RocksmithToolkitLib.DLCPackage,RijndaelEncryptor,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\RijndaelEncryptor.cs,Zip,The following statement contains a magic number: var zOutputStream = new ZOutputStream(outStream' 9);
Magic Number,RocksmithToolkitLib.DLCPackage,RijndaelEncryptor,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\RijndaelEncryptor.cs,DecryptProfile,The following statement contains a magic number: using (var decrypted = new MemoryStream())              using (var br = new EndianBinaryReader(source' str))              using (var brDec = new EndianBinaryReader(dec' decrypted))              {                  //EVAS + header                  br.ReadBytes(16);                  uint zLen = br.ReadUInt32();                  DecryptFile(br.BaseStream' decrypted' PCSaveKey);                    //unZip                  ushort xU = brDec.ReadUInt16();                  brDec.BaseStream.Position -= sizeof(ushort);                  if (xU == 30938)//LE 55928 //BE 30938                  {                      Unzip(brDec.BaseStream' outStream);                  }//endless loop if not              }
Magic Number,RocksmithToolkitLib.DLCPackage,RijndaelEncryptor,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\RijndaelEncryptor.cs,DecryptProfile,The following statement contains a magic number: using (var decrypted = new MemoryStream())              using (var br = new EndianBinaryReader(source' str))              using (var brDec = new EndianBinaryReader(dec' decrypted))              {                  //EVAS + header                  br.ReadBytes(16);                  uint zLen = br.ReadUInt32();                  DecryptFile(br.BaseStream' decrypted' PCSaveKey);                    //unZip                  ushort xU = brDec.ReadUInt16();                  brDec.BaseStream.Position -= sizeof(ushort);                  if (xU == 30938)//LE 55928 //BE 30938                  {                      Unzip(brDec.BaseStream' outStream);                  }//endless loop if not              }
Magic Number,RocksmithToolkitLib.DLCPackage,RijndaelEncryptor,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\RijndaelEncryptor.cs,EncryptSngData,The following statement contains a magic number: byte[] iv = new byte[16];
Magic Number,RocksmithToolkitLib.DLCPackage,RijndaelEncryptor,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\RijndaelEncryptor.cs,EncryptSngData,The following statement contains a magic number: using (var rij = new RijndaelManaged())              {                  InitRijndael(rij' key' CipherMode.CFB);                  output.Write(iv' 0' iv.Length);                    var buffer = new byte[16];                  long len = input.Length - input.Position;                  for (long i = 0; i < len; i += buffer.Length)                  {                      using (ICryptoTransform transform = rij.CreateEncryptor())                      {                          var cs = new CryptoStream(output' transform' CryptoStreamMode.Write);                          int bytesread = input.Read(buffer' 0' buffer.Length);                          cs.Write(buffer' 0' bytesread);                            int pad = buffer.Length - bytesread;                          if (pad > 0)                              cs.Write(new byte[pad]' 0' pad);                            cs.FlushFinalBlock();                      }                        int j;                      bool carry;                      for (j = (rij.IV.Length) - 1' carry = true; j >= 0 && carry; j--)                          carry = ((iv[j] = (byte)(rij.IV[j] + 1)) == 0);                      rij.IV = iv;                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,RijndaelEncryptor,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\RijndaelEncryptor.cs,DecryptSngData,The following statement contains a magic number: reader.ReadBytes(4);
Magic Number,RocksmithToolkitLib.DLCPackage,RijndaelEncryptor,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\RijndaelEncryptor.cs,DecryptSngData,The following statement contains a magic number: byte[] iv = reader.ReadBytes(16);
Magic Number,RocksmithToolkitLib.DLCPackage,RijndaelEncryptor,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\RijndaelEncryptor.cs,DecryptSngData,The following statement contains a magic number: using (var rij = new RijndaelManaged())              {                  InitRijndael(rij' key' CipherMode.CFB);                  rij.IV = iv;                    var buffer = new byte[16];                  long len = input.Length - input.Position;                  for (long i = 0; i < len; i += buffer.Length)                  {                      using (ICryptoTransform transform = rij.CreateDecryptor())                      {                          var cs = new CryptoStream(output' transform' CryptoStreamMode.Write);                          int bytesread = input.Read(buffer' 0' buffer.Length);                          cs.Write(buffer' 0' bytesread);                            int pad = buffer.Length - bytesread;                          if (pad > 0)                              cs.Write(new byte[pad]' 0' pad);                            cs.Flush();                      }                        int j;                      bool carry;                      for (j = (rij.IV.Length) - 1' carry = true; j >= 0 && carry; j--)                          carry = ((iv[j] = (byte)(rij.IV[j] + 1)) == 0);                      rij.IV = iv;                  }                  output.SetLength(input.Length - (iv.Length + 8));              }
Magic Number,RocksmithToolkitLib.DLCPackage,RijndaelEncryptor,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\RijndaelEncryptor.cs,DecryptSngData,The following statement contains a magic number: using (var rij = new RijndaelManaged())              {                  InitRijndael(rij' key' CipherMode.CFB);                  rij.IV = iv;                    var buffer = new byte[16];                  long len = input.Length - input.Position;                  for (long i = 0; i < len; i += buffer.Length)                  {                      using (ICryptoTransform transform = rij.CreateDecryptor())                      {                          var cs = new CryptoStream(output' transform' CryptoStreamMode.Write);                          int bytesread = input.Read(buffer' 0' buffer.Length);                          cs.Write(buffer' 0' bytesread);                            int pad = buffer.Length - bytesread;                          if (pad > 0)                              cs.Write(new byte[pad]' 0' pad);                            cs.Flush();                      }                        int j;                      bool carry;                      for (j = (rij.IV.Length) - 1' carry = true; j >= 0 && carry; j--)                          carry = ((iv[j] = (byte)(rij.IV[j] + 1)) == 0);                      rij.IV = iv;                  }                  output.SetLength(input.Length - (iv.Length + 8));              }
Magic Number,RocksmithToolkitLib.DLCPackage,RijndaelEncryptor,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\RijndaelEncryptor.cs,InitRijndael,The following statement contains a magic number: rij.BlockSize = 128;
Magic Number,RocksmithToolkitLib.DLCPackage,RijndaelEncryptor,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\RijndaelEncryptor.cs,InitRijndael,The following statement contains a magic number: rij.IV = new byte[16];
Magic Number,RocksmithToolkitLib.DLCPackage,RijndaelEncryptor,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\RijndaelEncryptor.cs,Crypto,The following statement contains a magic number: var buffer = new byte[512];
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,HashString,The following statement contains a magic number: uint hash = 2166136261;
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,HashString,The following statement contains a magic number: for (var i = 0; i < str.Length; i++) {                  hash *= 16777619;                  hash = hash ^ bytes[i];              }
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,GenerateSoundBank,The following statement contains a magic number: using (var bankStream = new MemoryStream(soundbank))              using (var bankReader = new EndianBinaryReader(bitConverter' bankStream))              {                  var audioReader = new EndianBinaryReader(bitConverter' audioStream);                  var bankWriter = new EndianBinaryWriter(bitConverter' outStream);                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[0]));                  bankReader.ReadInt32();                  bankWriter.Write(id);                  bankWriter.Write(bankReader.ReadInt32());                  int dataSize = bankReader.ReadInt32();                  bankWriter.Write(dataSize);                  bankWriter.Write(bankReader.ReadInt32());                  bankWriter.Write(bankReader.ReadInt32());                  bankWriter.Write(audioReader.ReadBytes(dataSize));                  bankReader.BaseStream.Seek(dataSize' SeekOrigin.Current);                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[1]));                  bankWriter.Write(id);                  bankWriter.Write(id);                  bankReader.BaseStream.Seek(8' SeekOrigin.Current);                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[2]));                  bankWriter.Write((float)volume);                  bankReader.ReadInt32();                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[3]));                  bankReader.ReadInt32();                  bankWriter.Write(HashString(eventName));                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[4]));                  bankReader.ReadInt32();                  bankWriter.Write(HashString(previewName));                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[5]));                  bankWriter.Write(12 + bankName.Length + 1);                  bankReader.ReadInt32();                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[6]));                  bankWriter.Write((byte)bankName.Length);                  bankWriter.Write(Encoding.ASCII.GetBytes(bankName));                  bankWriter.Flush();              }
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,GenerateSoundBank,The following statement contains a magic number: using (var bankStream = new MemoryStream(soundbank))              using (var bankReader = new EndianBinaryReader(bitConverter' bankStream))              {                  var audioReader = new EndianBinaryReader(bitConverter' audioStream);                  var bankWriter = new EndianBinaryWriter(bitConverter' outStream);                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[0]));                  bankReader.ReadInt32();                  bankWriter.Write(id);                  bankWriter.Write(bankReader.ReadInt32());                  int dataSize = bankReader.ReadInt32();                  bankWriter.Write(dataSize);                  bankWriter.Write(bankReader.ReadInt32());                  bankWriter.Write(bankReader.ReadInt32());                  bankWriter.Write(audioReader.ReadBytes(dataSize));                  bankReader.BaseStream.Seek(dataSize' SeekOrigin.Current);                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[1]));                  bankWriter.Write(id);                  bankWriter.Write(id);                  bankReader.BaseStream.Seek(8' SeekOrigin.Current);                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[2]));                  bankWriter.Write((float)volume);                  bankReader.ReadInt32();                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[3]));                  bankReader.ReadInt32();                  bankWriter.Write(HashString(eventName));                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[4]));                  bankReader.ReadInt32();                  bankWriter.Write(HashString(previewName));                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[5]));                  bankWriter.Write(12 + bankName.Length + 1);                  bankReader.ReadInt32();                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[6]));                  bankWriter.Write((byte)bankName.Length);                  bankWriter.Write(Encoding.ASCII.GetBytes(bankName));                  bankWriter.Flush();              }
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,GenerateSoundBank,The following statement contains a magic number: using (var bankStream = new MemoryStream(soundbank))              using (var bankReader = new EndianBinaryReader(bitConverter' bankStream))              {                  var audioReader = new EndianBinaryReader(bitConverter' audioStream);                  var bankWriter = new EndianBinaryWriter(bitConverter' outStream);                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[0]));                  bankReader.ReadInt32();                  bankWriter.Write(id);                  bankWriter.Write(bankReader.ReadInt32());                  int dataSize = bankReader.ReadInt32();                  bankWriter.Write(dataSize);                  bankWriter.Write(bankReader.ReadInt32());                  bankWriter.Write(bankReader.ReadInt32());                  bankWriter.Write(audioReader.ReadBytes(dataSize));                  bankReader.BaseStream.Seek(dataSize' SeekOrigin.Current);                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[1]));                  bankWriter.Write(id);                  bankWriter.Write(id);                  bankReader.BaseStream.Seek(8' SeekOrigin.Current);                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[2]));                  bankWriter.Write((float)volume);                  bankReader.ReadInt32();                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[3]));                  bankReader.ReadInt32();                  bankWriter.Write(HashString(eventName));                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[4]));                  bankReader.ReadInt32();                  bankWriter.Write(HashString(previewName));                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[5]));                  bankWriter.Write(12 + bankName.Length + 1);                  bankReader.ReadInt32();                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[6]));                  bankWriter.Write((byte)bankName.Length);                  bankWriter.Write(Encoding.ASCII.GetBytes(bankName));                  bankWriter.Flush();              }
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,GenerateSoundBank,The following statement contains a magic number: using (var bankStream = new MemoryStream(soundbank))              using (var bankReader = new EndianBinaryReader(bitConverter' bankStream))              {                  var audioReader = new EndianBinaryReader(bitConverter' audioStream);                  var bankWriter = new EndianBinaryWriter(bitConverter' outStream);                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[0]));                  bankReader.ReadInt32();                  bankWriter.Write(id);                  bankWriter.Write(bankReader.ReadInt32());                  int dataSize = bankReader.ReadInt32();                  bankWriter.Write(dataSize);                  bankWriter.Write(bankReader.ReadInt32());                  bankWriter.Write(bankReader.ReadInt32());                  bankWriter.Write(audioReader.ReadBytes(dataSize));                  bankReader.BaseStream.Seek(dataSize' SeekOrigin.Current);                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[1]));                  bankWriter.Write(id);                  bankWriter.Write(id);                  bankReader.BaseStream.Seek(8' SeekOrigin.Current);                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[2]));                  bankWriter.Write((float)volume);                  bankReader.ReadInt32();                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[3]));                  bankReader.ReadInt32();                  bankWriter.Write(HashString(eventName));                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[4]));                  bankReader.ReadInt32();                  bankWriter.Write(HashString(previewName));                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[5]));                  bankWriter.Write(12 + bankName.Length + 1);                  bankReader.ReadInt32();                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[6]));                  bankWriter.Write((byte)bankName.Length);                  bankWriter.Write(Encoding.ASCII.GetBytes(bankName));                  bankWriter.Flush();              }
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,GenerateSoundBank,The following statement contains a magic number: using (var bankStream = new MemoryStream(soundbank))              using (var bankReader = new EndianBinaryReader(bitConverter' bankStream))              {                  var audioReader = new EndianBinaryReader(bitConverter' audioStream);                  var bankWriter = new EndianBinaryWriter(bitConverter' outStream);                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[0]));                  bankReader.ReadInt32();                  bankWriter.Write(id);                  bankWriter.Write(bankReader.ReadInt32());                  int dataSize = bankReader.ReadInt32();                  bankWriter.Write(dataSize);                  bankWriter.Write(bankReader.ReadInt32());                  bankWriter.Write(bankReader.ReadInt32());                  bankWriter.Write(audioReader.ReadBytes(dataSize));                  bankReader.BaseStream.Seek(dataSize' SeekOrigin.Current);                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[1]));                  bankWriter.Write(id);                  bankWriter.Write(id);                  bankReader.BaseStream.Seek(8' SeekOrigin.Current);                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[2]));                  bankWriter.Write((float)volume);                  bankReader.ReadInt32();                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[3]));                  bankReader.ReadInt32();                  bankWriter.Write(HashString(eventName));                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[4]));                  bankReader.ReadInt32();                  bankWriter.Write(HashString(previewName));                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[5]));                  bankWriter.Write(12 + bankName.Length + 1);                  bankReader.ReadInt32();                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[6]));                  bankWriter.Write((byte)bankName.Length);                  bankWriter.Write(Encoding.ASCII.GetBytes(bankName));                  bankWriter.Flush();              }
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,GenerateSoundBank,The following statement contains a magic number: using (var bankStream = new MemoryStream(soundbank))              using (var bankReader = new EndianBinaryReader(bitConverter' bankStream))              {                  var audioReader = new EndianBinaryReader(bitConverter' audioStream);                  var bankWriter = new EndianBinaryWriter(bitConverter' outStream);                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[0]));                  bankReader.ReadInt32();                  bankWriter.Write(id);                  bankWriter.Write(bankReader.ReadInt32());                  int dataSize = bankReader.ReadInt32();                  bankWriter.Write(dataSize);                  bankWriter.Write(bankReader.ReadInt32());                  bankWriter.Write(bankReader.ReadInt32());                  bankWriter.Write(audioReader.ReadBytes(dataSize));                  bankReader.BaseStream.Seek(dataSize' SeekOrigin.Current);                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[1]));                  bankWriter.Write(id);                  bankWriter.Write(id);                  bankReader.BaseStream.Seek(8' SeekOrigin.Current);                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[2]));                  bankWriter.Write((float)volume);                  bankReader.ReadInt32();                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[3]));                  bankReader.ReadInt32();                  bankWriter.Write(HashString(eventName));                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[4]));                  bankReader.ReadInt32();                  bankWriter.Write(HashString(previewName));                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[5]));                  bankWriter.Write(12 + bankName.Length + 1);                  bankReader.ReadInt32();                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[6]));                  bankWriter.Write((byte)bankName.Length);                  bankWriter.Write(Encoding.ASCII.GetBytes(bankName));                  bankWriter.Flush();              }
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,GenerateSoundBank,The following statement contains a magic number: using (var bankStream = new MemoryStream(soundbank))              using (var bankReader = new EndianBinaryReader(bitConverter' bankStream))              {                  var audioReader = new EndianBinaryReader(bitConverter' audioStream);                  var bankWriter = new EndianBinaryWriter(bitConverter' outStream);                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[0]));                  bankReader.ReadInt32();                  bankWriter.Write(id);                  bankWriter.Write(bankReader.ReadInt32());                  int dataSize = bankReader.ReadInt32();                  bankWriter.Write(dataSize);                  bankWriter.Write(bankReader.ReadInt32());                  bankWriter.Write(bankReader.ReadInt32());                  bankWriter.Write(audioReader.ReadBytes(dataSize));                  bankReader.BaseStream.Seek(dataSize' SeekOrigin.Current);                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[1]));                  bankWriter.Write(id);                  bankWriter.Write(id);                  bankReader.BaseStream.Seek(8' SeekOrigin.Current);                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[2]));                  bankWriter.Write((float)volume);                  bankReader.ReadInt32();                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[3]));                  bankReader.ReadInt32();                  bankWriter.Write(HashString(eventName));                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[4]));                  bankReader.ReadInt32();                  bankWriter.Write(HashString(previewName));                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[5]));                  bankWriter.Write(12 + bankName.Length + 1);                  bankReader.ReadInt32();                  bankWriter.Write(bankReader.ReadBytes(platform.GetOffsets()[6]));                  bankWriter.Write((byte)bankName.Length);                  bankWriter.Write(Encoding.ASCII.GetBytes(bankName));                  bankWriter.Flush();              }
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,HashString,The following statement contains a magic number: uint hash = 2166136261;
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,HashString,The following statement contains a magic number: for (var i = 0; i < str.Length; i++)              {                  hash *= 16777619;                  hash = hash ^ bytes[i];              }
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,ReadBNKVolume,The following statement contains a magic number: using (var v = new EndianBinaryReader(platform.GetBitConverter' inputStream))              {                  if (v.ReadInt32() != 1145588546) //BKHD                      throw new Exception("Unknown BNK file format!");                  v.ReadBytes(v.ReadInt32());                    //offset till HRIC (chunk len+8)                  while (v.ReadInt32() != 1129466184 && (inputStream.Position < inputStream.Length-1))                  {                      v.ReadBytes(v.ReadInt32());                  }                  //ok we're in Hric now' let's validate again!                  v.BaseStream.Position -= 4;                  if (v.ReadInt32() != 1129466184)                      throw new Exception("Something goes wrong with bnk parser.");                    //get HRIC size                  var len = v.ReadInt32();                  var obj = v.ReadInt32();                  for (var o = 0; o < obj; o++)                  {                      var type = v.ReadByte();                      var length = v.ReadInt32();                      // find correct object type - SFXV                      if (type == 2)                      {                          //skip 46 bytes to find volume                          v.ReadBytes(46);                          return v.ReadSingle();                      }                      v.ReadBytes(length);                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,ReadBNKVolume,The following statement contains a magic number: using (var v = new EndianBinaryReader(platform.GetBitConverter' inputStream))              {                  if (v.ReadInt32() != 1145588546) //BKHD                      throw new Exception("Unknown BNK file format!");                  v.ReadBytes(v.ReadInt32());                    //offset till HRIC (chunk len+8)                  while (v.ReadInt32() != 1129466184 && (inputStream.Position < inputStream.Length-1))                  {                      v.ReadBytes(v.ReadInt32());                  }                  //ok we're in Hric now' let's validate again!                  v.BaseStream.Position -= 4;                  if (v.ReadInt32() != 1129466184)                      throw new Exception("Something goes wrong with bnk parser.");                    //get HRIC size                  var len = v.ReadInt32();                  var obj = v.ReadInt32();                  for (var o = 0; o < obj; o++)                  {                      var type = v.ReadByte();                      var length = v.ReadInt32();                      // find correct object type - SFXV                      if (type == 2)                      {                          //skip 46 bytes to find volume                          v.ReadBytes(46);                          return v.ReadSingle();                      }                      v.ReadBytes(length);                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,ReadBNKVolume,The following statement contains a magic number: using (var v = new EndianBinaryReader(platform.GetBitConverter' inputStream))              {                  if (v.ReadInt32() != 1145588546) //BKHD                      throw new Exception("Unknown BNK file format!");                  v.ReadBytes(v.ReadInt32());                    //offset till HRIC (chunk len+8)                  while (v.ReadInt32() != 1129466184 && (inputStream.Position < inputStream.Length-1))                  {                      v.ReadBytes(v.ReadInt32());                  }                  //ok we're in Hric now' let's validate again!                  v.BaseStream.Position -= 4;                  if (v.ReadInt32() != 1129466184)                      throw new Exception("Something goes wrong with bnk parser.");                    //get HRIC size                  var len = v.ReadInt32();                  var obj = v.ReadInt32();                  for (var o = 0; o < obj; o++)                  {                      var type = v.ReadByte();                      var length = v.ReadInt32();                      // find correct object type - SFXV                      if (type == 2)                      {                          //skip 46 bytes to find volume                          v.ReadBytes(46);                          return v.ReadSingle();                      }                      v.ReadBytes(length);                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,ReadBNKVolume,The following statement contains a magic number: using (var v = new EndianBinaryReader(platform.GetBitConverter' inputStream))              {                  if (v.ReadInt32() != 1145588546) //BKHD                      throw new Exception("Unknown BNK file format!");                  v.ReadBytes(v.ReadInt32());                    //offset till HRIC (chunk len+8)                  while (v.ReadInt32() != 1129466184 && (inputStream.Position < inputStream.Length-1))                  {                      v.ReadBytes(v.ReadInt32());                  }                  //ok we're in Hric now' let's validate again!                  v.BaseStream.Position -= 4;                  if (v.ReadInt32() != 1129466184)                      throw new Exception("Something goes wrong with bnk parser.");                    //get HRIC size                  var len = v.ReadInt32();                  var obj = v.ReadInt32();                  for (var o = 0; o < obj; o++)                  {                      var type = v.ReadByte();                      var length = v.ReadInt32();                      // find correct object type - SFXV                      if (type == 2)                      {                          //skip 46 bytes to find volume                          v.ReadBytes(46);                          return v.ReadSingle();                      }                      v.ReadBytes(length);                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,ReadBNKVolume,The following statement contains a magic number: using (var v = new EndianBinaryReader(platform.GetBitConverter' inputStream))              {                  if (v.ReadInt32() != 1145588546) //BKHD                      throw new Exception("Unknown BNK file format!");                  v.ReadBytes(v.ReadInt32());                    //offset till HRIC (chunk len+8)                  while (v.ReadInt32() != 1129466184 && (inputStream.Position < inputStream.Length-1))                  {                      v.ReadBytes(v.ReadInt32());                  }                  //ok we're in Hric now' let's validate again!                  v.BaseStream.Position -= 4;                  if (v.ReadInt32() != 1129466184)                      throw new Exception("Something goes wrong with bnk parser.");                    //get HRIC size                  var len = v.ReadInt32();                  var obj = v.ReadInt32();                  for (var o = 0; o < obj; o++)                  {                      var type = v.ReadByte();                      var length = v.ReadInt32();                      // find correct object type - SFXV                      if (type == 2)                      {                          //skip 46 bytes to find volume                          v.ReadBytes(46);                          return v.ReadSingle();                      }                      v.ReadBytes(length);                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,ReadBNKVolume,The following statement contains a magic number: using (var v = new EndianBinaryReader(platform.GetBitConverter' inputStream))              {                  if (v.ReadInt32() != 1145588546) //BKHD                      throw new Exception("Unknown BNK file format!");                  v.ReadBytes(v.ReadInt32());                    //offset till HRIC (chunk len+8)                  while (v.ReadInt32() != 1129466184 && (inputStream.Position < inputStream.Length-1))                  {                      v.ReadBytes(v.ReadInt32());                  }                  //ok we're in Hric now' let's validate again!                  v.BaseStream.Position -= 4;                  if (v.ReadInt32() != 1129466184)                      throw new Exception("Something goes wrong with bnk parser.");                    //get HRIC size                  var len = v.ReadInt32();                  var obj = v.ReadInt32();                  for (var o = 0; o < obj; o++)                  {                      var type = v.ReadByte();                      var length = v.ReadInt32();                      // find correct object type - SFXV                      if (type == 2)                      {                          //skip 46 bytes to find volume                          v.ReadBytes(46);                          return v.ReadSingle();                      }                      v.ReadBytes(length);                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,ReadBNKVolume,The following statement contains a magic number: return -7;
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,Header,The following statement contains a magic number: int soundbankVersion = 91;
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,Header,The following statement contains a magic number: using (var chunkStream = new MemoryStream())              using (var chunk = new EndianBinaryWriter(_bitConverter' chunkStream))              {                  chunk.Write(soundbankVersion);                  chunk.Write(soundbankID);                  chunk.Write(languageID);                  chunk.Write(hasFeedback);                    int alignSize = isConsole ? 2048 : 16;                  int dataSize = (int)chunkStream.Length;                  int junkSize = 24 + didxSize;                  int paddingSize = (dataSize + junkSize) % alignSize;                  if (paddingSize != 0)                  {                      for (int i = 0; i < (alignSize - paddingSize) / 4; i++)                          chunk.Write((int)0);                  }                    chunkStream.Flush();                  return chunkStream.ToArray();              }
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,Header,The following statement contains a magic number: using (var chunkStream = new MemoryStream())              using (var chunk = new EndianBinaryWriter(_bitConverter' chunkStream))              {                  chunk.Write(soundbankVersion);                  chunk.Write(soundbankID);                  chunk.Write(languageID);                  chunk.Write(hasFeedback);                    int alignSize = isConsole ? 2048 : 16;                  int dataSize = (int)chunkStream.Length;                  int junkSize = 24 + didxSize;                  int paddingSize = (dataSize + junkSize) % alignSize;                  if (paddingSize != 0)                  {                      for (int i = 0; i < (alignSize - paddingSize) / 4; i++)                          chunk.Write((int)0);                  }                    chunkStream.Flush();                  return chunkStream.ToArray();              }
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,Header,The following statement contains a magic number: using (var chunkStream = new MemoryStream())              using (var chunk = new EndianBinaryWriter(_bitConverter' chunkStream))              {                  chunk.Write(soundbankVersion);                  chunk.Write(soundbankID);                  chunk.Write(languageID);                  chunk.Write(hasFeedback);                    int alignSize = isConsole ? 2048 : 16;                  int dataSize = (int)chunkStream.Length;                  int junkSize = 24 + didxSize;                  int paddingSize = (dataSize + junkSize) % alignSize;                  if (paddingSize != 0)                  {                      for (int i = 0; i < (alignSize - paddingSize) / 4; i++)                          chunk.Write((int)0);                  }                    chunkStream.Flush();                  return chunkStream.ToArray();              }
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,Header,The following statement contains a magic number: using (var chunkStream = new MemoryStream())              using (var chunk = new EndianBinaryWriter(_bitConverter' chunkStream))              {                  chunk.Write(soundbankVersion);                  chunk.Write(soundbankID);                  chunk.Write(languageID);                  chunk.Write(hasFeedback);                    int alignSize = isConsole ? 2048 : 16;                  int dataSize = (int)chunkStream.Length;                  int junkSize = 24 + didxSize;                  int paddingSize = (dataSize + junkSize) % alignSize;                  if (paddingSize != 0)                  {                      for (int i = 0; i < (alignSize - paddingSize) / 4; i++)                          chunk.Write((int)0);                  }                    chunkStream.Flush();                  return chunkStream.ToArray();              }
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,HierarchySound,The following statement contains a magic number: int pluginID = 262145;
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,HierarchySound,The following statement contains a magic number: int streamType = 2;
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,HierarchySound,The following statement contains a magic number: int directParentID = isConsole ? 134217984 : 65536;
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,HierarchySound,The following statement contains a magic number: int directParentID = isConsole ? 134217984 : 65536;
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,HierarchySound,The following statement contains a magic number: uint unkID1 = (preview) ? 4178100890 : 0;
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,HierarchySound,The following statement contains a magic number: byte numParam = 3;
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,HierarchySound,The following statement contains a magic number: byte param2Type = 46;
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,HierarchySound,The following statement contains a magic number: byte param3Type = 47;
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,HierarchySound,The following statement contains a magic number: int param3Value = 3;
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,HierarchyAction,The following statement contains a magic number: short actionType = 1027;
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,HierarchyAction,The following statement contains a magic number: byte fadeCurve = 4;
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,HierarchyActorMixer,The following statement contains a magic number: uint parentBusID = 2616261673;
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,HierarchyActorMixer,The following statement contains a magic number: int unkID2 = 65792;
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,Hierarchy,The following statement contains a magic number: int mixerID = 650605636;
Magic Number,RocksmithToolkitLib.DLCPackage,SoundBankGenerator2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\SoundBankGenerator.cs,GenerateSoundBank,The following statement contains a magic number: byte[] dataChunk = audioReader.ReadBytes(51200);
Magic Number,RocksmithToolkitLib.SngToTab,Common,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\Common.cs,TimeToString,The following statement contains a magic number: string minutes = (timeInSeconds / 60).ToString();
Magic Number,RocksmithToolkitLib.SngToTab,Common,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\Common.cs,TimeToString,The following statement contains a magic number: string seconds = (timeInSeconds % 60).ToString();
Magic Number,RocksmithToolkitLib.SngToTab,Sng2Tab,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\Sng2Tab.cs,Convert,The following statement contains a magic number: if (allDif)                  difficulties = Enumerable.Range(0' maxDifficulty + 1).ToArray();              else // if (max)                  //  difficulties = new int[] { maxDifficulty };                  difficulties = new int[] { 255 };
Magic Number,RocksmithToolkitLib.SngToTab,TabChord,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\TabChord.cs,TabChord,The following statement contains a magic number: Frets[2] = chord.Fret2;
Magic Number,RocksmithToolkitLib.SngToTab,TabChord,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\TabChord.cs,TabChord,The following statement contains a magic number: Frets[3] = chord.Fret3;
Magic Number,RocksmithToolkitLib.SngToTab,TabChord,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\TabChord.cs,TabChord,The following statement contains a magic number: Frets[4] = chord.Fret4;
Magic Number,RocksmithToolkitLib.SngToTab,TabChord,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\TabChord.cs,TabChord,The following statement contains a magic number: Frets[5] = chord.Fret5;
Magic Number,RocksmithToolkitLib.SngToTab,TabFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\TabFile.cs,TabFile,The following statement contains a magic number: StringCount = 6;
Magic Number,RocksmithToolkitLib.SngToTab,TabHeader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\TabHeader.cs,Apply,The following statement contains a magic number: if (diff == 255)                  tabFile.AppendLine("LENGTH: " + Length + " (MAXIMUM DIFFICULTY LEVEL)" + Environment.NewLine);              else                  tabFile.AppendLine("LENGTH: " + Length + String.Format(" (DIFFICULTY LEVEL {0})"' diff) + Environment.NewLine);
Magic Number,RocksmithToolkitLib.SngToTab,TabMeasure,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\TabMeasure.cs,GetLines,The following statement contains a magic number: while (slots[slots.Length - 1] * slotLength > TabFile.LINE_WRAP)              {                  int[] nextSlots = new int[slots.Length];                  bool last = false;                    for (int i = 0; i < slots.Length; i++)                  {                      nextSlots[i] = slots[i] / 2;                        // Stop if 2 notes/chords would occupy the same position on the next compression step                      if (i != 0 && slotIsNote[i] && slotIsNote[i - 1] && nextSlots[i] == nextSlots[i - 1])                      {                          last = true; // "break out of for loop"                          break;                      }                  }                    if (last)                      break;                    slots = nextSlots;              }
Magic Number,RocksmithToolkitLib.SngToTab,TabMeasure,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\TabMeasure.cs,GetLines,The following statement contains a magic number: _lines[0] += "".PadLeft(2' TabFile.PADDING_INFO);
Magic Number,RocksmithToolkitLib.SngToTab,TabMeasure,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\TabMeasure.cs,GetLines,The following statement contains a magic number: _lines[1] += "".PadLeft(2' TabFile.PADDING_INFO);
Magic Number,RocksmithToolkitLib.SngToTab,TabMeasure,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\TabMeasure.cs,GetLines,The following statement contains a magic number: _lines[2] += "".PadLeft(2' TabFile.PADDING_INFO);
Magic Number,RocksmithToolkitLib.SngToTab,TabMeasure,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\TabMeasure.cs,GetLines,The following statement contains a magic number: _lines[2] += "".PadLeft(2' TabFile.PADDING_INFO);
Magic Number,RocksmithToolkitLib.SngToTab,TabMeasure,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\TabMeasure.cs,GetLines,The following statement contains a magic number: _lines[TabFile.FIRST_STRING + 0] += "|".PadLeft(2' TabFile.PADDING_STRING);
Magic Number,RocksmithToolkitLib.SngToTab,TabMeasure,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\TabMeasure.cs,GetLines,The following statement contains a magic number: _lines[TabFile.FIRST_STRING + 1] += "|".PadLeft(2' TabFile.PADDING_STRING);
Magic Number,RocksmithToolkitLib.SngToTab,TabMeasure,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\TabMeasure.cs,GetLines,The following statement contains a magic number: _lines[TabFile.FIRST_STRING + 2] += "|".PadLeft(2' TabFile.PADDING_STRING);
Magic Number,RocksmithToolkitLib.SngToTab,TabMeasure,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\TabMeasure.cs,GetLines,The following statement contains a magic number: _lines[TabFile.FIRST_STRING + 2] += "|".PadLeft(2' TabFile.PADDING_STRING);
Magic Number,RocksmithToolkitLib.SngToTab,TabMeasure,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\TabMeasure.cs,GetLines,The following statement contains a magic number: _lines[TabFile.FIRST_STRING + 3] += "|".PadLeft(2' TabFile.PADDING_STRING);
Magic Number,RocksmithToolkitLib.SngToTab,TabMeasure,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\TabMeasure.cs,GetLines,The following statement contains a magic number: _lines[TabFile.FIRST_STRING + 3] += "|".PadLeft(2' TabFile.PADDING_STRING);
Magic Number,RocksmithToolkitLib.SngToTab,TabMeasure,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\TabMeasure.cs,GetLines,The following statement contains a magic number: _lines[TabFile.FIRST_STRING + 4] += "|".PadLeft(2' TabFile.PADDING_STRING);
Magic Number,RocksmithToolkitLib.SngToTab,TabMeasure,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\TabMeasure.cs,GetLines,The following statement contains a magic number: _lines[TabFile.FIRST_STRING + 4] += "|".PadLeft(2' TabFile.PADDING_STRING);
Magic Number,RocksmithToolkitLib.SngToTab,TabMeasure,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\TabMeasure.cs,GetLines,The following statement contains a magic number: _lines[TabFile.FIRST_STRING + 5] += "|".PadLeft(2' TabFile.PADDING_STRING);
Magic Number,RocksmithToolkitLib.SngToTab,TabMeasure,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\SngToTab\TabMeasure.cs,GetLines,The following statement contains a magic number: _lines[TabFile.FIRST_STRING + 5] += "|".PadLeft(2' TabFile.PADDING_STRING);
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest2014,Attributes2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest2014\Attributes2014.cs,Attributes2014,The following statement contains a magic number: TargetScore = 100000;
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest2014,Manifest2014<T>,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest2014\Manifest2014.cs,Manifest2014,The following statement contains a magic number: switch (dlcType) {                  case DLCPackageType.Song:                      ModelName = "RSEnumerable_Song";                      IterationVersion = 2;                      InsertRoot = "Static.Songs.Entries";                      Entries = new Dictionary<string' Dictionary<string' T>>();                      break;                  case DLCPackageType.Lesson:                      throw new NotImplementedException("Lesson package type not implemented yet :(");                  case DLCPackageType.Inlay:                      ModelName = "RSEnumerable_Guitars";                      IterationVersion = 2;                      InsertRoot = "Static.Guitars.Entries";                      Entries = new Dictionary<string' Dictionary<string' T>>();                      break;              }
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest2014,Manifest2014<T>,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest2014\Manifest2014.cs,Manifest2014,The following statement contains a magic number: switch (dlcType) {                  case DLCPackageType.Song:                      ModelName = "RSEnumerable_Song";                      IterationVersion = 2;                      InsertRoot = "Static.Songs.Entries";                      Entries = new Dictionary<string' Dictionary<string' T>>();                      break;                  case DLCPackageType.Lesson:                      throw new NotImplementedException("Lesson package type not implemented yet :(");                  case DLCPackageType.Inlay:                      ModelName = "RSEnumerable_Guitars";                      IterationVersion = 2;                      InsertRoot = "Static.Guitars.Entries";                      Entries = new Dictionary<string' Dictionary<string' T>>();                      break;              }
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest,ManifestBuilder,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\ManifestBuilder.cs,GenerateManifest,The following statement contains a magic number: foreach (var x in arrangements)              {                  var isVocal = x.ArrangementType == Sng.ArrangementType.Vocal;                  var song = (isVocal) ? null : Song.LoadFromFile(x.SongXml.File);                    var attribute = new Attributes();                  attribute.AlbumArt = String.Format("urn:llid:{0}"' AggregateGraph.AlbumArt.LLID);                  // added better AlbumNameSort feature                  attribute.AlbumName = songInfo.Album;                  attribute.AlbumNameSort = songInfo.AlbumSort;                  attribute.ArrangementName = x.Name.ToString();                  attribute.ArtistName = songInfo.Artist;                  attribute.ArtistNameSort = songInfo.ArtistSort;                  attribute.AssociatedTechniques = new List<string>();                  //Should be 51 for bass' 49 for vocal and guitar                  attribute.BinaryVersion = x.ArrangementType == Sng.ArrangementType.Bass ? 51 : 49;                  attribute.BlockAsset = String.Format("urn:emergent-world:{0}"' AggregateGraph.XBlock.Name);                  attribute.ChordTemplates = null;                  attribute.DISC_DLC_OTHER = "Disc";                  attribute.DisplayName = songInfo.SongDisplayName;                  attribute.DLCPreview = false;                  attribute.EffectChainMultiplayerName = string.Empty;                  attribute.EffectChainName = isVocal ? "" : (dlcKey + "_" + x.ToneBase == null ? "Default" : x.ToneBase.Replace(' '' '_'));                  attribute.EventFirstTimeSortOrder = 9999;                  attribute.ExclusiveBuild = new List<object>();                  attribute.FirstArrangementInSong = false;                  if (isVocal && !firstarrangset)                  {                      firstarrangset = true;                      attribute.FirstArrangementInSong = true;                  }                  attribute.ForceUseXML = true;                  attribute.Genre = "PLACEHOLDER Genre";                  attribute.InputEvent = isVocal ? "Play_Tone_Standard_Mic" : "Play_Tone_";                  attribute.IsDemoSong = false;                  attribute.IsDLC = true;                  attribute.LastConversionDateTime = "";                  int masterId = isVocal ? 1 : x.MasterId;                  attribute.MasterID_PS3 = masterId;                  attribute.MasterID_Xbox360 = masterId;                  attribute.MaxPhraseDifficulty = 0;                  attribute.PersistentID = x.Id.ToString().Replace("-"' "").ToUpper();                  attribute.PhraseIterations = new List<PhraseIteration>();                  attribute.Phrases = new List<Phrase>();                  attribute.PluckedType = x.PluckedType == Sng.PluckedType.Picked ? "Picked" : "Not Picked";                  attribute.RelativeDifficulty = isVocal ? 0 : song.Levels.Length;                  attribute.RepresentativeArrangement = false;                  attribute.Score_MaxNotes = 0;                  attribute.Score_PNV = 0;                  attribute.Sections = new List<Section>();                  attribute.Shipping = true;                  attribute.SongAsset = String.Format("urn:llid:{0}"' x.SongFile.LLID);                  attribute.SongEvent = String.Format("Play_{0}"' dlcKey);                  attribute.SongKey = dlcKey;                  attribute.SongLength = 0;                  attribute.SongName = songInfo.SongDisplayName;                  attribute.SongNameSort = songInfo.SongDisplayNameSort;                  attribute.SongXml = String.Format("urn:llid:{0}"' x.SongXml.LLID);                  attribute.SongYear = songInfo.SongYear;                  attribute.TargetScore = 0;                  attribute.ToneUnlockScore = 0;                  attribute.TwoHandTapping = false;                  attribute.UnlockKey = "";                  attribute.Tuning = x.Tuning;                  attribute.VocalsAssetId = x.ArrangementType == Sng.ArrangementType.Vocal ? "" : (vocal != null) ? String.Format("{0}|GRSong_{1}"' vocal.Id' vocal.Name) : "";                  attribute.ChordTemplates = new List<ChordTemplate>();                  manifestFunctions.GenerateDynamicVisualDensity(attribute' song' x' GameVersion.RS2012);                    if (!isVocal)                  {                      #region "Associated Techniques"                        attribute.PowerChords = song.HasPowerChords();                      if (song.HasPowerChords()) AssociateTechniques(x' attribute' "PowerChords");                      attribute.BarChords = song.HasBarChords();                      if (song.HasBarChords()) AssociateTechniques(x' attribute' "BarChords");                      attribute.OpenChords = song.HasOpenChords();                      if (song.HasOpenChords()) AssociateTechniques(x' attribute' "ChordIntro");                      attribute.DoubleStops = song.HasDoubleStops();                      if (song.HasDoubleStops()) AssociateTechniques(x' attribute' "DoubleStops");                      attribute.Sustain = song.HasSustain();                      if (song.HasSustain()) AssociateTechniques(x' attribute' "Sustain");                      attribute.Bends = song.HasBends();                      if (song.HasBends()) AssociateTechniques(x' attribute' "Bends");                      attribute.Slides = song.HasSlides();                      if (song.HasSlides()) AssociateTechniques(x' attribute' "Slides");                      attribute.Tremolo = song.HasTremolo();                      if (song.HasTremolo()) AssociateTechniques(x' attribute' "Tremolo");                      attribute.SlapAndPop = song.HasSlapAndPop();                      if (song.HasSlapAndPop()) AssociateTechniques(x' attribute' "Slap");                      attribute.Harmonics = song.HasHarmonics();                      if (song.HasHarmonics()) AssociateTechniques(x' attribute' "Harmonics");                      attribute.PalmMutes = song.HasPalmMutes();                      if (song.HasPalmMutes()) AssociateTechniques(x' attribute' "PalmMutes");                      attribute.HOPOs = song.HasHOPOs();                      if (song.HasHOPOs()) AssociateTechniques(x' attribute' "HOPOs");                      attribute.FretHandMutes = song.HasFretHandMutes();                      if (song.HasFretHandMutes()) AssociateTechniques(x' attribute' "FretHandMutes");                      attribute.DropDPowerChords = song.HasDropDPowerChords();                      if (song.HasDropDPowerChords()) AssociateTechniques(x' attribute' "DropDPowerChords");                      attribute.Prebends = song.HasPrebends();                      if (song.HasPrebends()) AssociateTechniques(x' attribute' "Prebends");                      attribute.Vibrato = song.HasVibrato();                      if (song.HasVibrato()) AssociateTechniques(x' attribute' "Vibrato");                        //Bass exclusive                      attribute.TwoFingerPlucking = song.HasTwoFingerPlucking();                      if (song.HasTwoFingerPlucking()) AssociateTechniques(x' attribute' "Plucking");                      attribute.FifthsAndOctaves = song.HasFifthsAndOctaves();                      if (song.HasFifthsAndOctaves()) AssociateTechniques(x' attribute' "Octave");                      attribute.Syncopation = song.HasSyncopation();                      if (song.HasSyncopation()) AssociateTechniques(x' attribute' "Syncopation");                        #endregion                        attribute.AverageTempo = songInfo.AverageTempo;                      attribute.RepresentativeArrangement = true;                      attribute.SongPartition = songPartition.GetSongPartition(x.Name' x.ArrangementType);                      attribute.SongLength = (float)Math.Round((decimal)song.SongLength' 3' MidpointRounding.AwayFromZero); //rounded                      attribute.LastConversionDateTime = song.LastConversionDateTime;                      attribute.TargetScore = 100000;                      attribute.ToneUnlockScore = 70000;                      attribute.SongDifficulty = (float)song.PhraseIterations.Average(it => song.Phrases[it.PhraseId].MaxDifficulty);                      manifestFunctions.GenerateChordTemplateData(attribute' song);                      manifestFunctions.GeneratePhraseData(attribute' song);                      manifestFunctions.GenerateSectionData(attribute' song);                      manifestFunctions.GeneratePhraseIterationsData(attribute' song' platform.version);                  }                  var attrDict = new Dictionary<string' Attributes> { { "Attributes"' attribute } };                  manifest.Entries.Add(attribute.PersistentID' attrDict);              }
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest,ManifestBuilder,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\ManifestBuilder.cs,GenerateManifest,The following statement contains a magic number: foreach (var x in arrangements)              {                  var isVocal = x.ArrangementType == Sng.ArrangementType.Vocal;                  var song = (isVocal) ? null : Song.LoadFromFile(x.SongXml.File);                    var attribute = new Attributes();                  attribute.AlbumArt = String.Format("urn:llid:{0}"' AggregateGraph.AlbumArt.LLID);                  // added better AlbumNameSort feature                  attribute.AlbumName = songInfo.Album;                  attribute.AlbumNameSort = songInfo.AlbumSort;                  attribute.ArrangementName = x.Name.ToString();                  attribute.ArtistName = songInfo.Artist;                  attribute.ArtistNameSort = songInfo.ArtistSort;                  attribute.AssociatedTechniques = new List<string>();                  //Should be 51 for bass' 49 for vocal and guitar                  attribute.BinaryVersion = x.ArrangementType == Sng.ArrangementType.Bass ? 51 : 49;                  attribute.BlockAsset = String.Format("urn:emergent-world:{0}"' AggregateGraph.XBlock.Name);                  attribute.ChordTemplates = null;                  attribute.DISC_DLC_OTHER = "Disc";                  attribute.DisplayName = songInfo.SongDisplayName;                  attribute.DLCPreview = false;                  attribute.EffectChainMultiplayerName = string.Empty;                  attribute.EffectChainName = isVocal ? "" : (dlcKey + "_" + x.ToneBase == null ? "Default" : x.ToneBase.Replace(' '' '_'));                  attribute.EventFirstTimeSortOrder = 9999;                  attribute.ExclusiveBuild = new List<object>();                  attribute.FirstArrangementInSong = false;                  if (isVocal && !firstarrangset)                  {                      firstarrangset = true;                      attribute.FirstArrangementInSong = true;                  }                  attribute.ForceUseXML = true;                  attribute.Genre = "PLACEHOLDER Genre";                  attribute.InputEvent = isVocal ? "Play_Tone_Standard_Mic" : "Play_Tone_";                  attribute.IsDemoSong = false;                  attribute.IsDLC = true;                  attribute.LastConversionDateTime = "";                  int masterId = isVocal ? 1 : x.MasterId;                  attribute.MasterID_PS3 = masterId;                  attribute.MasterID_Xbox360 = masterId;                  attribute.MaxPhraseDifficulty = 0;                  attribute.PersistentID = x.Id.ToString().Replace("-"' "").ToUpper();                  attribute.PhraseIterations = new List<PhraseIteration>();                  attribute.Phrases = new List<Phrase>();                  attribute.PluckedType = x.PluckedType == Sng.PluckedType.Picked ? "Picked" : "Not Picked";                  attribute.RelativeDifficulty = isVocal ? 0 : song.Levels.Length;                  attribute.RepresentativeArrangement = false;                  attribute.Score_MaxNotes = 0;                  attribute.Score_PNV = 0;                  attribute.Sections = new List<Section>();                  attribute.Shipping = true;                  attribute.SongAsset = String.Format("urn:llid:{0}"' x.SongFile.LLID);                  attribute.SongEvent = String.Format("Play_{0}"' dlcKey);                  attribute.SongKey = dlcKey;                  attribute.SongLength = 0;                  attribute.SongName = songInfo.SongDisplayName;                  attribute.SongNameSort = songInfo.SongDisplayNameSort;                  attribute.SongXml = String.Format("urn:llid:{0}"' x.SongXml.LLID);                  attribute.SongYear = songInfo.SongYear;                  attribute.TargetScore = 0;                  attribute.ToneUnlockScore = 0;                  attribute.TwoHandTapping = false;                  attribute.UnlockKey = "";                  attribute.Tuning = x.Tuning;                  attribute.VocalsAssetId = x.ArrangementType == Sng.ArrangementType.Vocal ? "" : (vocal != null) ? String.Format("{0}|GRSong_{1}"' vocal.Id' vocal.Name) : "";                  attribute.ChordTemplates = new List<ChordTemplate>();                  manifestFunctions.GenerateDynamicVisualDensity(attribute' song' x' GameVersion.RS2012);                    if (!isVocal)                  {                      #region "Associated Techniques"                        attribute.PowerChords = song.HasPowerChords();                      if (song.HasPowerChords()) AssociateTechniques(x' attribute' "PowerChords");                      attribute.BarChords = song.HasBarChords();                      if (song.HasBarChords()) AssociateTechniques(x' attribute' "BarChords");                      attribute.OpenChords = song.HasOpenChords();                      if (song.HasOpenChords()) AssociateTechniques(x' attribute' "ChordIntro");                      attribute.DoubleStops = song.HasDoubleStops();                      if (song.HasDoubleStops()) AssociateTechniques(x' attribute' "DoubleStops");                      attribute.Sustain = song.HasSustain();                      if (song.HasSustain()) AssociateTechniques(x' attribute' "Sustain");                      attribute.Bends = song.HasBends();                      if (song.HasBends()) AssociateTechniques(x' attribute' "Bends");                      attribute.Slides = song.HasSlides();                      if (song.HasSlides()) AssociateTechniques(x' attribute' "Slides");                      attribute.Tremolo = song.HasTremolo();                      if (song.HasTremolo()) AssociateTechniques(x' attribute' "Tremolo");                      attribute.SlapAndPop = song.HasSlapAndPop();                      if (song.HasSlapAndPop()) AssociateTechniques(x' attribute' "Slap");                      attribute.Harmonics = song.HasHarmonics();                      if (song.HasHarmonics()) AssociateTechniques(x' attribute' "Harmonics");                      attribute.PalmMutes = song.HasPalmMutes();                      if (song.HasPalmMutes()) AssociateTechniques(x' attribute' "PalmMutes");                      attribute.HOPOs = song.HasHOPOs();                      if (song.HasHOPOs()) AssociateTechniques(x' attribute' "HOPOs");                      attribute.FretHandMutes = song.HasFretHandMutes();                      if (song.HasFretHandMutes()) AssociateTechniques(x' attribute' "FretHandMutes");                      attribute.DropDPowerChords = song.HasDropDPowerChords();                      if (song.HasDropDPowerChords()) AssociateTechniques(x' attribute' "DropDPowerChords");                      attribute.Prebends = song.HasPrebends();                      if (song.HasPrebends()) AssociateTechniques(x' attribute' "Prebends");                      attribute.Vibrato = song.HasVibrato();                      if (song.HasVibrato()) AssociateTechniques(x' attribute' "Vibrato");                        //Bass exclusive                      attribute.TwoFingerPlucking = song.HasTwoFingerPlucking();                      if (song.HasTwoFingerPlucking()) AssociateTechniques(x' attribute' "Plucking");                      attribute.FifthsAndOctaves = song.HasFifthsAndOctaves();                      if (song.HasFifthsAndOctaves()) AssociateTechniques(x' attribute' "Octave");                      attribute.Syncopation = song.HasSyncopation();                      if (song.HasSyncopation()) AssociateTechniques(x' attribute' "Syncopation");                        #endregion                        attribute.AverageTempo = songInfo.AverageTempo;                      attribute.RepresentativeArrangement = true;                      attribute.SongPartition = songPartition.GetSongPartition(x.Name' x.ArrangementType);                      attribute.SongLength = (float)Math.Round((decimal)song.SongLength' 3' MidpointRounding.AwayFromZero); //rounded                      attribute.LastConversionDateTime = song.LastConversionDateTime;                      attribute.TargetScore = 100000;                      attribute.ToneUnlockScore = 70000;                      attribute.SongDifficulty = (float)song.PhraseIterations.Average(it => song.Phrases[it.PhraseId].MaxDifficulty);                      manifestFunctions.GenerateChordTemplateData(attribute' song);                      manifestFunctions.GeneratePhraseData(attribute' song);                      manifestFunctions.GenerateSectionData(attribute' song);                      manifestFunctions.GeneratePhraseIterationsData(attribute' song' platform.version);                  }                  var attrDict = new Dictionary<string' Attributes> { { "Attributes"' attribute } };                  manifest.Entries.Add(attribute.PersistentID' attrDict);              }
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest,ManifestBuilder,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\ManifestBuilder.cs,GenerateManifest,The following statement contains a magic number: foreach (var x in arrangements)              {                  var isVocal = x.ArrangementType == Sng.ArrangementType.Vocal;                  var song = (isVocal) ? null : Song.LoadFromFile(x.SongXml.File);                    var attribute = new Attributes();                  attribute.AlbumArt = String.Format("urn:llid:{0}"' AggregateGraph.AlbumArt.LLID);                  // added better AlbumNameSort feature                  attribute.AlbumName = songInfo.Album;                  attribute.AlbumNameSort = songInfo.AlbumSort;                  attribute.ArrangementName = x.Name.ToString();                  attribute.ArtistName = songInfo.Artist;                  attribute.ArtistNameSort = songInfo.ArtistSort;                  attribute.AssociatedTechniques = new List<string>();                  //Should be 51 for bass' 49 for vocal and guitar                  attribute.BinaryVersion = x.ArrangementType == Sng.ArrangementType.Bass ? 51 : 49;                  attribute.BlockAsset = String.Format("urn:emergent-world:{0}"' AggregateGraph.XBlock.Name);                  attribute.ChordTemplates = null;                  attribute.DISC_DLC_OTHER = "Disc";                  attribute.DisplayName = songInfo.SongDisplayName;                  attribute.DLCPreview = false;                  attribute.EffectChainMultiplayerName = string.Empty;                  attribute.EffectChainName = isVocal ? "" : (dlcKey + "_" + x.ToneBase == null ? "Default" : x.ToneBase.Replace(' '' '_'));                  attribute.EventFirstTimeSortOrder = 9999;                  attribute.ExclusiveBuild = new List<object>();                  attribute.FirstArrangementInSong = false;                  if (isVocal && !firstarrangset)                  {                      firstarrangset = true;                      attribute.FirstArrangementInSong = true;                  }                  attribute.ForceUseXML = true;                  attribute.Genre = "PLACEHOLDER Genre";                  attribute.InputEvent = isVocal ? "Play_Tone_Standard_Mic" : "Play_Tone_";                  attribute.IsDemoSong = false;                  attribute.IsDLC = true;                  attribute.LastConversionDateTime = "";                  int masterId = isVocal ? 1 : x.MasterId;                  attribute.MasterID_PS3 = masterId;                  attribute.MasterID_Xbox360 = masterId;                  attribute.MaxPhraseDifficulty = 0;                  attribute.PersistentID = x.Id.ToString().Replace("-"' "").ToUpper();                  attribute.PhraseIterations = new List<PhraseIteration>();                  attribute.Phrases = new List<Phrase>();                  attribute.PluckedType = x.PluckedType == Sng.PluckedType.Picked ? "Picked" : "Not Picked";                  attribute.RelativeDifficulty = isVocal ? 0 : song.Levels.Length;                  attribute.RepresentativeArrangement = false;                  attribute.Score_MaxNotes = 0;                  attribute.Score_PNV = 0;                  attribute.Sections = new List<Section>();                  attribute.Shipping = true;                  attribute.SongAsset = String.Format("urn:llid:{0}"' x.SongFile.LLID);                  attribute.SongEvent = String.Format("Play_{0}"' dlcKey);                  attribute.SongKey = dlcKey;                  attribute.SongLength = 0;                  attribute.SongName = songInfo.SongDisplayName;                  attribute.SongNameSort = songInfo.SongDisplayNameSort;                  attribute.SongXml = String.Format("urn:llid:{0}"' x.SongXml.LLID);                  attribute.SongYear = songInfo.SongYear;                  attribute.TargetScore = 0;                  attribute.ToneUnlockScore = 0;                  attribute.TwoHandTapping = false;                  attribute.UnlockKey = "";                  attribute.Tuning = x.Tuning;                  attribute.VocalsAssetId = x.ArrangementType == Sng.ArrangementType.Vocal ? "" : (vocal != null) ? String.Format("{0}|GRSong_{1}"' vocal.Id' vocal.Name) : "";                  attribute.ChordTemplates = new List<ChordTemplate>();                  manifestFunctions.GenerateDynamicVisualDensity(attribute' song' x' GameVersion.RS2012);                    if (!isVocal)                  {                      #region "Associated Techniques"                        attribute.PowerChords = song.HasPowerChords();                      if (song.HasPowerChords()) AssociateTechniques(x' attribute' "PowerChords");                      attribute.BarChords = song.HasBarChords();                      if (song.HasBarChords()) AssociateTechniques(x' attribute' "BarChords");                      attribute.OpenChords = song.HasOpenChords();                      if (song.HasOpenChords()) AssociateTechniques(x' attribute' "ChordIntro");                      attribute.DoubleStops = song.HasDoubleStops();                      if (song.HasDoubleStops()) AssociateTechniques(x' attribute' "DoubleStops");                      attribute.Sustain = song.HasSustain();                      if (song.HasSustain()) AssociateTechniques(x' attribute' "Sustain");                      attribute.Bends = song.HasBends();                      if (song.HasBends()) AssociateTechniques(x' attribute' "Bends");                      attribute.Slides = song.HasSlides();                      if (song.HasSlides()) AssociateTechniques(x' attribute' "Slides");                      attribute.Tremolo = song.HasTremolo();                      if (song.HasTremolo()) AssociateTechniques(x' attribute' "Tremolo");                      attribute.SlapAndPop = song.HasSlapAndPop();                      if (song.HasSlapAndPop()) AssociateTechniques(x' attribute' "Slap");                      attribute.Harmonics = song.HasHarmonics();                      if (song.HasHarmonics()) AssociateTechniques(x' attribute' "Harmonics");                      attribute.PalmMutes = song.HasPalmMutes();                      if (song.HasPalmMutes()) AssociateTechniques(x' attribute' "PalmMutes");                      attribute.HOPOs = song.HasHOPOs();                      if (song.HasHOPOs()) AssociateTechniques(x' attribute' "HOPOs");                      attribute.FretHandMutes = song.HasFretHandMutes();                      if (song.HasFretHandMutes()) AssociateTechniques(x' attribute' "FretHandMutes");                      attribute.DropDPowerChords = song.HasDropDPowerChords();                      if (song.HasDropDPowerChords()) AssociateTechniques(x' attribute' "DropDPowerChords");                      attribute.Prebends = song.HasPrebends();                      if (song.HasPrebends()) AssociateTechniques(x' attribute' "Prebends");                      attribute.Vibrato = song.HasVibrato();                      if (song.HasVibrato()) AssociateTechniques(x' attribute' "Vibrato");                        //Bass exclusive                      attribute.TwoFingerPlucking = song.HasTwoFingerPlucking();                      if (song.HasTwoFingerPlucking()) AssociateTechniques(x' attribute' "Plucking");                      attribute.FifthsAndOctaves = song.HasFifthsAndOctaves();                      if (song.HasFifthsAndOctaves()) AssociateTechniques(x' attribute' "Octave");                      attribute.Syncopation = song.HasSyncopation();                      if (song.HasSyncopation()) AssociateTechniques(x' attribute' "Syncopation");                        #endregion                        attribute.AverageTempo = songInfo.AverageTempo;                      attribute.RepresentativeArrangement = true;                      attribute.SongPartition = songPartition.GetSongPartition(x.Name' x.ArrangementType);                      attribute.SongLength = (float)Math.Round((decimal)song.SongLength' 3' MidpointRounding.AwayFromZero); //rounded                      attribute.LastConversionDateTime = song.LastConversionDateTime;                      attribute.TargetScore = 100000;                      attribute.ToneUnlockScore = 70000;                      attribute.SongDifficulty = (float)song.PhraseIterations.Average(it => song.Phrases[it.PhraseId].MaxDifficulty);                      manifestFunctions.GenerateChordTemplateData(attribute' song);                      manifestFunctions.GeneratePhraseData(attribute' song);                      manifestFunctions.GenerateSectionData(attribute' song);                      manifestFunctions.GeneratePhraseIterationsData(attribute' song' platform.version);                  }                  var attrDict = new Dictionary<string' Attributes> { { "Attributes"' attribute } };                  manifest.Entries.Add(attribute.PersistentID' attrDict);              }
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest,ManifestBuilder,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\ManifestBuilder.cs,GenerateManifest,The following statement contains a magic number: foreach (var x in arrangements)              {                  var isVocal = x.ArrangementType == Sng.ArrangementType.Vocal;                  var song = (isVocal) ? null : Song.LoadFromFile(x.SongXml.File);                    var attribute = new Attributes();                  attribute.AlbumArt = String.Format("urn:llid:{0}"' AggregateGraph.AlbumArt.LLID);                  // added better AlbumNameSort feature                  attribute.AlbumName = songInfo.Album;                  attribute.AlbumNameSort = songInfo.AlbumSort;                  attribute.ArrangementName = x.Name.ToString();                  attribute.ArtistName = songInfo.Artist;                  attribute.ArtistNameSort = songInfo.ArtistSort;                  attribute.AssociatedTechniques = new List<string>();                  //Should be 51 for bass' 49 for vocal and guitar                  attribute.BinaryVersion = x.ArrangementType == Sng.ArrangementType.Bass ? 51 : 49;                  attribute.BlockAsset = String.Format("urn:emergent-world:{0}"' AggregateGraph.XBlock.Name);                  attribute.ChordTemplates = null;                  attribute.DISC_DLC_OTHER = "Disc";                  attribute.DisplayName = songInfo.SongDisplayName;                  attribute.DLCPreview = false;                  attribute.EffectChainMultiplayerName = string.Empty;                  attribute.EffectChainName = isVocal ? "" : (dlcKey + "_" + x.ToneBase == null ? "Default" : x.ToneBase.Replace(' '' '_'));                  attribute.EventFirstTimeSortOrder = 9999;                  attribute.ExclusiveBuild = new List<object>();                  attribute.FirstArrangementInSong = false;                  if (isVocal && !firstarrangset)                  {                      firstarrangset = true;                      attribute.FirstArrangementInSong = true;                  }                  attribute.ForceUseXML = true;                  attribute.Genre = "PLACEHOLDER Genre";                  attribute.InputEvent = isVocal ? "Play_Tone_Standard_Mic" : "Play_Tone_";                  attribute.IsDemoSong = false;                  attribute.IsDLC = true;                  attribute.LastConversionDateTime = "";                  int masterId = isVocal ? 1 : x.MasterId;                  attribute.MasterID_PS3 = masterId;                  attribute.MasterID_Xbox360 = masterId;                  attribute.MaxPhraseDifficulty = 0;                  attribute.PersistentID = x.Id.ToString().Replace("-"' "").ToUpper();                  attribute.PhraseIterations = new List<PhraseIteration>();                  attribute.Phrases = new List<Phrase>();                  attribute.PluckedType = x.PluckedType == Sng.PluckedType.Picked ? "Picked" : "Not Picked";                  attribute.RelativeDifficulty = isVocal ? 0 : song.Levels.Length;                  attribute.RepresentativeArrangement = false;                  attribute.Score_MaxNotes = 0;                  attribute.Score_PNV = 0;                  attribute.Sections = new List<Section>();                  attribute.Shipping = true;                  attribute.SongAsset = String.Format("urn:llid:{0}"' x.SongFile.LLID);                  attribute.SongEvent = String.Format("Play_{0}"' dlcKey);                  attribute.SongKey = dlcKey;                  attribute.SongLength = 0;                  attribute.SongName = songInfo.SongDisplayName;                  attribute.SongNameSort = songInfo.SongDisplayNameSort;                  attribute.SongXml = String.Format("urn:llid:{0}"' x.SongXml.LLID);                  attribute.SongYear = songInfo.SongYear;                  attribute.TargetScore = 0;                  attribute.ToneUnlockScore = 0;                  attribute.TwoHandTapping = false;                  attribute.UnlockKey = "";                  attribute.Tuning = x.Tuning;                  attribute.VocalsAssetId = x.ArrangementType == Sng.ArrangementType.Vocal ? "" : (vocal != null) ? String.Format("{0}|GRSong_{1}"' vocal.Id' vocal.Name) : "";                  attribute.ChordTemplates = new List<ChordTemplate>();                  manifestFunctions.GenerateDynamicVisualDensity(attribute' song' x' GameVersion.RS2012);                    if (!isVocal)                  {                      #region "Associated Techniques"                        attribute.PowerChords = song.HasPowerChords();                      if (song.HasPowerChords()) AssociateTechniques(x' attribute' "PowerChords");                      attribute.BarChords = song.HasBarChords();                      if (song.HasBarChords()) AssociateTechniques(x' attribute' "BarChords");                      attribute.OpenChords = song.HasOpenChords();                      if (song.HasOpenChords()) AssociateTechniques(x' attribute' "ChordIntro");                      attribute.DoubleStops = song.HasDoubleStops();                      if (song.HasDoubleStops()) AssociateTechniques(x' attribute' "DoubleStops");                      attribute.Sustain = song.HasSustain();                      if (song.HasSustain()) AssociateTechniques(x' attribute' "Sustain");                      attribute.Bends = song.HasBends();                      if (song.HasBends()) AssociateTechniques(x' attribute' "Bends");                      attribute.Slides = song.HasSlides();                      if (song.HasSlides()) AssociateTechniques(x' attribute' "Slides");                      attribute.Tremolo = song.HasTremolo();                      if (song.HasTremolo()) AssociateTechniques(x' attribute' "Tremolo");                      attribute.SlapAndPop = song.HasSlapAndPop();                      if (song.HasSlapAndPop()) AssociateTechniques(x' attribute' "Slap");                      attribute.Harmonics = song.HasHarmonics();                      if (song.HasHarmonics()) AssociateTechniques(x' attribute' "Harmonics");                      attribute.PalmMutes = song.HasPalmMutes();                      if (song.HasPalmMutes()) AssociateTechniques(x' attribute' "PalmMutes");                      attribute.HOPOs = song.HasHOPOs();                      if (song.HasHOPOs()) AssociateTechniques(x' attribute' "HOPOs");                      attribute.FretHandMutes = song.HasFretHandMutes();                      if (song.HasFretHandMutes()) AssociateTechniques(x' attribute' "FretHandMutes");                      attribute.DropDPowerChords = song.HasDropDPowerChords();                      if (song.HasDropDPowerChords()) AssociateTechniques(x' attribute' "DropDPowerChords");                      attribute.Prebends = song.HasPrebends();                      if (song.HasPrebends()) AssociateTechniques(x' attribute' "Prebends");                      attribute.Vibrato = song.HasVibrato();                      if (song.HasVibrato()) AssociateTechniques(x' attribute' "Vibrato");                        //Bass exclusive                      attribute.TwoFingerPlucking = song.HasTwoFingerPlucking();                      if (song.HasTwoFingerPlucking()) AssociateTechniques(x' attribute' "Plucking");                      attribute.FifthsAndOctaves = song.HasFifthsAndOctaves();                      if (song.HasFifthsAndOctaves()) AssociateTechniques(x' attribute' "Octave");                      attribute.Syncopation = song.HasSyncopation();                      if (song.HasSyncopation()) AssociateTechniques(x' attribute' "Syncopation");                        #endregion                        attribute.AverageTempo = songInfo.AverageTempo;                      attribute.RepresentativeArrangement = true;                      attribute.SongPartition = songPartition.GetSongPartition(x.Name' x.ArrangementType);                      attribute.SongLength = (float)Math.Round((decimal)song.SongLength' 3' MidpointRounding.AwayFromZero); //rounded                      attribute.LastConversionDateTime = song.LastConversionDateTime;                      attribute.TargetScore = 100000;                      attribute.ToneUnlockScore = 70000;                      attribute.SongDifficulty = (float)song.PhraseIterations.Average(it => song.Phrases[it.PhraseId].MaxDifficulty);                      manifestFunctions.GenerateChordTemplateData(attribute' song);                      manifestFunctions.GeneratePhraseData(attribute' song);                      manifestFunctions.GenerateSectionData(attribute' song);                      manifestFunctions.GeneratePhraseIterationsData(attribute' song' platform.version);                  }                  var attrDict = new Dictionary<string' Attributes> { { "Attributes"' attribute } };                  manifest.Entries.Add(attribute.PersistentID' attrDict);              }
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest,ManifestBuilder,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\ManifestBuilder.cs,GenerateManifest,The following statement contains a magic number: foreach (var x in arrangements)              {                  var isVocal = x.ArrangementType == Sng.ArrangementType.Vocal;                  var song = (isVocal) ? null : Song.LoadFromFile(x.SongXml.File);                    var attribute = new Attributes();                  attribute.AlbumArt = String.Format("urn:llid:{0}"' AggregateGraph.AlbumArt.LLID);                  // added better AlbumNameSort feature                  attribute.AlbumName = songInfo.Album;                  attribute.AlbumNameSort = songInfo.AlbumSort;                  attribute.ArrangementName = x.Name.ToString();                  attribute.ArtistName = songInfo.Artist;                  attribute.ArtistNameSort = songInfo.ArtistSort;                  attribute.AssociatedTechniques = new List<string>();                  //Should be 51 for bass' 49 for vocal and guitar                  attribute.BinaryVersion = x.ArrangementType == Sng.ArrangementType.Bass ? 51 : 49;                  attribute.BlockAsset = String.Format("urn:emergent-world:{0}"' AggregateGraph.XBlock.Name);                  attribute.ChordTemplates = null;                  attribute.DISC_DLC_OTHER = "Disc";                  attribute.DisplayName = songInfo.SongDisplayName;                  attribute.DLCPreview = false;                  attribute.EffectChainMultiplayerName = string.Empty;                  attribute.EffectChainName = isVocal ? "" : (dlcKey + "_" + x.ToneBase == null ? "Default" : x.ToneBase.Replace(' '' '_'));                  attribute.EventFirstTimeSortOrder = 9999;                  attribute.ExclusiveBuild = new List<object>();                  attribute.FirstArrangementInSong = false;                  if (isVocal && !firstarrangset)                  {                      firstarrangset = true;                      attribute.FirstArrangementInSong = true;                  }                  attribute.ForceUseXML = true;                  attribute.Genre = "PLACEHOLDER Genre";                  attribute.InputEvent = isVocal ? "Play_Tone_Standard_Mic" : "Play_Tone_";                  attribute.IsDemoSong = false;                  attribute.IsDLC = true;                  attribute.LastConversionDateTime = "";                  int masterId = isVocal ? 1 : x.MasterId;                  attribute.MasterID_PS3 = masterId;                  attribute.MasterID_Xbox360 = masterId;                  attribute.MaxPhraseDifficulty = 0;                  attribute.PersistentID = x.Id.ToString().Replace("-"' "").ToUpper();                  attribute.PhraseIterations = new List<PhraseIteration>();                  attribute.Phrases = new List<Phrase>();                  attribute.PluckedType = x.PluckedType == Sng.PluckedType.Picked ? "Picked" : "Not Picked";                  attribute.RelativeDifficulty = isVocal ? 0 : song.Levels.Length;                  attribute.RepresentativeArrangement = false;                  attribute.Score_MaxNotes = 0;                  attribute.Score_PNV = 0;                  attribute.Sections = new List<Section>();                  attribute.Shipping = true;                  attribute.SongAsset = String.Format("urn:llid:{0}"' x.SongFile.LLID);                  attribute.SongEvent = String.Format("Play_{0}"' dlcKey);                  attribute.SongKey = dlcKey;                  attribute.SongLength = 0;                  attribute.SongName = songInfo.SongDisplayName;                  attribute.SongNameSort = songInfo.SongDisplayNameSort;                  attribute.SongXml = String.Format("urn:llid:{0}"' x.SongXml.LLID);                  attribute.SongYear = songInfo.SongYear;                  attribute.TargetScore = 0;                  attribute.ToneUnlockScore = 0;                  attribute.TwoHandTapping = false;                  attribute.UnlockKey = "";                  attribute.Tuning = x.Tuning;                  attribute.VocalsAssetId = x.ArrangementType == Sng.ArrangementType.Vocal ? "" : (vocal != null) ? String.Format("{0}|GRSong_{1}"' vocal.Id' vocal.Name) : "";                  attribute.ChordTemplates = new List<ChordTemplate>();                  manifestFunctions.GenerateDynamicVisualDensity(attribute' song' x' GameVersion.RS2012);                    if (!isVocal)                  {                      #region "Associated Techniques"                        attribute.PowerChords = song.HasPowerChords();                      if (song.HasPowerChords()) AssociateTechniques(x' attribute' "PowerChords");                      attribute.BarChords = song.HasBarChords();                      if (song.HasBarChords()) AssociateTechniques(x' attribute' "BarChords");                      attribute.OpenChords = song.HasOpenChords();                      if (song.HasOpenChords()) AssociateTechniques(x' attribute' "ChordIntro");                      attribute.DoubleStops = song.HasDoubleStops();                      if (song.HasDoubleStops()) AssociateTechniques(x' attribute' "DoubleStops");                      attribute.Sustain = song.HasSustain();                      if (song.HasSustain()) AssociateTechniques(x' attribute' "Sustain");                      attribute.Bends = song.HasBends();                      if (song.HasBends()) AssociateTechniques(x' attribute' "Bends");                      attribute.Slides = song.HasSlides();                      if (song.HasSlides()) AssociateTechniques(x' attribute' "Slides");                      attribute.Tremolo = song.HasTremolo();                      if (song.HasTremolo()) AssociateTechniques(x' attribute' "Tremolo");                      attribute.SlapAndPop = song.HasSlapAndPop();                      if (song.HasSlapAndPop()) AssociateTechniques(x' attribute' "Slap");                      attribute.Harmonics = song.HasHarmonics();                      if (song.HasHarmonics()) AssociateTechniques(x' attribute' "Harmonics");                      attribute.PalmMutes = song.HasPalmMutes();                      if (song.HasPalmMutes()) AssociateTechniques(x' attribute' "PalmMutes");                      attribute.HOPOs = song.HasHOPOs();                      if (song.HasHOPOs()) AssociateTechniques(x' attribute' "HOPOs");                      attribute.FretHandMutes = song.HasFretHandMutes();                      if (song.HasFretHandMutes()) AssociateTechniques(x' attribute' "FretHandMutes");                      attribute.DropDPowerChords = song.HasDropDPowerChords();                      if (song.HasDropDPowerChords()) AssociateTechniques(x' attribute' "DropDPowerChords");                      attribute.Prebends = song.HasPrebends();                      if (song.HasPrebends()) AssociateTechniques(x' attribute' "Prebends");                      attribute.Vibrato = song.HasVibrato();                      if (song.HasVibrato()) AssociateTechniques(x' attribute' "Vibrato");                        //Bass exclusive                      attribute.TwoFingerPlucking = song.HasTwoFingerPlucking();                      if (song.HasTwoFingerPlucking()) AssociateTechniques(x' attribute' "Plucking");                      attribute.FifthsAndOctaves = song.HasFifthsAndOctaves();                      if (song.HasFifthsAndOctaves()) AssociateTechniques(x' attribute' "Octave");                      attribute.Syncopation = song.HasSyncopation();                      if (song.HasSyncopation()) AssociateTechniques(x' attribute' "Syncopation");                        #endregion                        attribute.AverageTempo = songInfo.AverageTempo;                      attribute.RepresentativeArrangement = true;                      attribute.SongPartition = songPartition.GetSongPartition(x.Name' x.ArrangementType);                      attribute.SongLength = (float)Math.Round((decimal)song.SongLength' 3' MidpointRounding.AwayFromZero); //rounded                      attribute.LastConversionDateTime = song.LastConversionDateTime;                      attribute.TargetScore = 100000;                      attribute.ToneUnlockScore = 70000;                      attribute.SongDifficulty = (float)song.PhraseIterations.Average(it => song.Phrases[it.PhraseId].MaxDifficulty);                      manifestFunctions.GenerateChordTemplateData(attribute' song);                      manifestFunctions.GeneratePhraseData(attribute' song);                      manifestFunctions.GenerateSectionData(attribute' song);                      manifestFunctions.GeneratePhraseIterationsData(attribute' song' platform.version);                  }                  var attrDict = new Dictionary<string' Attributes> { { "Attributes"' attribute } };                  manifest.Entries.Add(attribute.PersistentID' attrDict);              }
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest,ManifestBuilder,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\ManifestBuilder.cs,GenerateManifest,The following statement contains a magic number: foreach (var x in arrangements)              {                  var isVocal = x.ArrangementType == Sng.ArrangementType.Vocal;                  var song = (isVocal) ? null : Song.LoadFromFile(x.SongXml.File);                    var attribute = new Attributes();                  attribute.AlbumArt = String.Format("urn:llid:{0}"' AggregateGraph.AlbumArt.LLID);                  // added better AlbumNameSort feature                  attribute.AlbumName = songInfo.Album;                  attribute.AlbumNameSort = songInfo.AlbumSort;                  attribute.ArrangementName = x.Name.ToString();                  attribute.ArtistName = songInfo.Artist;                  attribute.ArtistNameSort = songInfo.ArtistSort;                  attribute.AssociatedTechniques = new List<string>();                  //Should be 51 for bass' 49 for vocal and guitar                  attribute.BinaryVersion = x.ArrangementType == Sng.ArrangementType.Bass ? 51 : 49;                  attribute.BlockAsset = String.Format("urn:emergent-world:{0}"' AggregateGraph.XBlock.Name);                  attribute.ChordTemplates = null;                  attribute.DISC_DLC_OTHER = "Disc";                  attribute.DisplayName = songInfo.SongDisplayName;                  attribute.DLCPreview = false;                  attribute.EffectChainMultiplayerName = string.Empty;                  attribute.EffectChainName = isVocal ? "" : (dlcKey + "_" + x.ToneBase == null ? "Default" : x.ToneBase.Replace(' '' '_'));                  attribute.EventFirstTimeSortOrder = 9999;                  attribute.ExclusiveBuild = new List<object>();                  attribute.FirstArrangementInSong = false;                  if (isVocal && !firstarrangset)                  {                      firstarrangset = true;                      attribute.FirstArrangementInSong = true;                  }                  attribute.ForceUseXML = true;                  attribute.Genre = "PLACEHOLDER Genre";                  attribute.InputEvent = isVocal ? "Play_Tone_Standard_Mic" : "Play_Tone_";                  attribute.IsDemoSong = false;                  attribute.IsDLC = true;                  attribute.LastConversionDateTime = "";                  int masterId = isVocal ? 1 : x.MasterId;                  attribute.MasterID_PS3 = masterId;                  attribute.MasterID_Xbox360 = masterId;                  attribute.MaxPhraseDifficulty = 0;                  attribute.PersistentID = x.Id.ToString().Replace("-"' "").ToUpper();                  attribute.PhraseIterations = new List<PhraseIteration>();                  attribute.Phrases = new List<Phrase>();                  attribute.PluckedType = x.PluckedType == Sng.PluckedType.Picked ? "Picked" : "Not Picked";                  attribute.RelativeDifficulty = isVocal ? 0 : song.Levels.Length;                  attribute.RepresentativeArrangement = false;                  attribute.Score_MaxNotes = 0;                  attribute.Score_PNV = 0;                  attribute.Sections = new List<Section>();                  attribute.Shipping = true;                  attribute.SongAsset = String.Format("urn:llid:{0}"' x.SongFile.LLID);                  attribute.SongEvent = String.Format("Play_{0}"' dlcKey);                  attribute.SongKey = dlcKey;                  attribute.SongLength = 0;                  attribute.SongName = songInfo.SongDisplayName;                  attribute.SongNameSort = songInfo.SongDisplayNameSort;                  attribute.SongXml = String.Format("urn:llid:{0}"' x.SongXml.LLID);                  attribute.SongYear = songInfo.SongYear;                  attribute.TargetScore = 0;                  attribute.ToneUnlockScore = 0;                  attribute.TwoHandTapping = false;                  attribute.UnlockKey = "";                  attribute.Tuning = x.Tuning;                  attribute.VocalsAssetId = x.ArrangementType == Sng.ArrangementType.Vocal ? "" : (vocal != null) ? String.Format("{0}|GRSong_{1}"' vocal.Id' vocal.Name) : "";                  attribute.ChordTemplates = new List<ChordTemplate>();                  manifestFunctions.GenerateDynamicVisualDensity(attribute' song' x' GameVersion.RS2012);                    if (!isVocal)                  {                      #region "Associated Techniques"                        attribute.PowerChords = song.HasPowerChords();                      if (song.HasPowerChords()) AssociateTechniques(x' attribute' "PowerChords");                      attribute.BarChords = song.HasBarChords();                      if (song.HasBarChords()) AssociateTechniques(x' attribute' "BarChords");                      attribute.OpenChords = song.HasOpenChords();                      if (song.HasOpenChords()) AssociateTechniques(x' attribute' "ChordIntro");                      attribute.DoubleStops = song.HasDoubleStops();                      if (song.HasDoubleStops()) AssociateTechniques(x' attribute' "DoubleStops");                      attribute.Sustain = song.HasSustain();                      if (song.HasSustain()) AssociateTechniques(x' attribute' "Sustain");                      attribute.Bends = song.HasBends();                      if (song.HasBends()) AssociateTechniques(x' attribute' "Bends");                      attribute.Slides = song.HasSlides();                      if (song.HasSlides()) AssociateTechniques(x' attribute' "Slides");                      attribute.Tremolo = song.HasTremolo();                      if (song.HasTremolo()) AssociateTechniques(x' attribute' "Tremolo");                      attribute.SlapAndPop = song.HasSlapAndPop();                      if (song.HasSlapAndPop()) AssociateTechniques(x' attribute' "Slap");                      attribute.Harmonics = song.HasHarmonics();                      if (song.HasHarmonics()) AssociateTechniques(x' attribute' "Harmonics");                      attribute.PalmMutes = song.HasPalmMutes();                      if (song.HasPalmMutes()) AssociateTechniques(x' attribute' "PalmMutes");                      attribute.HOPOs = song.HasHOPOs();                      if (song.HasHOPOs()) AssociateTechniques(x' attribute' "HOPOs");                      attribute.FretHandMutes = song.HasFretHandMutes();                      if (song.HasFretHandMutes()) AssociateTechniques(x' attribute' "FretHandMutes");                      attribute.DropDPowerChords = song.HasDropDPowerChords();                      if (song.HasDropDPowerChords()) AssociateTechniques(x' attribute' "DropDPowerChords");                      attribute.Prebends = song.HasPrebends();                      if (song.HasPrebends()) AssociateTechniques(x' attribute' "Prebends");                      attribute.Vibrato = song.HasVibrato();                      if (song.HasVibrato()) AssociateTechniques(x' attribute' "Vibrato");                        //Bass exclusive                      attribute.TwoFingerPlucking = song.HasTwoFingerPlucking();                      if (song.HasTwoFingerPlucking()) AssociateTechniques(x' attribute' "Plucking");                      attribute.FifthsAndOctaves = song.HasFifthsAndOctaves();                      if (song.HasFifthsAndOctaves()) AssociateTechniques(x' attribute' "Octave");                      attribute.Syncopation = song.HasSyncopation();                      if (song.HasSyncopation()) AssociateTechniques(x' attribute' "Syncopation");                        #endregion                        attribute.AverageTempo = songInfo.AverageTempo;                      attribute.RepresentativeArrangement = true;                      attribute.SongPartition = songPartition.GetSongPartition(x.Name' x.ArrangementType);                      attribute.SongLength = (float)Math.Round((decimal)song.SongLength' 3' MidpointRounding.AwayFromZero); //rounded                      attribute.LastConversionDateTime = song.LastConversionDateTime;                      attribute.TargetScore = 100000;                      attribute.ToneUnlockScore = 70000;                      attribute.SongDifficulty = (float)song.PhraseIterations.Average(it => song.Phrases[it.PhraseId].MaxDifficulty);                      manifestFunctions.GenerateChordTemplateData(attribute' song);                      manifestFunctions.GeneratePhraseData(attribute' song);                      manifestFunctions.GenerateSectionData(attribute' song);                      manifestFunctions.GeneratePhraseIterationsData(attribute' song' platform.version);                  }                  var attrDict = new Dictionary<string' Attributes> { { "Attributes"' attribute } };                  manifest.Entries.Add(attribute.PersistentID' attrDict);              }
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest,ManifestBuilder,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\ManifestBuilder.cs,GenerateManifest,The following statement contains a magic number: manifest.IterationVersion = 2;
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest.Tone,Manifest,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Tone\Manifest.cs,Manifest,The following statement contains a magic number: IterationVersion = 2;
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest.Tone,Tone,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Tone\Tone.cs,Tone,The following statement contains a magic number: Volume = -12;
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest.Tone,Tone,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Tone\Tone.cs,Transform,The following statement contains a magic number: if (name.Equals("Pedal") && num == 2 && !Keys.Contains("Amp") && !Keys.Contains("Cabinet") && !Keys.Contains("PostPedal1"))              {                  num += 1;                  Keys.Add("PostPedal1");                  return "PostPedal1";              }
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest.Tone,Tone,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Tone\Tone.cs,Transform,The following statement contains a magic number: if (name.Equals("Pedal") && num >= 2 && !Keys.Contains("Amp") && Keys.Contains("Cabinet") && !Keys.Contains("LoopPedal2"))              {                  num += 1;                  Keys.Add("LoopPedal2");                  return "LoopPedal2";              }
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest.Tone,Tone,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Tone\Tone.cs,Transform,The following statement contains a magic number: if (name.Equals("Pedal") && num >= 3 && !Keys.Contains("Amp") && Keys.Contains("Cabinet") && !Keys.Contains("LoopPedal1"))              {                  num += 1;                  Keys.Add("LoopPedal1");                  return "LoopPedal1";              }
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest.Tone,Tone,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Tone\Tone.cs,Transform,The following statement contains a magic number: if (name.Equals("Pedal") && num >= 2 && Keys.Contains("Cabinet") && Keys.Contains("Amp") && !Keys.Contains("PrePedal3"))              {                  num += 1;                  Keys.Add("PrePedal3");                  return "PrePedal3";              }
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest.Tone,Tone,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Tone\Tone.cs,Transform,The following statement contains a magic number: if (name.Equals("Pedal") && num >= 3 && Keys.Contains("Cabinet") && Keys.Contains("Amp") && !Keys.Contains("PrePedal2"))              {                  num += 1;                  Keys.Add("PrePedal2");                  return "PrePedal2";              }
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest.Tone,Tone,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Tone\Tone.cs,Transform,The following statement contains a magic number: if (name.Equals("Pedal") && num >= 4 && Keys.Contains("Cabinet") && Keys.Contains("Amp") && !Keys.Contains("PrePedal1"))              {                  num += 1;                  Keys.Add("PrePedal1");                  return "PrePedal1";              }              else { throw new Exception("You have choose invalid RS tone file or something else!"); }
Magic Number,RocksmithToolkitLib.XmlRepository,ConfigComparer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XmlRepository\ConfigRepository.cs,GetHashCode,The following statement contains a magic number: return obj.Key.GetHashCode() * 397;
Magic Number,RocksmithToolkitLib.XmlRepository,TuningDefinition,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XmlRepository\TuningDefinition.cs,NoteName,The following statement contains a magic number: var id = Sng2014FileWriter.GetMidiNote(tuning.ToArray()' s' 0' false' 0) % 12;
Magic Number,RocksmithToolkitLib.XmlRepository,TuningDefinition,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XmlRepository\TuningDefinition.cs,NameFromStrings,The following statement contains a magic number: switch (GetTuningFamily(t))              {                  case TuningFamily.Standard:                      noteName = string.Format("{0} Standard"' NoteName(tuning' 0' flats));                      break;                  case TuningFamily.Drop:                      noteName = string.Format("{0} Drop {1}"' NoteName(tuning' 5' true)' NoteName(tuning' 0' flats));                      break;                  case TuningFamily.Open:                      break;                  default:                      for (Byte s = 0; s < 6; s++)                          noteName += NoteName(tuning' s' flats);                      break;              }
Magic Number,RocksmithToolkitLib.XmlRepository,TuningDefinition,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XmlRepository\TuningDefinition.cs,NameFromStrings,The following statement contains a magic number: switch (GetTuningFamily(t))              {                  case TuningFamily.Standard:                      noteName = string.Format("{0} Standard"' NoteName(tuning' 0' flats));                      break;                  case TuningFamily.Drop:                      noteName = string.Format("{0} Drop {1}"' NoteName(tuning' 5' true)' NoteName(tuning' 0' flats));                      break;                  case TuningFamily.Open:                      break;                  default:                      for (Byte s = 0; s < 6; s++)                          noteName += NoteName(tuning' s' flats);                      break;              }
Magic Number,RocksmithToolkitLib.XmlRepository,TuningDefinition,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XmlRepository\TuningDefinition.cs,GetTuningFamily,The following statement contains a magic number: if (t[1] != t[2] || t[2] != t[3] || t[3] != t[4] || t[4] != t[5])                  return TuningFamily.None;
Magic Number,RocksmithToolkitLib.XmlRepository,TuningDefinition,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XmlRepository\TuningDefinition.cs,GetTuningFamily,The following statement contains a magic number: if (t[1] != t[2] || t[2] != t[3] || t[3] != t[4] || t[4] != t[5])                  return TuningFamily.None;
Magic Number,RocksmithToolkitLib.XmlRepository,TuningDefinition,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XmlRepository\TuningDefinition.cs,GetTuningFamily,The following statement contains a magic number: if (t[1] != t[2] || t[2] != t[3] || t[3] != t[4] || t[4] != t[5])                  return TuningFamily.None;
Magic Number,RocksmithToolkitLib.XmlRepository,TuningDefinition,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XmlRepository\TuningDefinition.cs,GetTuningFamily,The following statement contains a magic number: if (t[1] != t[2] || t[2] != t[3] || t[3] != t[4] || t[4] != t[5])                  return TuningFamily.None;
Magic Number,RocksmithToolkitLib.XmlRepository,TuningDefinition,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XmlRepository\TuningDefinition.cs,GetTuningFamily,The following statement contains a magic number: if (t[1] != t[2] || t[2] != t[3] || t[3] != t[4] || t[4] != t[5])                  return TuningFamily.None;
Magic Number,RocksmithToolkitLib.XmlRepository,TuningDefinition,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XmlRepository\TuningDefinition.cs,GetTuningFamily,The following statement contains a magic number: if (t[1] != t[2] || t[2] != t[3] || t[3] != t[4] || t[4] != t[5])                  return TuningFamily.None;
Magic Number,RocksmithToolkitLib.XmlRepository,TuningDefinition,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XmlRepository\TuningDefinition.cs,GetTuningFamily,The following statement contains a magic number: if (t[1] != t[2] || t[2] != t[3] || t[3] != t[4] || t[4] != t[5])                  return TuningFamily.None;
Magic Number,RocksmithToolkitLib.XmlRepository,TuningDefinition,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XmlRepository\TuningDefinition.cs,GetTuningFamily,The following statement contains a magic number: if (t[0] + 2 == t[1])                  return TuningFamily.Drop;
Magic Number,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,AdjustShowlights,The following statement contains a magic number: if (showlightList.Count > 2 && !defaultShowlights)              {                  // remove notes that appear too early' showlights start at 10 seconds                  showlightList = showlightList.Where(s => s.Time >= 10.0F).ToList();                    // using bottoms up approach                  for (var i = showlightList.Count - 1; i > 0; i--)                  {                      // replace any bad/unknown notes: ranges 0-23' 36-41' 43-47' 60-65' 68-128                      if ((showlightList[i].Note > -1 && showlightList[i].Note < 24) ||                          (showlightList[i].Note > 35 && showlightList[i].Note < 42) ||                          (showlightList[i].Note > 42 && showlightList[i].Note < 48) ||                          (showlightList[i].Note > 59 && showlightList[i].Note < 66) ||                          (showlightList[i].Note > 67 && showlightList[i].Note < 128))                      {                          if (showlightList[i].Note < 48)                              showlightList[i].Note = GetFogNote(showlightList[i].Note);                            if (showlightList[i].Note > 59)                              showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      }                        // remove any back to back duplicate notes                      if (i < showlightList.Count - 1)                          if (showlightList[i].Note == showlightList[i + 1].Note)                          {                              showlightList.RemoveAt(i + 1);                              continue; // must be used                          }                        if (showlightList[i].Note == showlightList[i - 1].Note)                      {                          showlightList.RemoveAt(i);                          continue; // must be used                      }                        //// for testing music swell/solo effect                      //// Change FogNote to BeamNote when third of octive changes occure (quasi solo swell effect) not really                      //if ((showlightList[i].Note > 23 && showlightList[i].Note < 36) && (showlightList[i - 1].Note > 23 && showlightList[i - 1].Note < 36))                      //{                      //    if (Math.Abs(showlightList[i].Note - showlightList[i - 1].Note) > 3)                      //    {                      //        if (i % 2 == 0)                      //        {                      //            showlightList[i - 1].Note = 67; // turn off laser                      //            showlightList[i].Note = 66;                      //        }                      //        else                      //        {                      //            showlightList[i - 1].Note = 42; // spots off                      //            showlightList[i].Note = 52; // blue spot                      //        }                      //    }                      //}                        //// for testing laser                      //if (showlightList[i].Note > 67)                      //{                      //    showlightList[i - 1].Note = 66; // turn on laser                      //    showlightList[i].Note = 52; // blue spots back                      //}                        //// for testing randomize after 12 effects                      //if (i % 12 == 0)                      //{                      //    showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      //    showlightList[i - 1].Note = GetFogNote(showlightList[i - 1].Note);                      //}                  }                    // for testing overall laser activation                  var laserDeactivated = showlightList.Where(x => x.Note == 67).Any();                  var laserActived = showlightList.Where(x => x.Note == 66).Any();                  // turns on laser and searchlight effects for entire song if no other laser on was present                              if (!laserActived)                  {                      showlightList.Add(new Showlight { Note = GetBeamNote(showlightList[showlightList.Count - 1].Note)' Time = showlightList[showlightList.Count - 1].Time });                      showlightList[showlightList.Count - 2].Note = 66;                  }                    // initialize first two elements of showlights with Fog and Beam                  // nothing else seems to matter if initialization is done properly                  if (showlightList[0].Time > 10.0F)                      showlightList.Insert(0' new Showlight { Note = GetFogNote(showlightList[0].Note)' Time = 10.0F });                    if (showlightList[0].Note < 24 || showlightList[0].Note > 35)                      showlightList[0].Note = GetFogNote(showlightList[0].Note);                    if (showlightList[1].Note < 48 || showlightList[1].Note > 59)                      showlightList[1].Note = GetBeamNote(showlightList[1].Note);              }              else              {                  // create minimum default showlights                  showlightList.Clear();                  showlightList.Add(new Showlight { Note = 28' Time = 10.0F });                  showlightList.Add(new Showlight { Note = 52' Time = 10.1F });              }
Magic Number,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,AdjustShowlights,The following statement contains a magic number: if (showlightList.Count > 2 && !defaultShowlights)              {                  // remove notes that appear too early' showlights start at 10 seconds                  showlightList = showlightList.Where(s => s.Time >= 10.0F).ToList();                    // using bottoms up approach                  for (var i = showlightList.Count - 1; i > 0; i--)                  {                      // replace any bad/unknown notes: ranges 0-23' 36-41' 43-47' 60-65' 68-128                      if ((showlightList[i].Note > -1 && showlightList[i].Note < 24) ||                          (showlightList[i].Note > 35 && showlightList[i].Note < 42) ||                          (showlightList[i].Note > 42 && showlightList[i].Note < 48) ||                          (showlightList[i].Note > 59 && showlightList[i].Note < 66) ||                          (showlightList[i].Note > 67 && showlightList[i].Note < 128))                      {                          if (showlightList[i].Note < 48)                              showlightList[i].Note = GetFogNote(showlightList[i].Note);                            if (showlightList[i].Note > 59)                              showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      }                        // remove any back to back duplicate notes                      if (i < showlightList.Count - 1)                          if (showlightList[i].Note == showlightList[i + 1].Note)                          {                              showlightList.RemoveAt(i + 1);                              continue; // must be used                          }                        if (showlightList[i].Note == showlightList[i - 1].Note)                      {                          showlightList.RemoveAt(i);                          continue; // must be used                      }                        //// for testing music swell/solo effect                      //// Change FogNote to BeamNote when third of octive changes occure (quasi solo swell effect) not really                      //if ((showlightList[i].Note > 23 && showlightList[i].Note < 36) && (showlightList[i - 1].Note > 23 && showlightList[i - 1].Note < 36))                      //{                      //    if (Math.Abs(showlightList[i].Note - showlightList[i - 1].Note) > 3)                      //    {                      //        if (i % 2 == 0)                      //        {                      //            showlightList[i - 1].Note = 67; // turn off laser                      //            showlightList[i].Note = 66;                      //        }                      //        else                      //        {                      //            showlightList[i - 1].Note = 42; // spots off                      //            showlightList[i].Note = 52; // blue spot                      //        }                      //    }                      //}                        //// for testing laser                      //if (showlightList[i].Note > 67)                      //{                      //    showlightList[i - 1].Note = 66; // turn on laser                      //    showlightList[i].Note = 52; // blue spots back                      //}                        //// for testing randomize after 12 effects                      //if (i % 12 == 0)                      //{                      //    showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      //    showlightList[i - 1].Note = GetFogNote(showlightList[i - 1].Note);                      //}                  }                    // for testing overall laser activation                  var laserDeactivated = showlightList.Where(x => x.Note == 67).Any();                  var laserActived = showlightList.Where(x => x.Note == 66).Any();                  // turns on laser and searchlight effects for entire song if no other laser on was present                              if (!laserActived)                  {                      showlightList.Add(new Showlight { Note = GetBeamNote(showlightList[showlightList.Count - 1].Note)' Time = showlightList[showlightList.Count - 1].Time });                      showlightList[showlightList.Count - 2].Note = 66;                  }                    // initialize first two elements of showlights with Fog and Beam                  // nothing else seems to matter if initialization is done properly                  if (showlightList[0].Time > 10.0F)                      showlightList.Insert(0' new Showlight { Note = GetFogNote(showlightList[0].Note)' Time = 10.0F });                    if (showlightList[0].Note < 24 || showlightList[0].Note > 35)                      showlightList[0].Note = GetFogNote(showlightList[0].Note);                    if (showlightList[1].Note < 48 || showlightList[1].Note > 59)                      showlightList[1].Note = GetBeamNote(showlightList[1].Note);              }              else              {                  // create minimum default showlights                  showlightList.Clear();                  showlightList.Add(new Showlight { Note = 28' Time = 10.0F });                  showlightList.Add(new Showlight { Note = 52' Time = 10.1F });              }
Magic Number,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,AdjustShowlights,The following statement contains a magic number: if (showlightList.Count > 2 && !defaultShowlights)              {                  // remove notes that appear too early' showlights start at 10 seconds                  showlightList = showlightList.Where(s => s.Time >= 10.0F).ToList();                    // using bottoms up approach                  for (var i = showlightList.Count - 1; i > 0; i--)                  {                      // replace any bad/unknown notes: ranges 0-23' 36-41' 43-47' 60-65' 68-128                      if ((showlightList[i].Note > -1 && showlightList[i].Note < 24) ||                          (showlightList[i].Note > 35 && showlightList[i].Note < 42) ||                          (showlightList[i].Note > 42 && showlightList[i].Note < 48) ||                          (showlightList[i].Note > 59 && showlightList[i].Note < 66) ||                          (showlightList[i].Note > 67 && showlightList[i].Note < 128))                      {                          if (showlightList[i].Note < 48)                              showlightList[i].Note = GetFogNote(showlightList[i].Note);                            if (showlightList[i].Note > 59)                              showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      }                        // remove any back to back duplicate notes                      if (i < showlightList.Count - 1)                          if (showlightList[i].Note == showlightList[i + 1].Note)                          {                              showlightList.RemoveAt(i + 1);                              continue; // must be used                          }                        if (showlightList[i].Note == showlightList[i - 1].Note)                      {                          showlightList.RemoveAt(i);                          continue; // must be used                      }                        //// for testing music swell/solo effect                      //// Change FogNote to BeamNote when third of octive changes occure (quasi solo swell effect) not really                      //if ((showlightList[i].Note > 23 && showlightList[i].Note < 36) && (showlightList[i - 1].Note > 23 && showlightList[i - 1].Note < 36))                      //{                      //    if (Math.Abs(showlightList[i].Note - showlightList[i - 1].Note) > 3)                      //    {                      //        if (i % 2 == 0)                      //        {                      //            showlightList[i - 1].Note = 67; // turn off laser                      //            showlightList[i].Note = 66;                      //        }                      //        else                      //        {                      //            showlightList[i - 1].Note = 42; // spots off                      //            showlightList[i].Note = 52; // blue spot                      //        }                      //    }                      //}                        //// for testing laser                      //if (showlightList[i].Note > 67)                      //{                      //    showlightList[i - 1].Note = 66; // turn on laser                      //    showlightList[i].Note = 52; // blue spots back                      //}                        //// for testing randomize after 12 effects                      //if (i % 12 == 0)                      //{                      //    showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      //    showlightList[i - 1].Note = GetFogNote(showlightList[i - 1].Note);                      //}                  }                    // for testing overall laser activation                  var laserDeactivated = showlightList.Where(x => x.Note == 67).Any();                  var laserActived = showlightList.Where(x => x.Note == 66).Any();                  // turns on laser and searchlight effects for entire song if no other laser on was present                              if (!laserActived)                  {                      showlightList.Add(new Showlight { Note = GetBeamNote(showlightList[showlightList.Count - 1].Note)' Time = showlightList[showlightList.Count - 1].Time });                      showlightList[showlightList.Count - 2].Note = 66;                  }                    // initialize first two elements of showlights with Fog and Beam                  // nothing else seems to matter if initialization is done properly                  if (showlightList[0].Time > 10.0F)                      showlightList.Insert(0' new Showlight { Note = GetFogNote(showlightList[0].Note)' Time = 10.0F });                    if (showlightList[0].Note < 24 || showlightList[0].Note > 35)                      showlightList[0].Note = GetFogNote(showlightList[0].Note);                    if (showlightList[1].Note < 48 || showlightList[1].Note > 59)                      showlightList[1].Note = GetBeamNote(showlightList[1].Note);              }              else              {                  // create minimum default showlights                  showlightList.Clear();                  showlightList.Add(new Showlight { Note = 28' Time = 10.0F });                  showlightList.Add(new Showlight { Note = 52' Time = 10.1F });              }
Magic Number,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,AdjustShowlights,The following statement contains a magic number: if (showlightList.Count > 2 && !defaultShowlights)              {                  // remove notes that appear too early' showlights start at 10 seconds                  showlightList = showlightList.Where(s => s.Time >= 10.0F).ToList();                    // using bottoms up approach                  for (var i = showlightList.Count - 1; i > 0; i--)                  {                      // replace any bad/unknown notes: ranges 0-23' 36-41' 43-47' 60-65' 68-128                      if ((showlightList[i].Note > -1 && showlightList[i].Note < 24) ||                          (showlightList[i].Note > 35 && showlightList[i].Note < 42) ||                          (showlightList[i].Note > 42 && showlightList[i].Note < 48) ||                          (showlightList[i].Note > 59 && showlightList[i].Note < 66) ||                          (showlightList[i].Note > 67 && showlightList[i].Note < 128))                      {                          if (showlightList[i].Note < 48)                              showlightList[i].Note = GetFogNote(showlightList[i].Note);                            if (showlightList[i].Note > 59)                              showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      }                        // remove any back to back duplicate notes                      if (i < showlightList.Count - 1)                          if (showlightList[i].Note == showlightList[i + 1].Note)                          {                              showlightList.RemoveAt(i + 1);                              continue; // must be used                          }                        if (showlightList[i].Note == showlightList[i - 1].Note)                      {                          showlightList.RemoveAt(i);                          continue; // must be used                      }                        //// for testing music swell/solo effect                      //// Change FogNote to BeamNote when third of octive changes occure (quasi solo swell effect) not really                      //if ((showlightList[i].Note > 23 && showlightList[i].Note < 36) && (showlightList[i - 1].Note > 23 && showlightList[i - 1].Note < 36))                      //{                      //    if (Math.Abs(showlightList[i].Note - showlightList[i - 1].Note) > 3)                      //    {                      //        if (i % 2 == 0)                      //        {                      //            showlightList[i - 1].Note = 67; // turn off laser                      //            showlightList[i].Note = 66;                      //        }                      //        else                      //        {                      //            showlightList[i - 1].Note = 42; // spots off                      //            showlightList[i].Note = 52; // blue spot                      //        }                      //    }                      //}                        //// for testing laser                      //if (showlightList[i].Note > 67)                      //{                      //    showlightList[i - 1].Note = 66; // turn on laser                      //    showlightList[i].Note = 52; // blue spots back                      //}                        //// for testing randomize after 12 effects                      //if (i % 12 == 0)                      //{                      //    showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      //    showlightList[i - 1].Note = GetFogNote(showlightList[i - 1].Note);                      //}                  }                    // for testing overall laser activation                  var laserDeactivated = showlightList.Where(x => x.Note == 67).Any();                  var laserActived = showlightList.Where(x => x.Note == 66).Any();                  // turns on laser and searchlight effects for entire song if no other laser on was present                              if (!laserActived)                  {                      showlightList.Add(new Showlight { Note = GetBeamNote(showlightList[showlightList.Count - 1].Note)' Time = showlightList[showlightList.Count - 1].Time });                      showlightList[showlightList.Count - 2].Note = 66;                  }                    // initialize first two elements of showlights with Fog and Beam                  // nothing else seems to matter if initialization is done properly                  if (showlightList[0].Time > 10.0F)                      showlightList.Insert(0' new Showlight { Note = GetFogNote(showlightList[0].Note)' Time = 10.0F });                    if (showlightList[0].Note < 24 || showlightList[0].Note > 35)                      showlightList[0].Note = GetFogNote(showlightList[0].Note);                    if (showlightList[1].Note < 48 || showlightList[1].Note > 59)                      showlightList[1].Note = GetBeamNote(showlightList[1].Note);              }              else              {                  // create minimum default showlights                  showlightList.Clear();                  showlightList.Add(new Showlight { Note = 28' Time = 10.0F });                  showlightList.Add(new Showlight { Note = 52' Time = 10.1F });              }
Magic Number,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,AdjustShowlights,The following statement contains a magic number: if (showlightList.Count > 2 && !defaultShowlights)              {                  // remove notes that appear too early' showlights start at 10 seconds                  showlightList = showlightList.Where(s => s.Time >= 10.0F).ToList();                    // using bottoms up approach                  for (var i = showlightList.Count - 1; i > 0; i--)                  {                      // replace any bad/unknown notes: ranges 0-23' 36-41' 43-47' 60-65' 68-128                      if ((showlightList[i].Note > -1 && showlightList[i].Note < 24) ||                          (showlightList[i].Note > 35 && showlightList[i].Note < 42) ||                          (showlightList[i].Note > 42 && showlightList[i].Note < 48) ||                          (showlightList[i].Note > 59 && showlightList[i].Note < 66) ||                          (showlightList[i].Note > 67 && showlightList[i].Note < 128))                      {                          if (showlightList[i].Note < 48)                              showlightList[i].Note = GetFogNote(showlightList[i].Note);                            if (showlightList[i].Note > 59)                              showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      }                        // remove any back to back duplicate notes                      if (i < showlightList.Count - 1)                          if (showlightList[i].Note == showlightList[i + 1].Note)                          {                              showlightList.RemoveAt(i + 1);                              continue; // must be used                          }                        if (showlightList[i].Note == showlightList[i - 1].Note)                      {                          showlightList.RemoveAt(i);                          continue; // must be used                      }                        //// for testing music swell/solo effect                      //// Change FogNote to BeamNote when third of octive changes occure (quasi solo swell effect) not really                      //if ((showlightList[i].Note > 23 && showlightList[i].Note < 36) && (showlightList[i - 1].Note > 23 && showlightList[i - 1].Note < 36))                      //{                      //    if (Math.Abs(showlightList[i].Note - showlightList[i - 1].Note) > 3)                      //    {                      //        if (i % 2 == 0)                      //        {                      //            showlightList[i - 1].Note = 67; // turn off laser                      //            showlightList[i].Note = 66;                      //        }                      //        else                      //        {                      //            showlightList[i - 1].Note = 42; // spots off                      //            showlightList[i].Note = 52; // blue spot                      //        }                      //    }                      //}                        //// for testing laser                      //if (showlightList[i].Note > 67)                      //{                      //    showlightList[i - 1].Note = 66; // turn on laser                      //    showlightList[i].Note = 52; // blue spots back                      //}                        //// for testing randomize after 12 effects                      //if (i % 12 == 0)                      //{                      //    showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      //    showlightList[i - 1].Note = GetFogNote(showlightList[i - 1].Note);                      //}                  }                    // for testing overall laser activation                  var laserDeactivated = showlightList.Where(x => x.Note == 67).Any();                  var laserActived = showlightList.Where(x => x.Note == 66).Any();                  // turns on laser and searchlight effects for entire song if no other laser on was present                              if (!laserActived)                  {                      showlightList.Add(new Showlight { Note = GetBeamNote(showlightList[showlightList.Count - 1].Note)' Time = showlightList[showlightList.Count - 1].Time });                      showlightList[showlightList.Count - 2].Note = 66;                  }                    // initialize first two elements of showlights with Fog and Beam                  // nothing else seems to matter if initialization is done properly                  if (showlightList[0].Time > 10.0F)                      showlightList.Insert(0' new Showlight { Note = GetFogNote(showlightList[0].Note)' Time = 10.0F });                    if (showlightList[0].Note < 24 || showlightList[0].Note > 35)                      showlightList[0].Note = GetFogNote(showlightList[0].Note);                    if (showlightList[1].Note < 48 || showlightList[1].Note > 59)                      showlightList[1].Note = GetBeamNote(showlightList[1].Note);              }              else              {                  // create minimum default showlights                  showlightList.Clear();                  showlightList.Add(new Showlight { Note = 28' Time = 10.0F });                  showlightList.Add(new Showlight { Note = 52' Time = 10.1F });              }
Magic Number,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,AdjustShowlights,The following statement contains a magic number: if (showlightList.Count > 2 && !defaultShowlights)              {                  // remove notes that appear too early' showlights start at 10 seconds                  showlightList = showlightList.Where(s => s.Time >= 10.0F).ToList();                    // using bottoms up approach                  for (var i = showlightList.Count - 1; i > 0; i--)                  {                      // replace any bad/unknown notes: ranges 0-23' 36-41' 43-47' 60-65' 68-128                      if ((showlightList[i].Note > -1 && showlightList[i].Note < 24) ||                          (showlightList[i].Note > 35 && showlightList[i].Note < 42) ||                          (showlightList[i].Note > 42 && showlightList[i].Note < 48) ||                          (showlightList[i].Note > 59 && showlightList[i].Note < 66) ||                          (showlightList[i].Note > 67 && showlightList[i].Note < 128))                      {                          if (showlightList[i].Note < 48)                              showlightList[i].Note = GetFogNote(showlightList[i].Note);                            if (showlightList[i].Note > 59)                              showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      }                        // remove any back to back duplicate notes                      if (i < showlightList.Count - 1)                          if (showlightList[i].Note == showlightList[i + 1].Note)                          {                              showlightList.RemoveAt(i + 1);                              continue; // must be used                          }                        if (showlightList[i].Note == showlightList[i - 1].Note)                      {                          showlightList.RemoveAt(i);                          continue; // must be used                      }                        //// for testing music swell/solo effect                      //// Change FogNote to BeamNote when third of octive changes occure (quasi solo swell effect) not really                      //if ((showlightList[i].Note > 23 && showlightList[i].Note < 36) && (showlightList[i - 1].Note > 23 && showlightList[i - 1].Note < 36))                      //{                      //    if (Math.Abs(showlightList[i].Note - showlightList[i - 1].Note) > 3)                      //    {                      //        if (i % 2 == 0)                      //        {                      //            showlightList[i - 1].Note = 67; // turn off laser                      //            showlightList[i].Note = 66;                      //        }                      //        else                      //        {                      //            showlightList[i - 1].Note = 42; // spots off                      //            showlightList[i].Note = 52; // blue spot                      //        }                      //    }                      //}                        //// for testing laser                      //if (showlightList[i].Note > 67)                      //{                      //    showlightList[i - 1].Note = 66; // turn on laser                      //    showlightList[i].Note = 52; // blue spots back                      //}                        //// for testing randomize after 12 effects                      //if (i % 12 == 0)                      //{                      //    showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      //    showlightList[i - 1].Note = GetFogNote(showlightList[i - 1].Note);                      //}                  }                    // for testing overall laser activation                  var laserDeactivated = showlightList.Where(x => x.Note == 67).Any();                  var laserActived = showlightList.Where(x => x.Note == 66).Any();                  // turns on laser and searchlight effects for entire song if no other laser on was present                              if (!laserActived)                  {                      showlightList.Add(new Showlight { Note = GetBeamNote(showlightList[showlightList.Count - 1].Note)' Time = showlightList[showlightList.Count - 1].Time });                      showlightList[showlightList.Count - 2].Note = 66;                  }                    // initialize first two elements of showlights with Fog and Beam                  // nothing else seems to matter if initialization is done properly                  if (showlightList[0].Time > 10.0F)                      showlightList.Insert(0' new Showlight { Note = GetFogNote(showlightList[0].Note)' Time = 10.0F });                    if (showlightList[0].Note < 24 || showlightList[0].Note > 35)                      showlightList[0].Note = GetFogNote(showlightList[0].Note);                    if (showlightList[1].Note < 48 || showlightList[1].Note > 59)                      showlightList[1].Note = GetBeamNote(showlightList[1].Note);              }              else              {                  // create minimum default showlights                  showlightList.Clear();                  showlightList.Add(new Showlight { Note = 28' Time = 10.0F });                  showlightList.Add(new Showlight { Note = 52' Time = 10.1F });              }
Magic Number,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,AdjustShowlights,The following statement contains a magic number: if (showlightList.Count > 2 && !defaultShowlights)              {                  // remove notes that appear too early' showlights start at 10 seconds                  showlightList = showlightList.Where(s => s.Time >= 10.0F).ToList();                    // using bottoms up approach                  for (var i = showlightList.Count - 1; i > 0; i--)                  {                      // replace any bad/unknown notes: ranges 0-23' 36-41' 43-47' 60-65' 68-128                      if ((showlightList[i].Note > -1 && showlightList[i].Note < 24) ||                          (showlightList[i].Note > 35 && showlightList[i].Note < 42) ||                          (showlightList[i].Note > 42 && showlightList[i].Note < 48) ||                          (showlightList[i].Note > 59 && showlightList[i].Note < 66) ||                          (showlightList[i].Note > 67 && showlightList[i].Note < 128))                      {                          if (showlightList[i].Note < 48)                              showlightList[i].Note = GetFogNote(showlightList[i].Note);                            if (showlightList[i].Note > 59)                              showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      }                        // remove any back to back duplicate notes                      if (i < showlightList.Count - 1)                          if (showlightList[i].Note == showlightList[i + 1].Note)                          {                              showlightList.RemoveAt(i + 1);                              continue; // must be used                          }                        if (showlightList[i].Note == showlightList[i - 1].Note)                      {                          showlightList.RemoveAt(i);                          continue; // must be used                      }                        //// for testing music swell/solo effect                      //// Change FogNote to BeamNote when third of octive changes occure (quasi solo swell effect) not really                      //if ((showlightList[i].Note > 23 && showlightList[i].Note < 36) && (showlightList[i - 1].Note > 23 && showlightList[i - 1].Note < 36))                      //{                      //    if (Math.Abs(showlightList[i].Note - showlightList[i - 1].Note) > 3)                      //    {                      //        if (i % 2 == 0)                      //        {                      //            showlightList[i - 1].Note = 67; // turn off laser                      //            showlightList[i].Note = 66;                      //        }                      //        else                      //        {                      //            showlightList[i - 1].Note = 42; // spots off                      //            showlightList[i].Note = 52; // blue spot                      //        }                      //    }                      //}                        //// for testing laser                      //if (showlightList[i].Note > 67)                      //{                      //    showlightList[i - 1].Note = 66; // turn on laser                      //    showlightList[i].Note = 52; // blue spots back                      //}                        //// for testing randomize after 12 effects                      //if (i % 12 == 0)                      //{                      //    showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      //    showlightList[i - 1].Note = GetFogNote(showlightList[i - 1].Note);                      //}                  }                    // for testing overall laser activation                  var laserDeactivated = showlightList.Where(x => x.Note == 67).Any();                  var laserActived = showlightList.Where(x => x.Note == 66).Any();                  // turns on laser and searchlight effects for entire song if no other laser on was present                              if (!laserActived)                  {                      showlightList.Add(new Showlight { Note = GetBeamNote(showlightList[showlightList.Count - 1].Note)' Time = showlightList[showlightList.Count - 1].Time });                      showlightList[showlightList.Count - 2].Note = 66;                  }                    // initialize first two elements of showlights with Fog and Beam                  // nothing else seems to matter if initialization is done properly                  if (showlightList[0].Time > 10.0F)                      showlightList.Insert(0' new Showlight { Note = GetFogNote(showlightList[0].Note)' Time = 10.0F });                    if (showlightList[0].Note < 24 || showlightList[0].Note > 35)                      showlightList[0].Note = GetFogNote(showlightList[0].Note);                    if (showlightList[1].Note < 48 || showlightList[1].Note > 59)                      showlightList[1].Note = GetBeamNote(showlightList[1].Note);              }              else              {                  // create minimum default showlights                  showlightList.Clear();                  showlightList.Add(new Showlight { Note = 28' Time = 10.0F });                  showlightList.Add(new Showlight { Note = 52' Time = 10.1F });              }
Magic Number,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,AdjustShowlights,The following statement contains a magic number: if (showlightList.Count > 2 && !defaultShowlights)              {                  // remove notes that appear too early' showlights start at 10 seconds                  showlightList = showlightList.Where(s => s.Time >= 10.0F).ToList();                    // using bottoms up approach                  for (var i = showlightList.Count - 1; i > 0; i--)                  {                      // replace any bad/unknown notes: ranges 0-23' 36-41' 43-47' 60-65' 68-128                      if ((showlightList[i].Note > -1 && showlightList[i].Note < 24) ||                          (showlightList[i].Note > 35 && showlightList[i].Note < 42) ||                          (showlightList[i].Note > 42 && showlightList[i].Note < 48) ||                          (showlightList[i].Note > 59 && showlightList[i].Note < 66) ||                          (showlightList[i].Note > 67 && showlightList[i].Note < 128))                      {                          if (showlightList[i].Note < 48)                              showlightList[i].Note = GetFogNote(showlightList[i].Note);                            if (showlightList[i].Note > 59)                              showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      }                        // remove any back to back duplicate notes                      if (i < showlightList.Count - 1)                          if (showlightList[i].Note == showlightList[i + 1].Note)                          {                              showlightList.RemoveAt(i + 1);                              continue; // must be used                          }                        if (showlightList[i].Note == showlightList[i - 1].Note)                      {                          showlightList.RemoveAt(i);                          continue; // must be used                      }                        //// for testing music swell/solo effect                      //// Change FogNote to BeamNote when third of octive changes occure (quasi solo swell effect) not really                      //if ((showlightList[i].Note > 23 && showlightList[i].Note < 36) && (showlightList[i - 1].Note > 23 && showlightList[i - 1].Note < 36))                      //{                      //    if (Math.Abs(showlightList[i].Note - showlightList[i - 1].Note) > 3)                      //    {                      //        if (i % 2 == 0)                      //        {                      //            showlightList[i - 1].Note = 67; // turn off laser                      //            showlightList[i].Note = 66;                      //        }                      //        else                      //        {                      //            showlightList[i - 1].Note = 42; // spots off                      //            showlightList[i].Note = 52; // blue spot                      //        }                      //    }                      //}                        //// for testing laser                      //if (showlightList[i].Note > 67)                      //{                      //    showlightList[i - 1].Note = 66; // turn on laser                      //    showlightList[i].Note = 52; // blue spots back                      //}                        //// for testing randomize after 12 effects                      //if (i % 12 == 0)                      //{                      //    showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      //    showlightList[i - 1].Note = GetFogNote(showlightList[i - 1].Note);                      //}                  }                    // for testing overall laser activation                  var laserDeactivated = showlightList.Where(x => x.Note == 67).Any();                  var laserActived = showlightList.Where(x => x.Note == 66).Any();                  // turns on laser and searchlight effects for entire song if no other laser on was present                              if (!laserActived)                  {                      showlightList.Add(new Showlight { Note = GetBeamNote(showlightList[showlightList.Count - 1].Note)' Time = showlightList[showlightList.Count - 1].Time });                      showlightList[showlightList.Count - 2].Note = 66;                  }                    // initialize first two elements of showlights with Fog and Beam                  // nothing else seems to matter if initialization is done properly                  if (showlightList[0].Time > 10.0F)                      showlightList.Insert(0' new Showlight { Note = GetFogNote(showlightList[0].Note)' Time = 10.0F });                    if (showlightList[0].Note < 24 || showlightList[0].Note > 35)                      showlightList[0].Note = GetFogNote(showlightList[0].Note);                    if (showlightList[1].Note < 48 || showlightList[1].Note > 59)                      showlightList[1].Note = GetBeamNote(showlightList[1].Note);              }              else              {                  // create minimum default showlights                  showlightList.Clear();                  showlightList.Add(new Showlight { Note = 28' Time = 10.0F });                  showlightList.Add(new Showlight { Note = 52' Time = 10.1F });              }
Magic Number,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,AdjustShowlights,The following statement contains a magic number: if (showlightList.Count > 2 && !defaultShowlights)              {                  // remove notes that appear too early' showlights start at 10 seconds                  showlightList = showlightList.Where(s => s.Time >= 10.0F).ToList();                    // using bottoms up approach                  for (var i = showlightList.Count - 1; i > 0; i--)                  {                      // replace any bad/unknown notes: ranges 0-23' 36-41' 43-47' 60-65' 68-128                      if ((showlightList[i].Note > -1 && showlightList[i].Note < 24) ||                          (showlightList[i].Note > 35 && showlightList[i].Note < 42) ||                          (showlightList[i].Note > 42 && showlightList[i].Note < 48) ||                          (showlightList[i].Note > 59 && showlightList[i].Note < 66) ||                          (showlightList[i].Note > 67 && showlightList[i].Note < 128))                      {                          if (showlightList[i].Note < 48)                              showlightList[i].Note = GetFogNote(showlightList[i].Note);                            if (showlightList[i].Note > 59)                              showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      }                        // remove any back to back duplicate notes                      if (i < showlightList.Count - 1)                          if (showlightList[i].Note == showlightList[i + 1].Note)                          {                              showlightList.RemoveAt(i + 1);                              continue; // must be used                          }                        if (showlightList[i].Note == showlightList[i - 1].Note)                      {                          showlightList.RemoveAt(i);                          continue; // must be used                      }                        //// for testing music swell/solo effect                      //// Change FogNote to BeamNote when third of octive changes occure (quasi solo swell effect) not really                      //if ((showlightList[i].Note > 23 && showlightList[i].Note < 36) && (showlightList[i - 1].Note > 23 && showlightList[i - 1].Note < 36))                      //{                      //    if (Math.Abs(showlightList[i].Note - showlightList[i - 1].Note) > 3)                      //    {                      //        if (i % 2 == 0)                      //        {                      //            showlightList[i - 1].Note = 67; // turn off laser                      //            showlightList[i].Note = 66;                      //        }                      //        else                      //        {                      //            showlightList[i - 1].Note = 42; // spots off                      //            showlightList[i].Note = 52; // blue spot                      //        }                      //    }                      //}                        //// for testing laser                      //if (showlightList[i].Note > 67)                      //{                      //    showlightList[i - 1].Note = 66; // turn on laser                      //    showlightList[i].Note = 52; // blue spots back                      //}                        //// for testing randomize after 12 effects                      //if (i % 12 == 0)                      //{                      //    showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      //    showlightList[i - 1].Note = GetFogNote(showlightList[i - 1].Note);                      //}                  }                    // for testing overall laser activation                  var laserDeactivated = showlightList.Where(x => x.Note == 67).Any();                  var laserActived = showlightList.Where(x => x.Note == 66).Any();                  // turns on laser and searchlight effects for entire song if no other laser on was present                              if (!laserActived)                  {                      showlightList.Add(new Showlight { Note = GetBeamNote(showlightList[showlightList.Count - 1].Note)' Time = showlightList[showlightList.Count - 1].Time });                      showlightList[showlightList.Count - 2].Note = 66;                  }                    // initialize first two elements of showlights with Fog and Beam                  // nothing else seems to matter if initialization is done properly                  if (showlightList[0].Time > 10.0F)                      showlightList.Insert(0' new Showlight { Note = GetFogNote(showlightList[0].Note)' Time = 10.0F });                    if (showlightList[0].Note < 24 || showlightList[0].Note > 35)                      showlightList[0].Note = GetFogNote(showlightList[0].Note);                    if (showlightList[1].Note < 48 || showlightList[1].Note > 59)                      showlightList[1].Note = GetBeamNote(showlightList[1].Note);              }              else              {                  // create minimum default showlights                  showlightList.Clear();                  showlightList.Add(new Showlight { Note = 28' Time = 10.0F });                  showlightList.Add(new Showlight { Note = 52' Time = 10.1F });              }
Magic Number,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,AdjustShowlights,The following statement contains a magic number: if (showlightList.Count > 2 && !defaultShowlights)              {                  // remove notes that appear too early' showlights start at 10 seconds                  showlightList = showlightList.Where(s => s.Time >= 10.0F).ToList();                    // using bottoms up approach                  for (var i = showlightList.Count - 1; i > 0; i--)                  {                      // replace any bad/unknown notes: ranges 0-23' 36-41' 43-47' 60-65' 68-128                      if ((showlightList[i].Note > -1 && showlightList[i].Note < 24) ||                          (showlightList[i].Note > 35 && showlightList[i].Note < 42) ||                          (showlightList[i].Note > 42 && showlightList[i].Note < 48) ||                          (showlightList[i].Note > 59 && showlightList[i].Note < 66) ||                          (showlightList[i].Note > 67 && showlightList[i].Note < 128))                      {                          if (showlightList[i].Note < 48)                              showlightList[i].Note = GetFogNote(showlightList[i].Note);                            if (showlightList[i].Note > 59)                              showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      }                        // remove any back to back duplicate notes                      if (i < showlightList.Count - 1)                          if (showlightList[i].Note == showlightList[i + 1].Note)                          {                              showlightList.RemoveAt(i + 1);                              continue; // must be used                          }                        if (showlightList[i].Note == showlightList[i - 1].Note)                      {                          showlightList.RemoveAt(i);                          continue; // must be used                      }                        //// for testing music swell/solo effect                      //// Change FogNote to BeamNote when third of octive changes occure (quasi solo swell effect) not really                      //if ((showlightList[i].Note > 23 && showlightList[i].Note < 36) && (showlightList[i - 1].Note > 23 && showlightList[i - 1].Note < 36))                      //{                      //    if (Math.Abs(showlightList[i].Note - showlightList[i - 1].Note) > 3)                      //    {                      //        if (i % 2 == 0)                      //        {                      //            showlightList[i - 1].Note = 67; // turn off laser                      //            showlightList[i].Note = 66;                      //        }                      //        else                      //        {                      //            showlightList[i - 1].Note = 42; // spots off                      //            showlightList[i].Note = 52; // blue spot                      //        }                      //    }                      //}                        //// for testing laser                      //if (showlightList[i].Note > 67)                      //{                      //    showlightList[i - 1].Note = 66; // turn on laser                      //    showlightList[i].Note = 52; // blue spots back                      //}                        //// for testing randomize after 12 effects                      //if (i % 12 == 0)                      //{                      //    showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      //    showlightList[i - 1].Note = GetFogNote(showlightList[i - 1].Note);                      //}                  }                    // for testing overall laser activation                  var laserDeactivated = showlightList.Where(x => x.Note == 67).Any();                  var laserActived = showlightList.Where(x => x.Note == 66).Any();                  // turns on laser and searchlight effects for entire song if no other laser on was present                              if (!laserActived)                  {                      showlightList.Add(new Showlight { Note = GetBeamNote(showlightList[showlightList.Count - 1].Note)' Time = showlightList[showlightList.Count - 1].Time });                      showlightList[showlightList.Count - 2].Note = 66;                  }                    // initialize first two elements of showlights with Fog and Beam                  // nothing else seems to matter if initialization is done properly                  if (showlightList[0].Time > 10.0F)                      showlightList.Insert(0' new Showlight { Note = GetFogNote(showlightList[0].Note)' Time = 10.0F });                    if (showlightList[0].Note < 24 || showlightList[0].Note > 35)                      showlightList[0].Note = GetFogNote(showlightList[0].Note);                    if (showlightList[1].Note < 48 || showlightList[1].Note > 59)                      showlightList[1].Note = GetBeamNote(showlightList[1].Note);              }              else              {                  // create minimum default showlights                  showlightList.Clear();                  showlightList.Add(new Showlight { Note = 28' Time = 10.0F });                  showlightList.Add(new Showlight { Note = 52' Time = 10.1F });              }
Magic Number,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,AdjustShowlights,The following statement contains a magic number: if (showlightList.Count > 2 && !defaultShowlights)              {                  // remove notes that appear too early' showlights start at 10 seconds                  showlightList = showlightList.Where(s => s.Time >= 10.0F).ToList();                    // using bottoms up approach                  for (var i = showlightList.Count - 1; i > 0; i--)                  {                      // replace any bad/unknown notes: ranges 0-23' 36-41' 43-47' 60-65' 68-128                      if ((showlightList[i].Note > -1 && showlightList[i].Note < 24) ||                          (showlightList[i].Note > 35 && showlightList[i].Note < 42) ||                          (showlightList[i].Note > 42 && showlightList[i].Note < 48) ||                          (showlightList[i].Note > 59 && showlightList[i].Note < 66) ||                          (showlightList[i].Note > 67 && showlightList[i].Note < 128))                      {                          if (showlightList[i].Note < 48)                              showlightList[i].Note = GetFogNote(showlightList[i].Note);                            if (showlightList[i].Note > 59)                              showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      }                        // remove any back to back duplicate notes                      if (i < showlightList.Count - 1)                          if (showlightList[i].Note == showlightList[i + 1].Note)                          {                              showlightList.RemoveAt(i + 1);                              continue; // must be used                          }                        if (showlightList[i].Note == showlightList[i - 1].Note)                      {                          showlightList.RemoveAt(i);                          continue; // must be used                      }                        //// for testing music swell/solo effect                      //// Change FogNote to BeamNote when third of octive changes occure (quasi solo swell effect) not really                      //if ((showlightList[i].Note > 23 && showlightList[i].Note < 36) && (showlightList[i - 1].Note > 23 && showlightList[i - 1].Note < 36))                      //{                      //    if (Math.Abs(showlightList[i].Note - showlightList[i - 1].Note) > 3)                      //    {                      //        if (i % 2 == 0)                      //        {                      //            showlightList[i - 1].Note = 67; // turn off laser                      //            showlightList[i].Note = 66;                      //        }                      //        else                      //        {                      //            showlightList[i - 1].Note = 42; // spots off                      //            showlightList[i].Note = 52; // blue spot                      //        }                      //    }                      //}                        //// for testing laser                      //if (showlightList[i].Note > 67)                      //{                      //    showlightList[i - 1].Note = 66; // turn on laser                      //    showlightList[i].Note = 52; // blue spots back                      //}                        //// for testing randomize after 12 effects                      //if (i % 12 == 0)                      //{                      //    showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      //    showlightList[i - 1].Note = GetFogNote(showlightList[i - 1].Note);                      //}                  }                    // for testing overall laser activation                  var laserDeactivated = showlightList.Where(x => x.Note == 67).Any();                  var laserActived = showlightList.Where(x => x.Note == 66).Any();                  // turns on laser and searchlight effects for entire song if no other laser on was present                              if (!laserActived)                  {                      showlightList.Add(new Showlight { Note = GetBeamNote(showlightList[showlightList.Count - 1].Note)' Time = showlightList[showlightList.Count - 1].Time });                      showlightList[showlightList.Count - 2].Note = 66;                  }                    // initialize first two elements of showlights with Fog and Beam                  // nothing else seems to matter if initialization is done properly                  if (showlightList[0].Time > 10.0F)                      showlightList.Insert(0' new Showlight { Note = GetFogNote(showlightList[0].Note)' Time = 10.0F });                    if (showlightList[0].Note < 24 || showlightList[0].Note > 35)                      showlightList[0].Note = GetFogNote(showlightList[0].Note);                    if (showlightList[1].Note < 48 || showlightList[1].Note > 59)                      showlightList[1].Note = GetBeamNote(showlightList[1].Note);              }              else              {                  // create minimum default showlights                  showlightList.Clear();                  showlightList.Add(new Showlight { Note = 28' Time = 10.0F });                  showlightList.Add(new Showlight { Note = 52' Time = 10.1F });              }
Magic Number,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,AdjustShowlights,The following statement contains a magic number: if (showlightList.Count > 2 && !defaultShowlights)              {                  // remove notes that appear too early' showlights start at 10 seconds                  showlightList = showlightList.Where(s => s.Time >= 10.0F).ToList();                    // using bottoms up approach                  for (var i = showlightList.Count - 1; i > 0; i--)                  {                      // replace any bad/unknown notes: ranges 0-23' 36-41' 43-47' 60-65' 68-128                      if ((showlightList[i].Note > -1 && showlightList[i].Note < 24) ||                          (showlightList[i].Note > 35 && showlightList[i].Note < 42) ||                          (showlightList[i].Note > 42 && showlightList[i].Note < 48) ||                          (showlightList[i].Note > 59 && showlightList[i].Note < 66) ||                          (showlightList[i].Note > 67 && showlightList[i].Note < 128))                      {                          if (showlightList[i].Note < 48)                              showlightList[i].Note = GetFogNote(showlightList[i].Note);                            if (showlightList[i].Note > 59)                              showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      }                        // remove any back to back duplicate notes                      if (i < showlightList.Count - 1)                          if (showlightList[i].Note == showlightList[i + 1].Note)                          {                              showlightList.RemoveAt(i + 1);                              continue; // must be used                          }                        if (showlightList[i].Note == showlightList[i - 1].Note)                      {                          showlightList.RemoveAt(i);                          continue; // must be used                      }                        //// for testing music swell/solo effect                      //// Change FogNote to BeamNote when third of octive changes occure (quasi solo swell effect) not really                      //if ((showlightList[i].Note > 23 && showlightList[i].Note < 36) && (showlightList[i - 1].Note > 23 && showlightList[i - 1].Note < 36))                      //{                      //    if (Math.Abs(showlightList[i].Note - showlightList[i - 1].Note) > 3)                      //    {                      //        if (i % 2 == 0)                      //        {                      //            showlightList[i - 1].Note = 67; // turn off laser                      //            showlightList[i].Note = 66;                      //        }                      //        else                      //        {                      //            showlightList[i - 1].Note = 42; // spots off                      //            showlightList[i].Note = 52; // blue spot                      //        }                      //    }                      //}                        //// for testing laser                      //if (showlightList[i].Note > 67)                      //{                      //    showlightList[i - 1].Note = 66; // turn on laser                      //    showlightList[i].Note = 52; // blue spots back                      //}                        //// for testing randomize after 12 effects                      //if (i % 12 == 0)                      //{                      //    showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      //    showlightList[i - 1].Note = GetFogNote(showlightList[i - 1].Note);                      //}                  }                    // for testing overall laser activation                  var laserDeactivated = showlightList.Where(x => x.Note == 67).Any();                  var laserActived = showlightList.Where(x => x.Note == 66).Any();                  // turns on laser and searchlight effects for entire song if no other laser on was present                              if (!laserActived)                  {                      showlightList.Add(new Showlight { Note = GetBeamNote(showlightList[showlightList.Count - 1].Note)' Time = showlightList[showlightList.Count - 1].Time });                      showlightList[showlightList.Count - 2].Note = 66;                  }                    // initialize first two elements of showlights with Fog and Beam                  // nothing else seems to matter if initialization is done properly                  if (showlightList[0].Time > 10.0F)                      showlightList.Insert(0' new Showlight { Note = GetFogNote(showlightList[0].Note)' Time = 10.0F });                    if (showlightList[0].Note < 24 || showlightList[0].Note > 35)                      showlightList[0].Note = GetFogNote(showlightList[0].Note);                    if (showlightList[1].Note < 48 || showlightList[1].Note > 59)                      showlightList[1].Note = GetBeamNote(showlightList[1].Note);              }              else              {                  // create minimum default showlights                  showlightList.Clear();                  showlightList.Add(new Showlight { Note = 28' Time = 10.0F });                  showlightList.Add(new Showlight { Note = 52' Time = 10.1F });              }
Magic Number,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,AdjustShowlights,The following statement contains a magic number: if (showlightList.Count > 2 && !defaultShowlights)              {                  // remove notes that appear too early' showlights start at 10 seconds                  showlightList = showlightList.Where(s => s.Time >= 10.0F).ToList();                    // using bottoms up approach                  for (var i = showlightList.Count - 1; i > 0; i--)                  {                      // replace any bad/unknown notes: ranges 0-23' 36-41' 43-47' 60-65' 68-128                      if ((showlightList[i].Note > -1 && showlightList[i].Note < 24) ||                          (showlightList[i].Note > 35 && showlightList[i].Note < 42) ||                          (showlightList[i].Note > 42 && showlightList[i].Note < 48) ||                          (showlightList[i].Note > 59 && showlightList[i].Note < 66) ||                          (showlightList[i].Note > 67 && showlightList[i].Note < 128))                      {                          if (showlightList[i].Note < 48)                              showlightList[i].Note = GetFogNote(showlightList[i].Note);                            if (showlightList[i].Note > 59)                              showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      }                        // remove any back to back duplicate notes                      if (i < showlightList.Count - 1)                          if (showlightList[i].Note == showlightList[i + 1].Note)                          {                              showlightList.RemoveAt(i + 1);                              continue; // must be used                          }                        if (showlightList[i].Note == showlightList[i - 1].Note)                      {                          showlightList.RemoveAt(i);                          continue; // must be used                      }                        //// for testing music swell/solo effect                      //// Change FogNote to BeamNote when third of octive changes occure (quasi solo swell effect) not really                      //if ((showlightList[i].Note > 23 && showlightList[i].Note < 36) && (showlightList[i - 1].Note > 23 && showlightList[i - 1].Note < 36))                      //{                      //    if (Math.Abs(showlightList[i].Note - showlightList[i - 1].Note) > 3)                      //    {                      //        if (i % 2 == 0)                      //        {                      //            showlightList[i - 1].Note = 67; // turn off laser                      //            showlightList[i].Note = 66;                      //        }                      //        else                      //        {                      //            showlightList[i - 1].Note = 42; // spots off                      //            showlightList[i].Note = 52; // blue spot                      //        }                      //    }                      //}                        //// for testing laser                      //if (showlightList[i].Note > 67)                      //{                      //    showlightList[i - 1].Note = 66; // turn on laser                      //    showlightList[i].Note = 52; // blue spots back                      //}                        //// for testing randomize after 12 effects                      //if (i % 12 == 0)                      //{                      //    showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      //    showlightList[i - 1].Note = GetFogNote(showlightList[i - 1].Note);                      //}                  }                    // for testing overall laser activation                  var laserDeactivated = showlightList.Where(x => x.Note == 67).Any();                  var laserActived = showlightList.Where(x => x.Note == 66).Any();                  // turns on laser and searchlight effects for entire song if no other laser on was present                              if (!laserActived)                  {                      showlightList.Add(new Showlight { Note = GetBeamNote(showlightList[showlightList.Count - 1].Note)' Time = showlightList[showlightList.Count - 1].Time });                      showlightList[showlightList.Count - 2].Note = 66;                  }                    // initialize first two elements of showlights with Fog and Beam                  // nothing else seems to matter if initialization is done properly                  if (showlightList[0].Time > 10.0F)                      showlightList.Insert(0' new Showlight { Note = GetFogNote(showlightList[0].Note)' Time = 10.0F });                    if (showlightList[0].Note < 24 || showlightList[0].Note > 35)                      showlightList[0].Note = GetFogNote(showlightList[0].Note);                    if (showlightList[1].Note < 48 || showlightList[1].Note > 59)                      showlightList[1].Note = GetBeamNote(showlightList[1].Note);              }              else              {                  // create minimum default showlights                  showlightList.Clear();                  showlightList.Add(new Showlight { Note = 28' Time = 10.0F });                  showlightList.Add(new Showlight { Note = 52' Time = 10.1F });              }
Magic Number,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,AdjustShowlights,The following statement contains a magic number: if (showlightList.Count > 2 && !defaultShowlights)              {                  // remove notes that appear too early' showlights start at 10 seconds                  showlightList = showlightList.Where(s => s.Time >= 10.0F).ToList();                    // using bottoms up approach                  for (var i = showlightList.Count - 1; i > 0; i--)                  {                      // replace any bad/unknown notes: ranges 0-23' 36-41' 43-47' 60-65' 68-128                      if ((showlightList[i].Note > -1 && showlightList[i].Note < 24) ||                          (showlightList[i].Note > 35 && showlightList[i].Note < 42) ||                          (showlightList[i].Note > 42 && showlightList[i].Note < 48) ||                          (showlightList[i].Note > 59 && showlightList[i].Note < 66) ||                          (showlightList[i].Note > 67 && showlightList[i].Note < 128))                      {                          if (showlightList[i].Note < 48)                              showlightList[i].Note = GetFogNote(showlightList[i].Note);                            if (showlightList[i].Note > 59)                              showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      }                        // remove any back to back duplicate notes                      if (i < showlightList.Count - 1)                          if (showlightList[i].Note == showlightList[i + 1].Note)                          {                              showlightList.RemoveAt(i + 1);                              continue; // must be used                          }                        if (showlightList[i].Note == showlightList[i - 1].Note)                      {                          showlightList.RemoveAt(i);                          continue; // must be used                      }                        //// for testing music swell/solo effect                      //// Change FogNote to BeamNote when third of octive changes occure (quasi solo swell effect) not really                      //if ((showlightList[i].Note > 23 && showlightList[i].Note < 36) && (showlightList[i - 1].Note > 23 && showlightList[i - 1].Note < 36))                      //{                      //    if (Math.Abs(showlightList[i].Note - showlightList[i - 1].Note) > 3)                      //    {                      //        if (i % 2 == 0)                      //        {                      //            showlightList[i - 1].Note = 67; // turn off laser                      //            showlightList[i].Note = 66;                      //        }                      //        else                      //        {                      //            showlightList[i - 1].Note = 42; // spots off                      //            showlightList[i].Note = 52; // blue spot                      //        }                      //    }                      //}                        //// for testing laser                      //if (showlightList[i].Note > 67)                      //{                      //    showlightList[i - 1].Note = 66; // turn on laser                      //    showlightList[i].Note = 52; // blue spots back                      //}                        //// for testing randomize after 12 effects                      //if (i % 12 == 0)                      //{                      //    showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      //    showlightList[i - 1].Note = GetFogNote(showlightList[i - 1].Note);                      //}                  }                    // for testing overall laser activation                  var laserDeactivated = showlightList.Where(x => x.Note == 67).Any();                  var laserActived = showlightList.Where(x => x.Note == 66).Any();                  // turns on laser and searchlight effects for entire song if no other laser on was present                              if (!laserActived)                  {                      showlightList.Add(new Showlight { Note = GetBeamNote(showlightList[showlightList.Count - 1].Note)' Time = showlightList[showlightList.Count - 1].Time });                      showlightList[showlightList.Count - 2].Note = 66;                  }                    // initialize first two elements of showlights with Fog and Beam                  // nothing else seems to matter if initialization is done properly                  if (showlightList[0].Time > 10.0F)                      showlightList.Insert(0' new Showlight { Note = GetFogNote(showlightList[0].Note)' Time = 10.0F });                    if (showlightList[0].Note < 24 || showlightList[0].Note > 35)                      showlightList[0].Note = GetFogNote(showlightList[0].Note);                    if (showlightList[1].Note < 48 || showlightList[1].Note > 59)                      showlightList[1].Note = GetBeamNote(showlightList[1].Note);              }              else              {                  // create minimum default showlights                  showlightList.Clear();                  showlightList.Add(new Showlight { Note = 28' Time = 10.0F });                  showlightList.Add(new Showlight { Note = 52' Time = 10.1F });              }
Magic Number,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,AdjustShowlights,The following statement contains a magic number: if (showlightList.Count > 2 && !defaultShowlights)              {                  // remove notes that appear too early' showlights start at 10 seconds                  showlightList = showlightList.Where(s => s.Time >= 10.0F).ToList();                    // using bottoms up approach                  for (var i = showlightList.Count - 1; i > 0; i--)                  {                      // replace any bad/unknown notes: ranges 0-23' 36-41' 43-47' 60-65' 68-128                      if ((showlightList[i].Note > -1 && showlightList[i].Note < 24) ||                          (showlightList[i].Note > 35 && showlightList[i].Note < 42) ||                          (showlightList[i].Note > 42 && showlightList[i].Note < 48) ||                          (showlightList[i].Note > 59 && showlightList[i].Note < 66) ||                          (showlightList[i].Note > 67 && showlightList[i].Note < 128))                      {                          if (showlightList[i].Note < 48)                              showlightList[i].Note = GetFogNote(showlightList[i].Note);                            if (showlightList[i].Note > 59)                              showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      }                        // remove any back to back duplicate notes                      if (i < showlightList.Count - 1)                          if (showlightList[i].Note == showlightList[i + 1].Note)                          {                              showlightList.RemoveAt(i + 1);                              continue; // must be used                          }                        if (showlightList[i].Note == showlightList[i - 1].Note)                      {                          showlightList.RemoveAt(i);                          continue; // must be used                      }                        //// for testing music swell/solo effect                      //// Change FogNote to BeamNote when third of octive changes occure (quasi solo swell effect) not really                      //if ((showlightList[i].Note > 23 && showlightList[i].Note < 36) && (showlightList[i - 1].Note > 23 && showlightList[i - 1].Note < 36))                      //{                      //    if (Math.Abs(showlightList[i].Note - showlightList[i - 1].Note) > 3)                      //    {                      //        if (i % 2 == 0)                      //        {                      //            showlightList[i - 1].Note = 67; // turn off laser                      //            showlightList[i].Note = 66;                      //        }                      //        else                      //        {                      //            showlightList[i - 1].Note = 42; // spots off                      //            showlightList[i].Note = 52; // blue spot                      //        }                      //    }                      //}                        //// for testing laser                      //if (showlightList[i].Note > 67)                      //{                      //    showlightList[i - 1].Note = 66; // turn on laser                      //    showlightList[i].Note = 52; // blue spots back                      //}                        //// for testing randomize after 12 effects                      //if (i % 12 == 0)                      //{                      //    showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      //    showlightList[i - 1].Note = GetFogNote(showlightList[i - 1].Note);                      //}                  }                    // for testing overall laser activation                  var laserDeactivated = showlightList.Where(x => x.Note == 67).Any();                  var laserActived = showlightList.Where(x => x.Note == 66).Any();                  // turns on laser and searchlight effects for entire song if no other laser on was present                              if (!laserActived)                  {                      showlightList.Add(new Showlight { Note = GetBeamNote(showlightList[showlightList.Count - 1].Note)' Time = showlightList[showlightList.Count - 1].Time });                      showlightList[showlightList.Count - 2].Note = 66;                  }                    // initialize first two elements of showlights with Fog and Beam                  // nothing else seems to matter if initialization is done properly                  if (showlightList[0].Time > 10.0F)                      showlightList.Insert(0' new Showlight { Note = GetFogNote(showlightList[0].Note)' Time = 10.0F });                    if (showlightList[0].Note < 24 || showlightList[0].Note > 35)                      showlightList[0].Note = GetFogNote(showlightList[0].Note);                    if (showlightList[1].Note < 48 || showlightList[1].Note > 59)                      showlightList[1].Note = GetBeamNote(showlightList[1].Note);              }              else              {                  // create minimum default showlights                  showlightList.Clear();                  showlightList.Add(new Showlight { Note = 28' Time = 10.0F });                  showlightList.Add(new Showlight { Note = 52' Time = 10.1F });              }
Magic Number,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,AdjustShowlights,The following statement contains a magic number: if (showlightList.Count > 2 && !defaultShowlights)              {                  // remove notes that appear too early' showlights start at 10 seconds                  showlightList = showlightList.Where(s => s.Time >= 10.0F).ToList();                    // using bottoms up approach                  for (var i = showlightList.Count - 1; i > 0; i--)                  {                      // replace any bad/unknown notes: ranges 0-23' 36-41' 43-47' 60-65' 68-128                      if ((showlightList[i].Note > -1 && showlightList[i].Note < 24) ||                          (showlightList[i].Note > 35 && showlightList[i].Note < 42) ||                          (showlightList[i].Note > 42 && showlightList[i].Note < 48) ||                          (showlightList[i].Note > 59 && showlightList[i].Note < 66) ||                          (showlightList[i].Note > 67 && showlightList[i].Note < 128))                      {                          if (showlightList[i].Note < 48)                              showlightList[i].Note = GetFogNote(showlightList[i].Note);                            if (showlightList[i].Note > 59)                              showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      }                        // remove any back to back duplicate notes                      if (i < showlightList.Count - 1)                          if (showlightList[i].Note == showlightList[i + 1].Note)                          {                              showlightList.RemoveAt(i + 1);                              continue; // must be used                          }                        if (showlightList[i].Note == showlightList[i - 1].Note)                      {                          showlightList.RemoveAt(i);                          continue; // must be used                      }                        //// for testing music swell/solo effect                      //// Change FogNote to BeamNote when third of octive changes occure (quasi solo swell effect) not really                      //if ((showlightList[i].Note > 23 && showlightList[i].Note < 36) && (showlightList[i - 1].Note > 23 && showlightList[i - 1].Note < 36))                      //{                      //    if (Math.Abs(showlightList[i].Note - showlightList[i - 1].Note) > 3)                      //    {                      //        if (i % 2 == 0)                      //        {                      //            showlightList[i - 1].Note = 67; // turn off laser                      //            showlightList[i].Note = 66;                      //        }                      //        else                      //        {                      //            showlightList[i - 1].Note = 42; // spots off                      //            showlightList[i].Note = 52; // blue spot                      //        }                      //    }                      //}                        //// for testing laser                      //if (showlightList[i].Note > 67)                      //{                      //    showlightList[i - 1].Note = 66; // turn on laser                      //    showlightList[i].Note = 52; // blue spots back                      //}                        //// for testing randomize after 12 effects                      //if (i % 12 == 0)                      //{                      //    showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      //    showlightList[i - 1].Note = GetFogNote(showlightList[i - 1].Note);                      //}                  }                    // for testing overall laser activation                  var laserDeactivated = showlightList.Where(x => x.Note == 67).Any();                  var laserActived = showlightList.Where(x => x.Note == 66).Any();                  // turns on laser and searchlight effects for entire song if no other laser on was present                              if (!laserActived)                  {                      showlightList.Add(new Showlight { Note = GetBeamNote(showlightList[showlightList.Count - 1].Note)' Time = showlightList[showlightList.Count - 1].Time });                      showlightList[showlightList.Count - 2].Note = 66;                  }                    // initialize first two elements of showlights with Fog and Beam                  // nothing else seems to matter if initialization is done properly                  if (showlightList[0].Time > 10.0F)                      showlightList.Insert(0' new Showlight { Note = GetFogNote(showlightList[0].Note)' Time = 10.0F });                    if (showlightList[0].Note < 24 || showlightList[0].Note > 35)                      showlightList[0].Note = GetFogNote(showlightList[0].Note);                    if (showlightList[1].Note < 48 || showlightList[1].Note > 59)                      showlightList[1].Note = GetBeamNote(showlightList[1].Note);              }              else              {                  // create minimum default showlights                  showlightList.Clear();                  showlightList.Add(new Showlight { Note = 28' Time = 10.0F });                  showlightList.Add(new Showlight { Note = 52' Time = 10.1F });              }
Magic Number,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,AdjustShowlights,The following statement contains a magic number: if (showlightList.Count > 2 && !defaultShowlights)              {                  // remove notes that appear too early' showlights start at 10 seconds                  showlightList = showlightList.Where(s => s.Time >= 10.0F).ToList();                    // using bottoms up approach                  for (var i = showlightList.Count - 1; i > 0; i--)                  {                      // replace any bad/unknown notes: ranges 0-23' 36-41' 43-47' 60-65' 68-128                      if ((showlightList[i].Note > -1 && showlightList[i].Note < 24) ||                          (showlightList[i].Note > 35 && showlightList[i].Note < 42) ||                          (showlightList[i].Note > 42 && showlightList[i].Note < 48) ||                          (showlightList[i].Note > 59 && showlightList[i].Note < 66) ||                          (showlightList[i].Note > 67 && showlightList[i].Note < 128))                      {                          if (showlightList[i].Note < 48)                              showlightList[i].Note = GetFogNote(showlightList[i].Note);                            if (showlightList[i].Note > 59)                              showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      }                        // remove any back to back duplicate notes                      if (i < showlightList.Count - 1)                          if (showlightList[i].Note == showlightList[i + 1].Note)                          {                              showlightList.RemoveAt(i + 1);                              continue; // must be used                          }                        if (showlightList[i].Note == showlightList[i - 1].Note)                      {                          showlightList.RemoveAt(i);                          continue; // must be used                      }                        //// for testing music swell/solo effect                      //// Change FogNote to BeamNote when third of octive changes occure (quasi solo swell effect) not really                      //if ((showlightList[i].Note > 23 && showlightList[i].Note < 36) && (showlightList[i - 1].Note > 23 && showlightList[i - 1].Note < 36))                      //{                      //    if (Math.Abs(showlightList[i].Note - showlightList[i - 1].Note) > 3)                      //    {                      //        if (i % 2 == 0)                      //        {                      //            showlightList[i - 1].Note = 67; // turn off laser                      //            showlightList[i].Note = 66;                      //        }                      //        else                      //        {                      //            showlightList[i - 1].Note = 42; // spots off                      //            showlightList[i].Note = 52; // blue spot                      //        }                      //    }                      //}                        //// for testing laser                      //if (showlightList[i].Note > 67)                      //{                      //    showlightList[i - 1].Note = 66; // turn on laser                      //    showlightList[i].Note = 52; // blue spots back                      //}                        //// for testing randomize after 12 effects                      //if (i % 12 == 0)                      //{                      //    showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      //    showlightList[i - 1].Note = GetFogNote(showlightList[i - 1].Note);                      //}                  }                    // for testing overall laser activation                  var laserDeactivated = showlightList.Where(x => x.Note == 67).Any();                  var laserActived = showlightList.Where(x => x.Note == 66).Any();                  // turns on laser and searchlight effects for entire song if no other laser on was present                              if (!laserActived)                  {                      showlightList.Add(new Showlight { Note = GetBeamNote(showlightList[showlightList.Count - 1].Note)' Time = showlightList[showlightList.Count - 1].Time });                      showlightList[showlightList.Count - 2].Note = 66;                  }                    // initialize first two elements of showlights with Fog and Beam                  // nothing else seems to matter if initialization is done properly                  if (showlightList[0].Time > 10.0F)                      showlightList.Insert(0' new Showlight { Note = GetFogNote(showlightList[0].Note)' Time = 10.0F });                    if (showlightList[0].Note < 24 || showlightList[0].Note > 35)                      showlightList[0].Note = GetFogNote(showlightList[0].Note);                    if (showlightList[1].Note < 48 || showlightList[1].Note > 59)                      showlightList[1].Note = GetBeamNote(showlightList[1].Note);              }              else              {                  // create minimum default showlights                  showlightList.Clear();                  showlightList.Add(new Showlight { Note = 28' Time = 10.0F });                  showlightList.Add(new Showlight { Note = 52' Time = 10.1F });              }
Magic Number,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,AdjustShowlights,The following statement contains a magic number: if (showlightList.Count > 2 && !defaultShowlights)              {                  // remove notes that appear too early' showlights start at 10 seconds                  showlightList = showlightList.Where(s => s.Time >= 10.0F).ToList();                    // using bottoms up approach                  for (var i = showlightList.Count - 1; i > 0; i--)                  {                      // replace any bad/unknown notes: ranges 0-23' 36-41' 43-47' 60-65' 68-128                      if ((showlightList[i].Note > -1 && showlightList[i].Note < 24) ||                          (showlightList[i].Note > 35 && showlightList[i].Note < 42) ||                          (showlightList[i].Note > 42 && showlightList[i].Note < 48) ||                          (showlightList[i].Note > 59 && showlightList[i].Note < 66) ||                          (showlightList[i].Note > 67 && showlightList[i].Note < 128))                      {                          if (showlightList[i].Note < 48)                              showlightList[i].Note = GetFogNote(showlightList[i].Note);                            if (showlightList[i].Note > 59)                              showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      }                        // remove any back to back duplicate notes                      if (i < showlightList.Count - 1)                          if (showlightList[i].Note == showlightList[i + 1].Note)                          {                              showlightList.RemoveAt(i + 1);                              continue; // must be used                          }                        if (showlightList[i].Note == showlightList[i - 1].Note)                      {                          showlightList.RemoveAt(i);                          continue; // must be used                      }                        //// for testing music swell/solo effect                      //// Change FogNote to BeamNote when third of octive changes occure (quasi solo swell effect) not really                      //if ((showlightList[i].Note > 23 && showlightList[i].Note < 36) && (showlightList[i - 1].Note > 23 && showlightList[i - 1].Note < 36))                      //{                      //    if (Math.Abs(showlightList[i].Note - showlightList[i - 1].Note) > 3)                      //    {                      //        if (i % 2 == 0)                      //        {                      //            showlightList[i - 1].Note = 67; // turn off laser                      //            showlightList[i].Note = 66;                      //        }                      //        else                      //        {                      //            showlightList[i - 1].Note = 42; // spots off                      //            showlightList[i].Note = 52; // blue spot                      //        }                      //    }                      //}                        //// for testing laser                      //if (showlightList[i].Note > 67)                      //{                      //    showlightList[i - 1].Note = 66; // turn on laser                      //    showlightList[i].Note = 52; // blue spots back                      //}                        //// for testing randomize after 12 effects                      //if (i % 12 == 0)                      //{                      //    showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      //    showlightList[i - 1].Note = GetFogNote(showlightList[i - 1].Note);                      //}                  }                    // for testing overall laser activation                  var laserDeactivated = showlightList.Where(x => x.Note == 67).Any();                  var laserActived = showlightList.Where(x => x.Note == 66).Any();                  // turns on laser and searchlight effects for entire song if no other laser on was present                              if (!laserActived)                  {                      showlightList.Add(new Showlight { Note = GetBeamNote(showlightList[showlightList.Count - 1].Note)' Time = showlightList[showlightList.Count - 1].Time });                      showlightList[showlightList.Count - 2].Note = 66;                  }                    // initialize first two elements of showlights with Fog and Beam                  // nothing else seems to matter if initialization is done properly                  if (showlightList[0].Time > 10.0F)                      showlightList.Insert(0' new Showlight { Note = GetFogNote(showlightList[0].Note)' Time = 10.0F });                    if (showlightList[0].Note < 24 || showlightList[0].Note > 35)                      showlightList[0].Note = GetFogNote(showlightList[0].Note);                    if (showlightList[1].Note < 48 || showlightList[1].Note > 59)                      showlightList[1].Note = GetBeamNote(showlightList[1].Note);              }              else              {                  // create minimum default showlights                  showlightList.Clear();                  showlightList.Add(new Showlight { Note = 28' Time = 10.0F });                  showlightList.Add(new Showlight { Note = 52' Time = 10.1F });              }
Magic Number,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,AdjustShowlights,The following statement contains a magic number: if (showlightList.Count > 2 && !defaultShowlights)              {                  // remove notes that appear too early' showlights start at 10 seconds                  showlightList = showlightList.Where(s => s.Time >= 10.0F).ToList();                    // using bottoms up approach                  for (var i = showlightList.Count - 1; i > 0; i--)                  {                      // replace any bad/unknown notes: ranges 0-23' 36-41' 43-47' 60-65' 68-128                      if ((showlightList[i].Note > -1 && showlightList[i].Note < 24) ||                          (showlightList[i].Note > 35 && showlightList[i].Note < 42) ||                          (showlightList[i].Note > 42 && showlightList[i].Note < 48) ||                          (showlightList[i].Note > 59 && showlightList[i].Note < 66) ||                          (showlightList[i].Note > 67 && showlightList[i].Note < 128))                      {                          if (showlightList[i].Note < 48)                              showlightList[i].Note = GetFogNote(showlightList[i].Note);                            if (showlightList[i].Note > 59)                              showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      }                        // remove any back to back duplicate notes                      if (i < showlightList.Count - 1)                          if (showlightList[i].Note == showlightList[i + 1].Note)                          {                              showlightList.RemoveAt(i + 1);                              continue; // must be used                          }                        if (showlightList[i].Note == showlightList[i - 1].Note)                      {                          showlightList.RemoveAt(i);                          continue; // must be used                      }                        //// for testing music swell/solo effect                      //// Change FogNote to BeamNote when third of octive changes occure (quasi solo swell effect) not really                      //if ((showlightList[i].Note > 23 && showlightList[i].Note < 36) && (showlightList[i - 1].Note > 23 && showlightList[i - 1].Note < 36))                      //{                      //    if (Math.Abs(showlightList[i].Note - showlightList[i - 1].Note) > 3)                      //    {                      //        if (i % 2 == 0)                      //        {                      //            showlightList[i - 1].Note = 67; // turn off laser                      //            showlightList[i].Note = 66;                      //        }                      //        else                      //        {                      //            showlightList[i - 1].Note = 42; // spots off                      //            showlightList[i].Note = 52; // blue spot                      //        }                      //    }                      //}                        //// for testing laser                      //if (showlightList[i].Note > 67)                      //{                      //    showlightList[i - 1].Note = 66; // turn on laser                      //    showlightList[i].Note = 52; // blue spots back                      //}                        //// for testing randomize after 12 effects                      //if (i % 12 == 0)                      //{                      //    showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      //    showlightList[i - 1].Note = GetFogNote(showlightList[i - 1].Note);                      //}                  }                    // for testing overall laser activation                  var laserDeactivated = showlightList.Where(x => x.Note == 67).Any();                  var laserActived = showlightList.Where(x => x.Note == 66).Any();                  // turns on laser and searchlight effects for entire song if no other laser on was present                              if (!laserActived)                  {                      showlightList.Add(new Showlight { Note = GetBeamNote(showlightList[showlightList.Count - 1].Note)' Time = showlightList[showlightList.Count - 1].Time });                      showlightList[showlightList.Count - 2].Note = 66;                  }                    // initialize first two elements of showlights with Fog and Beam                  // nothing else seems to matter if initialization is done properly                  if (showlightList[0].Time > 10.0F)                      showlightList.Insert(0' new Showlight { Note = GetFogNote(showlightList[0].Note)' Time = 10.0F });                    if (showlightList[0].Note < 24 || showlightList[0].Note > 35)                      showlightList[0].Note = GetFogNote(showlightList[0].Note);                    if (showlightList[1].Note < 48 || showlightList[1].Note > 59)                      showlightList[1].Note = GetBeamNote(showlightList[1].Note);              }              else              {                  // create minimum default showlights                  showlightList.Clear();                  showlightList.Add(new Showlight { Note = 28' Time = 10.0F });                  showlightList.Add(new Showlight { Note = 52' Time = 10.1F });              }
Magic Number,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,AdjustShowlights,The following statement contains a magic number: if (showlightList.Count > 2 && !defaultShowlights)              {                  // remove notes that appear too early' showlights start at 10 seconds                  showlightList = showlightList.Where(s => s.Time >= 10.0F).ToList();                    // using bottoms up approach                  for (var i = showlightList.Count - 1; i > 0; i--)                  {                      // replace any bad/unknown notes: ranges 0-23' 36-41' 43-47' 60-65' 68-128                      if ((showlightList[i].Note > -1 && showlightList[i].Note < 24) ||                          (showlightList[i].Note > 35 && showlightList[i].Note < 42) ||                          (showlightList[i].Note > 42 && showlightList[i].Note < 48) ||                          (showlightList[i].Note > 59 && showlightList[i].Note < 66) ||                          (showlightList[i].Note > 67 && showlightList[i].Note < 128))                      {                          if (showlightList[i].Note < 48)                              showlightList[i].Note = GetFogNote(showlightList[i].Note);                            if (showlightList[i].Note > 59)                              showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      }                        // remove any back to back duplicate notes                      if (i < showlightList.Count - 1)                          if (showlightList[i].Note == showlightList[i + 1].Note)                          {                              showlightList.RemoveAt(i + 1);                              continue; // must be used                          }                        if (showlightList[i].Note == showlightList[i - 1].Note)                      {                          showlightList.RemoveAt(i);                          continue; // must be used                      }                        //// for testing music swell/solo effect                      //// Change FogNote to BeamNote when third of octive changes occure (quasi solo swell effect) not really                      //if ((showlightList[i].Note > 23 && showlightList[i].Note < 36) && (showlightList[i - 1].Note > 23 && showlightList[i - 1].Note < 36))                      //{                      //    if (Math.Abs(showlightList[i].Note - showlightList[i - 1].Note) > 3)                      //    {                      //        if (i % 2 == 0)                      //        {                      //            showlightList[i - 1].Note = 67; // turn off laser                      //            showlightList[i].Note = 66;                      //        }                      //        else                      //        {                      //            showlightList[i - 1].Note = 42; // spots off                      //            showlightList[i].Note = 52; // blue spot                      //        }                      //    }                      //}                        //// for testing laser                      //if (showlightList[i].Note > 67)                      //{                      //    showlightList[i - 1].Note = 66; // turn on laser                      //    showlightList[i].Note = 52; // blue spots back                      //}                        //// for testing randomize after 12 effects                      //if (i % 12 == 0)                      //{                      //    showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      //    showlightList[i - 1].Note = GetFogNote(showlightList[i - 1].Note);                      //}                  }                    // for testing overall laser activation                  var laserDeactivated = showlightList.Where(x => x.Note == 67).Any();                  var laserActived = showlightList.Where(x => x.Note == 66).Any();                  // turns on laser and searchlight effects for entire song if no other laser on was present                              if (!laserActived)                  {                      showlightList.Add(new Showlight { Note = GetBeamNote(showlightList[showlightList.Count - 1].Note)' Time = showlightList[showlightList.Count - 1].Time });                      showlightList[showlightList.Count - 2].Note = 66;                  }                    // initialize first two elements of showlights with Fog and Beam                  // nothing else seems to matter if initialization is done properly                  if (showlightList[0].Time > 10.0F)                      showlightList.Insert(0' new Showlight { Note = GetFogNote(showlightList[0].Note)' Time = 10.0F });                    if (showlightList[0].Note < 24 || showlightList[0].Note > 35)                      showlightList[0].Note = GetFogNote(showlightList[0].Note);                    if (showlightList[1].Note < 48 || showlightList[1].Note > 59)                      showlightList[1].Note = GetBeamNote(showlightList[1].Note);              }              else              {                  // create minimum default showlights                  showlightList.Clear();                  showlightList.Add(new Showlight { Note = 28' Time = 10.0F });                  showlightList.Add(new Showlight { Note = 52' Time = 10.1F });              }
Magic Number,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,AdjustShowlights,The following statement contains a magic number: if (showlightList.Count > 2 && !defaultShowlights)              {                  // remove notes that appear too early' showlights start at 10 seconds                  showlightList = showlightList.Where(s => s.Time >= 10.0F).ToList();                    // using bottoms up approach                  for (var i = showlightList.Count - 1; i > 0; i--)                  {                      // replace any bad/unknown notes: ranges 0-23' 36-41' 43-47' 60-65' 68-128                      if ((showlightList[i].Note > -1 && showlightList[i].Note < 24) ||                          (showlightList[i].Note > 35 && showlightList[i].Note < 42) ||                          (showlightList[i].Note > 42 && showlightList[i].Note < 48) ||                          (showlightList[i].Note > 59 && showlightList[i].Note < 66) ||                          (showlightList[i].Note > 67 && showlightList[i].Note < 128))                      {                          if (showlightList[i].Note < 48)                              showlightList[i].Note = GetFogNote(showlightList[i].Note);                            if (showlightList[i].Note > 59)                              showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      }                        // remove any back to back duplicate notes                      if (i < showlightList.Count - 1)                          if (showlightList[i].Note == showlightList[i + 1].Note)                          {                              showlightList.RemoveAt(i + 1);                              continue; // must be used                          }                        if (showlightList[i].Note == showlightList[i - 1].Note)                      {                          showlightList.RemoveAt(i);                          continue; // must be used                      }                        //// for testing music swell/solo effect                      //// Change FogNote to BeamNote when third of octive changes occure (quasi solo swell effect) not really                      //if ((showlightList[i].Note > 23 && showlightList[i].Note < 36) && (showlightList[i - 1].Note > 23 && showlightList[i - 1].Note < 36))                      //{                      //    if (Math.Abs(showlightList[i].Note - showlightList[i - 1].Note) > 3)                      //    {                      //        if (i % 2 == 0)                      //        {                      //            showlightList[i - 1].Note = 67; // turn off laser                      //            showlightList[i].Note = 66;                      //        }                      //        else                      //        {                      //            showlightList[i - 1].Note = 42; // spots off                      //            showlightList[i].Note = 52; // blue spot                      //        }                      //    }                      //}                        //// for testing laser                      //if (showlightList[i].Note > 67)                      //{                      //    showlightList[i - 1].Note = 66; // turn on laser                      //    showlightList[i].Note = 52; // blue spots back                      //}                        //// for testing randomize after 12 effects                      //if (i % 12 == 0)                      //{                      //    showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      //    showlightList[i - 1].Note = GetFogNote(showlightList[i - 1].Note);                      //}                  }                    // for testing overall laser activation                  var laserDeactivated = showlightList.Where(x => x.Note == 67).Any();                  var laserActived = showlightList.Where(x => x.Note == 66).Any();                  // turns on laser and searchlight effects for entire song if no other laser on was present                              if (!laserActived)                  {                      showlightList.Add(new Showlight { Note = GetBeamNote(showlightList[showlightList.Count - 1].Note)' Time = showlightList[showlightList.Count - 1].Time });                      showlightList[showlightList.Count - 2].Note = 66;                  }                    // initialize first two elements of showlights with Fog and Beam                  // nothing else seems to matter if initialization is done properly                  if (showlightList[0].Time > 10.0F)                      showlightList.Insert(0' new Showlight { Note = GetFogNote(showlightList[0].Note)' Time = 10.0F });                    if (showlightList[0].Note < 24 || showlightList[0].Note > 35)                      showlightList[0].Note = GetFogNote(showlightList[0].Note);                    if (showlightList[1].Note < 48 || showlightList[1].Note > 59)                      showlightList[1].Note = GetBeamNote(showlightList[1].Note);              }              else              {                  // create minimum default showlights                  showlightList.Clear();                  showlightList.Add(new Showlight { Note = 28' Time = 10.0F });                  showlightList.Add(new Showlight { Note = 52' Time = 10.1F });              }
Magic Number,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,AdjustShowlights,The following statement contains a magic number: if (showlightList.Count > 2 && !defaultShowlights)              {                  // remove notes that appear too early' showlights start at 10 seconds                  showlightList = showlightList.Where(s => s.Time >= 10.0F).ToList();                    // using bottoms up approach                  for (var i = showlightList.Count - 1; i > 0; i--)                  {                      // replace any bad/unknown notes: ranges 0-23' 36-41' 43-47' 60-65' 68-128                      if ((showlightList[i].Note > -1 && showlightList[i].Note < 24) ||                          (showlightList[i].Note > 35 && showlightList[i].Note < 42) ||                          (showlightList[i].Note > 42 && showlightList[i].Note < 48) ||                          (showlightList[i].Note > 59 && showlightList[i].Note < 66) ||                          (showlightList[i].Note > 67 && showlightList[i].Note < 128))                      {                          if (showlightList[i].Note < 48)                              showlightList[i].Note = GetFogNote(showlightList[i].Note);                            if (showlightList[i].Note > 59)                              showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      }                        // remove any back to back duplicate notes                      if (i < showlightList.Count - 1)                          if (showlightList[i].Note == showlightList[i + 1].Note)                          {                              showlightList.RemoveAt(i + 1);                              continue; // must be used                          }                        if (showlightList[i].Note == showlightList[i - 1].Note)                      {                          showlightList.RemoveAt(i);                          continue; // must be used                      }                        //// for testing music swell/solo effect                      //// Change FogNote to BeamNote when third of octive changes occure (quasi solo swell effect) not really                      //if ((showlightList[i].Note > 23 && showlightList[i].Note < 36) && (showlightList[i - 1].Note > 23 && showlightList[i - 1].Note < 36))                      //{                      //    if (Math.Abs(showlightList[i].Note - showlightList[i - 1].Note) > 3)                      //    {                      //        if (i % 2 == 0)                      //        {                      //            showlightList[i - 1].Note = 67; // turn off laser                      //            showlightList[i].Note = 66;                      //        }                      //        else                      //        {                      //            showlightList[i - 1].Note = 42; // spots off                      //            showlightList[i].Note = 52; // blue spot                      //        }                      //    }                      //}                        //// for testing laser                      //if (showlightList[i].Note > 67)                      //{                      //    showlightList[i - 1].Note = 66; // turn on laser                      //    showlightList[i].Note = 52; // blue spots back                      //}                        //// for testing randomize after 12 effects                      //if (i % 12 == 0)                      //{                      //    showlightList[i].Note = GetBeamNote(showlightList[i].Note);                      //    showlightList[i - 1].Note = GetFogNote(showlightList[i - 1].Note);                      //}                  }                    // for testing overall laser activation                  var laserDeactivated = showlightList.Where(x => x.Note == 67).Any();                  var laserActived = showlightList.Where(x => x.Note == 66).Any();                  // turns on laser and searchlight effects for entire song if no other laser on was present                              if (!laserActived)                  {                      showlightList.Add(new Showlight { Note = GetBeamNote(showlightList[showlightList.Count - 1].Note)' Time = showlightList[showlightList.Count - 1].Time });                      showlightList[showlightList.Count - 2].Note = 66;                  }                    // initialize first two elements of showlights with Fog and Beam                  // nothing else seems to matter if initialization is done properly                  if (showlightList[0].Time > 10.0F)                      showlightList.Insert(0' new Showlight { Note = GetFogNote(showlightList[0].Note)' Time = 10.0F });                    if (showlightList[0].Note < 24 || showlightList[0].Note > 35)                      showlightList[0].Note = GetFogNote(showlightList[0].Note);                    if (showlightList[1].Note < 48 || showlightList[1].Note > 59)                      showlightList[1].Note = GetBeamNote(showlightList[1].Note);              }              else              {                  // create minimum default showlights                  showlightList.Clear();                  showlightList.Add(new Showlight { Note = 28' Time = 10.0F });                  showlightList.Add(new Showlight { Note = 52' Time = 10.1F });              }
Magic Number,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,GetFogNote,The following statement contains a magic number: var fogNote = rnd.Next(24' 36);
Magic Number,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,GetFogNote,The following statement contains a magic number: var fogNote = rnd.Next(24' 36);
Magic Number,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,GetBeamNote,The following statement contains a magic number: var beamNote = rnd.Next(48' 60);
Magic Number,RocksmithToolkitLib.XML,Showlights,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Showlights.cs,GetBeamNote,The following statement contains a magic number: var beamNote = rnd.Next(48' 60);
Magic Number,RocksmithToolkitLib.XML,HeroLevel,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Parse,The following statement contains a magic number: var heroLevels = new HeroLevel[3];
Magic Number,RocksmithToolkitLib.XML,HeroLevel,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Parse,The following statement contains a magic number: var heroLevels = new HeroLevel[3];
Magic Number,RocksmithToolkitLib.XML,SongChordTemplate2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Parse,The following statement contains a magic number: for (int i = 0; i < cteamplateList.Count; i++)              {                  chordTemplates[i] = new SongChordTemplate2014                  {                      ChordName = cteamplateList[i].ChordName'                      // split getting funky RS1 -> RS2 results when combined                      DisplayName = cteamplateList[i].ChordName'                      Finger0 = (sbyte)cteamplateList[i].Fingers[0]'                      Finger1 = (sbyte)cteamplateList[i].Fingers[1]'                      Finger2 = (sbyte)cteamplateList[i].Fingers[2]'                      Finger3 = (sbyte)cteamplateList[i].Fingers[3]'                      Finger4 = (sbyte)cteamplateList[i].Fingers[4]'                      Finger5 = (sbyte)cteamplateList[i].Fingers[5]'                      Fret0 = (sbyte)cteamplateList[i].Frets[0]'                      Fret1 = (sbyte)cteamplateList[i].Frets[1]'                      Fret2 = (sbyte)cteamplateList[i].Frets[2]'                      Fret3 = (sbyte)cteamplateList[i].Frets[3]'                      Fret4 = (sbyte)cteamplateList[i].Frets[4]'                      Fret5 = (sbyte)cteamplateList[i].Frets[5]'                      ChordId = cteamplateList[i].ChordId                  };              }
Magic Number,RocksmithToolkitLib.XML,SongChordTemplate2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Parse,The following statement contains a magic number: for (int i = 0; i < cteamplateList.Count; i++)              {                  chordTemplates[i] = new SongChordTemplate2014                  {                      ChordName = cteamplateList[i].ChordName'                      // split getting funky RS1 -> RS2 results when combined                      DisplayName = cteamplateList[i].ChordName'                      Finger0 = (sbyte)cteamplateList[i].Fingers[0]'                      Finger1 = (sbyte)cteamplateList[i].Fingers[1]'                      Finger2 = (sbyte)cteamplateList[i].Fingers[2]'                      Finger3 = (sbyte)cteamplateList[i].Fingers[3]'                      Finger4 = (sbyte)cteamplateList[i].Fingers[4]'                      Finger5 = (sbyte)cteamplateList[i].Fingers[5]'                      Fret0 = (sbyte)cteamplateList[i].Frets[0]'                      Fret1 = (sbyte)cteamplateList[i].Frets[1]'                      Fret2 = (sbyte)cteamplateList[i].Frets[2]'                      Fret3 = (sbyte)cteamplateList[i].Frets[3]'                      Fret4 = (sbyte)cteamplateList[i].Frets[4]'                      Fret5 = (sbyte)cteamplateList[i].Frets[5]'                      ChordId = cteamplateList[i].ChordId                  };              }
Magic Number,RocksmithToolkitLib.XML,SongChordTemplate2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Parse,The following statement contains a magic number: for (int i = 0; i < cteamplateList.Count; i++)              {                  chordTemplates[i] = new SongChordTemplate2014                  {                      ChordName = cteamplateList[i].ChordName'                      // split getting funky RS1 -> RS2 results when combined                      DisplayName = cteamplateList[i].ChordName'                      Finger0 = (sbyte)cteamplateList[i].Fingers[0]'                      Finger1 = (sbyte)cteamplateList[i].Fingers[1]'                      Finger2 = (sbyte)cteamplateList[i].Fingers[2]'                      Finger3 = (sbyte)cteamplateList[i].Fingers[3]'                      Finger4 = (sbyte)cteamplateList[i].Fingers[4]'                      Finger5 = (sbyte)cteamplateList[i].Fingers[5]'                      Fret0 = (sbyte)cteamplateList[i].Frets[0]'                      Fret1 = (sbyte)cteamplateList[i].Frets[1]'                      Fret2 = (sbyte)cteamplateList[i].Frets[2]'                      Fret3 = (sbyte)cteamplateList[i].Frets[3]'                      Fret4 = (sbyte)cteamplateList[i].Frets[4]'                      Fret5 = (sbyte)cteamplateList[i].Frets[5]'                      ChordId = cteamplateList[i].ChordId                  };              }
Magic Number,RocksmithToolkitLib.XML,SongChordTemplate2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Parse,The following statement contains a magic number: for (int i = 0; i < cteamplateList.Count; i++)              {                  chordTemplates[i] = new SongChordTemplate2014                  {                      ChordName = cteamplateList[i].ChordName'                      // split getting funky RS1 -> RS2 results when combined                      DisplayName = cteamplateList[i].ChordName'                      Finger0 = (sbyte)cteamplateList[i].Fingers[0]'                      Finger1 = (sbyte)cteamplateList[i].Fingers[1]'                      Finger2 = (sbyte)cteamplateList[i].Fingers[2]'                      Finger3 = (sbyte)cteamplateList[i].Fingers[3]'                      Finger4 = (sbyte)cteamplateList[i].Fingers[4]'                      Finger5 = (sbyte)cteamplateList[i].Fingers[5]'                      Fret0 = (sbyte)cteamplateList[i].Frets[0]'                      Fret1 = (sbyte)cteamplateList[i].Frets[1]'                      Fret2 = (sbyte)cteamplateList[i].Frets[2]'                      Fret3 = (sbyte)cteamplateList[i].Frets[3]'                      Fret4 = (sbyte)cteamplateList[i].Frets[4]'                      Fret5 = (sbyte)cteamplateList[i].Frets[5]'                      ChordId = cteamplateList[i].ChordId                  };              }
Magic Number,RocksmithToolkitLib.XML,SongChordTemplate2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Parse,The following statement contains a magic number: for (int i = 0; i < cteamplateList.Count; i++)              {                  chordTemplates[i] = new SongChordTemplate2014                  {                      ChordName = cteamplateList[i].ChordName'                      // split getting funky RS1 -> RS2 results when combined                      DisplayName = cteamplateList[i].ChordName'                      Finger0 = (sbyte)cteamplateList[i].Fingers[0]'                      Finger1 = (sbyte)cteamplateList[i].Fingers[1]'                      Finger2 = (sbyte)cteamplateList[i].Fingers[2]'                      Finger3 = (sbyte)cteamplateList[i].Fingers[3]'                      Finger4 = (sbyte)cteamplateList[i].Fingers[4]'                      Finger5 = (sbyte)cteamplateList[i].Fingers[5]'                      Fret0 = (sbyte)cteamplateList[i].Frets[0]'                      Fret1 = (sbyte)cteamplateList[i].Frets[1]'                      Fret2 = (sbyte)cteamplateList[i].Frets[2]'                      Fret3 = (sbyte)cteamplateList[i].Frets[3]'                      Fret4 = (sbyte)cteamplateList[i].Frets[4]'                      Fret5 = (sbyte)cteamplateList[i].Frets[5]'                      ChordId = cteamplateList[i].ChordId                  };              }
Magic Number,RocksmithToolkitLib.XML,SongChordTemplate2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Parse,The following statement contains a magic number: for (int i = 0; i < cteamplateList.Count; i++)              {                  chordTemplates[i] = new SongChordTemplate2014                  {                      ChordName = cteamplateList[i].ChordName'                      // split getting funky RS1 -> RS2 results when combined                      DisplayName = cteamplateList[i].ChordName'                      Finger0 = (sbyte)cteamplateList[i].Fingers[0]'                      Finger1 = (sbyte)cteamplateList[i].Fingers[1]'                      Finger2 = (sbyte)cteamplateList[i].Fingers[2]'                      Finger3 = (sbyte)cteamplateList[i].Fingers[3]'                      Finger4 = (sbyte)cteamplateList[i].Fingers[4]'                      Finger5 = (sbyte)cteamplateList[i].Fingers[5]'                      Fret0 = (sbyte)cteamplateList[i].Frets[0]'                      Fret1 = (sbyte)cteamplateList[i].Frets[1]'                      Fret2 = (sbyte)cteamplateList[i].Frets[2]'                      Fret3 = (sbyte)cteamplateList[i].Frets[3]'                      Fret4 = (sbyte)cteamplateList[i].Frets[4]'                      Fret5 = (sbyte)cteamplateList[i].Frets[5]'                      ChordId = cteamplateList[i].ChordId                  };              }
Magic Number,RocksmithToolkitLib.XML,SongChordTemplate2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Parse,The following statement contains a magic number: for (int i = 0; i < cteamplateList.Count; i++)              {                  chordTemplates[i] = new SongChordTemplate2014                  {                      ChordName = cteamplateList[i].ChordName'                      // split getting funky RS1 -> RS2 results when combined                      DisplayName = cteamplateList[i].ChordName'                      Finger0 = (sbyte)cteamplateList[i].Fingers[0]'                      Finger1 = (sbyte)cteamplateList[i].Fingers[1]'                      Finger2 = (sbyte)cteamplateList[i].Fingers[2]'                      Finger3 = (sbyte)cteamplateList[i].Fingers[3]'                      Finger4 = (sbyte)cteamplateList[i].Fingers[4]'                      Finger5 = (sbyte)cteamplateList[i].Fingers[5]'                      Fret0 = (sbyte)cteamplateList[i].Frets[0]'                      Fret1 = (sbyte)cteamplateList[i].Frets[1]'                      Fret2 = (sbyte)cteamplateList[i].Frets[2]'                      Fret3 = (sbyte)cteamplateList[i].Frets[3]'                      Fret4 = (sbyte)cteamplateList[i].Frets[4]'                      Fret5 = (sbyte)cteamplateList[i].Frets[5]'                      ChordId = cteamplateList[i].ChordId                  };              }
Magic Number,RocksmithToolkitLib.XML,SongChordTemplate2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Parse,The following statement contains a magic number: for (int i = 0; i < cteamplateList.Count; i++)              {                  chordTemplates[i] = new SongChordTemplate2014                  {                      ChordName = cteamplateList[i].ChordName'                      // split getting funky RS1 -> RS2 results when combined                      DisplayName = cteamplateList[i].ChordName'                      Finger0 = (sbyte)cteamplateList[i].Fingers[0]'                      Finger1 = (sbyte)cteamplateList[i].Fingers[1]'                      Finger2 = (sbyte)cteamplateList[i].Fingers[2]'                      Finger3 = (sbyte)cteamplateList[i].Fingers[3]'                      Finger4 = (sbyte)cteamplateList[i].Fingers[4]'                      Finger5 = (sbyte)cteamplateList[i].Fingers[5]'                      Fret0 = (sbyte)cteamplateList[i].Frets[0]'                      Fret1 = (sbyte)cteamplateList[i].Frets[1]'                      Fret2 = (sbyte)cteamplateList[i].Frets[2]'                      Fret3 = (sbyte)cteamplateList[i].Frets[3]'                      Fret4 = (sbyte)cteamplateList[i].Frets[4]'                      Fret5 = (sbyte)cteamplateList[i].Frets[5]'                      ChordId = cteamplateList[i].ChordId                  };              }
Magic Number,RocksmithToolkitLib.XML,SongChordTemplate2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Parse,The following statement contains a magic number: for (int i = 0; i < chordSection.Count; i++)              {                  var sct2014 = new SongChordTemplate2014();                  sct2014.ChordName = sct2014.DisplayName = chordSection.Chords[i].Name.ToNullTerminatedAscii();                  sct2014.Finger0 = (sbyte)chordSection.Chords[i].Fingers[0];                  sct2014.Finger1 = (sbyte)chordSection.Chords[i].Fingers[1];                  sct2014.Finger2 = (sbyte)chordSection.Chords[i].Fingers[2];                  sct2014.Finger3 = (sbyte)chordSection.Chords[i].Fingers[3];                  sct2014.Finger4 = (sbyte)chordSection.Chords[i].Fingers[4];                  sct2014.Finger5 = (sbyte)chordSection.Chords[i].Fingers[5];                  sct2014.Fret0 = (sbyte)chordSection.Chords[i].Frets[0];                  sct2014.Fret1 = (sbyte)chordSection.Chords[i].Frets[1];                  sct2014.Fret2 = (sbyte)chordSection.Chords[i].Frets[2];                  sct2014.Fret3 = (sbyte)chordSection.Chords[i].Frets[3];                  sct2014.Fret4 = (sbyte)chordSection.Chords[i].Frets[4];                  sct2014.Fret5 = (sbyte)chordSection.Chords[i].Frets[5];                  sct2014.ChordId = null;                    // Parse chord mask                  var mask = chordSection.Chords[i].Mask;                  if ((mask & CON.CHORD_MASK_ARPEGGIO) != 0)                  {                      mask &= ~CON.CHORD_MASK_ARPEGGIO;                      sct2014.DisplayName += "-arp";                  }                  else if ((mask & CON.CHORD_MASK_NOP) != 0)                  {                      mask &= ~CON.CHORD_MASK_NOP;                      sct2014.DisplayName += "-nop";                  }                    chordTemplates[i] = sct2014;              }
Magic Number,RocksmithToolkitLib.XML,SongChordTemplate2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Parse,The following statement contains a magic number: for (int i = 0; i < chordSection.Count; i++)              {                  var sct2014 = new SongChordTemplate2014();                  sct2014.ChordName = sct2014.DisplayName = chordSection.Chords[i].Name.ToNullTerminatedAscii();                  sct2014.Finger0 = (sbyte)chordSection.Chords[i].Fingers[0];                  sct2014.Finger1 = (sbyte)chordSection.Chords[i].Fingers[1];                  sct2014.Finger2 = (sbyte)chordSection.Chords[i].Fingers[2];                  sct2014.Finger3 = (sbyte)chordSection.Chords[i].Fingers[3];                  sct2014.Finger4 = (sbyte)chordSection.Chords[i].Fingers[4];                  sct2014.Finger5 = (sbyte)chordSection.Chords[i].Fingers[5];                  sct2014.Fret0 = (sbyte)chordSection.Chords[i].Frets[0];                  sct2014.Fret1 = (sbyte)chordSection.Chords[i].Frets[1];                  sct2014.Fret2 = (sbyte)chordSection.Chords[i].Frets[2];                  sct2014.Fret3 = (sbyte)chordSection.Chords[i].Frets[3];                  sct2014.Fret4 = (sbyte)chordSection.Chords[i].Frets[4];                  sct2014.Fret5 = (sbyte)chordSection.Chords[i].Frets[5];                  sct2014.ChordId = null;                    // Parse chord mask                  var mask = chordSection.Chords[i].Mask;                  if ((mask & CON.CHORD_MASK_ARPEGGIO) != 0)                  {                      mask &= ~CON.CHORD_MASK_ARPEGGIO;                      sct2014.DisplayName += "-arp";                  }                  else if ((mask & CON.CHORD_MASK_NOP) != 0)                  {                      mask &= ~CON.CHORD_MASK_NOP;                      sct2014.DisplayName += "-nop";                  }                    chordTemplates[i] = sct2014;              }
Magic Number,RocksmithToolkitLib.XML,SongChordTemplate2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Parse,The following statement contains a magic number: for (int i = 0; i < chordSection.Count; i++)              {                  var sct2014 = new SongChordTemplate2014();                  sct2014.ChordName = sct2014.DisplayName = chordSection.Chords[i].Name.ToNullTerminatedAscii();                  sct2014.Finger0 = (sbyte)chordSection.Chords[i].Fingers[0];                  sct2014.Finger1 = (sbyte)chordSection.Chords[i].Fingers[1];                  sct2014.Finger2 = (sbyte)chordSection.Chords[i].Fingers[2];                  sct2014.Finger3 = (sbyte)chordSection.Chords[i].Fingers[3];                  sct2014.Finger4 = (sbyte)chordSection.Chords[i].Fingers[4];                  sct2014.Finger5 = (sbyte)chordSection.Chords[i].Fingers[5];                  sct2014.Fret0 = (sbyte)chordSection.Chords[i].Frets[0];                  sct2014.Fret1 = (sbyte)chordSection.Chords[i].Frets[1];                  sct2014.Fret2 = (sbyte)chordSection.Chords[i].Frets[2];                  sct2014.Fret3 = (sbyte)chordSection.Chords[i].Frets[3];                  sct2014.Fret4 = (sbyte)chordSection.Chords[i].Frets[4];                  sct2014.Fret5 = (sbyte)chordSection.Chords[i].Frets[5];                  sct2014.ChordId = null;                    // Parse chord mask                  var mask = chordSection.Chords[i].Mask;                  if ((mask & CON.CHORD_MASK_ARPEGGIO) != 0)                  {                      mask &= ~CON.CHORD_MASK_ARPEGGIO;                      sct2014.DisplayName += "-arp";                  }                  else if ((mask & CON.CHORD_MASK_NOP) != 0)                  {                      mask &= ~CON.CHORD_MASK_NOP;                      sct2014.DisplayName += "-nop";                  }                    chordTemplates[i] = sct2014;              }
Magic Number,RocksmithToolkitLib.XML,SongChordTemplate2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Parse,The following statement contains a magic number: for (int i = 0; i < chordSection.Count; i++)              {                  var sct2014 = new SongChordTemplate2014();                  sct2014.ChordName = sct2014.DisplayName = chordSection.Chords[i].Name.ToNullTerminatedAscii();                  sct2014.Finger0 = (sbyte)chordSection.Chords[i].Fingers[0];                  sct2014.Finger1 = (sbyte)chordSection.Chords[i].Fingers[1];                  sct2014.Finger2 = (sbyte)chordSection.Chords[i].Fingers[2];                  sct2014.Finger3 = (sbyte)chordSection.Chords[i].Fingers[3];                  sct2014.Finger4 = (sbyte)chordSection.Chords[i].Fingers[4];                  sct2014.Finger5 = (sbyte)chordSection.Chords[i].Fingers[5];                  sct2014.Fret0 = (sbyte)chordSection.Chords[i].Frets[0];                  sct2014.Fret1 = (sbyte)chordSection.Chords[i].Frets[1];                  sct2014.Fret2 = (sbyte)chordSection.Chords[i].Frets[2];                  sct2014.Fret3 = (sbyte)chordSection.Chords[i].Frets[3];                  sct2014.Fret4 = (sbyte)chordSection.Chords[i].Frets[4];                  sct2014.Fret5 = (sbyte)chordSection.Chords[i].Frets[5];                  sct2014.ChordId = null;                    // Parse chord mask                  var mask = chordSection.Chords[i].Mask;                  if ((mask & CON.CHORD_MASK_ARPEGGIO) != 0)                  {                      mask &= ~CON.CHORD_MASK_ARPEGGIO;                      sct2014.DisplayName += "-arp";                  }                  else if ((mask & CON.CHORD_MASK_NOP) != 0)                  {                      mask &= ~CON.CHORD_MASK_NOP;                      sct2014.DisplayName += "-nop";                  }                    chordTemplates[i] = sct2014;              }
Magic Number,RocksmithToolkitLib.XML,SongChordTemplate2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Parse,The following statement contains a magic number: for (int i = 0; i < chordSection.Count; i++)              {                  var sct2014 = new SongChordTemplate2014();                  sct2014.ChordName = sct2014.DisplayName = chordSection.Chords[i].Name.ToNullTerminatedAscii();                  sct2014.Finger0 = (sbyte)chordSection.Chords[i].Fingers[0];                  sct2014.Finger1 = (sbyte)chordSection.Chords[i].Fingers[1];                  sct2014.Finger2 = (sbyte)chordSection.Chords[i].Fingers[2];                  sct2014.Finger3 = (sbyte)chordSection.Chords[i].Fingers[3];                  sct2014.Finger4 = (sbyte)chordSection.Chords[i].Fingers[4];                  sct2014.Finger5 = (sbyte)chordSection.Chords[i].Fingers[5];                  sct2014.Fret0 = (sbyte)chordSection.Chords[i].Frets[0];                  sct2014.Fret1 = (sbyte)chordSection.Chords[i].Frets[1];                  sct2014.Fret2 = (sbyte)chordSection.Chords[i].Frets[2];                  sct2014.Fret3 = (sbyte)chordSection.Chords[i].Frets[3];                  sct2014.Fret4 = (sbyte)chordSection.Chords[i].Frets[4];                  sct2014.Fret5 = (sbyte)chordSection.Chords[i].Frets[5];                  sct2014.ChordId = null;                    // Parse chord mask                  var mask = chordSection.Chords[i].Mask;                  if ((mask & CON.CHORD_MASK_ARPEGGIO) != 0)                  {                      mask &= ~CON.CHORD_MASK_ARPEGGIO;                      sct2014.DisplayName += "-arp";                  }                  else if ((mask & CON.CHORD_MASK_NOP) != 0)                  {                      mask &= ~CON.CHORD_MASK_NOP;                      sct2014.DisplayName += "-nop";                  }                    chordTemplates[i] = sct2014;              }
Magic Number,RocksmithToolkitLib.XML,SongChordTemplate2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Parse,The following statement contains a magic number: for (int i = 0; i < chordSection.Count; i++)              {                  var sct2014 = new SongChordTemplate2014();                  sct2014.ChordName = sct2014.DisplayName = chordSection.Chords[i].Name.ToNullTerminatedAscii();                  sct2014.Finger0 = (sbyte)chordSection.Chords[i].Fingers[0];                  sct2014.Finger1 = (sbyte)chordSection.Chords[i].Fingers[1];                  sct2014.Finger2 = (sbyte)chordSection.Chords[i].Fingers[2];                  sct2014.Finger3 = (sbyte)chordSection.Chords[i].Fingers[3];                  sct2014.Finger4 = (sbyte)chordSection.Chords[i].Fingers[4];                  sct2014.Finger5 = (sbyte)chordSection.Chords[i].Fingers[5];                  sct2014.Fret0 = (sbyte)chordSection.Chords[i].Frets[0];                  sct2014.Fret1 = (sbyte)chordSection.Chords[i].Frets[1];                  sct2014.Fret2 = (sbyte)chordSection.Chords[i].Frets[2];                  sct2014.Fret3 = (sbyte)chordSection.Chords[i].Frets[3];                  sct2014.Fret4 = (sbyte)chordSection.Chords[i].Frets[4];                  sct2014.Fret5 = (sbyte)chordSection.Chords[i].Frets[5];                  sct2014.ChordId = null;                    // Parse chord mask                  var mask = chordSection.Chords[i].Mask;                  if ((mask & CON.CHORD_MASK_ARPEGGIO) != 0)                  {                      mask &= ~CON.CHORD_MASK_ARPEGGIO;                      sct2014.DisplayName += "-arp";                  }                  else if ((mask & CON.CHORD_MASK_NOP) != 0)                  {                      mask &= ~CON.CHORD_MASK_NOP;                      sct2014.DisplayName += "-nop";                  }                    chordTemplates[i] = sct2014;              }
Magic Number,RocksmithToolkitLib.XML,SongChordTemplate2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Parse,The following statement contains a magic number: for (int i = 0; i < chordSection.Count; i++)              {                  var sct2014 = new SongChordTemplate2014();                  sct2014.ChordName = sct2014.DisplayName = chordSection.Chords[i].Name.ToNullTerminatedAscii();                  sct2014.Finger0 = (sbyte)chordSection.Chords[i].Fingers[0];                  sct2014.Finger1 = (sbyte)chordSection.Chords[i].Fingers[1];                  sct2014.Finger2 = (sbyte)chordSection.Chords[i].Fingers[2];                  sct2014.Finger3 = (sbyte)chordSection.Chords[i].Fingers[3];                  sct2014.Finger4 = (sbyte)chordSection.Chords[i].Fingers[4];                  sct2014.Finger5 = (sbyte)chordSection.Chords[i].Fingers[5];                  sct2014.Fret0 = (sbyte)chordSection.Chords[i].Frets[0];                  sct2014.Fret1 = (sbyte)chordSection.Chords[i].Frets[1];                  sct2014.Fret2 = (sbyte)chordSection.Chords[i].Frets[2];                  sct2014.Fret3 = (sbyte)chordSection.Chords[i].Frets[3];                  sct2014.Fret4 = (sbyte)chordSection.Chords[i].Frets[4];                  sct2014.Fret5 = (sbyte)chordSection.Chords[i].Frets[5];                  sct2014.ChordId = null;                    // Parse chord mask                  var mask = chordSection.Chords[i].Mask;                  if ((mask & CON.CHORD_MASK_ARPEGGIO) != 0)                  {                      mask &= ~CON.CHORD_MASK_ARPEGGIO;                      sct2014.DisplayName += "-arp";                  }                  else if ((mask & CON.CHORD_MASK_NOP) != 0)                  {                      mask &= ~CON.CHORD_MASK_NOP;                      sct2014.DisplayName += "-nop";                  }                    chordTemplates[i] = sct2014;              }
Magic Number,RocksmithToolkitLib.XML,SongChordTemplate2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Parse,The following statement contains a magic number: for (int i = 0; i < chordSection.Count; i++)              {                  var sct2014 = new SongChordTemplate2014();                  sct2014.ChordName = sct2014.DisplayName = chordSection.Chords[i].Name.ToNullTerminatedAscii();                  sct2014.Finger0 = (sbyte)chordSection.Chords[i].Fingers[0];                  sct2014.Finger1 = (sbyte)chordSection.Chords[i].Fingers[1];                  sct2014.Finger2 = (sbyte)chordSection.Chords[i].Fingers[2];                  sct2014.Finger3 = (sbyte)chordSection.Chords[i].Fingers[3];                  sct2014.Finger4 = (sbyte)chordSection.Chords[i].Fingers[4];                  sct2014.Finger5 = (sbyte)chordSection.Chords[i].Fingers[5];                  sct2014.Fret0 = (sbyte)chordSection.Chords[i].Frets[0];                  sct2014.Fret1 = (sbyte)chordSection.Chords[i].Frets[1];                  sct2014.Fret2 = (sbyte)chordSection.Chords[i].Frets[2];                  sct2014.Fret3 = (sbyte)chordSection.Chords[i].Frets[3];                  sct2014.Fret4 = (sbyte)chordSection.Chords[i].Frets[4];                  sct2014.Fret5 = (sbyte)chordSection.Chords[i].Frets[5];                  sct2014.ChordId = null;                    // Parse chord mask                  var mask = chordSection.Chords[i].Mask;                  if ((mask & CON.CHORD_MASK_ARPEGGIO) != 0)                  {                      mask &= ~CON.CHORD_MASK_ARPEGGIO;                      sct2014.DisplayName += "-arp";                  }                  else if ((mask & CON.CHORD_MASK_NOP) != 0)                  {                      mask &= ~CON.CHORD_MASK_NOP;                      sct2014.DisplayName += "-nop";                  }                    chordTemplates[i] = sct2014;              }
Magic Number,RocksmithToolkitLib.XML,SongChordTemplate2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,AddChordIds,The following statement contains a magic number: for (int i = 0; i < ctemplateList.Count; i++)              {                  var ct = ctemplateList[i];                  var matchingChord = chordTemplates.FirstOrDefault(sct =>                      sct.Fret0 == ct.Frets[0] &&                      sct.Fret1 == ct.Frets[1] &&                      sct.Fret2 == ct.Frets[2] &&                      sct.Fret3 == ct.Frets[3] &&                      sct.Fret4 == ct.Frets[4] &&                      sct.Fret5 == ct.Frets[5]);                  if (matchingChord != null)                      matchingChord.ChordId = ct.ChordId;              }
Magic Number,RocksmithToolkitLib.XML,SongChordTemplate2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,AddChordIds,The following statement contains a magic number: for (int i = 0; i < ctemplateList.Count; i++)              {                  var ct = ctemplateList[i];                  var matchingChord = chordTemplates.FirstOrDefault(sct =>                      sct.Fret0 == ct.Frets[0] &&                      sct.Fret1 == ct.Frets[1] &&                      sct.Fret2 == ct.Frets[2] &&                      sct.Fret3 == ct.Frets[3] &&                      sct.Fret4 == ct.Frets[4] &&                      sct.Fret5 == ct.Frets[5]);                  if (matchingChord != null)                      matchingChord.ChordId = ct.ChordId;              }
Magic Number,RocksmithToolkitLib.XML,SongChordTemplate2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,AddChordIds,The following statement contains a magic number: for (int i = 0; i < ctemplateList.Count; i++)              {                  var ct = ctemplateList[i];                  var matchingChord = chordTemplates.FirstOrDefault(sct =>                      sct.Fret0 == ct.Frets[0] &&                      sct.Fret1 == ct.Frets[1] &&                      sct.Fret2 == ct.Frets[2] &&                      sct.Fret3 == ct.Frets[3] &&                      sct.Fret4 == ct.Frets[4] &&                      sct.Fret5 == ct.Frets[5]);                  if (matchingChord != null)                      matchingChord.ChordId = ct.ChordId;              }
Magic Number,RocksmithToolkitLib.XML,SongChordTemplate2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,AddChordIds,The following statement contains a magic number: for (int i = 0; i < ctemplateList.Count; i++)              {                  var ct = ctemplateList[i];                  var matchingChord = chordTemplates.FirstOrDefault(sct =>                      sct.Fret0 == ct.Frets[0] &&                      sct.Fret1 == ct.Frets[1] &&                      sct.Fret2 == ct.Frets[2] &&                      sct.Fret3 == ct.Frets[3] &&                      sct.Fret4 == ct.Frets[4] &&                      sct.Fret5 == ct.Frets[5]);                  if (matchingChord != null)                      matchingChord.ChordId = ct.ChordId;              }
Magic Number,RocksmithToolkitLib.XML,SongNote2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Parse,The following statement contains a magic number: for (var i = 0; i < notesSection.Count; i++)              {                  if (notesSection.Notes[i].ChordId != -1)                      continue; //Skip chord notes (get only single notes)                    var note = new SongNote2014();                    // BASIC INFO                  note.Time = notesSection.Notes[i].Time;                  note.Fret = (sbyte)notesSection.Notes[i].FretId;                  note.String = notesSection.Notes[i].StringIndex;                    // TECHNIQUES                  note.PickDirection = notesSection.Notes[i].PickDirection;                  note.parseNoteMask(notesSection.Notes[i].NoteMask); //NOTE MASK need to be setup previous get property values                  // Techniques with own properties                  if (notesSection.Notes[i].LeftHand != 255) note.LeftHand = (sbyte)notesSection.Notes[i].LeftHand;                  if (notesSection.Notes[i].SlideTo != 255) note.SlideTo = (sbyte)notesSection.Notes[i].SlideTo;                  if (notesSection.Notes[i].SlideUnpitchTo != 255) note.SlideUnpitchTo = (sbyte)notesSection.Notes[i].SlideUnpitchTo;                  if (notesSection.Notes[i].Tap != 255) note.Tap = notesSection.Notes[i].Tap;                  if (notesSection.Notes[i].Slap != 255) note.Slap = (sbyte)notesSection.Notes[i].Slap;                  if (notesSection.Notes[i].Pluck != 255) note.Pluck = (sbyte)notesSection.Notes[i].Pluck;                  if (notesSection.Notes[i].Vibrato != 0) note.Vibrato = notesSection.Notes[i].Vibrato;                  if (notesSection.Notes[i].Sustain != 0) note.Sustain = notesSection.Notes[i].Sustain;                  if (notesSection.Notes[i].MaxBend != 0) note.Bend = notesSection.Notes[i].MaxBend;                  note.BendValues = BendValue.Parse(notesSection.Notes[i].BendData.BendData);                    notes.Add(note);              }
Magic Number,RocksmithToolkitLib.XML,SongNote2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Parse,The following statement contains a magic number: for (var i = 0; i < notesSection.Count; i++)              {                  if (notesSection.Notes[i].ChordId != -1)                      continue; //Skip chord notes (get only single notes)                    var note = new SongNote2014();                    // BASIC INFO                  note.Time = notesSection.Notes[i].Time;                  note.Fret = (sbyte)notesSection.Notes[i].FretId;                  note.String = notesSection.Notes[i].StringIndex;                    // TECHNIQUES                  note.PickDirection = notesSection.Notes[i].PickDirection;                  note.parseNoteMask(notesSection.Notes[i].NoteMask); //NOTE MASK need to be setup previous get property values                  // Techniques with own properties                  if (notesSection.Notes[i].LeftHand != 255) note.LeftHand = (sbyte)notesSection.Notes[i].LeftHand;                  if (notesSection.Notes[i].SlideTo != 255) note.SlideTo = (sbyte)notesSection.Notes[i].SlideTo;                  if (notesSection.Notes[i].SlideUnpitchTo != 255) note.SlideUnpitchTo = (sbyte)notesSection.Notes[i].SlideUnpitchTo;                  if (notesSection.Notes[i].Tap != 255) note.Tap = notesSection.Notes[i].Tap;                  if (notesSection.Notes[i].Slap != 255) note.Slap = (sbyte)notesSection.Notes[i].Slap;                  if (notesSection.Notes[i].Pluck != 255) note.Pluck = (sbyte)notesSection.Notes[i].Pluck;                  if (notesSection.Notes[i].Vibrato != 0) note.Vibrato = notesSection.Notes[i].Vibrato;                  if (notesSection.Notes[i].Sustain != 0) note.Sustain = notesSection.Notes[i].Sustain;                  if (notesSection.Notes[i].MaxBend != 0) note.Bend = notesSection.Notes[i].MaxBend;                  note.BendValues = BendValue.Parse(notesSection.Notes[i].BendData.BendData);                    notes.Add(note);              }
Magic Number,RocksmithToolkitLib.XML,SongNote2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Parse,The following statement contains a magic number: for (var i = 0; i < notesSection.Count; i++)              {                  if (notesSection.Notes[i].ChordId != -1)                      continue; //Skip chord notes (get only single notes)                    var note = new SongNote2014();                    // BASIC INFO                  note.Time = notesSection.Notes[i].Time;                  note.Fret = (sbyte)notesSection.Notes[i].FretId;                  note.String = notesSection.Notes[i].StringIndex;                    // TECHNIQUES                  note.PickDirection = notesSection.Notes[i].PickDirection;                  note.parseNoteMask(notesSection.Notes[i].NoteMask); //NOTE MASK need to be setup previous get property values                  // Techniques with own properties                  if (notesSection.Notes[i].LeftHand != 255) note.LeftHand = (sbyte)notesSection.Notes[i].LeftHand;                  if (notesSection.Notes[i].SlideTo != 255) note.SlideTo = (sbyte)notesSection.Notes[i].SlideTo;                  if (notesSection.Notes[i].SlideUnpitchTo != 255) note.SlideUnpitchTo = (sbyte)notesSection.Notes[i].SlideUnpitchTo;                  if (notesSection.Notes[i].Tap != 255) note.Tap = notesSection.Notes[i].Tap;                  if (notesSection.Notes[i].Slap != 255) note.Slap = (sbyte)notesSection.Notes[i].Slap;                  if (notesSection.Notes[i].Pluck != 255) note.Pluck = (sbyte)notesSection.Notes[i].Pluck;                  if (notesSection.Notes[i].Vibrato != 0) note.Vibrato = notesSection.Notes[i].Vibrato;                  if (notesSection.Notes[i].Sustain != 0) note.Sustain = notesSection.Notes[i].Sustain;                  if (notesSection.Notes[i].MaxBend != 0) note.Bend = notesSection.Notes[i].MaxBend;                  note.BendValues = BendValue.Parse(notesSection.Notes[i].BendData.BendData);                    notes.Add(note);              }
Magic Number,RocksmithToolkitLib.XML,SongNote2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Parse,The following statement contains a magic number: for (var i = 0; i < notesSection.Count; i++)              {                  if (notesSection.Notes[i].ChordId != -1)                      continue; //Skip chord notes (get only single notes)                    var note = new SongNote2014();                    // BASIC INFO                  note.Time = notesSection.Notes[i].Time;                  note.Fret = (sbyte)notesSection.Notes[i].FretId;                  note.String = notesSection.Notes[i].StringIndex;                    // TECHNIQUES                  note.PickDirection = notesSection.Notes[i].PickDirection;                  note.parseNoteMask(notesSection.Notes[i].NoteMask); //NOTE MASK need to be setup previous get property values                  // Techniques with own properties                  if (notesSection.Notes[i].LeftHand != 255) note.LeftHand = (sbyte)notesSection.Notes[i].LeftHand;                  if (notesSection.Notes[i].SlideTo != 255) note.SlideTo = (sbyte)notesSection.Notes[i].SlideTo;                  if (notesSection.Notes[i].SlideUnpitchTo != 255) note.SlideUnpitchTo = (sbyte)notesSection.Notes[i].SlideUnpitchTo;                  if (notesSection.Notes[i].Tap != 255) note.Tap = notesSection.Notes[i].Tap;                  if (notesSection.Notes[i].Slap != 255) note.Slap = (sbyte)notesSection.Notes[i].Slap;                  if (notesSection.Notes[i].Pluck != 255) note.Pluck = (sbyte)notesSection.Notes[i].Pluck;                  if (notesSection.Notes[i].Vibrato != 0) note.Vibrato = notesSection.Notes[i].Vibrato;                  if (notesSection.Notes[i].Sustain != 0) note.Sustain = notesSection.Notes[i].Sustain;                  if (notesSection.Notes[i].MaxBend != 0) note.Bend = notesSection.Notes[i].MaxBend;                  note.BendValues = BendValue.Parse(notesSection.Notes[i].BendData.BendData);                    notes.Add(note);              }
Magic Number,RocksmithToolkitLib.XML,SongNote2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Parse,The following statement contains a magic number: for (var i = 0; i < notesSection.Count; i++)              {                  if (notesSection.Notes[i].ChordId != -1)                      continue; //Skip chord notes (get only single notes)                    var note = new SongNote2014();                    // BASIC INFO                  note.Time = notesSection.Notes[i].Time;                  note.Fret = (sbyte)notesSection.Notes[i].FretId;                  note.String = notesSection.Notes[i].StringIndex;                    // TECHNIQUES                  note.PickDirection = notesSection.Notes[i].PickDirection;                  note.parseNoteMask(notesSection.Notes[i].NoteMask); //NOTE MASK need to be setup previous get property values                  // Techniques with own properties                  if (notesSection.Notes[i].LeftHand != 255) note.LeftHand = (sbyte)notesSection.Notes[i].LeftHand;                  if (notesSection.Notes[i].SlideTo != 255) note.SlideTo = (sbyte)notesSection.Notes[i].SlideTo;                  if (notesSection.Notes[i].SlideUnpitchTo != 255) note.SlideUnpitchTo = (sbyte)notesSection.Notes[i].SlideUnpitchTo;                  if (notesSection.Notes[i].Tap != 255) note.Tap = notesSection.Notes[i].Tap;                  if (notesSection.Notes[i].Slap != 255) note.Slap = (sbyte)notesSection.Notes[i].Slap;                  if (notesSection.Notes[i].Pluck != 255) note.Pluck = (sbyte)notesSection.Notes[i].Pluck;                  if (notesSection.Notes[i].Vibrato != 0) note.Vibrato = notesSection.Notes[i].Vibrato;                  if (notesSection.Notes[i].Sustain != 0) note.Sustain = notesSection.Notes[i].Sustain;                  if (notesSection.Notes[i].MaxBend != 0) note.Bend = notesSection.Notes[i].MaxBend;                  note.BendValues = BendValue.Parse(notesSection.Notes[i].BendData.BendData);                    notes.Add(note);              }
Magic Number,RocksmithToolkitLib.XML,SongNote2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Parse,The following statement contains a magic number: for (var i = 0; i < notesSection.Count; i++)              {                  if (notesSection.Notes[i].ChordId != -1)                      continue; //Skip chord notes (get only single notes)                    var note = new SongNote2014();                    // BASIC INFO                  note.Time = notesSection.Notes[i].Time;                  note.Fret = (sbyte)notesSection.Notes[i].FretId;                  note.String = notesSection.Notes[i].StringIndex;                    // TECHNIQUES                  note.PickDirection = notesSection.Notes[i].PickDirection;                  note.parseNoteMask(notesSection.Notes[i].NoteMask); //NOTE MASK need to be setup previous get property values                  // Techniques with own properties                  if (notesSection.Notes[i].LeftHand != 255) note.LeftHand = (sbyte)notesSection.Notes[i].LeftHand;                  if (notesSection.Notes[i].SlideTo != 255) note.SlideTo = (sbyte)notesSection.Notes[i].SlideTo;                  if (notesSection.Notes[i].SlideUnpitchTo != 255) note.SlideUnpitchTo = (sbyte)notesSection.Notes[i].SlideUnpitchTo;                  if (notesSection.Notes[i].Tap != 255) note.Tap = notesSection.Notes[i].Tap;                  if (notesSection.Notes[i].Slap != 255) note.Slap = (sbyte)notesSection.Notes[i].Slap;                  if (notesSection.Notes[i].Pluck != 255) note.Pluck = (sbyte)notesSection.Notes[i].Pluck;                  if (notesSection.Notes[i].Vibrato != 0) note.Vibrato = notesSection.Notes[i].Vibrato;                  if (notesSection.Notes[i].Sustain != 0) note.Sustain = notesSection.Notes[i].Sustain;                  if (notesSection.Notes[i].MaxBend != 0) note.Bend = notesSection.Notes[i].MaxBend;                  note.BendValues = BendValue.Parse(notesSection.Notes[i].BendData.BendData);                    notes.Add(note);              }
Magic Number,RocksmithToolkitLib.XML,SongChord2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,ParseChordNotes,The following statement contains a magic number: for (var i = 0; i < 6; i++)              {                  if ((chordNotes != null && chordNotes.NoteMask[i] != 0) || //notes with techniques                      (chordNotes == null && template.Frets[i] != 255))                  { // Notes without techniques                        var cnote = new SongNote2014();                        // SETUP DEFAULT VALUES                      cnote.RightHand = notSetup;                      cnote.LeftHand = notSetup;                      cnote.SlideTo = notSetup;                      cnote.SlideUnpitchTo = notSetup;                      cnote.Tap = (byte)0;                      cnote.Slap = notSetup;                      cnote.Pluck = notSetup;                        if ((chordNotes != null && chordNotes.NoteMask[i] != 0))                      {                          // SETUP FROM OWN PROPERTIES                          cnote.parseNoteMask(chordNotes.NoteMask[i]);                          cnote.SlideTo = (sbyte)chordNotes.SlideTo[i];                          cnote.SlideUnpitchTo = (sbyte)chordNotes.SlideUnpitchTo[i];                          cnote.Vibrato = chordNotes.Vibrato[i];                          cnote.Sustain = chordSustain;                          cnote.BendValues = BendValue.Parse(chordNotes.BendData[i].BendData32);                          //Fix bend status from step in bendvalues                          if (cnote.BendValues != null && cnote.BendValues.Length > 0)                              foreach (var bend in cnote.BendValues)                                  if (cnote.Bend < bend.Step)                                      cnote.Bend = bend.Step;                      }                        // BASIC INFO                      cnote.Time = this.Time;                      cnote.Fret = (sbyte)template.Frets[i];                      cnote.LeftHand = (sbyte)template.Fingers[i];                      cnote.String = (byte)i;                        notes.Add(cnote);                  }              }
Magic Number,RocksmithToolkitLib.XML,SongChord2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,ParseChordNotes,The following statement contains a magic number: for (var i = 0; i < 6; i++)              {                  if ((chordNotes != null && chordNotes.NoteMask[i] != 0) || //notes with techniques                      (chordNotes == null && template.Frets[i] != 255))                  { // Notes without techniques                        var cnote = new SongNote2014();                        // SETUP DEFAULT VALUES                      cnote.RightHand = notSetup;                      cnote.LeftHand = notSetup;                      cnote.SlideTo = notSetup;                      cnote.SlideUnpitchTo = notSetup;                      cnote.Tap = (byte)0;                      cnote.Slap = notSetup;                      cnote.Pluck = notSetup;                        if ((chordNotes != null && chordNotes.NoteMask[i] != 0))                      {                          // SETUP FROM OWN PROPERTIES                          cnote.parseNoteMask(chordNotes.NoteMask[i]);                          cnote.SlideTo = (sbyte)chordNotes.SlideTo[i];                          cnote.SlideUnpitchTo = (sbyte)chordNotes.SlideUnpitchTo[i];                          cnote.Vibrato = chordNotes.Vibrato[i];                          cnote.Sustain = chordSustain;                          cnote.BendValues = BendValue.Parse(chordNotes.BendData[i].BendData32);                          //Fix bend status from step in bendvalues                          if (cnote.BendValues != null && cnote.BendValues.Length > 0)                              foreach (var bend in cnote.BendValues)                                  if (cnote.Bend < bend.Step)                                      cnote.Bend = bend.Step;                      }                        // BASIC INFO                      cnote.Time = this.Time;                      cnote.Fret = (sbyte)template.Frets[i];                      cnote.LeftHand = (sbyte)template.Fingers[i];                      cnote.String = (byte)i;                        notes.Add(cnote);                  }              }
Magic Number,RocksmithToolkitLib.XML,SongTone2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Parse,The following statement contains a magic number: for (var i = 0; i < toneSection.Count; i++)              {                  var tone = new SongTone2014                  {                      Id = toneSection.Tones[i].ToneId'                      Time = toneSection.Tones[i].Time                  };                    if (attr != null)                  {                      // Get tone name                      switch (tone.Id)                      {                          case 0:                              tone.Name = attr.Tone_A;                              break;                          case 1:                              tone.Name = attr.Tone_B;                              break;                          case 2:                              tone.Name = attr.Tone_C;                              break;                          case 3:                              tone.Name = attr.Tone_D;                              break;                          default:                              tone.Name = "importedtone_" + tone.Id;                              break;                      }                  }                  else                      tone.Name = "importedtone_" + tone.Id;                    tones[i] = tone;              }
Magic Number,RocksmithToolkitLib.XML,SongTone2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song2014.cs,Parse,The following statement contains a magic number: for (var i = 0; i < toneSection.Count; i++)              {                  var tone = new SongTone2014                  {                      Id = toneSection.Tones[i].ToneId'                      Time = toneSection.Tones[i].Time                  };                    if (attr != null)                  {                      // Get tone name                      switch (tone.Id)                      {                          case 0:                              tone.Name = attr.Tone_A;                              break;                          case 1:                              tone.Name = attr.Tone_B;                              break;                          case 2:                              tone.Name = attr.Tone_C;                              break;                          case 3:                              tone.Name = attr.Tone_D;                              break;                          default:                              tone.Name = "importedtone_" + tone.Id;                              break;                      }                  }                  else                      tone.Name = "importedtone_" + tone.Id;                    tones[i] = tone;              }
Magic Number,RocksmithToolkitLib.XML,TuningStrings,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song.cs,TuningStrings,The following statement contains a magic number: String2 = stringArray[2];
Magic Number,RocksmithToolkitLib.XML,TuningStrings,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song.cs,TuningStrings,The following statement contains a magic number: String3 = stringArray[3];
Magic Number,RocksmithToolkitLib.XML,TuningStrings,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song.cs,TuningStrings,The following statement contains a magic number: if (stringArray.Length > 4)                  String4 = stringArray[4];
Magic Number,RocksmithToolkitLib.XML,TuningStrings,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song.cs,TuningStrings,The following statement contains a magic number: if (stringArray.Length > 4)                  String4 = stringArray[4];
Magic Number,RocksmithToolkitLib.XML,TuningStrings,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song.cs,TuningStrings,The following statement contains a magic number: if (stringArray.Length > 5)                  String5 = stringArray[5];
Magic Number,RocksmithToolkitLib.XML,TuningStrings,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song.cs,TuningStrings,The following statement contains a magic number: if (stringArray.Length > 5)                  String5 = stringArray[5];
Magic Number,RocksmithToolkitLib.XML,TuningStrings,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = String0.GetHashCode();                  hashCode = (hashCode * 397) ^ String1.GetHashCode();                  hashCode = (hashCode * 397) ^ String2.GetHashCode();                  hashCode = (hashCode * 397) ^ String3.GetHashCode();                  hashCode = (hashCode * 397) ^ String4.GetHashCode();                  hashCode = (hashCode * 397) ^ String5.GetHashCode();                  return hashCode;              }
Magic Number,RocksmithToolkitLib.XML,TuningStrings,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = String0.GetHashCode();                  hashCode = (hashCode * 397) ^ String1.GetHashCode();                  hashCode = (hashCode * 397) ^ String2.GetHashCode();                  hashCode = (hashCode * 397) ^ String3.GetHashCode();                  hashCode = (hashCode * 397) ^ String4.GetHashCode();                  hashCode = (hashCode * 397) ^ String5.GetHashCode();                  return hashCode;              }
Magic Number,RocksmithToolkitLib.XML,TuningStrings,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = String0.GetHashCode();                  hashCode = (hashCode * 397) ^ String1.GetHashCode();                  hashCode = (hashCode * 397) ^ String2.GetHashCode();                  hashCode = (hashCode * 397) ^ String3.GetHashCode();                  hashCode = (hashCode * 397) ^ String4.GetHashCode();                  hashCode = (hashCode * 397) ^ String5.GetHashCode();                  return hashCode;              }
Magic Number,RocksmithToolkitLib.XML,TuningStrings,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = String0.GetHashCode();                  hashCode = (hashCode * 397) ^ String1.GetHashCode();                  hashCode = (hashCode * 397) ^ String2.GetHashCode();                  hashCode = (hashCode * 397) ^ String3.GetHashCode();                  hashCode = (hashCode * 397) ^ String4.GetHashCode();                  hashCode = (hashCode * 397) ^ String5.GetHashCode();                  return hashCode;              }
Magic Number,RocksmithToolkitLib.XML,TuningStrings,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\XML\Song.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  var hashCode = String0.GetHashCode();                  hashCode = (hashCode * 397) ^ String1.GetHashCode();                  hashCode = (hashCode * 397) ^ String2.GetHashCode();                  hashCode = (hashCode * 397) ^ String3.GetHashCode();                  hashCode = (hashCode * 397) ^ String4.GetHashCode();                  hashCode = (hashCode * 397) ^ String5.GetHashCode();                  return hashCode;              }
Magic Number,RocksmithToolkitLib.DLCPackage.XBlock,GameXblock<T>,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\XBlock\GameXblock.cs,Generate,The following statement contains a magic number: foreach (var x in manifest.Entries)              {                  var entry = x.Value["Attributes"];                  var entity = new Entity();                  bool isVocal = entry.ArrangementName == "Vocals";                  bool isBass = entry.ArrangementName == "Bass";                    entity.Id = entry.PersistentID.ToLower();                  entity.Name = String.Format("GRSong_Asset_{0}_{1}"' dlcName' entry.ArrangementName);                  entity.ModelName = "GRSong_Asset";                  entity.Iterations = 46;                  game.EntitySet.Add(entity);                  var properties = new List<Property>();                  var addProperty = new Action<string' object>((a' b) => properties.Add(CreateProperty(a' b.ToString())));                    if (isBass || isVocal)                      addProperty("BinaryVersion"' entry.BinaryVersion);                    addProperty("SongKey"' entry.SongKey);                  addProperty("SongAsset"' entry.SongAsset);                  addProperty("SongXml"' entry.SongXml);                  addProperty("ForceUseXML"' entry.ForceUseXML);                  addProperty("Shipping"' entry.Shipping);                  addProperty("DisplayName"' entry.DisplayName);                    addProperty("SongEvent"' entry.SongEvent);                    if (isVocal)                      addProperty("InputEvent"' entry.InputEvent);                    addProperty("ArrangementName"' entry.ArrangementName);                  addProperty("RepresentativeArrangement"' entry.RepresentativeArrangement);                    if (!isVocal && !String.IsNullOrEmpty(entry.VocalsAssetId))                  {                      addProperty("VocalsAssetId"' entry.VocalsAssetId.Split(new string[1] { "|" }' StringSplitOptions.RemoveEmptyEntries)[0]);                        var dynVisDen = new List<object>();                      foreach (var y in entry.DynamicVisualDensity)                          dynVisDen.Add(y);                      properties.Add(CreateMultiItemProperty("DynamicVisualDensity"' dynVisDen));                  }                    addProperty("ArtistName"' entry.ArtistName);                  addProperty("ArtistNameSort"' entry.ArtistNameSort);                  addProperty("SongName"' entry.SongName);                  addProperty("SongNameSort"' entry.SongNameSort);                  addProperty("AlbumName"' entry.AlbumName);                  addProperty("AlbumNameSort"' entry.AlbumNameSort);                  addProperty("SongYear"' entry.SongYear);                    if (!isVocal)                  {                      addProperty("RelativeDifficulty"' entry.RelativeDifficulty);                      addProperty("AverageTempo"' entry.AverageTempo);//fix this                        addProperty("NonStandardChords"' true);//fix this                      addProperty("DoubleStops"' entry.DoubleStops);                      addProperty("PowerChords"' entry.PowerChords);                      addProperty("OpenChords"' entry.OpenChords);                      addProperty("BarChords"' entry.BarChords);                      addProperty("Sustain"' entry.Sustain);                      addProperty("Bends"' entry.Bends);                      addProperty("Slides"' entry.Slides);                      addProperty("HOPOs"' entry.HOPOs);                      addProperty("PalmMutes"' entry.PalmMutes);                      addProperty("Vibrato"' entry.Vibrato);                        addProperty("MasterID_Xbox360"' entry.MasterID_Xbox360);                      addProperty("EffectChainName"' entry.EffectChainName);                      addProperty("CrowdTempo"' "Fast");//fix this                  }                    addProperty("AlbumArt"' entry.AlbumArt);                    entity.Properties = properties;              }
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,BetterDialog2,The following statement contains a magic number: this.Location = new Point((Screen.PrimaryScreen.WorkingArea.Width - this.Width) / 2 - leftFromCenter' (Screen.PrimaryScreen.WorkingArea.Height - this.Height) / 2 - topFromCenter);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,BetterDialog2,The following statement contains a magic number: this.Location = new Point((Screen.PrimaryScreen.WorkingArea.Width - this.Width) / 2 - leftFromCenter' (Screen.PrimaryScreen.WorkingArea.Height - this.Height) / 2 - topFromCenter);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,BetterDialog2,The following statement contains a magic number: int iconMessageTweak = 2;
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,BetterDialog2,The following statement contains a magic number: int dialogMessageTweak = 10;
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,BetterDialog2,The following statement contains a magic number: int heightTweak = 50;
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,BetterDialog2,The following statement contains a magic number: int widthTweak = 30;
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,BetterDialog2,The following statement contains a magic number: int minIconHeight = 48;
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,BetterDialog2,The following statement contains a magic number: int minIconWidth = 48;
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,BetterDialog2,The following statement contains a magic number: int buttonWidth = 100;
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,BetterDialog2,The following statement contains a magic number: int maxIconHeight = 240;
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,BetterDialog2,The following statement contains a magic number: int maxIconWidth = 240;
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,BetterDialog2,The following statement contains a magic number: using (Graphics graphics = this.CreateGraphics())              {                  var iconMessageSize = new SizeF();                  var dialogMessageSize = new SizeF();                    lblIconMessage.Font = new Font(SystemFonts.MessageBoxFont.FontFamily.Name' 10.0f' FontStyle.Bold' GraphicsUnit.Point);                  lblDialogMessage.Font = new Font(SystemFonts.MessageBoxFont.FontFamily.Name' 9.0f' FontStyle.Regular' GraphicsUnit.Point);                    // height automatically takes into account the number of line returns                  iconMessageSize = graphics.MeasureString(iconMessage' lblIconMessage.Font); //' this.lblIconMessage.Width);                  lblIconMessage.Width = (int)iconMessageSize.Width + iconMessageTweak;                  lblIconMessage.Height = (int)iconMessageSize.Height + iconMessageTweak;                  //                  dialogMessageSize = graphics.MeasureString(dialogMessage' lblDialogMessage.Font); // ' this.lblDialogMessage.Width);                  lblDialogMessage.Width = (int)dialogMessageSize.Width + widthTweak;                  lblDialogMessage.Height = (int)dialogMessageSize.Height + heightTweak + dialogMessageTweak;                    // customized table layout pannel (must clear)                  tlpDialog.ColumnStyles.Clear();                  tlpDialog.RowStyles.Clear();                    // apply colors for debugging                  //tlpDialog.BackColor = Color.Yellow;                  //lblIconMessage.BackColor = Color.Red;                  //lblDialogMessage.BackColor = Color.Lime;                    switch (checkByte) // eight possible conditions' 2^3=8                  {                      case 0x00: // no icon and no messages                          Controls.Remove(tlpDialog);                          Console.WriteLine("No icon or messages");                          break;                        case 0x01: // icon                          tlpDialog.ColumnCount = 1;                          tlpDialog.ColumnStyles.Add(new ColumnStyle(SizeType.Percent' 1.0F));                          tlpDialog.SetColumn(pbIcon' 0);                            tlpDialog.RowCount = 1;                          tlpDialog.RowStyles.Add(new RowStyle(SizeType.Percent' 1.0F));                          tlpDialog.SetRow(pbIcon' 0);                          // pbIcon.Dock = DockStyle.Fill;                            pbIcon.Anchor = (AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);                          Console.WriteLine("Icon image");                          break;                        case 0x02: // icon message                           tlpDialog.ColumnCount = 1;                          tlpDialog.ColumnStyles.Add(new ColumnStyle(SizeType.Percent' 1.0F));                          tlpDialog.SetColumn(lblIconMessage' 0);                            tlpDialog.RowCount = 1;                          tlpDialog.RowStyles.Add(new RowStyle(SizeType.Absolute' (int)iconMessageSize.Height + iconMessageTweak));                          tlpDialog.SetRow(lblIconMessage' 0);                            lblIconMessage.Anchor = (AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);                          heightTweak = heightTweak + iconMessageTweak;                          Console.WriteLine("Icon message");                          break;                        case 0x03: // icon and icon message                          tlpDialog.RowCount = 1;                          Console.WriteLine("Icon image and icon message");                            if (iconMessageSize.Height < minIconHeight)                              iconMessageSize.Height = minIconHeight;                          else                              heightTweak = heightTweak + iconMessageTweak;                            break;                        case 0x04: // dialog message                                      tlpDialog.ColumnCount = 1;                          tlpDialog.ColumnStyles.Add(new ColumnStyle(SizeType.Percent' 1.0F));                          tlpDialog.SetColumn(lblDialogMessage' 0);                            tlpDialog.RowCount = 1;                          tlpDialog.RowStyles.Add(new RowStyle(SizeType.Absolute' (int)dialogMessageSize.Height + dialogMessageTweak));                          tlpDialog.SetRow(lblDialogMessage' 0);                            lblDialogMessage.Anchor = (AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);                          // lblDialogMessage.Padding = new Padding(5' 5' 0' 0);                          heightTweak = heightTweak + dialogMessageTweak;                          Console.WriteLine("Dialog message");                          break;                        case 0x05: // icon and dialog message                          tlpDialog.RowCount = 1;                          tlpDialog.SetRow(lblDialogMessage' 0);                          Console.WriteLine("Icon image with dialog message");                            if (dialogMessageSize.Height < minIconHeight)                              dialogMessageSize.Height = minIconHeight;                          else                              heightTweak = heightTweak + dialogMessageTweak;                            break;                        case 0x06: // icon message and dialog message                          tlpDialog.ColumnCount = 1;                          tlpDialog.ColumnStyles.Add(new ColumnStyle(SizeType.Percent' 1.0F));                          tlpDialog.SetColumn(lblIconMessage' 0);                          tlpDialog.SetColumn(lblDialogMessage' 0);                            tlpDialog.RowCount = 2;                          tlpDialog.RowStyles.Add(new RowStyle(SizeType.Absolute' (int)iconMessageSize.Height + iconMessageTweak));                          tlpDialog.RowStyles.Add(new RowStyle(SizeType.Absolute' (int)dialogMessageSize.Height + dialogMessageTweak));                          tlpDialog.SetRow(lblIconMessage' 0);                          tlpDialog.SetRow(lblDialogMessage' 1);                            lblIconMessage.Anchor = (AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);                          lblDialogMessage.Anchor = (AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);                          heightTweak = heightTweak + iconMessageTweak + dialogMessageTweak;                          Console.WriteLine("Icon message and dialog message");                          break;                        case 0x07: // icon' icon message and dialog message                          tlpDialog.ColumnCount = 2;                          tlpDialog.ColumnStyles.Add(new ColumnStyle(SizeType.Absolute' 40));                          tlpDialog.ColumnStyles.Add(new ColumnStyle(SizeType.Percent' 1.0F));                          tlpDialog.SetColumn(pbIcon' 0);                          tlpDialog.SetColumn(lblIconMessage' 1);                          tlpDialog.SetColumn(lblDialogMessage' 1);                            if ((int)iconMessageSize.Height < minIconHeight)                              iconMessageSize.Height = minIconHeight;                            tlpDialog.RowCount = 2;                          tlpDialog.RowStyles.Add(new RowStyle(SizeType.Absolute' (int)iconMessageSize.Height + iconMessageTweak));                          tlpDialog.RowStyles.Add(new RowStyle(SizeType.Absolute' (int)dialogMessageSize.Height + dialogMessageTweak));                          tlpDialog.SetRow(pbIcon' 0);                          tlpDialog.SetRow(lblIconMessage' 0);                          tlpDialog.SetRow(lblDialogMessage' 1);                            lblIconMessage.Anchor = (AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);                          lblDialogMessage.Anchor = (AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);                          heightTweak = heightTweak + iconMessageTweak + dialogMessageTweak;                          Console.WriteLine("Icon image' icon message and dialog message");                          break;                        default:                          throw new Exception("Invalid parameter check byte sum");                  }                    // set height according to the message strings' button and tweaks                    this.Height = (int)iconMessageSize.Height + (int)dialogMessageSize.Height +                      btn3.Height + heightTweak;                    // set width based on the longest text's width                  int bigger = (dialogMessageSize.Width >= iconMessageSize.Width) ? (int)dialogMessageSize.Width : (int)iconMessageSize.Width;                    // this usually produces better results for width                  SizeF sizeIconMsg = TextRenderer.MeasureText("C" + iconMessage' lblIconMessage.Font);                  SizeF sizeDialogMsg = TextRenderer.MeasureText("C" + dialogMessage' lblDialogMessage.Font);                  var sizeC1 = sizeIconMsg.Width <= sizeDialogMsg.Width ? sizeDialogMsg : sizeIconMsg;                    if ((int)sizeC1.Width > (int)bigger)                      bigger = (int)sizeC1.Width;                      if (dialogIcon == null)                      this.Width = bigger + widthTweak;                  else                      this.Width = bigger + minIconWidth + widthTweak;              }
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,BetterDialog2,The following statement contains a magic number: using (Graphics graphics = this.CreateGraphics())              {                  var iconMessageSize = new SizeF();                  var dialogMessageSize = new SizeF();                    lblIconMessage.Font = new Font(SystemFonts.MessageBoxFont.FontFamily.Name' 10.0f' FontStyle.Bold' GraphicsUnit.Point);                  lblDialogMessage.Font = new Font(SystemFonts.MessageBoxFont.FontFamily.Name' 9.0f' FontStyle.Regular' GraphicsUnit.Point);                    // height automatically takes into account the number of line returns                  iconMessageSize = graphics.MeasureString(iconMessage' lblIconMessage.Font); //' this.lblIconMessage.Width);                  lblIconMessage.Width = (int)iconMessageSize.Width + iconMessageTweak;                  lblIconMessage.Height = (int)iconMessageSize.Height + iconMessageTweak;                  //                  dialogMessageSize = graphics.MeasureString(dialogMessage' lblDialogMessage.Font); // ' this.lblDialogMessage.Width);                  lblDialogMessage.Width = (int)dialogMessageSize.Width + widthTweak;                  lblDialogMessage.Height = (int)dialogMessageSize.Height + heightTweak + dialogMessageTweak;                    // customized table layout pannel (must clear)                  tlpDialog.ColumnStyles.Clear();                  tlpDialog.RowStyles.Clear();                    // apply colors for debugging                  //tlpDialog.BackColor = Color.Yellow;                  //lblIconMessage.BackColor = Color.Red;                  //lblDialogMessage.BackColor = Color.Lime;                    switch (checkByte) // eight possible conditions' 2^3=8                  {                      case 0x00: // no icon and no messages                          Controls.Remove(tlpDialog);                          Console.WriteLine("No icon or messages");                          break;                        case 0x01: // icon                          tlpDialog.ColumnCount = 1;                          tlpDialog.ColumnStyles.Add(new ColumnStyle(SizeType.Percent' 1.0F));                          tlpDialog.SetColumn(pbIcon' 0);                            tlpDialog.RowCount = 1;                          tlpDialog.RowStyles.Add(new RowStyle(SizeType.Percent' 1.0F));                          tlpDialog.SetRow(pbIcon' 0);                          // pbIcon.Dock = DockStyle.Fill;                            pbIcon.Anchor = (AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);                          Console.WriteLine("Icon image");                          break;                        case 0x02: // icon message                           tlpDialog.ColumnCount = 1;                          tlpDialog.ColumnStyles.Add(new ColumnStyle(SizeType.Percent' 1.0F));                          tlpDialog.SetColumn(lblIconMessage' 0);                            tlpDialog.RowCount = 1;                          tlpDialog.RowStyles.Add(new RowStyle(SizeType.Absolute' (int)iconMessageSize.Height + iconMessageTweak));                          tlpDialog.SetRow(lblIconMessage' 0);                            lblIconMessage.Anchor = (AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);                          heightTweak = heightTweak + iconMessageTweak;                          Console.WriteLine("Icon message");                          break;                        case 0x03: // icon and icon message                          tlpDialog.RowCount = 1;                          Console.WriteLine("Icon image and icon message");                            if (iconMessageSize.Height < minIconHeight)                              iconMessageSize.Height = minIconHeight;                          else                              heightTweak = heightTweak + iconMessageTweak;                            break;                        case 0x04: // dialog message                                      tlpDialog.ColumnCount = 1;                          tlpDialog.ColumnStyles.Add(new ColumnStyle(SizeType.Percent' 1.0F));                          tlpDialog.SetColumn(lblDialogMessage' 0);                            tlpDialog.RowCount = 1;                          tlpDialog.RowStyles.Add(new RowStyle(SizeType.Absolute' (int)dialogMessageSize.Height + dialogMessageTweak));                          tlpDialog.SetRow(lblDialogMessage' 0);                            lblDialogMessage.Anchor = (AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);                          // lblDialogMessage.Padding = new Padding(5' 5' 0' 0);                          heightTweak = heightTweak + dialogMessageTweak;                          Console.WriteLine("Dialog message");                          break;                        case 0x05: // icon and dialog message                          tlpDialog.RowCount = 1;                          tlpDialog.SetRow(lblDialogMessage' 0);                          Console.WriteLine("Icon image with dialog message");                            if (dialogMessageSize.Height < minIconHeight)                              dialogMessageSize.Height = minIconHeight;                          else                              heightTweak = heightTweak + dialogMessageTweak;                            break;                        case 0x06: // icon message and dialog message                          tlpDialog.ColumnCount = 1;                          tlpDialog.ColumnStyles.Add(new ColumnStyle(SizeType.Percent' 1.0F));                          tlpDialog.SetColumn(lblIconMessage' 0);                          tlpDialog.SetColumn(lblDialogMessage' 0);                            tlpDialog.RowCount = 2;                          tlpDialog.RowStyles.Add(new RowStyle(SizeType.Absolute' (int)iconMessageSize.Height + iconMessageTweak));                          tlpDialog.RowStyles.Add(new RowStyle(SizeType.Absolute' (int)dialogMessageSize.Height + dialogMessageTweak));                          tlpDialog.SetRow(lblIconMessage' 0);                          tlpDialog.SetRow(lblDialogMessage' 1);                            lblIconMessage.Anchor = (AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);                          lblDialogMessage.Anchor = (AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);                          heightTweak = heightTweak + iconMessageTweak + dialogMessageTweak;                          Console.WriteLine("Icon message and dialog message");                          break;                        case 0x07: // icon' icon message and dialog message                          tlpDialog.ColumnCount = 2;                          tlpDialog.ColumnStyles.Add(new ColumnStyle(SizeType.Absolute' 40));                          tlpDialog.ColumnStyles.Add(new ColumnStyle(SizeType.Percent' 1.0F));                          tlpDialog.SetColumn(pbIcon' 0);                          tlpDialog.SetColumn(lblIconMessage' 1);                          tlpDialog.SetColumn(lblDialogMessage' 1);                            if ((int)iconMessageSize.Height < minIconHeight)                              iconMessageSize.Height = minIconHeight;                            tlpDialog.RowCount = 2;                          tlpDialog.RowStyles.Add(new RowStyle(SizeType.Absolute' (int)iconMessageSize.Height + iconMessageTweak));                          tlpDialog.RowStyles.Add(new RowStyle(SizeType.Absolute' (int)dialogMessageSize.Height + dialogMessageTweak));                          tlpDialog.SetRow(pbIcon' 0);                          tlpDialog.SetRow(lblIconMessage' 0);                          tlpDialog.SetRow(lblDialogMessage' 1);                            lblIconMessage.Anchor = (AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);                          lblDialogMessage.Anchor = (AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);                          heightTweak = heightTweak + iconMessageTweak + dialogMessageTweak;                          Console.WriteLine("Icon image' icon message and dialog message");                          break;                        default:                          throw new Exception("Invalid parameter check byte sum");                  }                    // set height according to the message strings' button and tweaks                    this.Height = (int)iconMessageSize.Height + (int)dialogMessageSize.Height +                      btn3.Height + heightTweak;                    // set width based on the longest text's width                  int bigger = (dialogMessageSize.Width >= iconMessageSize.Width) ? (int)dialogMessageSize.Width : (int)iconMessageSize.Width;                    // this usually produces better results for width                  SizeF sizeIconMsg = TextRenderer.MeasureText("C" + iconMessage' lblIconMessage.Font);                  SizeF sizeDialogMsg = TextRenderer.MeasureText("C" + dialogMessage' lblDialogMessage.Font);                  var sizeC1 = sizeIconMsg.Width <= sizeDialogMsg.Width ? sizeDialogMsg : sizeIconMsg;                    if ((int)sizeC1.Width > (int)bigger)                      bigger = (int)sizeC1.Width;                      if (dialogIcon == null)                      this.Width = bigger + widthTweak;                  else                      this.Width = bigger + minIconWidth + widthTweak;              }
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,BetterDialog2,The following statement contains a magic number: using (Graphics graphics = this.CreateGraphics())              {                  var iconMessageSize = new SizeF();                  var dialogMessageSize = new SizeF();                    lblIconMessage.Font = new Font(SystemFonts.MessageBoxFont.FontFamily.Name' 10.0f' FontStyle.Bold' GraphicsUnit.Point);                  lblDialogMessage.Font = new Font(SystemFonts.MessageBoxFont.FontFamily.Name' 9.0f' FontStyle.Regular' GraphicsUnit.Point);                    // height automatically takes into account the number of line returns                  iconMessageSize = graphics.MeasureString(iconMessage' lblIconMessage.Font); //' this.lblIconMessage.Width);                  lblIconMessage.Width = (int)iconMessageSize.Width + iconMessageTweak;                  lblIconMessage.Height = (int)iconMessageSize.Height + iconMessageTweak;                  //                  dialogMessageSize = graphics.MeasureString(dialogMessage' lblDialogMessage.Font); // ' this.lblDialogMessage.Width);                  lblDialogMessage.Width = (int)dialogMessageSize.Width + widthTweak;                  lblDialogMessage.Height = (int)dialogMessageSize.Height + heightTweak + dialogMessageTweak;                    // customized table layout pannel (must clear)                  tlpDialog.ColumnStyles.Clear();                  tlpDialog.RowStyles.Clear();                    // apply colors for debugging                  //tlpDialog.BackColor = Color.Yellow;                  //lblIconMessage.BackColor = Color.Red;                  //lblDialogMessage.BackColor = Color.Lime;                    switch (checkByte) // eight possible conditions' 2^3=8                  {                      case 0x00: // no icon and no messages                          Controls.Remove(tlpDialog);                          Console.WriteLine("No icon or messages");                          break;                        case 0x01: // icon                          tlpDialog.ColumnCount = 1;                          tlpDialog.ColumnStyles.Add(new ColumnStyle(SizeType.Percent' 1.0F));                          tlpDialog.SetColumn(pbIcon' 0);                            tlpDialog.RowCount = 1;                          tlpDialog.RowStyles.Add(new RowStyle(SizeType.Percent' 1.0F));                          tlpDialog.SetRow(pbIcon' 0);                          // pbIcon.Dock = DockStyle.Fill;                            pbIcon.Anchor = (AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);                          Console.WriteLine("Icon image");                          break;                        case 0x02: // icon message                           tlpDialog.ColumnCount = 1;                          tlpDialog.ColumnStyles.Add(new ColumnStyle(SizeType.Percent' 1.0F));                          tlpDialog.SetColumn(lblIconMessage' 0);                            tlpDialog.RowCount = 1;                          tlpDialog.RowStyles.Add(new RowStyle(SizeType.Absolute' (int)iconMessageSize.Height + iconMessageTweak));                          tlpDialog.SetRow(lblIconMessage' 0);                            lblIconMessage.Anchor = (AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);                          heightTweak = heightTweak + iconMessageTweak;                          Console.WriteLine("Icon message");                          break;                        case 0x03: // icon and icon message                          tlpDialog.RowCount = 1;                          Console.WriteLine("Icon image and icon message");                            if (iconMessageSize.Height < minIconHeight)                              iconMessageSize.Height = minIconHeight;                          else                              heightTweak = heightTweak + iconMessageTweak;                            break;                        case 0x04: // dialog message                                      tlpDialog.ColumnCount = 1;                          tlpDialog.ColumnStyles.Add(new ColumnStyle(SizeType.Percent' 1.0F));                          tlpDialog.SetColumn(lblDialogMessage' 0);                            tlpDialog.RowCount = 1;                          tlpDialog.RowStyles.Add(new RowStyle(SizeType.Absolute' (int)dialogMessageSize.Height + dialogMessageTweak));                          tlpDialog.SetRow(lblDialogMessage' 0);                            lblDialogMessage.Anchor = (AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);                          // lblDialogMessage.Padding = new Padding(5' 5' 0' 0);                          heightTweak = heightTweak + dialogMessageTweak;                          Console.WriteLine("Dialog message");                          break;                        case 0x05: // icon and dialog message                          tlpDialog.RowCount = 1;                          tlpDialog.SetRow(lblDialogMessage' 0);                          Console.WriteLine("Icon image with dialog message");                            if (dialogMessageSize.Height < minIconHeight)                              dialogMessageSize.Height = minIconHeight;                          else                              heightTweak = heightTweak + dialogMessageTweak;                            break;                        case 0x06: // icon message and dialog message                          tlpDialog.ColumnCount = 1;                          tlpDialog.ColumnStyles.Add(new ColumnStyle(SizeType.Percent' 1.0F));                          tlpDialog.SetColumn(lblIconMessage' 0);                          tlpDialog.SetColumn(lblDialogMessage' 0);                            tlpDialog.RowCount = 2;                          tlpDialog.RowStyles.Add(new RowStyle(SizeType.Absolute' (int)iconMessageSize.Height + iconMessageTweak));                          tlpDialog.RowStyles.Add(new RowStyle(SizeType.Absolute' (int)dialogMessageSize.Height + dialogMessageTweak));                          tlpDialog.SetRow(lblIconMessage' 0);                          tlpDialog.SetRow(lblDialogMessage' 1);                            lblIconMessage.Anchor = (AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);                          lblDialogMessage.Anchor = (AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);                          heightTweak = heightTweak + iconMessageTweak + dialogMessageTweak;                          Console.WriteLine("Icon message and dialog message");                          break;                        case 0x07: // icon' icon message and dialog message                          tlpDialog.ColumnCount = 2;                          tlpDialog.ColumnStyles.Add(new ColumnStyle(SizeType.Absolute' 40));                          tlpDialog.ColumnStyles.Add(new ColumnStyle(SizeType.Percent' 1.0F));                          tlpDialog.SetColumn(pbIcon' 0);                          tlpDialog.SetColumn(lblIconMessage' 1);                          tlpDialog.SetColumn(lblDialogMessage' 1);                            if ((int)iconMessageSize.Height < minIconHeight)                              iconMessageSize.Height = minIconHeight;                            tlpDialog.RowCount = 2;                          tlpDialog.RowStyles.Add(new RowStyle(SizeType.Absolute' (int)iconMessageSize.Height + iconMessageTweak));                          tlpDialog.RowStyles.Add(new RowStyle(SizeType.Absolute' (int)dialogMessageSize.Height + dialogMessageTweak));                          tlpDialog.SetRow(pbIcon' 0);                          tlpDialog.SetRow(lblIconMessage' 0);                          tlpDialog.SetRow(lblDialogMessage' 1);                            lblIconMessage.Anchor = (AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);                          lblDialogMessage.Anchor = (AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);                          heightTweak = heightTweak + iconMessageTweak + dialogMessageTweak;                          Console.WriteLine("Icon image' icon message and dialog message");                          break;                        default:                          throw new Exception("Invalid parameter check byte sum");                  }                    // set height according to the message strings' button and tweaks                    this.Height = (int)iconMessageSize.Height + (int)dialogMessageSize.Height +                      btn3.Height + heightTweak;                    // set width based on the longest text's width                  int bigger = (dialogMessageSize.Width >= iconMessageSize.Width) ? (int)dialogMessageSize.Width : (int)iconMessageSize.Width;                    // this usually produces better results for width                  SizeF sizeIconMsg = TextRenderer.MeasureText("C" + iconMessage' lblIconMessage.Font);                  SizeF sizeDialogMsg = TextRenderer.MeasureText("C" + dialogMessage' lblDialogMessage.Font);                  var sizeC1 = sizeIconMsg.Width <= sizeDialogMsg.Width ? sizeDialogMsg : sizeIconMsg;                    if ((int)sizeC1.Width > (int)bigger)                      bigger = (int)sizeC1.Width;                      if (dialogIcon == null)                      this.Width = bigger + widthTweak;                  else                      this.Width = bigger + minIconWidth + widthTweak;              }
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,BetterDialog2,The following statement contains a magic number: using (Graphics graphics = this.CreateGraphics())              {                  var iconMessageSize = new SizeF();                  var dialogMessageSize = new SizeF();                    lblIconMessage.Font = new Font(SystemFonts.MessageBoxFont.FontFamily.Name' 10.0f' FontStyle.Bold' GraphicsUnit.Point);                  lblDialogMessage.Font = new Font(SystemFonts.MessageBoxFont.FontFamily.Name' 9.0f' FontStyle.Regular' GraphicsUnit.Point);                    // height automatically takes into account the number of line returns                  iconMessageSize = graphics.MeasureString(iconMessage' lblIconMessage.Font); //' this.lblIconMessage.Width);                  lblIconMessage.Width = (int)iconMessageSize.Width + iconMessageTweak;                  lblIconMessage.Height = (int)iconMessageSize.Height + iconMessageTweak;                  //                  dialogMessageSize = graphics.MeasureString(dialogMessage' lblDialogMessage.Font); // ' this.lblDialogMessage.Width);                  lblDialogMessage.Width = (int)dialogMessageSize.Width + widthTweak;                  lblDialogMessage.Height = (int)dialogMessageSize.Height + heightTweak + dialogMessageTweak;                    // customized table layout pannel (must clear)                  tlpDialog.ColumnStyles.Clear();                  tlpDialog.RowStyles.Clear();                    // apply colors for debugging                  //tlpDialog.BackColor = Color.Yellow;                  //lblIconMessage.BackColor = Color.Red;                  //lblDialogMessage.BackColor = Color.Lime;                    switch (checkByte) // eight possible conditions' 2^3=8                  {                      case 0x00: // no icon and no messages                          Controls.Remove(tlpDialog);                          Console.WriteLine("No icon or messages");                          break;                        case 0x01: // icon                          tlpDialog.ColumnCount = 1;                          tlpDialog.ColumnStyles.Add(new ColumnStyle(SizeType.Percent' 1.0F));                          tlpDialog.SetColumn(pbIcon' 0);                            tlpDialog.RowCount = 1;                          tlpDialog.RowStyles.Add(new RowStyle(SizeType.Percent' 1.0F));                          tlpDialog.SetRow(pbIcon' 0);                          // pbIcon.Dock = DockStyle.Fill;                            pbIcon.Anchor = (AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);                          Console.WriteLine("Icon image");                          break;                        case 0x02: // icon message                           tlpDialog.ColumnCount = 1;                          tlpDialog.ColumnStyles.Add(new ColumnStyle(SizeType.Percent' 1.0F));                          tlpDialog.SetColumn(lblIconMessage' 0);                            tlpDialog.RowCount = 1;                          tlpDialog.RowStyles.Add(new RowStyle(SizeType.Absolute' (int)iconMessageSize.Height + iconMessageTweak));                          tlpDialog.SetRow(lblIconMessage' 0);                            lblIconMessage.Anchor = (AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);                          heightTweak = heightTweak + iconMessageTweak;                          Console.WriteLine("Icon message");                          break;                        case 0x03: // icon and icon message                          tlpDialog.RowCount = 1;                          Console.WriteLine("Icon image and icon message");                            if (iconMessageSize.Height < minIconHeight)                              iconMessageSize.Height = minIconHeight;                          else                              heightTweak = heightTweak + iconMessageTweak;                            break;                        case 0x04: // dialog message                                      tlpDialog.ColumnCount = 1;                          tlpDialog.ColumnStyles.Add(new ColumnStyle(SizeType.Percent' 1.0F));                          tlpDialog.SetColumn(lblDialogMessage' 0);                            tlpDialog.RowCount = 1;                          tlpDialog.RowStyles.Add(new RowStyle(SizeType.Absolute' (int)dialogMessageSize.Height + dialogMessageTweak));                          tlpDialog.SetRow(lblDialogMessage' 0);                            lblDialogMessage.Anchor = (AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);                          // lblDialogMessage.Padding = new Padding(5' 5' 0' 0);                          heightTweak = heightTweak + dialogMessageTweak;                          Console.WriteLine("Dialog message");                          break;                        case 0x05: // icon and dialog message                          tlpDialog.RowCount = 1;                          tlpDialog.SetRow(lblDialogMessage' 0);                          Console.WriteLine("Icon image with dialog message");                            if (dialogMessageSize.Height < minIconHeight)                              dialogMessageSize.Height = minIconHeight;                          else                              heightTweak = heightTweak + dialogMessageTweak;                            break;                        case 0x06: // icon message and dialog message                          tlpDialog.ColumnCount = 1;                          tlpDialog.ColumnStyles.Add(new ColumnStyle(SizeType.Percent' 1.0F));                          tlpDialog.SetColumn(lblIconMessage' 0);                          tlpDialog.SetColumn(lblDialogMessage' 0);                            tlpDialog.RowCount = 2;                          tlpDialog.RowStyles.Add(new RowStyle(SizeType.Absolute' (int)iconMessageSize.Height + iconMessageTweak));                          tlpDialog.RowStyles.Add(new RowStyle(SizeType.Absolute' (int)dialogMessageSize.Height + dialogMessageTweak));                          tlpDialog.SetRow(lblIconMessage' 0);                          tlpDialog.SetRow(lblDialogMessage' 1);                            lblIconMessage.Anchor = (AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);                          lblDialogMessage.Anchor = (AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);                          heightTweak = heightTweak + iconMessageTweak + dialogMessageTweak;                          Console.WriteLine("Icon message and dialog message");                          break;                        case 0x07: // icon' icon message and dialog message                          tlpDialog.ColumnCount = 2;                          tlpDialog.ColumnStyles.Add(new ColumnStyle(SizeType.Absolute' 40));                          tlpDialog.ColumnStyles.Add(new ColumnStyle(SizeType.Percent' 1.0F));                          tlpDialog.SetColumn(pbIcon' 0);                          tlpDialog.SetColumn(lblIconMessage' 1);                          tlpDialog.SetColumn(lblDialogMessage' 1);                            if ((int)iconMessageSize.Height < minIconHeight)                              iconMessageSize.Height = minIconHeight;                            tlpDialog.RowCount = 2;                          tlpDialog.RowStyles.Add(new RowStyle(SizeType.Absolute' (int)iconMessageSize.Height + iconMessageTweak));                          tlpDialog.RowStyles.Add(new RowStyle(SizeType.Absolute' (int)dialogMessageSize.Height + dialogMessageTweak));                          tlpDialog.SetRow(pbIcon' 0);                          tlpDialog.SetRow(lblIconMessage' 0);                          tlpDialog.SetRow(lblDialogMessage' 1);                            lblIconMessage.Anchor = (AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);                          lblDialogMessage.Anchor = (AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);                          heightTweak = heightTweak + iconMessageTweak + dialogMessageTweak;                          Console.WriteLine("Icon image' icon message and dialog message");                          break;                        default:                          throw new Exception("Invalid parameter check byte sum");                  }                    // set height according to the message strings' button and tweaks                    this.Height = (int)iconMessageSize.Height + (int)dialogMessageSize.Height +                      btn3.Height + heightTweak;                    // set width based on the longest text's width                  int bigger = (dialogMessageSize.Width >= iconMessageSize.Width) ? (int)dialogMessageSize.Width : (int)iconMessageSize.Width;                    // this usually produces better results for width                  SizeF sizeIconMsg = TextRenderer.MeasureText("C" + iconMessage' lblIconMessage.Font);                  SizeF sizeDialogMsg = TextRenderer.MeasureText("C" + dialogMessage' lblDialogMessage.Font);                  var sizeC1 = sizeIconMsg.Width <= sizeDialogMsg.Width ? sizeDialogMsg : sizeIconMsg;                    if ((int)sizeC1.Width > (int)bigger)                      bigger = (int)sizeC1.Width;                      if (dialogIcon == null)                      this.Width = bigger + widthTweak;                  else                      this.Width = bigger + minIconWidth + widthTweak;              }
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,BetterDialog2,The following statement contains a magic number: switch (buttonCount)              {                  case 3: // 3 button                      btn1.Text = textDialogButton1;                      btn2.Text = textDialogButton2;                      btn3.Text = textDialogButton3;                      btn1.Visible = true;                      btn2.Visible = true;                      btn3.Visible = true;                      btn1.DialogResult = DialogResult.Yes;                      btn2.DialogResult = DialogResult.No;                      btn3.DialogResult = DialogResult.Cancel;                      this.AcceptButton = btn1;                      buttonWidth = buttonWidth * 3;                      break;                  case 2: // 2 button                      btn2.Text = textDialogButton2;                      btn3.Text = textDialogButton3;                      btn1.Visible = false;                      btn2.Visible = true;                      btn2.Visible = true;                      btn2.DialogResult = DialogResult.Yes;                      btn3.DialogResult = DialogResult.No;                      this.AcceptButton = btn2;                      buttonWidth = buttonWidth * 2;                      break;                  default:  // 1 button                                        btn3.Text = textDialogButton3;                      btn1.Visible = false;                      btn2.Visible = false;                      btn3.Visible = true;                      btn3.DialogResult = DialogResult.OK;                      this.AcceptButton = btn3;                      buttonWidth = buttonWidth * 2; // double wide                      break;              }
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,BetterDialog2,The following statement contains a magic number: switch (buttonCount)              {                  case 3: // 3 button                      btn1.Text = textDialogButton1;                      btn2.Text = textDialogButton2;                      btn3.Text = textDialogButton3;                      btn1.Visible = true;                      btn2.Visible = true;                      btn3.Visible = true;                      btn1.DialogResult = DialogResult.Yes;                      btn2.DialogResult = DialogResult.No;                      btn3.DialogResult = DialogResult.Cancel;                      this.AcceptButton = btn1;                      buttonWidth = buttonWidth * 3;                      break;                  case 2: // 2 button                      btn2.Text = textDialogButton2;                      btn3.Text = textDialogButton3;                      btn1.Visible = false;                      btn2.Visible = true;                      btn2.Visible = true;                      btn2.DialogResult = DialogResult.Yes;                      btn3.DialogResult = DialogResult.No;                      this.AcceptButton = btn2;                      buttonWidth = buttonWidth * 2;                      break;                  default:  // 1 button                                        btn3.Text = textDialogButton3;                      btn1.Visible = false;                      btn2.Visible = false;                      btn3.Visible = true;                      btn3.DialogResult = DialogResult.OK;                      this.AcceptButton = btn3;                      buttonWidth = buttonWidth * 2; // double wide                      break;              }
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,BetterDialog2,The following statement contains a magic number: switch (buttonCount)              {                  case 3: // 3 button                      btn1.Text = textDialogButton1;                      btn2.Text = textDialogButton2;                      btn3.Text = textDialogButton3;                      btn1.Visible = true;                      btn2.Visible = true;                      btn3.Visible = true;                      btn1.DialogResult = DialogResult.Yes;                      btn2.DialogResult = DialogResult.No;                      btn3.DialogResult = DialogResult.Cancel;                      this.AcceptButton = btn1;                      buttonWidth = buttonWidth * 3;                      break;                  case 2: // 2 button                      btn2.Text = textDialogButton2;                      btn3.Text = textDialogButton3;                      btn1.Visible = false;                      btn2.Visible = true;                      btn2.Visible = true;                      btn2.DialogResult = DialogResult.Yes;                      btn3.DialogResult = DialogResult.No;                      this.AcceptButton = btn2;                      buttonWidth = buttonWidth * 2;                      break;                  default:  // 1 button                                        btn3.Text = textDialogButton3;                      btn1.Visible = false;                      btn2.Visible = false;                      btn3.Visible = true;                      btn3.DialogResult = DialogResult.OK;                      this.AcceptButton = btn3;                      buttonWidth = buttonWidth * 2; // double wide                      break;              }
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,BetterDialog2,The following statement contains a magic number: switch (buttonCount)              {                  case 3: // 3 button                      btn1.Text = textDialogButton1;                      btn2.Text = textDialogButton2;                      btn3.Text = textDialogButton3;                      btn1.Visible = true;                      btn2.Visible = true;                      btn3.Visible = true;                      btn1.DialogResult = DialogResult.Yes;                      btn2.DialogResult = DialogResult.No;                      btn3.DialogResult = DialogResult.Cancel;                      this.AcceptButton = btn1;                      buttonWidth = buttonWidth * 3;                      break;                  case 2: // 2 button                      btn2.Text = textDialogButton2;                      btn3.Text = textDialogButton3;                      btn1.Visible = false;                      btn2.Visible = true;                      btn2.Visible = true;                      btn2.DialogResult = DialogResult.Yes;                      btn3.DialogResult = DialogResult.No;                      this.AcceptButton = btn2;                      buttonWidth = buttonWidth * 2;                      break;                  default:  // 1 button                                        btn3.Text = textDialogButton3;                      btn1.Visible = false;                      btn2.Visible = false;                      btn3.Visible = true;                      btn3.DialogResult = DialogResult.OK;                      this.AcceptButton = btn3;                      buttonWidth = buttonWidth * 2; // double wide                      break;              }
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,BetterDialog2,The following statement contains a magic number: switch (buttonCount)              {                  case 3: // 3 button                      btn1.Text = textDialogButton1;                      btn2.Text = textDialogButton2;                      btn3.Text = textDialogButton3;                      btn1.Visible = true;                      btn2.Visible = true;                      btn3.Visible = true;                      btn1.DialogResult = DialogResult.Yes;                      btn2.DialogResult = DialogResult.No;                      btn3.DialogResult = DialogResult.Cancel;                      this.AcceptButton = btn1;                      buttonWidth = buttonWidth * 3;                      break;                  case 2: // 2 button                      btn2.Text = textDialogButton2;                      btn3.Text = textDialogButton3;                      btn1.Visible = false;                      btn2.Visible = true;                      btn2.Visible = true;                      btn2.DialogResult = DialogResult.Yes;                      btn3.DialogResult = DialogResult.No;                      this.AcceptButton = btn2;                      buttonWidth = buttonWidth * 2;                      break;                  default:  // 1 button                                        btn3.Text = textDialogButton3;                      btn1.Visible = false;                      btn2.Visible = false;                      btn3.Visible = true;                      btn3.DialogResult = DialogResult.OK;                      this.AcceptButton = btn3;                      buttonWidth = buttonWidth * 2; // double wide                      break;              }
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.pbIcon.Location = new System.Drawing.Point(5' 5);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.pbIcon.Location = new System.Drawing.Point(5' 5);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.pbIcon.Margin = new System.Windows.Forms.Padding(5);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.pbIcon.Size = new System.Drawing.Size(30' 30);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.pbIcon.Size = new System.Drawing.Size(30' 30);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.lblIconMessage.Location = new System.Drawing.Point(43' 0);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.lblIconMessage.Padding = new System.Windows.Forms.Padding(5' 0' 5' 0);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.lblIconMessage.Padding = new System.Windows.Forms.Padding(5' 0' 5' 0);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.lblIconMessage.Size = new System.Drawing.Size(248' 40);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.lblIconMessage.Size = new System.Drawing.Size(248' 40);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.lblIconMessage.TabIndex = 2;
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.btn3.Location = new System.Drawing.Point(200' 138);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.btn3.Location = new System.Drawing.Point(200' 138);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.btn3.Size = new System.Drawing.Size(75' 23);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.btn3.Size = new System.Drawing.Size(75' 23);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.btn1.Location = new System.Drawing.Point(18' 138);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.btn1.Location = new System.Drawing.Point(18' 138);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.btn1.Size = new System.Drawing.Size(75' 23);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.btn1.Size = new System.Drawing.Size(75' 23);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.btn2.Location = new System.Drawing.Point(109' 138);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.btn2.Location = new System.Drawing.Point(109' 138);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.btn2.Size = new System.Drawing.Size(75' 23);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.btn2.Size = new System.Drawing.Size(75' 23);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.btn2.TabIndex = 3;
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.lblDialogMessage.Location = new System.Drawing.Point(43' 40);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.lblDialogMessage.Location = new System.Drawing.Point(43' 40);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.lblDialogMessage.Padding = new System.Windows.Forms.Padding(5' 0' 5' 5);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.lblDialogMessage.Padding = new System.Windows.Forms.Padding(5' 0' 5' 5);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.lblDialogMessage.Padding = new System.Windows.Forms.Padding(5' 0' 5' 5);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.lblDialogMessage.Size = new System.Drawing.Size(248' 83);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.lblDialogMessage.Size = new System.Drawing.Size(248' 83);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.lblDialogMessage.TabIndex = 4;
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.tlpDialog.ColumnCount = 2;
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.tlpDialog.RowCount = 2;
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.tlpDialog.Size = new System.Drawing.Size(294' 123);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.tlpDialog.Size = new System.Drawing.Size(294' 123);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.tlpDialog.TabIndex = 5;
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.pbLine.Location = new System.Drawing.Point(-9' 125);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.pbLine.Location = new System.Drawing.Point(-9' 125);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.pbLine.Size = new System.Drawing.Size(313' 51);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.pbLine.Size = new System.Drawing.Size(313' 51);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.pbLine.TabIndex = 6;
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(294' 168);
Magic Number,RocksmithToolkitLib.Extensions,BetterDialog2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\BetterDialog2.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(294' 168);
Magic Number,RocksmithToolkitLib.Extensions,StringExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\StringExtensions.cs,GetValidKey,The following statement contains a magic number: value = value.Substring(0' Math.Min(30' value.Length));
Magic Number,RocksmithToolkitLib.Extensions,StringExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\StringExtensions.cs,GetValidKey,The following statement contains a magic number: if (value.Length < 7 && !isTone)              {                  value = string.Concat(Enumerable.Repeat(value' 6));                  value = value.Substring(0' 6);              }
Magic Number,RocksmithToolkitLib.Extensions,StringExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\StringExtensions.cs,GetValidKey,The following statement contains a magic number: if (value.Length < 7 && !isTone)              {                  value = string.Concat(Enumerable.Repeat(value' 6));                  value = value.Substring(0' 6);              }
Magic Number,RocksmithToolkitLib.Extensions,StringExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\StringExtensions.cs,GetValidKey,The following statement contains a magic number: if (value.Length < 7 && !isTone)              {                  value = string.Concat(Enumerable.Repeat(value' 6));                  value = value.Substring(0' 6);              }
Magic Number,RocksmithToolkitLib.Extensions,StringExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\StringExtensions.cs,GetValidTempo,The following statement contains a magic number: if (bpm > 0 && bpm < 999)  // allow insane tempo                  return bpm.ToString();
Magic Number,RocksmithToolkitLib.Extensions,StringExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\StringExtensions.cs,IsFilePathLengthValid,The following statement contains a magic number: if (Environment.OSVersion.Version.Major >= 6 && filePath.Length > 260)                  return false;
Magic Number,RocksmithToolkitLib.Extensions,StringExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\StringExtensions.cs,IsFilePathLengthValid,The following statement contains a magic number: if (Environment.OSVersion.Version.Major >= 6 && filePath.Length > 260)                  return false;
Magic Number,RocksmithToolkitLib.Extensions,StringExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\StringExtensions.cs,IsFilePathLengthValid,The following statement contains a magic number: if (Environment.OSVersion.Version.Major < 6 && filePath.Length > 215)                  return false;
Magic Number,RocksmithToolkitLib.Extensions,StringExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\StringExtensions.cs,IsFilePathLengthValid,The following statement contains a magic number: if (Environment.OSVersion.Version.Major < 6 && filePath.Length > 215)                  return false;
Magic Number,RocksmithToolkitLib.Extensions,StringExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\StringExtensions.cs,StripPlatformEndName,The following statement contains a magic number: if (filePath.EndsWith(GamePlatform.Pc.GetPathName()[2]) ||                 filePath.EndsWith(GamePlatform.Mac.GetPathName()[2]) ||                 filePath.EndsWith(GamePlatform.XBox360.GetPathName()[2]) ||                 filePath.EndsWith(GamePlatform.PS3.GetPathName()[2]) ||                 filePath.EndsWith(GamePlatform.PS3.GetPathName()[2] + ".psarc"))              {                  return filePath.Substring(0' filePath.LastIndexOf("_"));              }
Magic Number,RocksmithToolkitLib.Extensions,StringExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\StringExtensions.cs,StripPlatformEndName,The following statement contains a magic number: if (filePath.EndsWith(GamePlatform.Pc.GetPathName()[2]) ||                 filePath.EndsWith(GamePlatform.Mac.GetPathName()[2]) ||                 filePath.EndsWith(GamePlatform.XBox360.GetPathName()[2]) ||                 filePath.EndsWith(GamePlatform.PS3.GetPathName()[2]) ||                 filePath.EndsWith(GamePlatform.PS3.GetPathName()[2] + ".psarc"))              {                  return filePath.Substring(0' filePath.LastIndexOf("_"));              }
Magic Number,RocksmithToolkitLib.Extensions,StringExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\StringExtensions.cs,StripPlatformEndName,The following statement contains a magic number: if (filePath.EndsWith(GamePlatform.Pc.GetPathName()[2]) ||                 filePath.EndsWith(GamePlatform.Mac.GetPathName()[2]) ||                 filePath.EndsWith(GamePlatform.XBox360.GetPathName()[2]) ||                 filePath.EndsWith(GamePlatform.PS3.GetPathName()[2]) ||                 filePath.EndsWith(GamePlatform.PS3.GetPathName()[2] + ".psarc"))              {                  return filePath.Substring(0' filePath.LastIndexOf("_"));              }
Magic Number,RocksmithToolkitLib.Extensions,StringExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\StringExtensions.cs,StripPlatformEndName,The following statement contains a magic number: if (filePath.EndsWith(GamePlatform.Pc.GetPathName()[2]) ||                 filePath.EndsWith(GamePlatform.Mac.GetPathName()[2]) ||                 filePath.EndsWith(GamePlatform.XBox360.GetPathName()[2]) ||                 filePath.EndsWith(GamePlatform.PS3.GetPathName()[2]) ||                 filePath.EndsWith(GamePlatform.PS3.GetPathName()[2] + ".psarc"))              {                  return filePath.Substring(0' filePath.LastIndexOf("_"));              }
Magic Number,RocksmithToolkitLib.Extensions,StringExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\StringExtensions.cs,StripPlatformEndName,The following statement contains a magic number: if (filePath.EndsWith(GamePlatform.Pc.GetPathName()[2]) ||                 filePath.EndsWith(GamePlatform.Mac.GetPathName()[2]) ||                 filePath.EndsWith(GamePlatform.XBox360.GetPathName()[2]) ||                 filePath.EndsWith(GamePlatform.PS3.GetPathName()[2]) ||                 filePath.EndsWith(GamePlatform.PS3.GetPathName()[2] + ".psarc"))              {                  return filePath.Substring(0' filePath.LastIndexOf("_"));              }
Magic Number,RocksmithToolkitLib.Extensions,JitVersionInfo,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\JitVersionInfo.cs,GetJitVersion,The following statement contains a magic number: if (IntPtr.Size == 8)                  return JitVersion.MsX64;
Magic Number,RocksmithToolkitLib.Extensions,JitVersionInfo,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\JitVersionInfo.cs,IsMsX64,The following statement contains a magic number: for (int i = 0; i < step; i++)              {                  bar = i + 10;                  for (int j = 0; j < 2*step; j += step)                      value = j + 10;              }
Magic Number,RocksmithToolkitLib.Extensions,JitVersionInfo,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\JitVersionInfo.cs,IsMsX64,The following statement contains a magic number: for (int i = 0; i < step; i++)              {                  bar = i + 10;                  for (int j = 0; j < 2*step; j += step)                      value = j + 10;              }
Magic Number,RocksmithToolkitLib.Extensions,JitVersionInfo,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\JitVersionInfo.cs,IsMsX64,The following statement contains a magic number: for (int i = 0; i < step; i++)              {                  bar = i + 10;                  for (int j = 0; j < 2*step; j += step)                      value = j + 10;              }
Magic Number,RocksmithToolkitLib.Extensions,JitVersionInfo,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\JitVersionInfo.cs,IsMsX64,The following statement contains a magic number: return value == 20 + step;
Magic Number,RocksmithToolkitLib.Extensions,JitVersionInfo,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\JitVersionInfo.cs,IsMsX86,The following statement contains a magic number: return !IsMono() && IntPtr.Size == 4;
Magic Number,RocksmithToolkitLib.Extensions,MemoryStreamExtension,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\MemoryStreamExtension.cs,ReadFrom,The following statement contains a magic number: byte[] buffer = new byte[4096];
Magic Number,RocksmithToolkitLib.Extensions,MemoryStreamExtension,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\MemoryStreamExtension.cs,ReadFrom,The following statement contains a magic number: do              {                  read = source.Read(buffer' 0' (int)Math.Min(4096' length));                  length -= read;                  this.Write(buffer' 0' read);                } while (length > 0);
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".dds"' new byte[] { 68' 68' 83' 32' 124 });
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".dds"' new byte[] { 68' 68' 83' 32' 124 });
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".dds"' new byte[] { 68' 68' 83' 32' 124 });
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".dds"' new byte[] { 68' 68' 83' 32' 124 });
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".dds"' new byte[] { 68' 68' 83' 32' 124 });
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".gif"' new byte[] { 71' 73' 70' 56 });
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".gif"' new byte[] { 71' 73' 70' 56 });
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".gif"' new byte[] { 71' 73' 70' 56 });
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".gif"' new byte[] { 71' 73' 70' 56 });
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".jpg"' new byte[] { 255' 216' 255 });
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".jpg"' new byte[] { 255' 216' 255 });
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".jpg"' new byte[] { 255' 216' 255 });
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".jpeg"' new byte[] { 255' 216' 255 });
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".jpeg"' new byte[] { 255' 216' 255 });
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".jpeg"' new byte[] { 255' 216' 255 });
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".bmp"' new byte[] { 66' 77 });
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".bmp"' new byte[] { 66' 77 });
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".png"' new byte[] { 137' 80' 78' 71' 13' 10' 26' 10' 0' 0' 0' 13' 73' 72' 68' 82 });
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".png"' new byte[] { 137' 80' 78' 71' 13' 10' 26' 10' 0' 0' 0' 13' 73' 72' 68' 82 });
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".png"' new byte[] { 137' 80' 78' 71' 13' 10' 26' 10' 0' 0' 0' 13' 73' 72' 68' 82 });
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".png"' new byte[] { 137' 80' 78' 71' 13' 10' 26' 10' 0' 0' 0' 13' 73' 72' 68' 82 });
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".png"' new byte[] { 137' 80' 78' 71' 13' 10' 26' 10' 0' 0' 0' 13' 73' 72' 68' 82 });
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".png"' new byte[] { 137' 80' 78' 71' 13' 10' 26' 10' 0' 0' 0' 13' 73' 72' 68' 82 });
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".png"' new byte[] { 137' 80' 78' 71' 13' 10' 26' 10' 0' 0' 0' 13' 73' 72' 68' 82 });
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".png"' new byte[] { 137' 80' 78' 71' 13' 10' 26' 10' 0' 0' 0' 13' 73' 72' 68' 82 });
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".png"' new byte[] { 137' 80' 78' 71' 13' 10' 26' 10' 0' 0' 0' 13' 73' 72' 68' 82 });
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".png"' new byte[] { 137' 80' 78' 71' 13' 10' 26' 10' 0' 0' 0' 13' 73' 72' 68' 82 });
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".png"' new byte[] { 137' 80' 78' 71' 13' 10' 26' 10' 0' 0' 0' 13' 73' 72' 68' 82 });
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".png"' new byte[] { 137' 80' 78' 71' 13' 10' 26' 10' 0' 0' 0' 13' 73' 72' 68' 82 });
Magic Number,RocksmithToolkitLib.Extensions,ImageHandler,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\ImageHandler.cs,IsValidImage,The following statement contains a magic number: mimeByteHeaderList.Add(".png"' new byte[] { 137' 80' 78' 71' 13' 10' 26' 10' 0' 0' 0' 13' 73' 72' 68' 82 });
Magic Number,RocksmithToolkitLib.Extensions,GeneralExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\GeneralExtension.cs,GetToolkitInfo,The following statement contains a magic number: while ((line = reader.ReadLine()) != null)              {                  // we need to decipher what this line contains;                  // older toolkit versions just put a single line with the version number                  // newer versions put several lines in the format "key : value"                  var tokens = line.Split(new char[] { ':' });                  // trim all tokens of surrounding whitespaces                  for (int i = 0; i < tokens.Length; ++i)                      tokens[i] = tokens[i].Trim();                    if (tokens.Length == 1)                  {                      // this is probably just the version number                      tkInfo.ToolkitVersion = tokens[0];                  }                  if (tokens.Length == 2)                  {                      // key/value attribute                      var key = tokens[0].ToLower();                      switch (key)                      {                          case "toolkit version":                              tkInfo.ToolkitVersion = tokens[1]; break;                          case "package author":                              tkInfo.PackageAuthor = tokens[1]; break;                          case "package version":                              tkInfo.PackageVersion = tokens[1]; break;                          case "package comment":                              tkInfo.PackageComment = tokens[1]; break;                          default:                              Console.WriteLine("  Notice: Unknown key in toolkit.version: {0}"' key);                              break;                      }                  }                  else                  {                      Console.WriteLine("  Notice: Unrecognized line in toolkit.version: {0}"' line);                  }              }
Magic Number,RocksmithToolkitLib.Extensions,GeneralExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\GeneralExtension.cs,IsPE64BitType,The following statement contains a magic number: return b.ReadByte() == 2;
Magic Number,RocksmithToolkitLib.Extensions,GeneralExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\GeneralExtension.cs,ToByteArray,The following statement contains a magic number: return Enumerable.Range(0' hexString.Length)                      .Where(x => x % 2 == 0)                      .Select(x => Convert.ToByte(hexString.Substring(x' 2)' 16))                      .ToArray();
Magic Number,RocksmithToolkitLib.Extensions,GeneralExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\GeneralExtension.cs,ToByteArray,The following statement contains a magic number: return Enumerable.Range(0' hexString.Length)                      .Where(x => x % 2 == 0)                      .Select(x => Convert.ToByte(hexString.Substring(x' 2)' 16))                      .ToArray();
Magic Number,RocksmithToolkitLib.Extensions,GeneralExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\GeneralExtension.cs,ToByteArray,The following statement contains a magic number: return Enumerable.Range(0' hexString.Length)                      .Where(x => x % 2 == 0)                      .Select(x => Convert.ToByte(hexString.Substring(x' 2)' 16))                      .ToArray();
Magic Number,RocksmithToolkitLib.Ogg,Wwise,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\Wwise.cs,GetWwiseFiles,The following statement contains a magic number: if (srcPaths.Length != 2)                  throw new Exception("Did not find converted Wem audio and preview files");
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,ConvertOgg,The following statement contains a magic number: if (inputStream.NeedsConversion())              {                  var platform = inputStream.GetAudioPlatform();                  var bitConverter = platform.GetBitConverter;                    using (var outputFileStream = new MemoryStream())                  using (var writer = new EndianBinaryWriter(bitConverter' outputFileStream))                  using (var reader = new EndianBinaryReader(bitConverter' inputStream))                  {                      writer.Write(reader.ReadBytes(4));                      UInt32 fileSize = reader.ReadUInt32();                      fileSize -= 8; // We're removing data' so update the size in the header                      writer.Write(fileSize);                      writer.Write(reader.ReadBytes(8));                      writer.Write(66); reader.ReadUInt32(); // New fmt size is 66                      writer.Write(reader.ReadBytes(16));                      writer.Write((ushort)48); reader.ReadUInt16(); // New cbSize is 48                      writer.Write(reader.ReadBytes(6));                      reader.BaseStream.Seek(8' SeekOrigin.Current); // Skip ahead 8 bytes' we don't want the vorb chunk                      writer.Write(reader.ReadBytes((int)reader.BaseStream.Length - (int)reader.BaseStream.Position));                        return new MemoryStream(outputFileStream.GetBuffer()' 0' (int)outputFileStream.Length);                  }              }              else                  return inputStream;
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,ConvertOgg,The following statement contains a magic number: if (inputStream.NeedsConversion())              {                  var platform = inputStream.GetAudioPlatform();                  var bitConverter = platform.GetBitConverter;                    using (var outputFileStream = new MemoryStream())                  using (var writer = new EndianBinaryWriter(bitConverter' outputFileStream))                  using (var reader = new EndianBinaryReader(bitConverter' inputStream))                  {                      writer.Write(reader.ReadBytes(4));                      UInt32 fileSize = reader.ReadUInt32();                      fileSize -= 8; // We're removing data' so update the size in the header                      writer.Write(fileSize);                      writer.Write(reader.ReadBytes(8));                      writer.Write(66); reader.ReadUInt32(); // New fmt size is 66                      writer.Write(reader.ReadBytes(16));                      writer.Write((ushort)48); reader.ReadUInt16(); // New cbSize is 48                      writer.Write(reader.ReadBytes(6));                      reader.BaseStream.Seek(8' SeekOrigin.Current); // Skip ahead 8 bytes' we don't want the vorb chunk                      writer.Write(reader.ReadBytes((int)reader.BaseStream.Length - (int)reader.BaseStream.Position));                        return new MemoryStream(outputFileStream.GetBuffer()' 0' (int)outputFileStream.Length);                  }              }              else                  return inputStream;
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,ConvertOgg,The following statement contains a magic number: if (inputStream.NeedsConversion())              {                  var platform = inputStream.GetAudioPlatform();                  var bitConverter = platform.GetBitConverter;                    using (var outputFileStream = new MemoryStream())                  using (var writer = new EndianBinaryWriter(bitConverter' outputFileStream))                  using (var reader = new EndianBinaryReader(bitConverter' inputStream))                  {                      writer.Write(reader.ReadBytes(4));                      UInt32 fileSize = reader.ReadUInt32();                      fileSize -= 8; // We're removing data' so update the size in the header                      writer.Write(fileSize);                      writer.Write(reader.ReadBytes(8));                      writer.Write(66); reader.ReadUInt32(); // New fmt size is 66                      writer.Write(reader.ReadBytes(16));                      writer.Write((ushort)48); reader.ReadUInt16(); // New cbSize is 48                      writer.Write(reader.ReadBytes(6));                      reader.BaseStream.Seek(8' SeekOrigin.Current); // Skip ahead 8 bytes' we don't want the vorb chunk                      writer.Write(reader.ReadBytes((int)reader.BaseStream.Length - (int)reader.BaseStream.Position));                        return new MemoryStream(outputFileStream.GetBuffer()' 0' (int)outputFileStream.Length);                  }              }              else                  return inputStream;
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,ConvertOgg,The following statement contains a magic number: if (inputStream.NeedsConversion())              {                  var platform = inputStream.GetAudioPlatform();                  var bitConverter = platform.GetBitConverter;                    using (var outputFileStream = new MemoryStream())                  using (var writer = new EndianBinaryWriter(bitConverter' outputFileStream))                  using (var reader = new EndianBinaryReader(bitConverter' inputStream))                  {                      writer.Write(reader.ReadBytes(4));                      UInt32 fileSize = reader.ReadUInt32();                      fileSize -= 8; // We're removing data' so update the size in the header                      writer.Write(fileSize);                      writer.Write(reader.ReadBytes(8));                      writer.Write(66); reader.ReadUInt32(); // New fmt size is 66                      writer.Write(reader.ReadBytes(16));                      writer.Write((ushort)48); reader.ReadUInt16(); // New cbSize is 48                      writer.Write(reader.ReadBytes(6));                      reader.BaseStream.Seek(8' SeekOrigin.Current); // Skip ahead 8 bytes' we don't want the vorb chunk                      writer.Write(reader.ReadBytes((int)reader.BaseStream.Length - (int)reader.BaseStream.Position));                        return new MemoryStream(outputFileStream.GetBuffer()' 0' (int)outputFileStream.Length);                  }              }              else                  return inputStream;
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,ConvertOgg,The following statement contains a magic number: if (inputStream.NeedsConversion())              {                  var platform = inputStream.GetAudioPlatform();                  var bitConverter = platform.GetBitConverter;                    using (var outputFileStream = new MemoryStream())                  using (var writer = new EndianBinaryWriter(bitConverter' outputFileStream))                  using (var reader = new EndianBinaryReader(bitConverter' inputStream))                  {                      writer.Write(reader.ReadBytes(4));                      UInt32 fileSize = reader.ReadUInt32();                      fileSize -= 8; // We're removing data' so update the size in the header                      writer.Write(fileSize);                      writer.Write(reader.ReadBytes(8));                      writer.Write(66); reader.ReadUInt32(); // New fmt size is 66                      writer.Write(reader.ReadBytes(16));                      writer.Write((ushort)48); reader.ReadUInt16(); // New cbSize is 48                      writer.Write(reader.ReadBytes(6));                      reader.BaseStream.Seek(8' SeekOrigin.Current); // Skip ahead 8 bytes' we don't want the vorb chunk                      writer.Write(reader.ReadBytes((int)reader.BaseStream.Length - (int)reader.BaseStream.Position));                        return new MemoryStream(outputFileStream.GetBuffer()' 0' (int)outputFileStream.Length);                  }              }              else                  return inputStream;
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,ConvertOgg,The following statement contains a magic number: if (inputStream.NeedsConversion())              {                  var platform = inputStream.GetAudioPlatform();                  var bitConverter = platform.GetBitConverter;                    using (var outputFileStream = new MemoryStream())                  using (var writer = new EndianBinaryWriter(bitConverter' outputFileStream))                  using (var reader = new EndianBinaryReader(bitConverter' inputStream))                  {                      writer.Write(reader.ReadBytes(4));                      UInt32 fileSize = reader.ReadUInt32();                      fileSize -= 8; // We're removing data' so update the size in the header                      writer.Write(fileSize);                      writer.Write(reader.ReadBytes(8));                      writer.Write(66); reader.ReadUInt32(); // New fmt size is 66                      writer.Write(reader.ReadBytes(16));                      writer.Write((ushort)48); reader.ReadUInt16(); // New cbSize is 48                      writer.Write(reader.ReadBytes(6));                      reader.BaseStream.Seek(8' SeekOrigin.Current); // Skip ahead 8 bytes' we don't want the vorb chunk                      writer.Write(reader.ReadBytes((int)reader.BaseStream.Length - (int)reader.BaseStream.Position));                        return new MemoryStream(outputFileStream.GetBuffer()' 0' (int)outputFileStream.Length);                  }              }              else                  return inputStream;
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,ConvertOgg,The following statement contains a magic number: if (inputStream.NeedsConversion())              {                  var platform = inputStream.GetAudioPlatform();                  var bitConverter = platform.GetBitConverter;                    using (var outputFileStream = new MemoryStream())                  using (var writer = new EndianBinaryWriter(bitConverter' outputFileStream))                  using (var reader = new EndianBinaryReader(bitConverter' inputStream))                  {                      writer.Write(reader.ReadBytes(4));                      UInt32 fileSize = reader.ReadUInt32();                      fileSize -= 8; // We're removing data' so update the size in the header                      writer.Write(fileSize);                      writer.Write(reader.ReadBytes(8));                      writer.Write(66); reader.ReadUInt32(); // New fmt size is 66                      writer.Write(reader.ReadBytes(16));                      writer.Write((ushort)48); reader.ReadUInt16(); // New cbSize is 48                      writer.Write(reader.ReadBytes(6));                      reader.BaseStream.Seek(8' SeekOrigin.Current); // Skip ahead 8 bytes' we don't want the vorb chunk                      writer.Write(reader.ReadBytes((int)reader.BaseStream.Length - (int)reader.BaseStream.Position));                        return new MemoryStream(outputFileStream.GetBuffer()' 0' (int)outputFileStream.Length);                  }              }              else                  return inputStream;
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,ConvertOgg,The following statement contains a magic number: if (inputStream.NeedsConversion())              {                  var platform = inputStream.GetAudioPlatform();                  var bitConverter = platform.GetBitConverter;                    using (var outputFileStream = new MemoryStream())                  using (var writer = new EndianBinaryWriter(bitConverter' outputFileStream))                  using (var reader = new EndianBinaryReader(bitConverter' inputStream))                  {                      writer.Write(reader.ReadBytes(4));                      UInt32 fileSize = reader.ReadUInt32();                      fileSize -= 8; // We're removing data' so update the size in the header                      writer.Write(fileSize);                      writer.Write(reader.ReadBytes(8));                      writer.Write(66); reader.ReadUInt32(); // New fmt size is 66                      writer.Write(reader.ReadBytes(16));                      writer.Write((ushort)48); reader.ReadUInt16(); // New cbSize is 48                      writer.Write(reader.ReadBytes(6));                      reader.BaseStream.Seek(8' SeekOrigin.Current); // Skip ahead 8 bytes' we don't want the vorb chunk                      writer.Write(reader.ReadBytes((int)reader.BaseStream.Length - (int)reader.BaseStream.Position));                        return new MemoryStream(outputFileStream.GetBuffer()' 0' (int)outputFileStream.Length);                  }              }              else                  return inputStream;
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,DowngradeWemVersion,The following statement contains a magic number: using (var o = new MemoryStream())              using (var reader = new EndianBinaryReader(bitConverter' o))              using (var writer = new EndianBinaryWriter(bitConverter' o))              {                  File.Open(inputFile' FileMode.Open' FileAccess.Read).CopyTo(o);                  reader.Seek(40' SeekOrigin.Begin);                  if (reader.ReadUInt32() != 3)                  {                      writer.Seek(40' SeekOrigin.Begin);                      writer.Write(3);                  }                  return new MemoryStream(o.GetBuffer()' 0' (int)o.Length);              }
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,DowngradeWemVersion,The following statement contains a magic number: using (var o = new MemoryStream())              using (var reader = new EndianBinaryReader(bitConverter' o))              using (var writer = new EndianBinaryWriter(bitConverter' o))              {                  File.Open(inputFile' FileMode.Open' FileAccess.Read).CopyTo(o);                  reader.Seek(40' SeekOrigin.Begin);                  if (reader.ReadUInt32() != 3)                  {                      writer.Seek(40' SeekOrigin.Begin);                      writer.Write(3);                  }                  return new MemoryStream(o.GetBuffer()' 0' (int)o.Length);              }
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,DowngradeWemVersion,The following statement contains a magic number: using (var o = new MemoryStream())              using (var reader = new EndianBinaryReader(bitConverter' o))              using (var writer = new EndianBinaryWriter(bitConverter' o))              {                  File.Open(inputFile' FileMode.Open' FileAccess.Read).CopyTo(o);                  reader.Seek(40' SeekOrigin.Begin);                  if (reader.ReadUInt32() != 3)                  {                      writer.Seek(40' SeekOrigin.Begin);                      writer.Write(3);                  }                  return new MemoryStream(o.GetBuffer()' 0' (int)o.Length);              }
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,DowngradeWemVersion,The following statement contains a magic number: using (var o = new MemoryStream())              using (var reader = new EndianBinaryReader(bitConverter' o))              using (var writer = new EndianBinaryWriter(bitConverter' o))              {                  File.Open(inputFile' FileMode.Open' FileAccess.Read).CopyTo(o);                  reader.Seek(40' SeekOrigin.Begin);                  if (reader.ReadUInt32() != 3)                  {                      writer.Seek(40' SeekOrigin.Begin);                      writer.Write(3);                  }                  return new MemoryStream(o.GetBuffer()' 0' (int)o.Length);              }
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,ConvertAudioPlatform,The following statement contains a magic number: using (var outputFileStream = new MemoryStream())              using (var inputFileStream = File.Open(inputFile' FileMode.Open))              using (var writer = new EndianBinaryWriter(targetbitConverter' outputFileStream))              using (var reader = new EndianBinaryReader(bitConverter' inputFileStream))              {                  // Process Header                  UInt32 header = reader.ReadUInt32();                  if (header == 1179011410)//RIFF header to RIFX                      //raw                      writer.Write(1380533848);                  else                      //raw                      writer.Write(1179011410); // 1179011410                  writer.Write(reader.ReadUInt32()); // Size of File                  //raw                  writer.Write(reader.ReadBytes(4)); // WAVE (RIFF type)                    //Process Format                  writer.Write(reader.ReadBytes(4)); // fmt magicID                    //raw                  writer.Write(reader.ReadUInt32()); // fmt size                  writer.Write(reader.ReadUInt16()); // fmt tag (-1)                  writer.Write(reader.ReadUInt16()); // channels                  writer.Write(reader.ReadUInt32()); // samplesPerSec                  writer.Write(reader.ReadUInt32()); // avgBytesPerSec                 //SeekTableGranulary?                  writer.Write(reader.ReadUInt16()); // blockAlign                  writer.Write(reader.ReadUInt16()); // bitsPerSample                  writer.Write(reader.ReadUInt16()); //short cbSize 0-22               // WAVEFORMATEXTENSIBLE                  writer.Write(reader.ReadUInt16()); //short wSamplesPerBlock;         // WAVEFORMATEXTENSIBLE                  writer.Write(reader.ReadUInt32()); //long  dwChannelMask;            // WAVEFORMATEXTENSIBLE                  writer.Write(reader.ReadUInt32()); //long  dwTotalPCMFrames;         // Wwise                  UInt32 start = reader.ReadUInt32();                  writer.Write(start);              //long  dwLoopStartPacketOffset;   // Wwise                  UInt32 end = reader.ReadUInt32();                  writer.Write(end);                //long  dwLoopEndPacketOffset;     // Wwise                  writer.Write(reader.ReadUInt16());//short uLoopBeginExtra;           // Wwise                  writer.Write(reader.ReadUInt16());//short uLoopEndExtra;             // Wwise                  UInt32 seektablesize = reader.ReadUInt32();                  writer.Write(seektablesize);      //long dwSeekTableSize;            // Wwise                  writer.Write(reader.ReadUInt32());//long  dwVorbisDataOffset;        // Wwise                  writer.Write(reader.ReadUInt16());//short uMaxPacketSize;            // Wwise                  writer.Write(reader.ReadUInt16());//short uLastGranuleExtra;         // Wwise                  writer.Write(reader.ReadUInt32());//long  dwDecodeAllocSize;         // Wwise                  writer.Write(reader.ReadUInt32());//long  dwDecodeX64AllocSize;      // Wwise                  //raw                  writer.Write(reader.ReadBytes(4));//long  uHashCodebook;             // Wwise vorbis_analysis_headerout                  writer.Write(reader.ReadByte());  //char  uBlockSizes[2];            // Wwise                  writer.Write(reader.ReadByte());  //char  uBlockSizes[2];            // Wwise                    // Process DATA section - contains size' seektable' codebook' stream (biggest part)                  //raw data                  writer.Write(reader.ReadBytes(4)); // the word data                  writer.Write(reader.ReadUInt32()); //data size                    //seektable                  var y = seektablesize / 4;                  for (int i = 0; i < y; i++)                  {                      writer.Write(reader.ReadUInt16()); //seekgranularity                      writer.Write(reader.ReadUInt16()); //unk. actual granularity used??                  }                    //codebook                  UInt16 codebooksize = reader.ReadUInt16();                  writer.Write(codebooksize); //codebook size                  for (int i = 0; i < codebooksize; i++)                  {                      //raw data                      writer.Write(reader.ReadByte());                  }                    //stream                  var streamsize = (end - start); //calculate the total stream size till End of File                  for (int i = 0; i < streamsize; i++)                  {                      UInt16 packetsize = reader.ReadUInt16(); // size of packet                      i++; // increase because two bytes read for size of packet                      writer.Write(packetsize);                      for (int z = 0; z < packetsize; z++)                      {                          Byte packet = reader.ReadByte();                          writer.Write(packet); // the packets are the same in both pc/console                          i++; // add the  bytes read to packetsize counter.                      }                  }                  return new MemoryStream(outputFileStream.GetBuffer()' 0' (int)outputFileStream.Length);              }
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,ConvertAudioPlatform,The following statement contains a magic number: using (var outputFileStream = new MemoryStream())              using (var inputFileStream = File.Open(inputFile' FileMode.Open))              using (var writer = new EndianBinaryWriter(targetbitConverter' outputFileStream))              using (var reader = new EndianBinaryReader(bitConverter' inputFileStream))              {                  // Process Header                  UInt32 header = reader.ReadUInt32();                  if (header == 1179011410)//RIFF header to RIFX                      //raw                      writer.Write(1380533848);                  else                      //raw                      writer.Write(1179011410); // 1179011410                  writer.Write(reader.ReadUInt32()); // Size of File                  //raw                  writer.Write(reader.ReadBytes(4)); // WAVE (RIFF type)                    //Process Format                  writer.Write(reader.ReadBytes(4)); // fmt magicID                    //raw                  writer.Write(reader.ReadUInt32()); // fmt size                  writer.Write(reader.ReadUInt16()); // fmt tag (-1)                  writer.Write(reader.ReadUInt16()); // channels                  writer.Write(reader.ReadUInt32()); // samplesPerSec                  writer.Write(reader.ReadUInt32()); // avgBytesPerSec                 //SeekTableGranulary?                  writer.Write(reader.ReadUInt16()); // blockAlign                  writer.Write(reader.ReadUInt16()); // bitsPerSample                  writer.Write(reader.ReadUInt16()); //short cbSize 0-22               // WAVEFORMATEXTENSIBLE                  writer.Write(reader.ReadUInt16()); //short wSamplesPerBlock;         // WAVEFORMATEXTENSIBLE                  writer.Write(reader.ReadUInt32()); //long  dwChannelMask;            // WAVEFORMATEXTENSIBLE                  writer.Write(reader.ReadUInt32()); //long  dwTotalPCMFrames;         // Wwise                  UInt32 start = reader.ReadUInt32();                  writer.Write(start);              //long  dwLoopStartPacketOffset;   // Wwise                  UInt32 end = reader.ReadUInt32();                  writer.Write(end);                //long  dwLoopEndPacketOffset;     // Wwise                  writer.Write(reader.ReadUInt16());//short uLoopBeginExtra;           // Wwise                  writer.Write(reader.ReadUInt16());//short uLoopEndExtra;             // Wwise                  UInt32 seektablesize = reader.ReadUInt32();                  writer.Write(seektablesize);      //long dwSeekTableSize;            // Wwise                  writer.Write(reader.ReadUInt32());//long  dwVorbisDataOffset;        // Wwise                  writer.Write(reader.ReadUInt16());//short uMaxPacketSize;            // Wwise                  writer.Write(reader.ReadUInt16());//short uLastGranuleExtra;         // Wwise                  writer.Write(reader.ReadUInt32());//long  dwDecodeAllocSize;         // Wwise                  writer.Write(reader.ReadUInt32());//long  dwDecodeX64AllocSize;      // Wwise                  //raw                  writer.Write(reader.ReadBytes(4));//long  uHashCodebook;             // Wwise vorbis_analysis_headerout                  writer.Write(reader.ReadByte());  //char  uBlockSizes[2];            // Wwise                  writer.Write(reader.ReadByte());  //char  uBlockSizes[2];            // Wwise                    // Process DATA section - contains size' seektable' codebook' stream (biggest part)                  //raw data                  writer.Write(reader.ReadBytes(4)); // the word data                  writer.Write(reader.ReadUInt32()); //data size                    //seektable                  var y = seektablesize / 4;                  for (int i = 0; i < y; i++)                  {                      writer.Write(reader.ReadUInt16()); //seekgranularity                      writer.Write(reader.ReadUInt16()); //unk. actual granularity used??                  }                    //codebook                  UInt16 codebooksize = reader.ReadUInt16();                  writer.Write(codebooksize); //codebook size                  for (int i = 0; i < codebooksize; i++)                  {                      //raw data                      writer.Write(reader.ReadByte());                  }                    //stream                  var streamsize = (end - start); //calculate the total stream size till End of File                  for (int i = 0; i < streamsize; i++)                  {                      UInt16 packetsize = reader.ReadUInt16(); // size of packet                      i++; // increase because two bytes read for size of packet                      writer.Write(packetsize);                      for (int z = 0; z < packetsize; z++)                      {                          Byte packet = reader.ReadByte();                          writer.Write(packet); // the packets are the same in both pc/console                          i++; // add the  bytes read to packetsize counter.                      }                  }                  return new MemoryStream(outputFileStream.GetBuffer()' 0' (int)outputFileStream.Length);              }
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,ConvertAudioPlatform,The following statement contains a magic number: using (var outputFileStream = new MemoryStream())              using (var inputFileStream = File.Open(inputFile' FileMode.Open))              using (var writer = new EndianBinaryWriter(targetbitConverter' outputFileStream))              using (var reader = new EndianBinaryReader(bitConverter' inputFileStream))              {                  // Process Header                  UInt32 header = reader.ReadUInt32();                  if (header == 1179011410)//RIFF header to RIFX                      //raw                      writer.Write(1380533848);                  else                      //raw                      writer.Write(1179011410); // 1179011410                  writer.Write(reader.ReadUInt32()); // Size of File                  //raw                  writer.Write(reader.ReadBytes(4)); // WAVE (RIFF type)                    //Process Format                  writer.Write(reader.ReadBytes(4)); // fmt magicID                    //raw                  writer.Write(reader.ReadUInt32()); // fmt size                  writer.Write(reader.ReadUInt16()); // fmt tag (-1)                  writer.Write(reader.ReadUInt16()); // channels                  writer.Write(reader.ReadUInt32()); // samplesPerSec                  writer.Write(reader.ReadUInt32()); // avgBytesPerSec                 //SeekTableGranulary?                  writer.Write(reader.ReadUInt16()); // blockAlign                  writer.Write(reader.ReadUInt16()); // bitsPerSample                  writer.Write(reader.ReadUInt16()); //short cbSize 0-22               // WAVEFORMATEXTENSIBLE                  writer.Write(reader.ReadUInt16()); //short wSamplesPerBlock;         // WAVEFORMATEXTENSIBLE                  writer.Write(reader.ReadUInt32()); //long  dwChannelMask;            // WAVEFORMATEXTENSIBLE                  writer.Write(reader.ReadUInt32()); //long  dwTotalPCMFrames;         // Wwise                  UInt32 start = reader.ReadUInt32();                  writer.Write(start);              //long  dwLoopStartPacketOffset;   // Wwise                  UInt32 end = reader.ReadUInt32();                  writer.Write(end);                //long  dwLoopEndPacketOffset;     // Wwise                  writer.Write(reader.ReadUInt16());//short uLoopBeginExtra;           // Wwise                  writer.Write(reader.ReadUInt16());//short uLoopEndExtra;             // Wwise                  UInt32 seektablesize = reader.ReadUInt32();                  writer.Write(seektablesize);      //long dwSeekTableSize;            // Wwise                  writer.Write(reader.ReadUInt32());//long  dwVorbisDataOffset;        // Wwise                  writer.Write(reader.ReadUInt16());//short uMaxPacketSize;            // Wwise                  writer.Write(reader.ReadUInt16());//short uLastGranuleExtra;         // Wwise                  writer.Write(reader.ReadUInt32());//long  dwDecodeAllocSize;         // Wwise                  writer.Write(reader.ReadUInt32());//long  dwDecodeX64AllocSize;      // Wwise                  //raw                  writer.Write(reader.ReadBytes(4));//long  uHashCodebook;             // Wwise vorbis_analysis_headerout                  writer.Write(reader.ReadByte());  //char  uBlockSizes[2];            // Wwise                  writer.Write(reader.ReadByte());  //char  uBlockSizes[2];            // Wwise                    // Process DATA section - contains size' seektable' codebook' stream (biggest part)                  //raw data                  writer.Write(reader.ReadBytes(4)); // the word data                  writer.Write(reader.ReadUInt32()); //data size                    //seektable                  var y = seektablesize / 4;                  for (int i = 0; i < y; i++)                  {                      writer.Write(reader.ReadUInt16()); //seekgranularity                      writer.Write(reader.ReadUInt16()); //unk. actual granularity used??                  }                    //codebook                  UInt16 codebooksize = reader.ReadUInt16();                  writer.Write(codebooksize); //codebook size                  for (int i = 0; i < codebooksize; i++)                  {                      //raw data                      writer.Write(reader.ReadByte());                  }                    //stream                  var streamsize = (end - start); //calculate the total stream size till End of File                  for (int i = 0; i < streamsize; i++)                  {                      UInt16 packetsize = reader.ReadUInt16(); // size of packet                      i++; // increase because two bytes read for size of packet                      writer.Write(packetsize);                      for (int z = 0; z < packetsize; z++)                      {                          Byte packet = reader.ReadByte();                          writer.Write(packet); // the packets are the same in both pc/console                          i++; // add the  bytes read to packetsize counter.                      }                  }                  return new MemoryStream(outputFileStream.GetBuffer()' 0' (int)outputFileStream.Length);              }
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,ConvertAudioPlatform,The following statement contains a magic number: using (var outputFileStream = new MemoryStream())              using (var inputFileStream = File.Open(inputFile' FileMode.Open))              using (var writer = new EndianBinaryWriter(targetbitConverter' outputFileStream))              using (var reader = new EndianBinaryReader(bitConverter' inputFileStream))              {                  // Process Header                  UInt32 header = reader.ReadUInt32();                  if (header == 1179011410)//RIFF header to RIFX                      //raw                      writer.Write(1380533848);                  else                      //raw                      writer.Write(1179011410); // 1179011410                  writer.Write(reader.ReadUInt32()); // Size of File                  //raw                  writer.Write(reader.ReadBytes(4)); // WAVE (RIFF type)                    //Process Format                  writer.Write(reader.ReadBytes(4)); // fmt magicID                    //raw                  writer.Write(reader.ReadUInt32()); // fmt size                  writer.Write(reader.ReadUInt16()); // fmt tag (-1)                  writer.Write(reader.ReadUInt16()); // channels                  writer.Write(reader.ReadUInt32()); // samplesPerSec                  writer.Write(reader.ReadUInt32()); // avgBytesPerSec                 //SeekTableGranulary?                  writer.Write(reader.ReadUInt16()); // blockAlign                  writer.Write(reader.ReadUInt16()); // bitsPerSample                  writer.Write(reader.ReadUInt16()); //short cbSize 0-22               // WAVEFORMATEXTENSIBLE                  writer.Write(reader.ReadUInt16()); //short wSamplesPerBlock;         // WAVEFORMATEXTENSIBLE                  writer.Write(reader.ReadUInt32()); //long  dwChannelMask;            // WAVEFORMATEXTENSIBLE                  writer.Write(reader.ReadUInt32()); //long  dwTotalPCMFrames;         // Wwise                  UInt32 start = reader.ReadUInt32();                  writer.Write(start);              //long  dwLoopStartPacketOffset;   // Wwise                  UInt32 end = reader.ReadUInt32();                  writer.Write(end);                //long  dwLoopEndPacketOffset;     // Wwise                  writer.Write(reader.ReadUInt16());//short uLoopBeginExtra;           // Wwise                  writer.Write(reader.ReadUInt16());//short uLoopEndExtra;             // Wwise                  UInt32 seektablesize = reader.ReadUInt32();                  writer.Write(seektablesize);      //long dwSeekTableSize;            // Wwise                  writer.Write(reader.ReadUInt32());//long  dwVorbisDataOffset;        // Wwise                  writer.Write(reader.ReadUInt16());//short uMaxPacketSize;            // Wwise                  writer.Write(reader.ReadUInt16());//short uLastGranuleExtra;         // Wwise                  writer.Write(reader.ReadUInt32());//long  dwDecodeAllocSize;         // Wwise                  writer.Write(reader.ReadUInt32());//long  dwDecodeX64AllocSize;      // Wwise                  //raw                  writer.Write(reader.ReadBytes(4));//long  uHashCodebook;             // Wwise vorbis_analysis_headerout                  writer.Write(reader.ReadByte());  //char  uBlockSizes[2];            // Wwise                  writer.Write(reader.ReadByte());  //char  uBlockSizes[2];            // Wwise                    // Process DATA section - contains size' seektable' codebook' stream (biggest part)                  //raw data                  writer.Write(reader.ReadBytes(4)); // the word data                  writer.Write(reader.ReadUInt32()); //data size                    //seektable                  var y = seektablesize / 4;                  for (int i = 0; i < y; i++)                  {                      writer.Write(reader.ReadUInt16()); //seekgranularity                      writer.Write(reader.ReadUInt16()); //unk. actual granularity used??                  }                    //codebook                  UInt16 codebooksize = reader.ReadUInt16();                  writer.Write(codebooksize); //codebook size                  for (int i = 0; i < codebooksize; i++)                  {                      //raw data                      writer.Write(reader.ReadByte());                  }                    //stream                  var streamsize = (end - start); //calculate the total stream size till End of File                  for (int i = 0; i < streamsize; i++)                  {                      UInt16 packetsize = reader.ReadUInt16(); // size of packet                      i++; // increase because two bytes read for size of packet                      writer.Write(packetsize);                      for (int z = 0; z < packetsize; z++)                      {                          Byte packet = reader.ReadByte();                          writer.Write(packet); // the packets are the same in both pc/console                          i++; // add the  bytes read to packetsize counter.                      }                  }                  return new MemoryStream(outputFileStream.GetBuffer()' 0' (int)outputFileStream.Length);              }
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,ConvertAudioPlatform,The following statement contains a magic number: using (var outputFileStream = new MemoryStream())              using (var inputFileStream = File.Open(inputFile' FileMode.Open))              using (var writer = new EndianBinaryWriter(targetbitConverter' outputFileStream))              using (var reader = new EndianBinaryReader(bitConverter' inputFileStream))              {                  // Process Header                  UInt32 header = reader.ReadUInt32();                  if (header == 1179011410)//RIFF header to RIFX                      //raw                      writer.Write(1380533848);                  else                      //raw                      writer.Write(1179011410); // 1179011410                  writer.Write(reader.ReadUInt32()); // Size of File                  //raw                  writer.Write(reader.ReadBytes(4)); // WAVE (RIFF type)                    //Process Format                  writer.Write(reader.ReadBytes(4)); // fmt magicID                    //raw                  writer.Write(reader.ReadUInt32()); // fmt size                  writer.Write(reader.ReadUInt16()); // fmt tag (-1)                  writer.Write(reader.ReadUInt16()); // channels                  writer.Write(reader.ReadUInt32()); // samplesPerSec                  writer.Write(reader.ReadUInt32()); // avgBytesPerSec                 //SeekTableGranulary?                  writer.Write(reader.ReadUInt16()); // blockAlign                  writer.Write(reader.ReadUInt16()); // bitsPerSample                  writer.Write(reader.ReadUInt16()); //short cbSize 0-22               // WAVEFORMATEXTENSIBLE                  writer.Write(reader.ReadUInt16()); //short wSamplesPerBlock;         // WAVEFORMATEXTENSIBLE                  writer.Write(reader.ReadUInt32()); //long  dwChannelMask;            // WAVEFORMATEXTENSIBLE                  writer.Write(reader.ReadUInt32()); //long  dwTotalPCMFrames;         // Wwise                  UInt32 start = reader.ReadUInt32();                  writer.Write(start);              //long  dwLoopStartPacketOffset;   // Wwise                  UInt32 end = reader.ReadUInt32();                  writer.Write(end);                //long  dwLoopEndPacketOffset;     // Wwise                  writer.Write(reader.ReadUInt16());//short uLoopBeginExtra;           // Wwise                  writer.Write(reader.ReadUInt16());//short uLoopEndExtra;             // Wwise                  UInt32 seektablesize = reader.ReadUInt32();                  writer.Write(seektablesize);      //long dwSeekTableSize;            // Wwise                  writer.Write(reader.ReadUInt32());//long  dwVorbisDataOffset;        // Wwise                  writer.Write(reader.ReadUInt16());//short uMaxPacketSize;            // Wwise                  writer.Write(reader.ReadUInt16());//short uLastGranuleExtra;         // Wwise                  writer.Write(reader.ReadUInt32());//long  dwDecodeAllocSize;         // Wwise                  writer.Write(reader.ReadUInt32());//long  dwDecodeX64AllocSize;      // Wwise                  //raw                  writer.Write(reader.ReadBytes(4));//long  uHashCodebook;             // Wwise vorbis_analysis_headerout                  writer.Write(reader.ReadByte());  //char  uBlockSizes[2];            // Wwise                  writer.Write(reader.ReadByte());  //char  uBlockSizes[2];            // Wwise                    // Process DATA section - contains size' seektable' codebook' stream (biggest part)                  //raw data                  writer.Write(reader.ReadBytes(4)); // the word data                  writer.Write(reader.ReadUInt32()); //data size                    //seektable                  var y = seektablesize / 4;                  for (int i = 0; i < y; i++)                  {                      writer.Write(reader.ReadUInt16()); //seekgranularity                      writer.Write(reader.ReadUInt16()); //unk. actual granularity used??                  }                    //codebook                  UInt16 codebooksize = reader.ReadUInt16();                  writer.Write(codebooksize); //codebook size                  for (int i = 0; i < codebooksize; i++)                  {                      //raw data                      writer.Write(reader.ReadByte());                  }                    //stream                  var streamsize = (end - start); //calculate the total stream size till End of File                  for (int i = 0; i < streamsize; i++)                  {                      UInt16 packetsize = reader.ReadUInt16(); // size of packet                      i++; // increase because two bytes read for size of packet                      writer.Write(packetsize);                      for (int z = 0; z < packetsize; z++)                      {                          Byte packet = reader.ReadByte();                          writer.Write(packet); // the packets are the same in both pc/console                          i++; // add the  bytes read to packetsize counter.                      }                  }                  return new MemoryStream(outputFileStream.GetBuffer()' 0' (int)outputFileStream.Length);              }
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,ConvertAudioPlatform,The following statement contains a magic number: using (var outputFileStream = new MemoryStream())              using (var inputFileStream = File.Open(inputFile' FileMode.Open))              using (var writer = new EndianBinaryWriter(targetbitConverter' outputFileStream))              using (var reader = new EndianBinaryReader(bitConverter' inputFileStream))              {                  // Process Header                  UInt32 header = reader.ReadUInt32();                  if (header == 1179011410)//RIFF header to RIFX                      //raw                      writer.Write(1380533848);                  else                      //raw                      writer.Write(1179011410); // 1179011410                  writer.Write(reader.ReadUInt32()); // Size of File                  //raw                  writer.Write(reader.ReadBytes(4)); // WAVE (RIFF type)                    //Process Format                  writer.Write(reader.ReadBytes(4)); // fmt magicID                    //raw                  writer.Write(reader.ReadUInt32()); // fmt size                  writer.Write(reader.ReadUInt16()); // fmt tag (-1)                  writer.Write(reader.ReadUInt16()); // channels                  writer.Write(reader.ReadUInt32()); // samplesPerSec                  writer.Write(reader.ReadUInt32()); // avgBytesPerSec                 //SeekTableGranulary?                  writer.Write(reader.ReadUInt16()); // blockAlign                  writer.Write(reader.ReadUInt16()); // bitsPerSample                  writer.Write(reader.ReadUInt16()); //short cbSize 0-22               // WAVEFORMATEXTENSIBLE                  writer.Write(reader.ReadUInt16()); //short wSamplesPerBlock;         // WAVEFORMATEXTENSIBLE                  writer.Write(reader.ReadUInt32()); //long  dwChannelMask;            // WAVEFORMATEXTENSIBLE                  writer.Write(reader.ReadUInt32()); //long  dwTotalPCMFrames;         // Wwise                  UInt32 start = reader.ReadUInt32();                  writer.Write(start);              //long  dwLoopStartPacketOffset;   // Wwise                  UInt32 end = reader.ReadUInt32();                  writer.Write(end);                //long  dwLoopEndPacketOffset;     // Wwise                  writer.Write(reader.ReadUInt16());//short uLoopBeginExtra;           // Wwise                  writer.Write(reader.ReadUInt16());//short uLoopEndExtra;             // Wwise                  UInt32 seektablesize = reader.ReadUInt32();                  writer.Write(seektablesize);      //long dwSeekTableSize;            // Wwise                  writer.Write(reader.ReadUInt32());//long  dwVorbisDataOffset;        // Wwise                  writer.Write(reader.ReadUInt16());//short uMaxPacketSize;            // Wwise                  writer.Write(reader.ReadUInt16());//short uLastGranuleExtra;         // Wwise                  writer.Write(reader.ReadUInt32());//long  dwDecodeAllocSize;         // Wwise                  writer.Write(reader.ReadUInt32());//long  dwDecodeX64AllocSize;      // Wwise                  //raw                  writer.Write(reader.ReadBytes(4));//long  uHashCodebook;             // Wwise vorbis_analysis_headerout                  writer.Write(reader.ReadByte());  //char  uBlockSizes[2];            // Wwise                  writer.Write(reader.ReadByte());  //char  uBlockSizes[2];            // Wwise                    // Process DATA section - contains size' seektable' codebook' stream (biggest part)                  //raw data                  writer.Write(reader.ReadBytes(4)); // the word data                  writer.Write(reader.ReadUInt32()); //data size                    //seektable                  var y = seektablesize / 4;                  for (int i = 0; i < y; i++)                  {                      writer.Write(reader.ReadUInt16()); //seekgranularity                      writer.Write(reader.ReadUInt16()); //unk. actual granularity used??                  }                    //codebook                  UInt16 codebooksize = reader.ReadUInt16();                  writer.Write(codebooksize); //codebook size                  for (int i = 0; i < codebooksize; i++)                  {                      //raw data                      writer.Write(reader.ReadByte());                  }                    //stream                  var streamsize = (end - start); //calculate the total stream size till End of File                  for (int i = 0; i < streamsize; i++)                  {                      UInt16 packetsize = reader.ReadUInt16(); // size of packet                      i++; // increase because two bytes read for size of packet                      writer.Write(packetsize);                      for (int z = 0; z < packetsize; z++)                      {                          Byte packet = reader.ReadByte();                          writer.Write(packet); // the packets are the same in both pc/console                          i++; // add the  bytes read to packetsize counter.                      }                  }                  return new MemoryStream(outputFileStream.GetBuffer()' 0' (int)outputFileStream.Length);              }
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,ConvertAudioPlatform,The following statement contains a magic number: using (var outputFileStream = new MemoryStream())              using (var inputFileStream = File.Open(inputFile' FileMode.Open))              using (var writer = new EndianBinaryWriter(targetbitConverter' outputFileStream))              using (var reader = new EndianBinaryReader(bitConverter' inputFileStream))              {                  // Process Header                  UInt32 header = reader.ReadUInt32();                  if (header == 1179011410)//RIFF header to RIFX                      //raw                      writer.Write(1380533848);                  else                      //raw                      writer.Write(1179011410); // 1179011410                  writer.Write(reader.ReadUInt32()); // Size of File                  //raw                  writer.Write(reader.ReadBytes(4)); // WAVE (RIFF type)                    //Process Format                  writer.Write(reader.ReadBytes(4)); // fmt magicID                    //raw                  writer.Write(reader.ReadUInt32()); // fmt size                  writer.Write(reader.ReadUInt16()); // fmt tag (-1)                  writer.Write(reader.ReadUInt16()); // channels                  writer.Write(reader.ReadUInt32()); // samplesPerSec                  writer.Write(reader.ReadUInt32()); // avgBytesPerSec                 //SeekTableGranulary?                  writer.Write(reader.ReadUInt16()); // blockAlign                  writer.Write(reader.ReadUInt16()); // bitsPerSample                  writer.Write(reader.ReadUInt16()); //short cbSize 0-22               // WAVEFORMATEXTENSIBLE                  writer.Write(reader.ReadUInt16()); //short wSamplesPerBlock;         // WAVEFORMATEXTENSIBLE                  writer.Write(reader.ReadUInt32()); //long  dwChannelMask;            // WAVEFORMATEXTENSIBLE                  writer.Write(reader.ReadUInt32()); //long  dwTotalPCMFrames;         // Wwise                  UInt32 start = reader.ReadUInt32();                  writer.Write(start);              //long  dwLoopStartPacketOffset;   // Wwise                  UInt32 end = reader.ReadUInt32();                  writer.Write(end);                //long  dwLoopEndPacketOffset;     // Wwise                  writer.Write(reader.ReadUInt16());//short uLoopBeginExtra;           // Wwise                  writer.Write(reader.ReadUInt16());//short uLoopEndExtra;             // Wwise                  UInt32 seektablesize = reader.ReadUInt32();                  writer.Write(seektablesize);      //long dwSeekTableSize;            // Wwise                  writer.Write(reader.ReadUInt32());//long  dwVorbisDataOffset;        // Wwise                  writer.Write(reader.ReadUInt16());//short uMaxPacketSize;            // Wwise                  writer.Write(reader.ReadUInt16());//short uLastGranuleExtra;         // Wwise                  writer.Write(reader.ReadUInt32());//long  dwDecodeAllocSize;         // Wwise                  writer.Write(reader.ReadUInt32());//long  dwDecodeX64AllocSize;      // Wwise                  //raw                  writer.Write(reader.ReadBytes(4));//long  uHashCodebook;             // Wwise vorbis_analysis_headerout                  writer.Write(reader.ReadByte());  //char  uBlockSizes[2];            // Wwise                  writer.Write(reader.ReadByte());  //char  uBlockSizes[2];            // Wwise                    // Process DATA section - contains size' seektable' codebook' stream (biggest part)                  //raw data                  writer.Write(reader.ReadBytes(4)); // the word data                  writer.Write(reader.ReadUInt32()); //data size                    //seektable                  var y = seektablesize / 4;                  for (int i = 0; i < y; i++)                  {                      writer.Write(reader.ReadUInt16()); //seekgranularity                      writer.Write(reader.ReadUInt16()); //unk. actual granularity used??                  }                    //codebook                  UInt16 codebooksize = reader.ReadUInt16();                  writer.Write(codebooksize); //codebook size                  for (int i = 0; i < codebooksize; i++)                  {                      //raw data                      writer.Write(reader.ReadByte());                  }                    //stream                  var streamsize = (end - start); //calculate the total stream size till End of File                  for (int i = 0; i < streamsize; i++)                  {                      UInt16 packetsize = reader.ReadUInt16(); // size of packet                      i++; // increase because two bytes read for size of packet                      writer.Write(packetsize);                      for (int z = 0; z < packetsize; z++)                      {                          Byte packet = reader.ReadByte();                          writer.Write(packet); // the packets are the same in both pc/console                          i++; // add the  bytes read to packetsize counter.                      }                  }                  return new MemoryStream(outputFileStream.GetBuffer()' 0' (int)outputFileStream.Length);              }
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,ConvertAudioPlatform,The following statement contains a magic number: using (var outputFileStream = new MemoryStream())              using (var inputFileStream = File.Open(inputFile' FileMode.Open))              using (var writer = new EndianBinaryWriter(targetbitConverter' outputFileStream))              using (var reader = new EndianBinaryReader(bitConverter' inputFileStream))              {                  // Process Header                  UInt32 header = reader.ReadUInt32();                  if (header == 1179011410)//RIFF header to RIFX                      //raw                      writer.Write(1380533848);                  else                      //raw                      writer.Write(1179011410); // 1179011410                  writer.Write(reader.ReadUInt32()); // Size of File                  //raw                  writer.Write(reader.ReadBytes(4)); // WAVE (RIFF type)                    //Process Format                  writer.Write(reader.ReadBytes(4)); // fmt magicID                    //raw                  writer.Write(reader.ReadUInt32()); // fmt size                  writer.Write(reader.ReadUInt16()); // fmt tag (-1)                  writer.Write(reader.ReadUInt16()); // channels                  writer.Write(reader.ReadUInt32()); // samplesPerSec                  writer.Write(reader.ReadUInt32()); // avgBytesPerSec                 //SeekTableGranulary?                  writer.Write(reader.ReadUInt16()); // blockAlign                  writer.Write(reader.ReadUInt16()); // bitsPerSample                  writer.Write(reader.ReadUInt16()); //short cbSize 0-22               // WAVEFORMATEXTENSIBLE                  writer.Write(reader.ReadUInt16()); //short wSamplesPerBlock;         // WAVEFORMATEXTENSIBLE                  writer.Write(reader.ReadUInt32()); //long  dwChannelMask;            // WAVEFORMATEXTENSIBLE                  writer.Write(reader.ReadUInt32()); //long  dwTotalPCMFrames;         // Wwise                  UInt32 start = reader.ReadUInt32();                  writer.Write(start);              //long  dwLoopStartPacketOffset;   // Wwise                  UInt32 end = reader.ReadUInt32();                  writer.Write(end);                //long  dwLoopEndPacketOffset;     // Wwise                  writer.Write(reader.ReadUInt16());//short uLoopBeginExtra;           // Wwise                  writer.Write(reader.ReadUInt16());//short uLoopEndExtra;             // Wwise                  UInt32 seektablesize = reader.ReadUInt32();                  writer.Write(seektablesize);      //long dwSeekTableSize;            // Wwise                  writer.Write(reader.ReadUInt32());//long  dwVorbisDataOffset;        // Wwise                  writer.Write(reader.ReadUInt16());//short uMaxPacketSize;            // Wwise                  writer.Write(reader.ReadUInt16());//short uLastGranuleExtra;         // Wwise                  writer.Write(reader.ReadUInt32());//long  dwDecodeAllocSize;         // Wwise                  writer.Write(reader.ReadUInt32());//long  dwDecodeX64AllocSize;      // Wwise                  //raw                  writer.Write(reader.ReadBytes(4));//long  uHashCodebook;             // Wwise vorbis_analysis_headerout                  writer.Write(reader.ReadByte());  //char  uBlockSizes[2];            // Wwise                  writer.Write(reader.ReadByte());  //char  uBlockSizes[2];            // Wwise                    // Process DATA section - contains size' seektable' codebook' stream (biggest part)                  //raw data                  writer.Write(reader.ReadBytes(4)); // the word data                  writer.Write(reader.ReadUInt32()); //data size                    //seektable                  var y = seektablesize / 4;                  for (int i = 0; i < y; i++)                  {                      writer.Write(reader.ReadUInt16()); //seekgranularity                      writer.Write(reader.ReadUInt16()); //unk. actual granularity used??                  }                    //codebook                  UInt16 codebooksize = reader.ReadUInt16();                  writer.Write(codebooksize); //codebook size                  for (int i = 0; i < codebooksize; i++)                  {                      //raw data                      writer.Write(reader.ReadByte());                  }                    //stream                  var streamsize = (end - start); //calculate the total stream size till End of File                  for (int i = 0; i < streamsize; i++)                  {                      UInt16 packetsize = reader.ReadUInt16(); // size of packet                      i++; // increase because two bytes read for size of packet                      writer.Write(packetsize);                      for (int z = 0; z < packetsize; z++)                      {                          Byte packet = reader.ReadByte();                          writer.Write(packet); // the packets are the same in both pc/console                          i++; // add the  bytes read to packetsize counter.                      }                  }                  return new MemoryStream(outputFileStream.GetBuffer()' 0' (int)outputFileStream.Length);              }
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,Convert2Wem,The following statement contains a magic number: if (audioPath.Substring(audioPath.Length - 4).ToLower() == ".ogg") //in RS1 ogg was actually wwise              {                  ExternalApps.Ogg2Wav(audioPath' wavPath); //detect quality here                  if (!File.Exists(oggPreviewPath))                  {                      ExternalApps.Ogg2Preview(audioPath' oggPreviewPath' previewLength' chorusTime);                      ExternalApps.Ogg2Wav(oggPreviewPath' wavPreviewPath);                  }                  audioPath = wavPath;              }
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,Convert2Wem,The following statement contains a magic number: if (audioPath.Substring(audioPath.Length - 4).ToLower() == ".wav")              {                  if (!File.Exists(wavPreviewPath))                  {                      if (!File.Exists(oggPath))                      {                          //may cause issues if you've got another guitar.ogg in folder' but it's extremely rare.                          ExternalApps.Wav2Ogg(audioPath' oggPath' audioQuality); // 4                      }                      ExternalApps.Ogg2Preview(oggPath' oggPreviewPath' previewLength' chorusTime);                      ExternalApps.Ogg2Wav(oggPreviewPath' wavPreviewPath);                  }                  Wwise.Wav2Wem(audioPath' wemPath' audioQuality);                  audioPath = wemPath;              }
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,Convert2Wem,The following statement contains a magic number: if (audioPath.Substring(audioPath.Length - 4).ToLower() == ".wem" && !File.Exists(wemPreviewPath))              {                  Revorb(audioPath' oggPath' Path.GetDirectoryName(Application.ExecutablePath)' WwiseVersion.Wwise2013);                  ExternalApps.Ogg2Wav(oggPath' wavPath);                  ExternalApps.Ogg2Preview(oggPath' oggPreviewPath' previewLength' chorusTime);                  ExternalApps.Ogg2Wav(oggPreviewPath' wavPreviewPath);                  Wwise.Wav2Wem(wavPath' wemPath' audioQuality);                  audioPath = wemPath;              }
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,VerifyHeaders,The following statement contains a magic number: using (var inputFileStream = File.Open(inputFile' FileMode.Open))              using (var reader = new EndianBinaryReader(bitConverter' inputFileStream))              {                  reader.Seek(4' SeekOrigin.Begin);                  if (reader.ReadUInt32() != reader.BaseStream.Length - 8)                      throw new InvalidDataException("The input OGG file appears to be truncated.");                    if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "WAVE")                      throw new InvalidDataException("Error reading input file - expected WAVE");                    if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "fmt ")                      throw new InvalidDataException("Error reading input file - expected fmt");                    var fmtLength = reader.ReadUInt32();                  if (fmtLength != 24 && fmtLength != 66)                      throw new InvalidDataException("Error reading input file - expected fmt length of 24 or 66");                    if (fmtLength == 24)                  {                      if (reader.ReadUInt16() != 0xFFFF)                          throw new InvalidDataException("Error reading input file - expected Format Tag of 0xFFFF");                        reader.BaseStream.Seek(14' SeekOrigin.Current);                        if (reader.ReadUInt16() != 6)                          throw new InvalidDataException("Error reading input file - expected cbSize of 6");                        reader.BaseStream.Seek(6' SeekOrigin.Current);                        if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "vorb")                          throw new InvalidDataException("Error reading input file - expected vorb");                        if (reader.ReadUInt32() != 42)                          throw new InvalidDataException("Error reading input file - expected vorb length of 42");                  }              }
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,VerifyHeaders,The following statement contains a magic number: using (var inputFileStream = File.Open(inputFile' FileMode.Open))              using (var reader = new EndianBinaryReader(bitConverter' inputFileStream))              {                  reader.Seek(4' SeekOrigin.Begin);                  if (reader.ReadUInt32() != reader.BaseStream.Length - 8)                      throw new InvalidDataException("The input OGG file appears to be truncated.");                    if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "WAVE")                      throw new InvalidDataException("Error reading input file - expected WAVE");                    if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "fmt ")                      throw new InvalidDataException("Error reading input file - expected fmt");                    var fmtLength = reader.ReadUInt32();                  if (fmtLength != 24 && fmtLength != 66)                      throw new InvalidDataException("Error reading input file - expected fmt length of 24 or 66");                    if (fmtLength == 24)                  {                      if (reader.ReadUInt16() != 0xFFFF)                          throw new InvalidDataException("Error reading input file - expected Format Tag of 0xFFFF");                        reader.BaseStream.Seek(14' SeekOrigin.Current);                        if (reader.ReadUInt16() != 6)                          throw new InvalidDataException("Error reading input file - expected cbSize of 6");                        reader.BaseStream.Seek(6' SeekOrigin.Current);                        if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "vorb")                          throw new InvalidDataException("Error reading input file - expected vorb");                        if (reader.ReadUInt32() != 42)                          throw new InvalidDataException("Error reading input file - expected vorb length of 42");                  }              }
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,VerifyHeaders,The following statement contains a magic number: using (var inputFileStream = File.Open(inputFile' FileMode.Open))              using (var reader = new EndianBinaryReader(bitConverter' inputFileStream))              {                  reader.Seek(4' SeekOrigin.Begin);                  if (reader.ReadUInt32() != reader.BaseStream.Length - 8)                      throw new InvalidDataException("The input OGG file appears to be truncated.");                    if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "WAVE")                      throw new InvalidDataException("Error reading input file - expected WAVE");                    if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "fmt ")                      throw new InvalidDataException("Error reading input file - expected fmt");                    var fmtLength = reader.ReadUInt32();                  if (fmtLength != 24 && fmtLength != 66)                      throw new InvalidDataException("Error reading input file - expected fmt length of 24 or 66");                    if (fmtLength == 24)                  {                      if (reader.ReadUInt16() != 0xFFFF)                          throw new InvalidDataException("Error reading input file - expected Format Tag of 0xFFFF");                        reader.BaseStream.Seek(14' SeekOrigin.Current);                        if (reader.ReadUInt16() != 6)                          throw new InvalidDataException("Error reading input file - expected cbSize of 6");                        reader.BaseStream.Seek(6' SeekOrigin.Current);                        if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "vorb")                          throw new InvalidDataException("Error reading input file - expected vorb");                        if (reader.ReadUInt32() != 42)                          throw new InvalidDataException("Error reading input file - expected vorb length of 42");                  }              }
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,VerifyHeaders,The following statement contains a magic number: using (var inputFileStream = File.Open(inputFile' FileMode.Open))              using (var reader = new EndianBinaryReader(bitConverter' inputFileStream))              {                  reader.Seek(4' SeekOrigin.Begin);                  if (reader.ReadUInt32() != reader.BaseStream.Length - 8)                      throw new InvalidDataException("The input OGG file appears to be truncated.");                    if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "WAVE")                      throw new InvalidDataException("Error reading input file - expected WAVE");                    if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "fmt ")                      throw new InvalidDataException("Error reading input file - expected fmt");                    var fmtLength = reader.ReadUInt32();                  if (fmtLength != 24 && fmtLength != 66)                      throw new InvalidDataException("Error reading input file - expected fmt length of 24 or 66");                    if (fmtLength == 24)                  {                      if (reader.ReadUInt16() != 0xFFFF)                          throw new InvalidDataException("Error reading input file - expected Format Tag of 0xFFFF");                        reader.BaseStream.Seek(14' SeekOrigin.Current);                        if (reader.ReadUInt16() != 6)                          throw new InvalidDataException("Error reading input file - expected cbSize of 6");                        reader.BaseStream.Seek(6' SeekOrigin.Current);                        if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "vorb")                          throw new InvalidDataException("Error reading input file - expected vorb");                        if (reader.ReadUInt32() != 42)                          throw new InvalidDataException("Error reading input file - expected vorb length of 42");                  }              }
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,VerifyHeaders,The following statement contains a magic number: using (var inputFileStream = File.Open(inputFile' FileMode.Open))              using (var reader = new EndianBinaryReader(bitConverter' inputFileStream))              {                  reader.Seek(4' SeekOrigin.Begin);                  if (reader.ReadUInt32() != reader.BaseStream.Length - 8)                      throw new InvalidDataException("The input OGG file appears to be truncated.");                    if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "WAVE")                      throw new InvalidDataException("Error reading input file - expected WAVE");                    if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "fmt ")                      throw new InvalidDataException("Error reading input file - expected fmt");                    var fmtLength = reader.ReadUInt32();                  if (fmtLength != 24 && fmtLength != 66)                      throw new InvalidDataException("Error reading input file - expected fmt length of 24 or 66");                    if (fmtLength == 24)                  {                      if (reader.ReadUInt16() != 0xFFFF)                          throw new InvalidDataException("Error reading input file - expected Format Tag of 0xFFFF");                        reader.BaseStream.Seek(14' SeekOrigin.Current);                        if (reader.ReadUInt16() != 6)                          throw new InvalidDataException("Error reading input file - expected cbSize of 6");                        reader.BaseStream.Seek(6' SeekOrigin.Current);                        if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "vorb")                          throw new InvalidDataException("Error reading input file - expected vorb");                        if (reader.ReadUInt32() != 42)                          throw new InvalidDataException("Error reading input file - expected vorb length of 42");                  }              }
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,VerifyHeaders,The following statement contains a magic number: using (var inputFileStream = File.Open(inputFile' FileMode.Open))              using (var reader = new EndianBinaryReader(bitConverter' inputFileStream))              {                  reader.Seek(4' SeekOrigin.Begin);                  if (reader.ReadUInt32() != reader.BaseStream.Length - 8)                      throw new InvalidDataException("The input OGG file appears to be truncated.");                    if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "WAVE")                      throw new InvalidDataException("Error reading input file - expected WAVE");                    if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "fmt ")                      throw new InvalidDataException("Error reading input file - expected fmt");                    var fmtLength = reader.ReadUInt32();                  if (fmtLength != 24 && fmtLength != 66)                      throw new InvalidDataException("Error reading input file - expected fmt length of 24 or 66");                    if (fmtLength == 24)                  {                      if (reader.ReadUInt16() != 0xFFFF)                          throw new InvalidDataException("Error reading input file - expected Format Tag of 0xFFFF");                        reader.BaseStream.Seek(14' SeekOrigin.Current);                        if (reader.ReadUInt16() != 6)                          throw new InvalidDataException("Error reading input file - expected cbSize of 6");                        reader.BaseStream.Seek(6' SeekOrigin.Current);                        if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "vorb")                          throw new InvalidDataException("Error reading input file - expected vorb");                        if (reader.ReadUInt32() != 42)                          throw new InvalidDataException("Error reading input file - expected vorb length of 42");                  }              }
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,VerifyHeaders,The following statement contains a magic number: using (var inputFileStream = File.Open(inputFile' FileMode.Open))              using (var reader = new EndianBinaryReader(bitConverter' inputFileStream))              {                  reader.Seek(4' SeekOrigin.Begin);                  if (reader.ReadUInt32() != reader.BaseStream.Length - 8)                      throw new InvalidDataException("The input OGG file appears to be truncated.");                    if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "WAVE")                      throw new InvalidDataException("Error reading input file - expected WAVE");                    if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "fmt ")                      throw new InvalidDataException("Error reading input file - expected fmt");                    var fmtLength = reader.ReadUInt32();                  if (fmtLength != 24 && fmtLength != 66)                      throw new InvalidDataException("Error reading input file - expected fmt length of 24 or 66");                    if (fmtLength == 24)                  {                      if (reader.ReadUInt16() != 0xFFFF)                          throw new InvalidDataException("Error reading input file - expected Format Tag of 0xFFFF");                        reader.BaseStream.Seek(14' SeekOrigin.Current);                        if (reader.ReadUInt16() != 6)                          throw new InvalidDataException("Error reading input file - expected cbSize of 6");                        reader.BaseStream.Seek(6' SeekOrigin.Current);                        if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "vorb")                          throw new InvalidDataException("Error reading input file - expected vorb");                        if (reader.ReadUInt32() != 42)                          throw new InvalidDataException("Error reading input file - expected vorb length of 42");                  }              }
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,VerifyHeaders,The following statement contains a magic number: using (var inputFileStream = File.Open(inputFile' FileMode.Open))              using (var reader = new EndianBinaryReader(bitConverter' inputFileStream))              {                  reader.Seek(4' SeekOrigin.Begin);                  if (reader.ReadUInt32() != reader.BaseStream.Length - 8)                      throw new InvalidDataException("The input OGG file appears to be truncated.");                    if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "WAVE")                      throw new InvalidDataException("Error reading input file - expected WAVE");                    if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "fmt ")                      throw new InvalidDataException("Error reading input file - expected fmt");                    var fmtLength = reader.ReadUInt32();                  if (fmtLength != 24 && fmtLength != 66)                      throw new InvalidDataException("Error reading input file - expected fmt length of 24 or 66");                    if (fmtLength == 24)                  {                      if (reader.ReadUInt16() != 0xFFFF)                          throw new InvalidDataException("Error reading input file - expected Format Tag of 0xFFFF");                        reader.BaseStream.Seek(14' SeekOrigin.Current);                        if (reader.ReadUInt16() != 6)                          throw new InvalidDataException("Error reading input file - expected cbSize of 6");                        reader.BaseStream.Seek(6' SeekOrigin.Current);                        if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "vorb")                          throw new InvalidDataException("Error reading input file - expected vorb");                        if (reader.ReadUInt32() != 42)                          throw new InvalidDataException("Error reading input file - expected vorb length of 42");                  }              }
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,VerifyHeaders,The following statement contains a magic number: using (var inputFileStream = File.Open(inputFile' FileMode.Open))              using (var reader = new EndianBinaryReader(bitConverter' inputFileStream))              {                  reader.Seek(4' SeekOrigin.Begin);                  if (reader.ReadUInt32() != reader.BaseStream.Length - 8)                      throw new InvalidDataException("The input OGG file appears to be truncated.");                    if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "WAVE")                      throw new InvalidDataException("Error reading input file - expected WAVE");                    if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "fmt ")                      throw new InvalidDataException("Error reading input file - expected fmt");                    var fmtLength = reader.ReadUInt32();                  if (fmtLength != 24 && fmtLength != 66)                      throw new InvalidDataException("Error reading input file - expected fmt length of 24 or 66");                    if (fmtLength == 24)                  {                      if (reader.ReadUInt16() != 0xFFFF)                          throw new InvalidDataException("Error reading input file - expected Format Tag of 0xFFFF");                        reader.BaseStream.Seek(14' SeekOrigin.Current);                        if (reader.ReadUInt16() != 6)                          throw new InvalidDataException("Error reading input file - expected cbSize of 6");                        reader.BaseStream.Seek(6' SeekOrigin.Current);                        if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "vorb")                          throw new InvalidDataException("Error reading input file - expected vorb");                        if (reader.ReadUInt32() != 42)                          throw new InvalidDataException("Error reading input file - expected vorb length of 42");                  }              }
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,VerifyHeaders,The following statement contains a magic number: using (var inputFileStream = File.Open(inputFile' FileMode.Open))              using (var reader = new EndianBinaryReader(bitConverter' inputFileStream))              {                  reader.Seek(4' SeekOrigin.Begin);                  if (reader.ReadUInt32() != reader.BaseStream.Length - 8)                      throw new InvalidDataException("The input OGG file appears to be truncated.");                    if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "WAVE")                      throw new InvalidDataException("Error reading input file - expected WAVE");                    if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "fmt ")                      throw new InvalidDataException("Error reading input file - expected fmt");                    var fmtLength = reader.ReadUInt32();                  if (fmtLength != 24 && fmtLength != 66)                      throw new InvalidDataException("Error reading input file - expected fmt length of 24 or 66");                    if (fmtLength == 24)                  {                      if (reader.ReadUInt16() != 0xFFFF)                          throw new InvalidDataException("Error reading input file - expected Format Tag of 0xFFFF");                        reader.BaseStream.Seek(14' SeekOrigin.Current);                        if (reader.ReadUInt16() != 6)                          throw new InvalidDataException("Error reading input file - expected cbSize of 6");                        reader.BaseStream.Seek(6' SeekOrigin.Current);                        if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "vorb")                          throw new InvalidDataException("Error reading input file - expected vorb");                        if (reader.ReadUInt32() != 42)                          throw new InvalidDataException("Error reading input file - expected vorb length of 42");                  }              }
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,VerifyHeaders,The following statement contains a magic number: using (var inputFileStream = File.Open(inputFile' FileMode.Open))              using (var reader = new EndianBinaryReader(bitConverter' inputFileStream))              {                  reader.Seek(4' SeekOrigin.Begin);                  if (reader.ReadUInt32() != reader.BaseStream.Length - 8)                      throw new InvalidDataException("The input OGG file appears to be truncated.");                    if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "WAVE")                      throw new InvalidDataException("Error reading input file - expected WAVE");                    if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "fmt ")                      throw new InvalidDataException("Error reading input file - expected fmt");                    var fmtLength = reader.ReadUInt32();                  if (fmtLength != 24 && fmtLength != 66)                      throw new InvalidDataException("Error reading input file - expected fmt length of 24 or 66");                    if (fmtLength == 24)                  {                      if (reader.ReadUInt16() != 0xFFFF)                          throw new InvalidDataException("Error reading input file - expected Format Tag of 0xFFFF");                        reader.BaseStream.Seek(14' SeekOrigin.Current);                        if (reader.ReadUInt16() != 6)                          throw new InvalidDataException("Error reading input file - expected cbSize of 6");                        reader.BaseStream.Seek(6' SeekOrigin.Current);                        if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "vorb")                          throw new InvalidDataException("Error reading input file - expected vorb");                        if (reader.ReadUInt32() != 42)                          throw new InvalidDataException("Error reading input file - expected vorb length of 42");                  }              }
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,VerifyHeaders,The following statement contains a magic number: using (var inputFileStream = File.Open(inputFile' FileMode.Open))              using (var reader = new EndianBinaryReader(bitConverter' inputFileStream))              {                  reader.Seek(4' SeekOrigin.Begin);                  if (reader.ReadUInt32() != reader.BaseStream.Length - 8)                      throw new InvalidDataException("The input OGG file appears to be truncated.");                    if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "WAVE")                      throw new InvalidDataException("Error reading input file - expected WAVE");                    if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "fmt ")                      throw new InvalidDataException("Error reading input file - expected fmt");                    var fmtLength = reader.ReadUInt32();                  if (fmtLength != 24 && fmtLength != 66)                      throw new InvalidDataException("Error reading input file - expected fmt length of 24 or 66");                    if (fmtLength == 24)                  {                      if (reader.ReadUInt16() != 0xFFFF)                          throw new InvalidDataException("Error reading input file - expected Format Tag of 0xFFFF");                        reader.BaseStream.Seek(14' SeekOrigin.Current);                        if (reader.ReadUInt16() != 6)                          throw new InvalidDataException("Error reading input file - expected cbSize of 6");                        reader.BaseStream.Seek(6' SeekOrigin.Current);                        if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "vorb")                          throw new InvalidDataException("Error reading input file - expected vorb");                        if (reader.ReadUInt32() != 42)                          throw new InvalidDataException("Error reading input file - expected vorb length of 42");                  }              }
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,GetAudioPlatform,The following statement contains a magic number: using (var MS = new MemoryStream())              using (var reader = new BinaryReader(MS))              {                  input.Position = 0; input.CopyTo(MS);                  MS.Position = 0; input.Position = 0;                  var fileID = new string(reader.ReadChars(4));                  if (fileID == "RIFF")//LE                      return new Platform(GamePlatform.Pc' GameVersion.None);                  if (fileID == "RIFX")//BE                      return new Platform(GamePlatform.XBox360' GameVersion.None);              }
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,NeedsConversion,The following statement contains a magic number: using (var MS = new MemoryStream())              using (var reader = new EndianBinaryReader(bitConverter' MS))              {                  input.Position = 0; input.CopyTo(MS);                  MS.Position = 0; input.Position = 0;                  reader.Seek(16' SeekOrigin.Begin);                  if (reader.ReadUInt32() == 24)//fmtSize                      return true;              }
Magic Number,RocksmithToolkitLib.Ogg,OggFile,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Ogg\OggFile.cs,NeedsConversion,The following statement contains a magic number: using (var MS = new MemoryStream())              using (var reader = new EndianBinaryReader(bitConverter' MS))              {                  input.Position = 0; input.CopyTo(MS);                  MS.Position = 0; input.Position = 0;                  reader.Seek(16' SeekOrigin.Begin);                  if (reader.ReadUInt32() == 24)//fmtSize                      return true;              }
Magic Number,RocksmithToolkitLib.PsarcLoader,Entry,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\Entry.cs,UpdateNameMD5,The following statement contains a magic number: MD5 = (Name == String.Empty) ? new byte[16] : new MD5CryptoServiceProvider().ComputeHash(Encoding.ASCII.GetBytes(Name));
Magic Number,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,DeflateEntries,The following statement contains a magic number: foreach (Entry entry in _toc)              {                  var zList = new List<Tuple<byte[]' int>>();                  entry.zIndexBegin = (uint)zLengths.Count;                  entry.Data.Seek(0' SeekOrigin.Begin);                    while (entry.Data.Position < entry.Data.Length)                  {                      var array_i = new byte[blockSize];                      var array_o = new byte[blockSize * 2];                      var memoryStream = new MemoryStream(array_o);                        int plain_len = entry.Data.Read(array_i' 0' array_i.Length);                      int packed_len = (int)RijndaelEncryptor.Zip(array_i' memoryStream' plain_len' false);                        if (packed_len >= plain_len)                      {                          // If packed data "worse" than plain (i.e. already packed) z = 0                          zList.Add(new Tuple<byte[]' int>(array_i' plain_len));                      }                      else                      {                          // If packed data is good                          if (packed_len < (blockSize - 1))                          {                              // If packed data fits maximum packed block size z = packed_len                              zList.Add(new Tuple<byte[]' int>(array_o' packed_len));                          }                          else                          {                              // Write plain. z = 0                              zList.Add(new Tuple<byte[]' int>(array_i' plain_len));                          }                      }                  }                    int zSisesSum = 0;                  foreach (var zSize in zList)                  {                      zSisesSum += zSize.Item2;                      zLengths.Add((uint)zSize.Item2);                  }                    var array3 = new byte[zSisesSum];                  var memoryStream2 = new MemoryStream(array3);                  foreach (var entryblock in zList)                  {                      memoryStream2.Write(entryblock.Item1' 0' entryblock.Item2);                  }                    entryDeflatedData.Add(entry' array3);                  //   progress += step;                  //    GlobalExtension.UpdateProgress.Value = (int)progress;                  Console.WriteLine("Deflating: " + ndx++);              }
Magic Number,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,ParseTOC,The following statement contains a magic number: for (int i = 0' tocFiles = (int)_header.NumFiles; i < tocFiles; i++)              {                  _toc.Add(new Entry { Id = i' MD5 = _reader.ReadBytes(16)' zIndexBegin = _reader.ReadUInt32()' Length = _reader.ReadUInt40()' Offset = _reader.ReadUInt40() }); /* FIXME: general idea was to implement parallel inflate route' still need to re-think this.                  if (i == 0) continue;                  if (i == tocFiles - 1)                      _toc[i].zDatalen = (ulong)_reader.BaseStream.Length - _toc[i].Offset; //HACK: fails if psarc is truncated.                  _toc[i-1].zDatalen = _toc[i].Offset - _toc[i-1].Offset; */              }
Magic Number,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Read,The following statement contains a magic number: if (_header.MagicNumber == 1347633490U) //PSAR (BE)              {                  //Parse Header                  _header.VersionNumber = _reader.ReadUInt32();                  _header.CompressionMethod = _reader.ReadUInt32();                  _header.TotalTOCSize = _reader.ReadUInt32();                  _header.TOCEntrySize = _reader.ReadUInt32();                  _header.NumFiles = _reader.ReadUInt32();                  _header.BlockSizeAlloc = _reader.ReadUInt32();                  _header.ArchiveFlags = _reader.ReadUInt32();                  //Read TOC                  int tocSize = (int)(_header.TotalTOCSize - 32U);                  if (_header.ArchiveFlags == 4) //TOC_ENCRYPTED                  {                      // Decrypt TOC                      var tocStream = new MemoryStream();                      using (var decStream = new MemoryStream())                      {                          RijndaelEncryptor.DecryptPSARC(psarc' decStream' _header.TotalTOCSize);                            int bytesRead;                          int decSize = 0;                          var buffer = new byte[_header.BlockSizeAlloc];                          while ((bytesRead = decStream.Read(buffer' 0' buffer.Length)) > 0)                          {                              decSize += bytesRead;                              if (decSize > tocSize)                                  bytesRead = tocSize - (decSize - bytesRead);                              tocStream.Write(buffer' 0' bytesRead);                          }                      }                      tocStream.Position = 0;                      _reader = new BigEndianBinaryReader(tocStream);                  }                  ParseTOC();                  //Parse zBlocksSizeList                  int tocChunkSize = (int)(_header.NumFiles * _header.TOCEntrySize); //(int)_reader.BaseStream.Position //don't alter this with. causes issues                  int zNum = (tocSize - tocChunkSize) / bNum;                  var zLengths = new uint[zNum];                  for (int i = 0; i < zNum; i++)                  {                      switch (bNum)                      {                          case 2: //64KB                              zLengths[i] = _reader.ReadUInt16();                              break;                          case 3: //16MB                              zLengths[i] = _reader.ReadUInt24();                              break;                          case 4: //4GB                              zLengths[i] = _reader.ReadUInt32();                              break;                      }                  }                  _zBlocksSizeList = zLengths; //TODO: validate                    _reader.BaseStream.Flush(); //Free tocStream resources                  _reader = new BigEndianBinaryReader(psarc);                    // Validate psarc size                  // if (psarc.Length < RequiredPsarcSize())                  // throw new InvalidDataException("Truncated psarc.");                  // try to unpack corrupt CDLC for now                    switch (_header.CompressionMethod)                  {                      case 2053925218: //zlib (BE)                          ReadManifest();                          psarc.Seek(_header.TotalTOCSize' SeekOrigin.Begin);                          if (!lazy)                          {                              // Decompress Data                              InflateEntries();                          }                          break;                      case 1819962721: //lzma (BE)                          throw new NotImplementedException("LZMA compression not supported.");                      default:                          throw new InvalidDataException("Unknown compression.");                  }              }
Magic Number,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Read,The following statement contains a magic number: if (_header.MagicNumber == 1347633490U) //PSAR (BE)              {                  //Parse Header                  _header.VersionNumber = _reader.ReadUInt32();                  _header.CompressionMethod = _reader.ReadUInt32();                  _header.TotalTOCSize = _reader.ReadUInt32();                  _header.TOCEntrySize = _reader.ReadUInt32();                  _header.NumFiles = _reader.ReadUInt32();                  _header.BlockSizeAlloc = _reader.ReadUInt32();                  _header.ArchiveFlags = _reader.ReadUInt32();                  //Read TOC                  int tocSize = (int)(_header.TotalTOCSize - 32U);                  if (_header.ArchiveFlags == 4) //TOC_ENCRYPTED                  {                      // Decrypt TOC                      var tocStream = new MemoryStream();                      using (var decStream = new MemoryStream())                      {                          RijndaelEncryptor.DecryptPSARC(psarc' decStream' _header.TotalTOCSize);                            int bytesRead;                          int decSize = 0;                          var buffer = new byte[_header.BlockSizeAlloc];                          while ((bytesRead = decStream.Read(buffer' 0' buffer.Length)) > 0)                          {                              decSize += bytesRead;                              if (decSize > tocSize)                                  bytesRead = tocSize - (decSize - bytesRead);                              tocStream.Write(buffer' 0' bytesRead);                          }                      }                      tocStream.Position = 0;                      _reader = new BigEndianBinaryReader(tocStream);                  }                  ParseTOC();                  //Parse zBlocksSizeList                  int tocChunkSize = (int)(_header.NumFiles * _header.TOCEntrySize); //(int)_reader.BaseStream.Position //don't alter this with. causes issues                  int zNum = (tocSize - tocChunkSize) / bNum;                  var zLengths = new uint[zNum];                  for (int i = 0; i < zNum; i++)                  {                      switch (bNum)                      {                          case 2: //64KB                              zLengths[i] = _reader.ReadUInt16();                              break;                          case 3: //16MB                              zLengths[i] = _reader.ReadUInt24();                              break;                          case 4: //4GB                              zLengths[i] = _reader.ReadUInt32();                              break;                      }                  }                  _zBlocksSizeList = zLengths; //TODO: validate                    _reader.BaseStream.Flush(); //Free tocStream resources                  _reader = new BigEndianBinaryReader(psarc);                    // Validate psarc size                  // if (psarc.Length < RequiredPsarcSize())                  // throw new InvalidDataException("Truncated psarc.");                  // try to unpack corrupt CDLC for now                    switch (_header.CompressionMethod)                  {                      case 2053925218: //zlib (BE)                          ReadManifest();                          psarc.Seek(_header.TotalTOCSize' SeekOrigin.Begin);                          if (!lazy)                          {                              // Decompress Data                              InflateEntries();                          }                          break;                      case 1819962721: //lzma (BE)                          throw new NotImplementedException("LZMA compression not supported.");                      default:                          throw new InvalidDataException("Unknown compression.");                  }              }
Magic Number,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Read,The following statement contains a magic number: if (_header.MagicNumber == 1347633490U) //PSAR (BE)              {                  //Parse Header                  _header.VersionNumber = _reader.ReadUInt32();                  _header.CompressionMethod = _reader.ReadUInt32();                  _header.TotalTOCSize = _reader.ReadUInt32();                  _header.TOCEntrySize = _reader.ReadUInt32();                  _header.NumFiles = _reader.ReadUInt32();                  _header.BlockSizeAlloc = _reader.ReadUInt32();                  _header.ArchiveFlags = _reader.ReadUInt32();                  //Read TOC                  int tocSize = (int)(_header.TotalTOCSize - 32U);                  if (_header.ArchiveFlags == 4) //TOC_ENCRYPTED                  {                      // Decrypt TOC                      var tocStream = new MemoryStream();                      using (var decStream = new MemoryStream())                      {                          RijndaelEncryptor.DecryptPSARC(psarc' decStream' _header.TotalTOCSize);                            int bytesRead;                          int decSize = 0;                          var buffer = new byte[_header.BlockSizeAlloc];                          while ((bytesRead = decStream.Read(buffer' 0' buffer.Length)) > 0)                          {                              decSize += bytesRead;                              if (decSize > tocSize)                                  bytesRead = tocSize - (decSize - bytesRead);                              tocStream.Write(buffer' 0' bytesRead);                          }                      }                      tocStream.Position = 0;                      _reader = new BigEndianBinaryReader(tocStream);                  }                  ParseTOC();                  //Parse zBlocksSizeList                  int tocChunkSize = (int)(_header.NumFiles * _header.TOCEntrySize); //(int)_reader.BaseStream.Position //don't alter this with. causes issues                  int zNum = (tocSize - tocChunkSize) / bNum;                  var zLengths = new uint[zNum];                  for (int i = 0; i < zNum; i++)                  {                      switch (bNum)                      {                          case 2: //64KB                              zLengths[i] = _reader.ReadUInt16();                              break;                          case 3: //16MB                              zLengths[i] = _reader.ReadUInt24();                              break;                          case 4: //4GB                              zLengths[i] = _reader.ReadUInt32();                              break;                      }                  }                  _zBlocksSizeList = zLengths; //TODO: validate                    _reader.BaseStream.Flush(); //Free tocStream resources                  _reader = new BigEndianBinaryReader(psarc);                    // Validate psarc size                  // if (psarc.Length < RequiredPsarcSize())                  // throw new InvalidDataException("Truncated psarc.");                  // try to unpack corrupt CDLC for now                    switch (_header.CompressionMethod)                  {                      case 2053925218: //zlib (BE)                          ReadManifest();                          psarc.Seek(_header.TotalTOCSize' SeekOrigin.Begin);                          if (!lazy)                          {                              // Decompress Data                              InflateEntries();                          }                          break;                      case 1819962721: //lzma (BE)                          throw new NotImplementedException("LZMA compression not supported.");                      default:                          throw new InvalidDataException("Unknown compression.");                  }              }
Magic Number,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Read,The following statement contains a magic number: if (_header.MagicNumber == 1347633490U) //PSAR (BE)              {                  //Parse Header                  _header.VersionNumber = _reader.ReadUInt32();                  _header.CompressionMethod = _reader.ReadUInt32();                  _header.TotalTOCSize = _reader.ReadUInt32();                  _header.TOCEntrySize = _reader.ReadUInt32();                  _header.NumFiles = _reader.ReadUInt32();                  _header.BlockSizeAlloc = _reader.ReadUInt32();                  _header.ArchiveFlags = _reader.ReadUInt32();                  //Read TOC                  int tocSize = (int)(_header.TotalTOCSize - 32U);                  if (_header.ArchiveFlags == 4) //TOC_ENCRYPTED                  {                      // Decrypt TOC                      var tocStream = new MemoryStream();                      using (var decStream = new MemoryStream())                      {                          RijndaelEncryptor.DecryptPSARC(psarc' decStream' _header.TotalTOCSize);                            int bytesRead;                          int decSize = 0;                          var buffer = new byte[_header.BlockSizeAlloc];                          while ((bytesRead = decStream.Read(buffer' 0' buffer.Length)) > 0)                          {                              decSize += bytesRead;                              if (decSize > tocSize)                                  bytesRead = tocSize - (decSize - bytesRead);                              tocStream.Write(buffer' 0' bytesRead);                          }                      }                      tocStream.Position = 0;                      _reader = new BigEndianBinaryReader(tocStream);                  }                  ParseTOC();                  //Parse zBlocksSizeList                  int tocChunkSize = (int)(_header.NumFiles * _header.TOCEntrySize); //(int)_reader.BaseStream.Position //don't alter this with. causes issues                  int zNum = (tocSize - tocChunkSize) / bNum;                  var zLengths = new uint[zNum];                  for (int i = 0; i < zNum; i++)                  {                      switch (bNum)                      {                          case 2: //64KB                              zLengths[i] = _reader.ReadUInt16();                              break;                          case 3: //16MB                              zLengths[i] = _reader.ReadUInt24();                              break;                          case 4: //4GB                              zLengths[i] = _reader.ReadUInt32();                              break;                      }                  }                  _zBlocksSizeList = zLengths; //TODO: validate                    _reader.BaseStream.Flush(); //Free tocStream resources                  _reader = new BigEndianBinaryReader(psarc);                    // Validate psarc size                  // if (psarc.Length < RequiredPsarcSize())                  // throw new InvalidDataException("Truncated psarc.");                  // try to unpack corrupt CDLC for now                    switch (_header.CompressionMethod)                  {                      case 2053925218: //zlib (BE)                          ReadManifest();                          psarc.Seek(_header.TotalTOCSize' SeekOrigin.Begin);                          if (!lazy)                          {                              // Decompress Data                              InflateEntries();                          }                          break;                      case 1819962721: //lzma (BE)                          throw new NotImplementedException("LZMA compression not supported.");                      default:                          throw new InvalidDataException("Unknown compression.");                  }              }
Magic Number,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Read,The following statement contains a magic number: if (_header.MagicNumber == 1347633490U) //PSAR (BE)              {                  //Parse Header                  _header.VersionNumber = _reader.ReadUInt32();                  _header.CompressionMethod = _reader.ReadUInt32();                  _header.TotalTOCSize = _reader.ReadUInt32();                  _header.TOCEntrySize = _reader.ReadUInt32();                  _header.NumFiles = _reader.ReadUInt32();                  _header.BlockSizeAlloc = _reader.ReadUInt32();                  _header.ArchiveFlags = _reader.ReadUInt32();                  //Read TOC                  int tocSize = (int)(_header.TotalTOCSize - 32U);                  if (_header.ArchiveFlags == 4) //TOC_ENCRYPTED                  {                      // Decrypt TOC                      var tocStream = new MemoryStream();                      using (var decStream = new MemoryStream())                      {                          RijndaelEncryptor.DecryptPSARC(psarc' decStream' _header.TotalTOCSize);                            int bytesRead;                          int decSize = 0;                          var buffer = new byte[_header.BlockSizeAlloc];                          while ((bytesRead = decStream.Read(buffer' 0' buffer.Length)) > 0)                          {                              decSize += bytesRead;                              if (decSize > tocSize)                                  bytesRead = tocSize - (decSize - bytesRead);                              tocStream.Write(buffer' 0' bytesRead);                          }                      }                      tocStream.Position = 0;                      _reader = new BigEndianBinaryReader(tocStream);                  }                  ParseTOC();                  //Parse zBlocksSizeList                  int tocChunkSize = (int)(_header.NumFiles * _header.TOCEntrySize); //(int)_reader.BaseStream.Position //don't alter this with. causes issues                  int zNum = (tocSize - tocChunkSize) / bNum;                  var zLengths = new uint[zNum];                  for (int i = 0; i < zNum; i++)                  {                      switch (bNum)                      {                          case 2: //64KB                              zLengths[i] = _reader.ReadUInt16();                              break;                          case 3: //16MB                              zLengths[i] = _reader.ReadUInt24();                              break;                          case 4: //4GB                              zLengths[i] = _reader.ReadUInt32();                              break;                      }                  }                  _zBlocksSizeList = zLengths; //TODO: validate                    _reader.BaseStream.Flush(); //Free tocStream resources                  _reader = new BigEndianBinaryReader(psarc);                    // Validate psarc size                  // if (psarc.Length < RequiredPsarcSize())                  // throw new InvalidDataException("Truncated psarc.");                  // try to unpack corrupt CDLC for now                    switch (_header.CompressionMethod)                  {                      case 2053925218: //zlib (BE)                          ReadManifest();                          psarc.Seek(_header.TotalTOCSize' SeekOrigin.Begin);                          if (!lazy)                          {                              // Decompress Data                              InflateEntries();                          }                          break;                      case 1819962721: //lzma (BE)                          throw new NotImplementedException("LZMA compression not supported.");                      default:                          throw new InvalidDataException("Unknown compression.");                  }              }
Magic Number,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Read,The following statement contains a magic number: if (_header.MagicNumber == 1347633490U) //PSAR (BE)              {                  //Parse Header                  _header.VersionNumber = _reader.ReadUInt32();                  _header.CompressionMethod = _reader.ReadUInt32();                  _header.TotalTOCSize = _reader.ReadUInt32();                  _header.TOCEntrySize = _reader.ReadUInt32();                  _header.NumFiles = _reader.ReadUInt32();                  _header.BlockSizeAlloc = _reader.ReadUInt32();                  _header.ArchiveFlags = _reader.ReadUInt32();                  //Read TOC                  int tocSize = (int)(_header.TotalTOCSize - 32U);                  if (_header.ArchiveFlags == 4) //TOC_ENCRYPTED                  {                      // Decrypt TOC                      var tocStream = new MemoryStream();                      using (var decStream = new MemoryStream())                      {                          RijndaelEncryptor.DecryptPSARC(psarc' decStream' _header.TotalTOCSize);                            int bytesRead;                          int decSize = 0;                          var buffer = new byte[_header.BlockSizeAlloc];                          while ((bytesRead = decStream.Read(buffer' 0' buffer.Length)) > 0)                          {                              decSize += bytesRead;                              if (decSize > tocSize)                                  bytesRead = tocSize - (decSize - bytesRead);                              tocStream.Write(buffer' 0' bytesRead);                          }                      }                      tocStream.Position = 0;                      _reader = new BigEndianBinaryReader(tocStream);                  }                  ParseTOC();                  //Parse zBlocksSizeList                  int tocChunkSize = (int)(_header.NumFiles * _header.TOCEntrySize); //(int)_reader.BaseStream.Position //don't alter this with. causes issues                  int zNum = (tocSize - tocChunkSize) / bNum;                  var zLengths = new uint[zNum];                  for (int i = 0; i < zNum; i++)                  {                      switch (bNum)                      {                          case 2: //64KB                              zLengths[i] = _reader.ReadUInt16();                              break;                          case 3: //16MB                              zLengths[i] = _reader.ReadUInt24();                              break;                          case 4: //4GB                              zLengths[i] = _reader.ReadUInt32();                              break;                      }                  }                  _zBlocksSizeList = zLengths; //TODO: validate                    _reader.BaseStream.Flush(); //Free tocStream resources                  _reader = new BigEndianBinaryReader(psarc);                    // Validate psarc size                  // if (psarc.Length < RequiredPsarcSize())                  // throw new InvalidDataException("Truncated psarc.");                  // try to unpack corrupt CDLC for now                    switch (_header.CompressionMethod)                  {                      case 2053925218: //zlib (BE)                          ReadManifest();                          psarc.Seek(_header.TotalTOCSize' SeekOrigin.Begin);                          if (!lazy)                          {                              // Decompress Data                              InflateEntries();                          }                          break;                      case 1819962721: //lzma (BE)                          throw new NotImplementedException("LZMA compression not supported.");                      default:                          throw new InvalidDataException("Unknown compression.");                  }              }
Magic Number,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Write,The following statement contains a magic number: _header.TotalTOCSize = (uint)(32 + _toc.Count * _header.TOCEntrySize + zLengths.Count * bNum);
Magic Number,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Write,The following statement contains a magic number: foreach (uint zLen in zLengths)              {                  switch (bNum)                  {                      case 2:                          _writer.Write((ushort)zLen);                          break;                      case 3:                          _writer.WriteUInt24(zLen);                          break;                      case 4:                          _writer.Write(zLen);                          break;                  }              }
Magic Number,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Write,The following statement contains a magic number: foreach (uint zLen in zLengths)              {                  switch (bNum)                  {                      case 2:                          _writer.Write((ushort)zLen);                          break;                      case 3:                          _writer.WriteUInt24(zLen);                          break;                      case 4:                          _writer.Write(zLen);                          break;                  }              }
Magic Number,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Write,The following statement contains a magic number: foreach (uint zLen in zLengths)              {                  switch (bNum)                  {                      case 2:                          _writer.Write((ushort)zLen);                          break;                      case 3:                          _writer.WriteUInt24(zLen);                          break;                      case 4:                          _writer.Write(zLen);                          break;                  }              }
Magic Number,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Write,The following statement contains a magic number: var step = Math.Round(1.0 / (this.TOC.Count + 2) * 100' 3);
Magic Number,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Write,The following statement contains a magic number: var step = Math.Round(1.0 / (this.TOC.Count + 2) * 100' 3);
Magic Number,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Write,The following statement contains a magic number: var step = Math.Round(1.0 / (this.TOC.Count + 2) * 100' 3);
Magic Number,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Write,The following statement contains a magic number: if (encrypt) // Encrypt TOC              {                  using (var outputStream = new MemoryStreamExtension())                  {                      var encStream = new MemoryStreamExtension();                      inputStream.Position = 32L;                      RijndaelEncryptor.EncryptPSARC(inputStream' outputStream' _header.TotalTOCSize);                      inputStream.Position = 0L;                        // quick copy header from input stream                      var buffer = new byte[32];                      encStream.Write(buffer' 0' inputStream.Read(buffer' 0' buffer.Length));                      encStream.Position = 32; //sainty check ofc                      inputStream.Flush();                        int tocSize = (int)_header.TotalTOCSize - 32;                      int decSize = 0;                      buffer = new byte[1024 * 16]; // more effecient use of memory                        ndx = 0; // for debuging                      step = Math.Round(1.0 / ((tocSize / buffer.Length) + 2) * 100' 3);                      progress = 0;                      //  GlobalExtension.ShowProgress("Writing Encrypted Data ...");                        int bytesRead;                      while ((bytesRead = outputStream.Read(buffer' 0' buffer.Length)) > 0)                      {                          decSize += bytesRead;                          if (decSize > tocSize)                              bytesRead = tocSize - (decSize - bytesRead);                            encStream.Write(buffer' 0' bytesRead);                            progress += step;                          //     GlobalExtension.UpdateProgress.Value = (int)progress;                          Console.WriteLine("Encrypted: " + ndx++);                      }                        inputStream.Position = 0;                      encStream.Position = 0;                      encStream.CopyTo(inputStream' (int)_header.BlockSizeAlloc);                  }              }
Magic Number,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Write,The following statement contains a magic number: if (encrypt) // Encrypt TOC              {                  using (var outputStream = new MemoryStreamExtension())                  {                      var encStream = new MemoryStreamExtension();                      inputStream.Position = 32L;                      RijndaelEncryptor.EncryptPSARC(inputStream' outputStream' _header.TotalTOCSize);                      inputStream.Position = 0L;                        // quick copy header from input stream                      var buffer = new byte[32];                      encStream.Write(buffer' 0' inputStream.Read(buffer' 0' buffer.Length));                      encStream.Position = 32; //sainty check ofc                      inputStream.Flush();                        int tocSize = (int)_header.TotalTOCSize - 32;                      int decSize = 0;                      buffer = new byte[1024 * 16]; // more effecient use of memory                        ndx = 0; // for debuging                      step = Math.Round(1.0 / ((tocSize / buffer.Length) + 2) * 100' 3);                      progress = 0;                      //  GlobalExtension.ShowProgress("Writing Encrypted Data ...");                        int bytesRead;                      while ((bytesRead = outputStream.Read(buffer' 0' buffer.Length)) > 0)                      {                          decSize += bytesRead;                          if (decSize > tocSize)                              bytesRead = tocSize - (decSize - bytesRead);                            encStream.Write(buffer' 0' bytesRead);                            progress += step;                          //     GlobalExtension.UpdateProgress.Value = (int)progress;                          Console.WriteLine("Encrypted: " + ndx++);                      }                        inputStream.Position = 0;                      encStream.Position = 0;                      encStream.CopyTo(inputStream' (int)_header.BlockSizeAlloc);                  }              }
Magic Number,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Write,The following statement contains a magic number: if (encrypt) // Encrypt TOC              {                  using (var outputStream = new MemoryStreamExtension())                  {                      var encStream = new MemoryStreamExtension();                      inputStream.Position = 32L;                      RijndaelEncryptor.EncryptPSARC(inputStream' outputStream' _header.TotalTOCSize);                      inputStream.Position = 0L;                        // quick copy header from input stream                      var buffer = new byte[32];                      encStream.Write(buffer' 0' inputStream.Read(buffer' 0' buffer.Length));                      encStream.Position = 32; //sainty check ofc                      inputStream.Flush();                        int tocSize = (int)_header.TotalTOCSize - 32;                      int decSize = 0;                      buffer = new byte[1024 * 16]; // more effecient use of memory                        ndx = 0; // for debuging                      step = Math.Round(1.0 / ((tocSize / buffer.Length) + 2) * 100' 3);                      progress = 0;                      //  GlobalExtension.ShowProgress("Writing Encrypted Data ...");                        int bytesRead;                      while ((bytesRead = outputStream.Read(buffer' 0' buffer.Length)) > 0)                      {                          decSize += bytesRead;                          if (decSize > tocSize)                              bytesRead = tocSize - (decSize - bytesRead);                            encStream.Write(buffer' 0' bytesRead);                            progress += step;                          //     GlobalExtension.UpdateProgress.Value = (int)progress;                          Console.WriteLine("Encrypted: " + ndx++);                      }                        inputStream.Position = 0;                      encStream.Position = 0;                      encStream.CopyTo(inputStream' (int)_header.BlockSizeAlloc);                  }              }
Magic Number,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Write,The following statement contains a magic number: if (encrypt) // Encrypt TOC              {                  using (var outputStream = new MemoryStreamExtension())                  {                      var encStream = new MemoryStreamExtension();                      inputStream.Position = 32L;                      RijndaelEncryptor.EncryptPSARC(inputStream' outputStream' _header.TotalTOCSize);                      inputStream.Position = 0L;                        // quick copy header from input stream                      var buffer = new byte[32];                      encStream.Write(buffer' 0' inputStream.Read(buffer' 0' buffer.Length));                      encStream.Position = 32; //sainty check ofc                      inputStream.Flush();                        int tocSize = (int)_header.TotalTOCSize - 32;                      int decSize = 0;                      buffer = new byte[1024 * 16]; // more effecient use of memory                        ndx = 0; // for debuging                      step = Math.Round(1.0 / ((tocSize / buffer.Length) + 2) * 100' 3);                      progress = 0;                      //  GlobalExtension.ShowProgress("Writing Encrypted Data ...");                        int bytesRead;                      while ((bytesRead = outputStream.Read(buffer' 0' buffer.Length)) > 0)                      {                          decSize += bytesRead;                          if (decSize > tocSize)                              bytesRead = tocSize - (decSize - bytesRead);                            encStream.Write(buffer' 0' bytesRead);                            progress += step;                          //     GlobalExtension.UpdateProgress.Value = (int)progress;                          Console.WriteLine("Encrypted: " + ndx++);                      }                        inputStream.Position = 0;                      encStream.Position = 0;                      encStream.CopyTo(inputStream' (int)_header.BlockSizeAlloc);                  }              }
Magic Number,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Write,The following statement contains a magic number: if (encrypt) // Encrypt TOC              {                  using (var outputStream = new MemoryStreamExtension())                  {                      var encStream = new MemoryStreamExtension();                      inputStream.Position = 32L;                      RijndaelEncryptor.EncryptPSARC(inputStream' outputStream' _header.TotalTOCSize);                      inputStream.Position = 0L;                        // quick copy header from input stream                      var buffer = new byte[32];                      encStream.Write(buffer' 0' inputStream.Read(buffer' 0' buffer.Length));                      encStream.Position = 32; //sainty check ofc                      inputStream.Flush();                        int tocSize = (int)_header.TotalTOCSize - 32;                      int decSize = 0;                      buffer = new byte[1024 * 16]; // more effecient use of memory                        ndx = 0; // for debuging                      step = Math.Round(1.0 / ((tocSize / buffer.Length) + 2) * 100' 3);                      progress = 0;                      //  GlobalExtension.ShowProgress("Writing Encrypted Data ...");                        int bytesRead;                      while ((bytesRead = outputStream.Read(buffer' 0' buffer.Length)) > 0)                      {                          decSize += bytesRead;                          if (decSize > tocSize)                              bytesRead = tocSize - (decSize - bytesRead);                            encStream.Write(buffer' 0' bytesRead);                            progress += step;                          //     GlobalExtension.UpdateProgress.Value = (int)progress;                          Console.WriteLine("Encrypted: " + ndx++);                      }                        inputStream.Position = 0;                      encStream.Position = 0;                      encStream.CopyTo(inputStream' (int)_header.BlockSizeAlloc);                  }              }
Magic Number,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Write,The following statement contains a magic number: if (encrypt) // Encrypt TOC              {                  using (var outputStream = new MemoryStreamExtension())                  {                      var encStream = new MemoryStreamExtension();                      inputStream.Position = 32L;                      RijndaelEncryptor.EncryptPSARC(inputStream' outputStream' _header.TotalTOCSize);                      inputStream.Position = 0L;                        // quick copy header from input stream                      var buffer = new byte[32];                      encStream.Write(buffer' 0' inputStream.Read(buffer' 0' buffer.Length));                      encStream.Position = 32; //sainty check ofc                      inputStream.Flush();                        int tocSize = (int)_header.TotalTOCSize - 32;                      int decSize = 0;                      buffer = new byte[1024 * 16]; // more effecient use of memory                        ndx = 0; // for debuging                      step = Math.Round(1.0 / ((tocSize / buffer.Length) + 2) * 100' 3);                      progress = 0;                      //  GlobalExtension.ShowProgress("Writing Encrypted Data ...");                        int bytesRead;                      while ((bytesRead = outputStream.Read(buffer' 0' buffer.Length)) > 0)                      {                          decSize += bytesRead;                          if (decSize > tocSize)                              bytesRead = tocSize - (decSize - bytesRead);                            encStream.Write(buffer' 0' bytesRead);                            progress += step;                          //     GlobalExtension.UpdateProgress.Value = (int)progress;                          Console.WriteLine("Encrypted: " + ndx++);                      }                        inputStream.Position = 0;                      encStream.Position = 0;                      encStream.CopyTo(inputStream' (int)_header.BlockSizeAlloc);                  }              }
Magic Number,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Write,The following statement contains a magic number: if (encrypt) // Encrypt TOC              {                  using (var outputStream = new MemoryStreamExtension())                  {                      var encStream = new MemoryStreamExtension();                      inputStream.Position = 32L;                      RijndaelEncryptor.EncryptPSARC(inputStream' outputStream' _header.TotalTOCSize);                      inputStream.Position = 0L;                        // quick copy header from input stream                      var buffer = new byte[32];                      encStream.Write(buffer' 0' inputStream.Read(buffer' 0' buffer.Length));                      encStream.Position = 32; //sainty check ofc                      inputStream.Flush();                        int tocSize = (int)_header.TotalTOCSize - 32;                      int decSize = 0;                      buffer = new byte[1024 * 16]; // more effecient use of memory                        ndx = 0; // for debuging                      step = Math.Round(1.0 / ((tocSize / buffer.Length) + 2) * 100' 3);                      progress = 0;                      //  GlobalExtension.ShowProgress("Writing Encrypted Data ...");                        int bytesRead;                      while ((bytesRead = outputStream.Read(buffer' 0' buffer.Length)) > 0)                      {                          decSize += bytesRead;                          if (decSize > tocSize)                              bytesRead = tocSize - (decSize - bytesRead);                            encStream.Write(buffer' 0' bytesRead);                            progress += step;                          //     GlobalExtension.UpdateProgress.Value = (int)progress;                          Console.WriteLine("Encrypted: " + ndx++);                      }                        inputStream.Position = 0;                      encStream.Position = 0;                      encStream.CopyTo(inputStream' (int)_header.BlockSizeAlloc);                  }              }
Magic Number,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Write,The following statement contains a magic number: if (encrypt) // Encrypt TOC              {                  using (var outputStream = new MemoryStreamExtension())                  {                      var encStream = new MemoryStreamExtension();                      inputStream.Position = 32L;                      RijndaelEncryptor.EncryptPSARC(inputStream' outputStream' _header.TotalTOCSize);                      inputStream.Position = 0L;                        // quick copy header from input stream                      var buffer = new byte[32];                      encStream.Write(buffer' 0' inputStream.Read(buffer' 0' buffer.Length));                      encStream.Position = 32; //sainty check ofc                      inputStream.Flush();                        int tocSize = (int)_header.TotalTOCSize - 32;                      int decSize = 0;                      buffer = new byte[1024 * 16]; // more effecient use of memory                        ndx = 0; // for debuging                      step = Math.Round(1.0 / ((tocSize / buffer.Length) + 2) * 100' 3);                      progress = 0;                      //  GlobalExtension.ShowProgress("Writing Encrypted Data ...");                        int bytesRead;                      while ((bytesRead = outputStream.Read(buffer' 0' buffer.Length)) > 0)                      {                          decSize += bytesRead;                          if (decSize > tocSize)                              bytesRead = tocSize - (decSize - bytesRead);                            encStream.Write(buffer' 0' bytesRead);                            progress += step;                          //     GlobalExtension.UpdateProgress.Value = (int)progress;                          Console.WriteLine("Encrypted: " + ndx++);                      }                        inputStream.Position = 0;                      encStream.Position = 0;                      encStream.CopyTo(inputStream' (int)_header.BlockSizeAlloc);                  }              }
Magic Number,RocksmithToolkitLib.PsarcLoader,Header,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Header,The following statement contains a magic number: MagicNumber = 1347633490;
Magic Number,RocksmithToolkitLib.PsarcLoader,Header,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Header,The following statement contains a magic number: VersionNumber = 65540;
Magic Number,RocksmithToolkitLib.PsarcLoader,Header,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Header,The following statement contains a magic number: CompressionMethod = 2053925218;
Magic Number,RocksmithToolkitLib.PsarcLoader,Header,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Header,The following statement contains a magic number: TOCEntrySize = 30;
Magic Number,RocksmithToolkitLib.PsarcLoader,Header,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Header,The following statement contains a magic number: BlockSizeAlloc = 65536;
Magic Number,RocksmithToolkitLib.PsarcLoader,MemoryStreamExtension,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,ReadFrom,The following statement contains a magic number: byte[] buffer = new byte[4096];
Magic Number,RocksmithToolkitLib.PsarcLoader,MemoryStreamExtension,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,ReadFrom,The following statement contains a magic number: do              {                  read = source.Read(buffer' 0' (int)Math.Min(4096' length));                  length -= read;                  this.Write(buffer' 0' read);              } while (length > 0);
Magic Number,RocksmithToolkitLib.PsarcLoader,RijndaelEncryptor,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Unzip,The following statement contains a magic number: var buffer = new byte[65536];
Magic Number,RocksmithToolkitLib.PsarcLoader,RijndaelEncryptor,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Zip,The following statement contains a magic number: var buffer = new byte[65536];
Magic Number,RocksmithToolkitLib.PsarcLoader,RijndaelEncryptor,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Zip,The following statement contains a magic number: var zOutputStream = new ZOutputStream(outStream' 9);
Magic Number,RocksmithToolkitLib.PsarcLoader,RijndaelEncryptor,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,InitRijndael,The following statement contains a magic number: rij.BlockSize = 128;
Magic Number,RocksmithToolkitLib.PsarcLoader,RijndaelEncryptor,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,InitRijndael,The following statement contains a magic number: rij.IV = new byte[16];
Magic Number,RocksmithToolkitLib.PsarcLoader,RijndaelEncryptor,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Crypto,The following statement contains a magic number: var buffer = new byte[512];
Magic Number,RocksmithToolkitLib.PsarcLoader,PsarcExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PsarcExtensions.cs,InjectArchiveEntry,The following statement contains a magic number: int injectionCount = 2;
Magic Number,RocksmithToolkitLib.PsarcLoader,PsarcLoader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PsarcLoader.cs,ExtractEntryNames,The following statement contains a magic number: var step = Math.Round(1.0 / (_archive.TOC.Count + 2) * 100' 3);
Magic Number,RocksmithToolkitLib.PsarcLoader,PsarcLoader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PsarcLoader.cs,ExtractEntryNames,The following statement contains a magic number: var step = Math.Round(1.0 / (_archive.TOC.Count + 2) * 100' 3);
Magic Number,RocksmithToolkitLib.PsarcLoader,PsarcLoader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PsarcLoader.cs,ExtractEntryNames,The following statement contains a magic number: var step = Math.Round(1.0 / (_archive.TOC.Count + 2) * 100' 3);
Magic Number,RocksmithToolkitLib.PsarcLoader,PsarcLoader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PsarcLoader.cs,ExtractEntryNames,The following statement contains a magic number: GlobalExtension.UpdateProgress.Value = 100;
Magic Number,RocksmithToolkitLib.PsarcLoader,PsarcLoader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PsarcLoader.cs,FullErrorCheck,The following statement contains a magic number: foreach (var entry in _archive.TOC)              {                  _archive.InflateEntry(entry);                  if (!String.IsNullOrEmpty(entry.ErrMsg))                      errorLog.Add(entry.ErrMsg);                    if (entry.Data == null)                      errorLog.Add("Null Entry Error: " + entry.Name);                  else                  {                      entry.Data.Position = 0;                      var ms = new MemoryStream();                      using (var reader = new StreamReader(ms' new UTF8Encoding()' false' 65536)) //4Kb is default alloc size for windows .. 64Kb is default PSARC alloc                      {                          try                          {                              var canRead = reader.ReadToEnd();                          }                          catch (Exception ex)                          {                              errorLog.Add("Error Reading Entry: " + entry.Name + Environment.NewLine + ex.Message);                          }                      }                  }              }
Magic Number,RocksmithToolkitLib.PsarcLoader,PsarcLoader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PsarcLoader.cs,ExtractJsonManifests,The following statement contains a magic number: foreach (var xblockEntry in xblockEntries)              {                  var strippedName = xblockEntry.Name.Replace(".xblock"' "").Replace("gamexblocks/nsongs/"' "");                  if (strippedName.Contains("_fcp_dlc"))                      strippedName = strippedName.Replace("_fcp_dlc"' "");                    var jsonEntries = _archive.TOC.Where(x => x.Name.StartsWith("manifests/songs") && x.Name.EndsWith(".json") && x.Name.Contains(strippedName)).OrderBy(x => x.Name).ToList();                    // looping through song multiple times gathering each arrangement                  foreach (var jsonEntry in jsonEntries)                  {                      var dataObj = new Manifest2014<Attributes2014>();                        _archive.InflateEntry(jsonEntry);                      jsonEntry.Data.Position = 0;                      var ms = new MemoryStream();                      using (var reader = new StreamReader(ms' new UTF8Encoding()' false' 65536)) //4Kb is default alloc size for windows .. 64Kb is default PSARC alloc                      {                          jsonEntry.Data.Position = 0;                          jsonEntry.Data.CopyTo(ms);                          ms.Position = 0;                          var jsonObj = JObject.Parse(reader.ReadToEnd());                          dataObj = JsonConvert.DeserializeObject<Manifest2014<Attributes2014>>(jsonObj.ToString());                      }                        jsonData.Add(dataObj);                  }              }
Magic Number,RocksmithToolkitLib.PsarcLoader,PsarcLoader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PsarcLoader.cs,ExtractHsanManifest,The following statement contains a magic number: using (var reader = new StreamReader(ms' new UTF8Encoding()' false' 65536)) //4Kb is default alloc size for windows .. 64Kb is default PSARC alloc              {                  hsanEntry.Data.Position = 0;                  hsanEntry.Data.CopyTo(ms);                  ms.Position = 0;                  var jsonObj = JObject.Parse(reader.ReadToEnd());                  hsanData = JsonConvert.DeserializeObject<ManifestHeader2014<AttributesHeader2014>>(jsonObj.ToString());              }
Magic Number,RocksmithToolkitLib.Sng,Phrase,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFile.cs,Phrase,The following statement contains a magic number: _name = br.ReadBytes(32);
Magic Number,RocksmithToolkitLib.Sng,Control,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFile.cs,Control,The following statement contains a magic number: _code = br.ReadBytes(256);
Magic Number,RocksmithToolkitLib.Sng,SongEvent,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFile.cs,SongEvent,The following statement contains a magic number: _code = br.ReadBytes(256);
Magic Number,RocksmithToolkitLib.Sng,SongSection,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFile.cs,SongSection,The following statement contains a magic number: _name = br.ReadBytes(32);
Magic Number,RocksmithToolkitLib.Sng,Note,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFile.cs,Note,The following statement contains a magic number: if (version == 51)              {                  Slap = br.ReadInt32();                  Pluck = br.ReadInt32();              }
Magic Number,RocksmithToolkitLib.Sng,ChordTemplate,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFile.cs,ChordTemplate,The following statement contains a magic number: _name = br.ReadBytes(32);
Magic Number,RocksmithToolkitLib.Sng,Vocal,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFile.cs,Vocal,The following statement contains a magic number: _lyric = br.ReadBytes(32);
Magic Number,RocksmithToolkitLib.Sng,Metadata,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFile.cs,Metadata,The following statement contains a magic number: _lastConversion = br.ReadBytes(32);
Magic Number,RocksmithToolkitLib.Sng,Metadata,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFile.cs,Metadata,The following statement contains a magic number: _songTitle = br.ReadBytes(64);
Magic Number,RocksmithToolkitLib.Sng,Metadata,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFile.cs,Metadata,The following statement contains a magic number: _arrangement = br.ReadBytes(32);
Magic Number,RocksmithToolkitLib.Sng,Metadata,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFile.cs,Metadata,The following statement contains a magic number: _artist = br.ReadBytes(32);
Magic Number,RocksmithToolkitLib.Sng,UnknownSection1,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFile.cs,UnknownSection1,The following statement contains a magic number: Unknown1 = br.ReadBytes(4);
Magic Number,RocksmithToolkitLib.Sng,UnknownSection1,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFile.cs,UnknownSection1,The following statement contains a magic number: Unknown2 = br.ReadBytes(4);
Magic Number,RocksmithToolkitLib.Sng,UnknownSection2,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFile.cs,UnknownSection2,The following statement contains a magic number: _unknown1 = br.ReadBytes(64);
Magic Number,RocksmithToolkitLib.Sng,InstrumentTuningExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,GetMidiNote,The following statement contains a magic number: strNote -= arrangementType == ArrangementType.Bass ? 12 : 0;
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithVocalsFile,The following statement contains a magic number: using (FileStream fs = new FileStream(outputFile' FileMode.Create))              using (EndianBinaryWriter w = new EndianBinaryWriter(bitConverter' fs))              {                  // file header                  WriteRocksmithSngHeader(w' ArrangementType.Vocal);                    // unused filler                  w.Write(new byte[16]);                    // vocal count                  if (vocals.Count != vocals.Vocal.Length)                      throw new InvalidDataException("XML vocals header count does not match number of vocal items.");                  w.Write(vocals.Count);                    // vocals                  for (int i = 0; i < vocals.Vocal.Length; i++)                  {                      // vocal time                      w.Write(vocals.Vocal[i].Time);                        // vocal note                      w.Write(vocals.Vocal[i].Note);                        // vocal length                      w.Write(vocals.Vocal[i].Length);                        // vocal lyric                      string lyric = vocals.Vocal[i].Lyric;                      if (lyric.Length > 32)                          throw new InvalidDataException(string.Format("Vocal lyric '{0}' at position {1} exceeded the maximum width of 32 bytes."' lyric' i));                      foreach (char c in lyric)                      {                          w.Write(Convert.ToByte(c));                      }                      // padding after name                      w.Write(new byte[32 - lyric.Length]);                  }                    // unused                  w.Write(new byte[254]);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithVocalsFile,The following statement contains a magic number: using (FileStream fs = new FileStream(outputFile' FileMode.Create))              using (EndianBinaryWriter w = new EndianBinaryWriter(bitConverter' fs))              {                  // file header                  WriteRocksmithSngHeader(w' ArrangementType.Vocal);                    // unused filler                  w.Write(new byte[16]);                    // vocal count                  if (vocals.Count != vocals.Vocal.Length)                      throw new InvalidDataException("XML vocals header count does not match number of vocal items.");                  w.Write(vocals.Count);                    // vocals                  for (int i = 0; i < vocals.Vocal.Length; i++)                  {                      // vocal time                      w.Write(vocals.Vocal[i].Time);                        // vocal note                      w.Write(vocals.Vocal[i].Note);                        // vocal length                      w.Write(vocals.Vocal[i].Length);                        // vocal lyric                      string lyric = vocals.Vocal[i].Lyric;                      if (lyric.Length > 32)                          throw new InvalidDataException(string.Format("Vocal lyric '{0}' at position {1} exceeded the maximum width of 32 bytes."' lyric' i));                      foreach (char c in lyric)                      {                          w.Write(Convert.ToByte(c));                      }                      // padding after name                      w.Write(new byte[32 - lyric.Length]);                  }                    // unused                  w.Write(new byte[254]);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithVocalsFile,The following statement contains a magic number: using (FileStream fs = new FileStream(outputFile' FileMode.Create))              using (EndianBinaryWriter w = new EndianBinaryWriter(bitConverter' fs))              {                  // file header                  WriteRocksmithSngHeader(w' ArrangementType.Vocal);                    // unused filler                  w.Write(new byte[16]);                    // vocal count                  if (vocals.Count != vocals.Vocal.Length)                      throw new InvalidDataException("XML vocals header count does not match number of vocal items.");                  w.Write(vocals.Count);                    // vocals                  for (int i = 0; i < vocals.Vocal.Length; i++)                  {                      // vocal time                      w.Write(vocals.Vocal[i].Time);                        // vocal note                      w.Write(vocals.Vocal[i].Note);                        // vocal length                      w.Write(vocals.Vocal[i].Length);                        // vocal lyric                      string lyric = vocals.Vocal[i].Lyric;                      if (lyric.Length > 32)                          throw new InvalidDataException(string.Format("Vocal lyric '{0}' at position {1} exceeded the maximum width of 32 bytes."' lyric' i));                      foreach (char c in lyric)                      {                          w.Write(Convert.ToByte(c));                      }                      // padding after name                      w.Write(new byte[32 - lyric.Length]);                  }                    // unused                  w.Write(new byte[254]);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithVocalsFile,The following statement contains a magic number: using (FileStream fs = new FileStream(outputFile' FileMode.Create))              using (EndianBinaryWriter w = new EndianBinaryWriter(bitConverter' fs))              {                  // file header                  WriteRocksmithSngHeader(w' ArrangementType.Vocal);                    // unused filler                  w.Write(new byte[16]);                    // vocal count                  if (vocals.Count != vocals.Vocal.Length)                      throw new InvalidDataException("XML vocals header count does not match number of vocal items.");                  w.Write(vocals.Count);                    // vocals                  for (int i = 0; i < vocals.Vocal.Length; i++)                  {                      // vocal time                      w.Write(vocals.Vocal[i].Time);                        // vocal note                      w.Write(vocals.Vocal[i].Note);                        // vocal length                      w.Write(vocals.Vocal[i].Length);                        // vocal lyric                      string lyric = vocals.Vocal[i].Lyric;                      if (lyric.Length > 32)                          throw new InvalidDataException(string.Format("Vocal lyric '{0}' at position {1} exceeded the maximum width of 32 bytes."' lyric' i));                      foreach (char c in lyric)                      {                          w.Write(Convert.ToByte(c));                      }                      // padding after name                      w.Write(new byte[32 - lyric.Length]);                  }                    // unused                  w.Write(new byte[254]);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngFile,The following statement contains a magic number: using (FileStream fs = new FileStream(outputFile' FileMode.Create))              using (EndianBinaryWriter w = new EndianBinaryWriter(bitConverter' fs))              {                  // HEADER                  WriteRocksmithSngHeader(w' arrangementType);                    // EBEATS DATA                  WriteRocksmithSngEbeats(w' rocksmithSong.Ebeats);                    // PHRASES                  WriteRocksmithSngPhrases(w' rocksmithSong.Phrases' rocksmithSong.PhraseIterations);                    // CHORD TEMPLATES                  WriteRocksmithSngChordTemplates(w' rocksmithSong.ChordTemplates' tuning' arrangementType);                    // FRET HAND MUTE TEMPLATE                  WriteRocksmithSngFretHandMuteTemplates(w' rocksmithSong.FretHandMuteTemplates);                    // VOCALS TEMPLATE                   w.Write(new byte[4]); // not used on song file                    // PHRASE ITERATIONS                  WriteRocksmithSngPhraseIterations(w' rocksmithSong.PhraseIterations' rocksmithSong.SongLength);                    // PHRASE PROPERTIES                  WriteRocksmithSngPhraseProperties(w' rocksmithSong.PhraseProperties);                    // LINKED DIFFS                  WriteRocksmithSngLinkedDiffs(w' rocksmithSong.LinkedDiffs);                    // CONTROLS                  WriteRocksmithSngControls(w' rocksmithSong.Controls);                    // EVENTS                  WriteRocksmithSngEvents(w' rocksmithSong.Events);                    // SECTIONS                  WriteRocksmithSngSections(w' rocksmithSong.Sections' rocksmithSong.PhraseIterations' rocksmithSong.SongLength);                    // LEVELS                  WriteRocksmithSngLevels(w' rocksmithSong.Levels' rocksmithSong.SongLength' iterationInfo' arrangementType);                    // SONG META DATA                  WriteRocksmithSngMetaDetails(w' rocksmithSong' tuning' iterationInfo);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngHeader,The following statement contains a magic number: w.Write(arrangementType == ArrangementType.Bass ? 51 : 49);
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngHeader,The following statement contains a magic number: w.Write(arrangementType == ArrangementType.Bass ? 51 : 49);
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngEbeats,The following statement contains a magic number: if (ebeats == null || ebeats.Length == 0)              {                  w.Write(new byte[4]); // empty header                  return;              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngPhrases,The following statement contains a magic number: if (phrases == null || phrases.Length == 0)              {                  w.Write(new byte[4]); // empty header                  return;              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngPhrases,The following statement contains a magic number: for (int i = 0; i < phrases.Length; i++)              {                  // solo                  w.Write(phrases[i].Solo == 1);                    // disparity                  w.Write(phrases[i].Disparity == 1);                    // ignore                  w.Write(phrases[i].Ignore == 1);                    // unused padding                  w.Write(new byte());                    // maxDifficulty tag                  w.Write(phrases[i].MaxDifficulty);                    // count of usage in iterations                  int phraseIterationCount = 0;                  for (int i2 = 0; i2 < phraseIterations.Length; i2++)                  {                      if (phraseIterations[i2].PhraseId == i)                      {                          phraseIterationCount++;                      }                  }                  w.Write(phraseIterationCount);                    // name tag                  string name = phrases[i].Name;                  if (name.Length > 32)                  {                      name = name.Substring(0' 32);                  }                  foreach (char c in name)                  {                      w.Write(Convert.ToByte(c));                  }                  // padding after name                  w.Write(new byte[32 - name.Length]);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngPhrases,The following statement contains a magic number: for (int i = 0; i < phrases.Length; i++)              {                  // solo                  w.Write(phrases[i].Solo == 1);                    // disparity                  w.Write(phrases[i].Disparity == 1);                    // ignore                  w.Write(phrases[i].Ignore == 1);                    // unused padding                  w.Write(new byte());                    // maxDifficulty tag                  w.Write(phrases[i].MaxDifficulty);                    // count of usage in iterations                  int phraseIterationCount = 0;                  for (int i2 = 0; i2 < phraseIterations.Length; i2++)                  {                      if (phraseIterations[i2].PhraseId == i)                      {                          phraseIterationCount++;                      }                  }                  w.Write(phraseIterationCount);                    // name tag                  string name = phrases[i].Name;                  if (name.Length > 32)                  {                      name = name.Substring(0' 32);                  }                  foreach (char c in name)                  {                      w.Write(Convert.ToByte(c));                  }                  // padding after name                  w.Write(new byte[32 - name.Length]);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngPhrases,The following statement contains a magic number: for (int i = 0; i < phrases.Length; i++)              {                  // solo                  w.Write(phrases[i].Solo == 1);                    // disparity                  w.Write(phrases[i].Disparity == 1);                    // ignore                  w.Write(phrases[i].Ignore == 1);                    // unused padding                  w.Write(new byte());                    // maxDifficulty tag                  w.Write(phrases[i].MaxDifficulty);                    // count of usage in iterations                  int phraseIterationCount = 0;                  for (int i2 = 0; i2 < phraseIterations.Length; i2++)                  {                      if (phraseIterations[i2].PhraseId == i)                      {                          phraseIterationCount++;                      }                  }                  w.Write(phraseIterationCount);                    // name tag                  string name = phrases[i].Name;                  if (name.Length > 32)                  {                      name = name.Substring(0' 32);                  }                  foreach (char c in name)                  {                      w.Write(Convert.ToByte(c));                  }                  // padding after name                  w.Write(new byte[32 - name.Length]);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngChordTemplates,The following statement contains a magic number: if (chordTemplates == null || chordTemplates.Length == 0)              {                  w.Write(new byte[4]); // empty header                  return;              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngChordTemplates,The following statement contains a magic number: foreach (SongChordTemplate chordTemplate in chordTemplates)              {                  // fret numbers                  w.Write(chordTemplate.Fret0);                  w.Write(chordTemplate.Fret1);                  w.Write(chordTemplate.Fret2);                  w.Write(chordTemplate.Fret3);                  w.Write(chordTemplate.Fret4);                  w.Write(chordTemplate.Fret5);                    // finger positions                  w.Write(chordTemplate.Finger0);                  w.Write(chordTemplate.Finger1);                  w.Write(chordTemplate.Finger2);                  w.Write(chordTemplate.Finger3);                  w.Write(chordTemplate.Finger4);                  w.Write(chordTemplate.Finger5);                    // note values                  w.Write(tuning.GetMidiNote(arrangementType' 0' chordTemplate.Fret0));                  w.Write(tuning.GetMidiNote(arrangementType' 1' chordTemplate.Fret1));                  w.Write(tuning.GetMidiNote(arrangementType' 2' chordTemplate.Fret2));                  w.Write(tuning.GetMidiNote(arrangementType' 3' chordTemplate.Fret3));                  w.Write(tuning.GetMidiNote(arrangementType' 4' chordTemplate.Fret4));                  w.Write(tuning.GetMidiNote(arrangementType' 5' chordTemplate.Fret5));                    // chord name                  string name = chordTemplate.ChordName;                  if (name.Length > 32)                  {                      name = name.Substring(0' 32);                  }                  foreach (char c in name)                  {                      w.Write(Convert.ToByte(c));                  }                  // padding after name                  w.Write(new byte[32 - name.Length]);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngChordTemplates,The following statement contains a magic number: foreach (SongChordTemplate chordTemplate in chordTemplates)              {                  // fret numbers                  w.Write(chordTemplate.Fret0);                  w.Write(chordTemplate.Fret1);                  w.Write(chordTemplate.Fret2);                  w.Write(chordTemplate.Fret3);                  w.Write(chordTemplate.Fret4);                  w.Write(chordTemplate.Fret5);                    // finger positions                  w.Write(chordTemplate.Finger0);                  w.Write(chordTemplate.Finger1);                  w.Write(chordTemplate.Finger2);                  w.Write(chordTemplate.Finger3);                  w.Write(chordTemplate.Finger4);                  w.Write(chordTemplate.Finger5);                    // note values                  w.Write(tuning.GetMidiNote(arrangementType' 0' chordTemplate.Fret0));                  w.Write(tuning.GetMidiNote(arrangementType' 1' chordTemplate.Fret1));                  w.Write(tuning.GetMidiNote(arrangementType' 2' chordTemplate.Fret2));                  w.Write(tuning.GetMidiNote(arrangementType' 3' chordTemplate.Fret3));                  w.Write(tuning.GetMidiNote(arrangementType' 4' chordTemplate.Fret4));                  w.Write(tuning.GetMidiNote(arrangementType' 5' chordTemplate.Fret5));                    // chord name                  string name = chordTemplate.ChordName;                  if (name.Length > 32)                  {                      name = name.Substring(0' 32);                  }                  foreach (char c in name)                  {                      w.Write(Convert.ToByte(c));                  }                  // padding after name                  w.Write(new byte[32 - name.Length]);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngChordTemplates,The following statement contains a magic number: foreach (SongChordTemplate chordTemplate in chordTemplates)              {                  // fret numbers                  w.Write(chordTemplate.Fret0);                  w.Write(chordTemplate.Fret1);                  w.Write(chordTemplate.Fret2);                  w.Write(chordTemplate.Fret3);                  w.Write(chordTemplate.Fret4);                  w.Write(chordTemplate.Fret5);                    // finger positions                  w.Write(chordTemplate.Finger0);                  w.Write(chordTemplate.Finger1);                  w.Write(chordTemplate.Finger2);                  w.Write(chordTemplate.Finger3);                  w.Write(chordTemplate.Finger4);                  w.Write(chordTemplate.Finger5);                    // note values                  w.Write(tuning.GetMidiNote(arrangementType' 0' chordTemplate.Fret0));                  w.Write(tuning.GetMidiNote(arrangementType' 1' chordTemplate.Fret1));                  w.Write(tuning.GetMidiNote(arrangementType' 2' chordTemplate.Fret2));                  w.Write(tuning.GetMidiNote(arrangementType' 3' chordTemplate.Fret3));                  w.Write(tuning.GetMidiNote(arrangementType' 4' chordTemplate.Fret4));                  w.Write(tuning.GetMidiNote(arrangementType' 5' chordTemplate.Fret5));                    // chord name                  string name = chordTemplate.ChordName;                  if (name.Length > 32)                  {                      name = name.Substring(0' 32);                  }                  foreach (char c in name)                  {                      w.Write(Convert.ToByte(c));                  }                  // padding after name                  w.Write(new byte[32 - name.Length]);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngChordTemplates,The following statement contains a magic number: foreach (SongChordTemplate chordTemplate in chordTemplates)              {                  // fret numbers                  w.Write(chordTemplate.Fret0);                  w.Write(chordTemplate.Fret1);                  w.Write(chordTemplate.Fret2);                  w.Write(chordTemplate.Fret3);                  w.Write(chordTemplate.Fret4);                  w.Write(chordTemplate.Fret5);                    // finger positions                  w.Write(chordTemplate.Finger0);                  w.Write(chordTemplate.Finger1);                  w.Write(chordTemplate.Finger2);                  w.Write(chordTemplate.Finger3);                  w.Write(chordTemplate.Finger4);                  w.Write(chordTemplate.Finger5);                    // note values                  w.Write(tuning.GetMidiNote(arrangementType' 0' chordTemplate.Fret0));                  w.Write(tuning.GetMidiNote(arrangementType' 1' chordTemplate.Fret1));                  w.Write(tuning.GetMidiNote(arrangementType' 2' chordTemplate.Fret2));                  w.Write(tuning.GetMidiNote(arrangementType' 3' chordTemplate.Fret3));                  w.Write(tuning.GetMidiNote(arrangementType' 4' chordTemplate.Fret4));                  w.Write(tuning.GetMidiNote(arrangementType' 5' chordTemplate.Fret5));                    // chord name                  string name = chordTemplate.ChordName;                  if (name.Length > 32)                  {                      name = name.Substring(0' 32);                  }                  foreach (char c in name)                  {                      w.Write(Convert.ToByte(c));                  }                  // padding after name                  w.Write(new byte[32 - name.Length]);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngChordTemplates,The following statement contains a magic number: foreach (SongChordTemplate chordTemplate in chordTemplates)              {                  // fret numbers                  w.Write(chordTemplate.Fret0);                  w.Write(chordTemplate.Fret1);                  w.Write(chordTemplate.Fret2);                  w.Write(chordTemplate.Fret3);                  w.Write(chordTemplate.Fret4);                  w.Write(chordTemplate.Fret5);                    // finger positions                  w.Write(chordTemplate.Finger0);                  w.Write(chordTemplate.Finger1);                  w.Write(chordTemplate.Finger2);                  w.Write(chordTemplate.Finger3);                  w.Write(chordTemplate.Finger4);                  w.Write(chordTemplate.Finger5);                    // note values                  w.Write(tuning.GetMidiNote(arrangementType' 0' chordTemplate.Fret0));                  w.Write(tuning.GetMidiNote(arrangementType' 1' chordTemplate.Fret1));                  w.Write(tuning.GetMidiNote(arrangementType' 2' chordTemplate.Fret2));                  w.Write(tuning.GetMidiNote(arrangementType' 3' chordTemplate.Fret3));                  w.Write(tuning.GetMidiNote(arrangementType' 4' chordTemplate.Fret4));                  w.Write(tuning.GetMidiNote(arrangementType' 5' chordTemplate.Fret5));                    // chord name                  string name = chordTemplate.ChordName;                  if (name.Length > 32)                  {                      name = name.Substring(0' 32);                  }                  foreach (char c in name)                  {                      w.Write(Convert.ToByte(c));                  }                  // padding after name                  w.Write(new byte[32 - name.Length]);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngChordTemplates,The following statement contains a magic number: foreach (SongChordTemplate chordTemplate in chordTemplates)              {                  // fret numbers                  w.Write(chordTemplate.Fret0);                  w.Write(chordTemplate.Fret1);                  w.Write(chordTemplate.Fret2);                  w.Write(chordTemplate.Fret3);                  w.Write(chordTemplate.Fret4);                  w.Write(chordTemplate.Fret5);                    // finger positions                  w.Write(chordTemplate.Finger0);                  w.Write(chordTemplate.Finger1);                  w.Write(chordTemplate.Finger2);                  w.Write(chordTemplate.Finger3);                  w.Write(chordTemplate.Finger4);                  w.Write(chordTemplate.Finger5);                    // note values                  w.Write(tuning.GetMidiNote(arrangementType' 0' chordTemplate.Fret0));                  w.Write(tuning.GetMidiNote(arrangementType' 1' chordTemplate.Fret1));                  w.Write(tuning.GetMidiNote(arrangementType' 2' chordTemplate.Fret2));                  w.Write(tuning.GetMidiNote(arrangementType' 3' chordTemplate.Fret3));                  w.Write(tuning.GetMidiNote(arrangementType' 4' chordTemplate.Fret4));                  w.Write(tuning.GetMidiNote(arrangementType' 5' chordTemplate.Fret5));                    // chord name                  string name = chordTemplate.ChordName;                  if (name.Length > 32)                  {                      name = name.Substring(0' 32);                  }                  foreach (char c in name)                  {                      w.Write(Convert.ToByte(c));                  }                  // padding after name                  w.Write(new byte[32 - name.Length]);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngChordTemplates,The following statement contains a magic number: foreach (SongChordTemplate chordTemplate in chordTemplates)              {                  // fret numbers                  w.Write(chordTemplate.Fret0);                  w.Write(chordTemplate.Fret1);                  w.Write(chordTemplate.Fret2);                  w.Write(chordTemplate.Fret3);                  w.Write(chordTemplate.Fret4);                  w.Write(chordTemplate.Fret5);                    // finger positions                  w.Write(chordTemplate.Finger0);                  w.Write(chordTemplate.Finger1);                  w.Write(chordTemplate.Finger2);                  w.Write(chordTemplate.Finger3);                  w.Write(chordTemplate.Finger4);                  w.Write(chordTemplate.Finger5);                    // note values                  w.Write(tuning.GetMidiNote(arrangementType' 0' chordTemplate.Fret0));                  w.Write(tuning.GetMidiNote(arrangementType' 1' chordTemplate.Fret1));                  w.Write(tuning.GetMidiNote(arrangementType' 2' chordTemplate.Fret2));                  w.Write(tuning.GetMidiNote(arrangementType' 3' chordTemplate.Fret3));                  w.Write(tuning.GetMidiNote(arrangementType' 4' chordTemplate.Fret4));                  w.Write(tuning.GetMidiNote(arrangementType' 5' chordTemplate.Fret5));                    // chord name                  string name = chordTemplate.ChordName;                  if (name.Length > 32)                  {                      name = name.Substring(0' 32);                  }                  foreach (char c in name)                  {                      w.Write(Convert.ToByte(c));                  }                  // padding after name                  w.Write(new byte[32 - name.Length]);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngFretHandMuteTemplates,The following statement contains a magic number: w.Write(new byte[4]);
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngPhraseIterations,The following statement contains a magic number: if (phraseIterations == null || phraseIterations.Length == 0)              {                  w.Write(new byte[4]); // empty header                  return;              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngPhraseProperties,The following statement contains a magic number: if (phraseProperties == null || phraseProperties.Length == 0)              {                  w.Write(new byte[4]); // empty header                  return;              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngLinkedDiffs,The following statement contains a magic number: if (linkedDiffs == null || linkedDiffs.Length == 0)              {                  w.Write(new byte[4]); // empty header                  return;              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngControls,The following statement contains a magic number: if (controls == null || controls.Length == 0)              {                  w.Write(new byte[4]); // empty header                  return;              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngControls,The following statement contains a magic number: foreach (var songControl in controls)              {                  // control time                  w.Write(songControl.Time);                    // control code                  string code = songControl.Code;                  if (code.Length > 256)                  {                      code = code.Substring(0' 256);                  }                  foreach (char c in code)                  {                      w.Write(Convert.ToByte(c));                  }                  // padding after control code                  w.Write(new byte[256 - code.Length]);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngControls,The following statement contains a magic number: foreach (var songControl in controls)              {                  // control time                  w.Write(songControl.Time);                    // control code                  string code = songControl.Code;                  if (code.Length > 256)                  {                      code = code.Substring(0' 256);                  }                  foreach (char c in code)                  {                      w.Write(Convert.ToByte(c));                  }                  // padding after control code                  w.Write(new byte[256 - code.Length]);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngControls,The following statement contains a magic number: foreach (var songControl in controls)              {                  // control time                  w.Write(songControl.Time);                    // control code                  string code = songControl.Code;                  if (code.Length > 256)                  {                      code = code.Substring(0' 256);                  }                  foreach (char c in code)                  {                      w.Write(Convert.ToByte(c));                  }                  // padding after control code                  w.Write(new byte[256 - code.Length]);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngEvents,The following statement contains a magic number: if (events == null || events.Length == 0)              {                  w.Write(new byte[4]); // empty header                  return;              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngEvents,The following statement contains a magic number: foreach (var songEvent in events)              {                  // event time                  w.Write(songEvent.Time);                  // event code                  string eventCode = songEvent.Code;                  if (eventCode.Length > 256)                  {                      eventCode = eventCode.Substring(0' 256);                  }                  foreach (char c in eventCode)                  {                      w.Write(Convert.ToByte(c));                  }                  // padding after event code                  w.Write(new byte[256 - eventCode.Length]);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngEvents,The following statement contains a magic number: foreach (var songEvent in events)              {                  // event time                  w.Write(songEvent.Time);                  // event code                  string eventCode = songEvent.Code;                  if (eventCode.Length > 256)                  {                      eventCode = eventCode.Substring(0' 256);                  }                  foreach (char c in eventCode)                  {                      w.Write(Convert.ToByte(c));                  }                  // padding after event code                  w.Write(new byte[256 - eventCode.Length]);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngEvents,The following statement contains a magic number: foreach (var songEvent in events)              {                  // event time                  w.Write(songEvent.Time);                  // event code                  string eventCode = songEvent.Code;                  if (eventCode.Length > 256)                  {                      eventCode = eventCode.Substring(0' 256);                  }                  foreach (char c in eventCode)                  {                      w.Write(Convert.ToByte(c));                  }                  // padding after event code                  w.Write(new byte[256 - eventCode.Length]);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngSections,The following statement contains a magic number: if (sections == null || sections.Length == 0)              {                  w.Write(new byte[4]); // empty header                  return;              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngSections,The following statement contains a magic number: for (int i = 0; i < sections.Length; i++)              {                  // section name                  string name = sections[i].Name;                  if (name.Length > 32)                  {                      name = name.Substring(0' 32);                  }                  foreach (char c in name)                  {                      w.Write(Convert.ToByte(c));                  }                  // padding after section name                  w.Write(new byte[32 - name.Length]);                    // number tag                  w.Write(sections[i].Number);                    // start time                  w.Write(sections[i].StartTime);                    // end time                  var endTime = i == sections.Length - 1                      ? songLength                      : sections[i + 1].StartTime;                  w.Write(endTime);                    // phrase iteration start index                  bool phraseIterationFound = false;                  for (int p = 0; p < phraseIterations.Length; p++)                  {                      if (sections[i].StartTime <= phraseIterations[p].Time)                      {                          w.Write(p);                          phraseIterationFound = true;                          break;                      }                  }                  if (!phraseIterationFound)                      throw new Exception(string.Format("No phrase iteration found with matching time for section {0}."' i.ToString()));                    // phrase iteration end index                  if (i == sections.Length - 1) // if last section' default to last phrase iteration                  {                      w.Write(phraseIterations.Length - 1);                  }                  else                  {                      //bool endPhraseIterationFound = false;                      for (int p = 0; p < phraseIterations.Length; p++)                      {                          if (sections[i + 1].StartTime <= phraseIterations[p].Time)                          {                              w.Write(Convert.ToInt32(p - 1));                              //endPhraseIterationFound = true;                              break;                          }                      }                      //if (!endPhraseIterationFound)                      //    throw new Exception(string.Format("No end phrase iteration found with matching time for section {0}."' i.ToString()));                  }                    // series of 8 unknown bytes (look like flags)? below logic is wrong' just defaulting for now                  w.Write(true);                  w.Write(true);                  w.Write(true);                  w.Write(true);                  w.Write(true);                  w.Write(false);                  w.Write(false);                  w.Write(false);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngSections,The following statement contains a magic number: for (int i = 0; i < sections.Length; i++)              {                  // section name                  string name = sections[i].Name;                  if (name.Length > 32)                  {                      name = name.Substring(0' 32);                  }                  foreach (char c in name)                  {                      w.Write(Convert.ToByte(c));                  }                  // padding after section name                  w.Write(new byte[32 - name.Length]);                    // number tag                  w.Write(sections[i].Number);                    // start time                  w.Write(sections[i].StartTime);                    // end time                  var endTime = i == sections.Length - 1                      ? songLength                      : sections[i + 1].StartTime;                  w.Write(endTime);                    // phrase iteration start index                  bool phraseIterationFound = false;                  for (int p = 0; p < phraseIterations.Length; p++)                  {                      if (sections[i].StartTime <= phraseIterations[p].Time)                      {                          w.Write(p);                          phraseIterationFound = true;                          break;                      }                  }                  if (!phraseIterationFound)                      throw new Exception(string.Format("No phrase iteration found with matching time for section {0}."' i.ToString()));                    // phrase iteration end index                  if (i == sections.Length - 1) // if last section' default to last phrase iteration                  {                      w.Write(phraseIterations.Length - 1);                  }                  else                  {                      //bool endPhraseIterationFound = false;                      for (int p = 0; p < phraseIterations.Length; p++)                      {                          if (sections[i + 1].StartTime <= phraseIterations[p].Time)                          {                              w.Write(Convert.ToInt32(p - 1));                              //endPhraseIterationFound = true;                              break;                          }                      }                      //if (!endPhraseIterationFound)                      //    throw new Exception(string.Format("No end phrase iteration found with matching time for section {0}."' i.ToString()));                  }                    // series of 8 unknown bytes (look like flags)? below logic is wrong' just defaulting for now                  w.Write(true);                  w.Write(true);                  w.Write(true);                  w.Write(true);                  w.Write(true);                  w.Write(false);                  w.Write(false);                  w.Write(false);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngSections,The following statement contains a magic number: for (int i = 0; i < sections.Length; i++)              {                  // section name                  string name = sections[i].Name;                  if (name.Length > 32)                  {                      name = name.Substring(0' 32);                  }                  foreach (char c in name)                  {                      w.Write(Convert.ToByte(c));                  }                  // padding after section name                  w.Write(new byte[32 - name.Length]);                    // number tag                  w.Write(sections[i].Number);                    // start time                  w.Write(sections[i].StartTime);                    // end time                  var endTime = i == sections.Length - 1                      ? songLength                      : sections[i + 1].StartTime;                  w.Write(endTime);                    // phrase iteration start index                  bool phraseIterationFound = false;                  for (int p = 0; p < phraseIterations.Length; p++)                  {                      if (sections[i].StartTime <= phraseIterations[p].Time)                      {                          w.Write(p);                          phraseIterationFound = true;                          break;                      }                  }                  if (!phraseIterationFound)                      throw new Exception(string.Format("No phrase iteration found with matching time for section {0}."' i.ToString()));                    // phrase iteration end index                  if (i == sections.Length - 1) // if last section' default to last phrase iteration                  {                      w.Write(phraseIterations.Length - 1);                  }                  else                  {                      //bool endPhraseIterationFound = false;                      for (int p = 0; p < phraseIterations.Length; p++)                      {                          if (sections[i + 1].StartTime <= phraseIterations[p].Time)                          {                              w.Write(Convert.ToInt32(p - 1));                              //endPhraseIterationFound = true;                              break;                          }                      }                      //if (!endPhraseIterationFound)                      //    throw new Exception(string.Format("No end phrase iteration found with matching time for section {0}."' i.ToString()));                  }                    // series of 8 unknown bytes (look like flags)? below logic is wrong' just defaulting for now                  w.Write(true);                  w.Write(true);                  w.Write(true);                  w.Write(true);                  w.Write(true);                  w.Write(false);                  w.Write(false);                  w.Write(false);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngLevels,The following statement contains a magic number: if (levels == null || levels.Length == 0)              {                  w.Write(new byte[4]); // empty header                  return;              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngLevelAnchors,The following statement contains a magic number: if (anchors == null || anchors.Length == 0)              {                  w.Write(new byte[4]); // empty header                  return;              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRockmithSngLevelSlideProperties,The following statement contains a magic number: if (notes == null || notes.Length == 0)              {                  w.Write(new byte[4]);                  return;              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRockmithSngLevelSlideProperties,The following statement contains a magic number: foreach (SongNote note in notes)              {                  if (note.SlideTo > -1)                  {                      // slide end time                      if (note.Sustain > 0)                      {                          w.Write(note.Time + note.Sustain);                      }                      else                      { // default sustain if user forgets it                          w.Write(note.Time + (float)0.125);                      }                        // slide end fret                      w.Write(note.SlideTo);                  }              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngLevelHandShapes,The following statement contains a magic number: if (handShapes == null || handShapes.Length == 0)              {                  w.Write(new byte[4]); // empty header                  return;              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngLevelNotes,The following statement contains a magic number: if (notesChords.Count == 0)              {                  w.Write(new byte[4]); // empty header                  return;              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngLevelNotes,The following statement contains a magic number: for (int i = 0; i < (notesChords.Count); i++)              {                  // note time tag                  w.Write(notesChords[i].Time);                    // string tag                  w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? ((SongNote)notesChords[i].Entity).String : -1);                    // fret tag                  w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? ((SongNote)notesChords[i].Entity).Fret : (sbyte)-1);                    // chord id                  w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? -1 : ((SongChord)notesChords[i].Entity).ChordId);                    // unknown                  w.Write(Convert.ToInt32(-1));                    // sustain time                  w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? ((SongNote)notesChords[i].Entity).Sustain : 0);                    // bend                  w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? ((SongNote)notesChords[i].Entity).Bend : (byte)0);                    // slideTo                  w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? ((SongNote)notesChords[i].Entity).SlideTo : (sbyte)-1);                    // tremolo                  w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? ((SongNote)notesChords[i].Entity).Tremolo : new byte());                    // harmonic                  w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? ((SongNote)notesChords[i].Entity).Harmonic : new byte());                    // palm mute                  w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? ((SongNote)notesChords[i].Entity).PalmMute : new byte());                    if (arrangementType == ArrangementType.Bass)                  {                      w.Write(new byte());//unknownB                        //Bass only - Slap                      w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? ((SongNote)notesChords[i].Entity).Slap : (sbyte)-1);                        //Bass only - Pluck                      w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? ((SongNote)notesChords[i].Entity).Pluck : (sbyte)-1);                  }                    // hopo                  w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? ((SongNote)notesChords[i].Entity).Hopo : new byte());                    // hammerOn                  w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? ((SongNote)notesChords[i].Entity).HammerOn : new byte());                    // pullOff                  w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? ((SongNote)notesChords[i].Entity).PullOff : new byte());                    // ignore                  w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? ((SongNote)notesChords[i].Entity).Ignore : ((SongChord)notesChords[i].Entity).Ignore);                    // high density chord                  if (arrangementType == ArrangementType.Bass)                  {                      w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? new byte() : (byte)((SongChord)notesChords[i].Entity).HighDensity);                      w.Write(new byte());                      w.Write((byte)140);                      w.Write(new byte());                  }                  else                  {                      w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? new byte() : ((SongChord)notesChords[i].Entity).HighDensity);                      w.Write(new byte[4]);                  }                    //w.Write(Convert.ToInt16(246));                  //w.Write(Convert.ToInt16(7472));                    // phrase iteration start index and id ????                  bool phraseStartIterationFound = false;                  foreach (var iteration in iterationInfo)                  {                      if (notesChords[i].Time >= iteration.StartTime && notesChords[i].Time < iteration.EndTime)                      {                          w.Write(iteration.IterationId); // phrase iteration                          w.Write(iteration.PhraseId);                          phraseStartIterationFound = true;                          break;                      }                  }                  if (!phraseStartIterationFound)                  {                      throw new Exception(string.Format("No phrase start iteration found with matching time for note {0}."' i.ToString()));                  }              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngLevelNotes,The following statement contains a magic number: for (int i = 0; i < (notesChords.Count); i++)              {                  // note time tag                  w.Write(notesChords[i].Time);                    // string tag                  w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? ((SongNote)notesChords[i].Entity).String : -1);                    // fret tag                  w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? ((SongNote)notesChords[i].Entity).Fret : (sbyte)-1);                    // chord id                  w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? -1 : ((SongChord)notesChords[i].Entity).ChordId);                    // unknown                  w.Write(Convert.ToInt32(-1));                    // sustain time                  w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? ((SongNote)notesChords[i].Entity).Sustain : 0);                    // bend                  w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? ((SongNote)notesChords[i].Entity).Bend : (byte)0);                    // slideTo                  w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? ((SongNote)notesChords[i].Entity).SlideTo : (sbyte)-1);                    // tremolo                  w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? ((SongNote)notesChords[i].Entity).Tremolo : new byte());                    // harmonic                  w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? ((SongNote)notesChords[i].Entity).Harmonic : new byte());                    // palm mute                  w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? ((SongNote)notesChords[i].Entity).PalmMute : new byte());                    if (arrangementType == ArrangementType.Bass)                  {                      w.Write(new byte());//unknownB                        //Bass only - Slap                      w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? ((SongNote)notesChords[i].Entity).Slap : (sbyte)-1);                        //Bass only - Pluck                      w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? ((SongNote)notesChords[i].Entity).Pluck : (sbyte)-1);                  }                    // hopo                  w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? ((SongNote)notesChords[i].Entity).Hopo : new byte());                    // hammerOn                  w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? ((SongNote)notesChords[i].Entity).HammerOn : new byte());                    // pullOff                  w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? ((SongNote)notesChords[i].Entity).PullOff : new byte());                    // ignore                  w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? ((SongNote)notesChords[i].Entity).Ignore : ((SongChord)notesChords[i].Entity).Ignore);                    // high density chord                  if (arrangementType == ArrangementType.Bass)                  {                      w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? new byte() : (byte)((SongChord)notesChords[i].Entity).HighDensity);                      w.Write(new byte());                      w.Write((byte)140);                      w.Write(new byte());                  }                  else                  {                      w.Write(notesChords[i].Entity.GetType() == typeof(SongNote) ? new byte() : ((SongChord)notesChords[i].Entity).HighDensity);                      w.Write(new byte[4]);                  }                    //w.Write(Convert.ToInt16(246));                  //w.Write(Convert.ToInt16(7472));                    // phrase iteration start index and id ????                  bool phraseStartIterationFound = false;                  foreach (var iteration in iterationInfo)                  {                      if (notesChords[i].Time >= iteration.StartTime && notesChords[i].Time < iteration.EndTime)                      {                          w.Write(iteration.IterationId); // phrase iteration                          w.Write(iteration.PhraseId);                          phraseStartIterationFound = true;                          break;                      }                  }                  if (!phraseStartIterationFound)                  {                      throw new Exception(string.Format("No phrase start iteration found with matching time for note {0}."' i.ToString()));                  }              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngMetaDetails,The following statement contains a magic number: w.Write((double)100000);
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngMetaDetails,The following statement contains a magic number: if (s.Ebeats.Length < 2)                  throw new InvalidDataException("Song must contain at least 2 beats");
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngMetaDetails,The following statement contains a magic number: if (lastConvertDate.Length > 32)              {                  lastConvertDate = lastConvertDate.Substring(0' 32);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngMetaDetails,The following statement contains a magic number: if (lastConvertDate.Length > 32)              {                  lastConvertDate = lastConvertDate.Substring(0' 32);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngMetaDetails,The following statement contains a magic number: w.Write(new byte[32 - lastConvertDate.Length]);
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngMetaDetails,The following statement contains a magic number: if (title.Length > 64)              {                  title = title.Substring(0' 64);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngMetaDetails,The following statement contains a magic number: if (title.Length > 64)              {                  title = title.Substring(0' 64);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngMetaDetails,The following statement contains a magic number: w.Write(new byte[64 - title.Length]);
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngMetaDetails,The following statement contains a magic number: if (arrangement.Length > 32)              {                  arrangement = arrangement.Substring(0' 32);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngMetaDetails,The following statement contains a magic number: if (arrangement.Length > 32)              {                  arrangement = arrangement.Substring(0' 32);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngMetaDetails,The following statement contains a magic number: w.Write(new byte[32 - arrangement.Length]);
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngMetaDetails,The following statement contains a magic number: if (artistValue.Length > 32)              {                  artistValue = artistValue.Substring(0' 32);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngMetaDetails,The following statement contains a magic number: if (artistValue.Length > 32)              {                  artistValue = artistValue.Substring(0' 32);              }
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngMetaDetails,The following statement contains a magic number: w.Write(new byte[32 - artistValue.Length]);
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngMetaDetails,The following statement contains a magic number: w.Write(new byte[4]);
Magic Number,RocksmithToolkitLib.Sng,SngFileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\SngFileWriter.cs,WriteRocksmithSngMetaDetails,The following statement contains a magic number: w.Write(new byte[4]);
Magic Number,RocksmithToolkitLib,ToolkitVersionOnline,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\ToolkitVersionOnline.cs,Load,The following statement contains a magic number: try              {                  if (GeneralExtensions.IsInDesignMode)                  {                      // for debugging dumby JSON data                      versionInfoJson = "{\"version\":\"2.7.1.0\"'\"date\":1470934174'\"update\":true'\"commits\":[\"2016-08-11:AppVeyour build failed so recommitting\"'\"2016-08-11: Commit for Beta Version 2.7.1.0\"]'\"revision\":\"7f8f5233\"}";                      toolkitVersionOnline = JsonConvert.DeserializeObject<ToolkitVersionOnline>(versionInfoJson);                  }                  else                  {                      versionInfoJson = new WebClient().DownloadString(versionInfoUrl);                      toolkitVersionOnline = JsonConvert.DeserializeObject<ToolkitVersionOnline>(versionInfoJson);                        //  recommend update to latest revision under special conditions                      var useBeta = ConfigRepository.Instance().GetBoolean("general_usebeta");                                            if ((!useBeta && ToolkitVersion.AssemblyConfiguration == "BETA") ||                           (useBeta && ToolkitVersion.AssemblyConfiguration != "BETA") ||                           (String.IsNullOrEmpty(toolkitVersionOnline.Revision) &&                           !toolkitVersionOnline.UpdateAvailable))                      {                          versionInfoJson = new WebClient().DownloadString(GetFileUrl());                          toolkitVersionOnline = JsonConvert.DeserializeObject<ToolkitVersionOnline>(versionInfoJson);                          toolkitVersionOnline.CommitMessages = new string[2];                          toolkitVersionOnline.CommitMessages[0] = "<WARNING>: Special conditions were detected ...";                          toolkitVersionOnline.CommitMessages[1] = "Recommend installing the latest online version.";                          toolkitVersionOnline.UpdateAvailable = true;                      }                  }              }              catch (Exception ex)              {                  Console.WriteLine("VersionInfoUrl Load Error: " + ex.Message);              }
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest2014.Tone,Tone2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest2014\Tone\Tone2014.cs,Tone2014,The following statement contains a magic number: Volume = -12;
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest.Functions,ManifestFunctions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Functions\ManifestFunctions.cs,getNoteTech,The following statement contains a magic number: if (1 == n.Mute)                  t.Add(2);
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest.Functions,ManifestFunctions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Functions\ManifestFunctions.cs,getNoteTech,The following statement contains a magic number: if (1 == n.HammerOn)                  t.Add(3);
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest.Functions,ManifestFunctions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Functions\ManifestFunctions.cs,getNoteTech,The following statement contains a magic number: if (1 == n.Harmonic)                  t.Add(4);
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest.Functions,ManifestFunctions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Functions\ManifestFunctions.cs,getNoteTech,The following statement contains a magic number: if (1 == n.HarmonicPinch)                  t.Add(5);
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest.Functions,ManifestFunctions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Functions\ManifestFunctions.cs,getNoteTech,The following statement contains a magic number: if (1 == n.Hopo)                  t.Add(6);
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest.Functions,ManifestFunctions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Functions\ManifestFunctions.cs,getNoteTech,The following statement contains a magic number: if (1 == n.PalmMute)                  t.Add(7);
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest.Functions,ManifestFunctions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Functions\ManifestFunctions.cs,getNoteTech,The following statement contains a magic number: if (1 == n.Pluck)                  t.Add(8);
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest.Functions,ManifestFunctions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Functions\ManifestFunctions.cs,getNoteTech,The following statement contains a magic number: if (1 == n.PullOff)                  t.Add(9);
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest.Functions,ManifestFunctions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Functions\ManifestFunctions.cs,getNoteTech,The following statement contains a magic number: if (1 == n.Slap)                  t.Add(10);
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest.Functions,ManifestFunctions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Functions\ManifestFunctions.cs,getNoteTech,The following statement contains a magic number: if (n.SlideTo > 0)                  t.Add(11);
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest.Functions,ManifestFunctions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Functions\ManifestFunctions.cs,getNoteTech,The following statement contains a magic number: if (n.SlideUnpitchTo > 0)                  t.Add(12);
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest.Functions,ManifestFunctions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Functions\ManifestFunctions.cs,getNoteTech,The following statement contains a magic number: if (n.Sustain > 0)                  t.Add(13);
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest.Functions,ManifestFunctions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Functions\ManifestFunctions.cs,getNoteTech,The following statement contains a magic number: if (1 == n.Tap)                  t.Add(14);
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest.Functions,ManifestFunctions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Functions\ManifestFunctions.cs,getNoteTech,The following statement contains a magic number: if (1 == n.Tremolo)                  t.Add(15);
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest.Functions,ManifestFunctions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Functions\ManifestFunctions.cs,getNoteTech,The following statement contains a magic number: if (1 == n.Vibrato)                  t.Add(16);
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest.Functions,ManifestFunctions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Functions\ManifestFunctions.cs,GetSongDifficulty,The following statement contains a magic number: for (int i = 0; i < song.PhraseIterations.Length; i++)              {                  var pt = song.PhraseIterations[i];                  var hard = song.Phrases[pt.PhraseId].MaxDifficulty;                  if (pt.HeroLevels != null)                      foreach (var h in pt.HeroLevels)                      {                          switch (h.Hero)                          {                              case 1:                                  easyArray.Add(h.Difficulty);                                  break;                              case 2:                                  mediumArray.Add(h.Difficulty);                                  break;                              case 3:                                  hard = h.Difficulty;                                  break;                          }                          hardArray.Add(hard);                      }              }
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest.Functions,ManifestFunctions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Functions\ManifestFunctions.cs,GetSongDifficulty,The following statement contains a magic number: for (int i = 0; i < song.PhraseIterations.Length; i++)              {                  var pt = song.PhraseIterations[i];                  var hard = song.Phrases[pt.PhraseId].MaxDifficulty;                  if (pt.HeroLevels != null)                      foreach (var h in pt.HeroLevels)                      {                          switch (h.Hero)                          {                              case 1:                                  easyArray.Add(h.Difficulty);                                  break;                              case 2:                                  mediumArray.Add(h.Difficulty);                                  break;                              case 3:                                  hard = h.Difficulty;                                  break;                          }                          hardArray.Add(hard);                      }              }
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest.Functions,ManifestFunctions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Functions\ManifestFunctions.cs,GenerateDynamicVisualDensity,The following statement contains a magic number: if (arrangement.ArrangementType == ArrangementType.Vocal)              {                  if (version == GameVersion.RS2014)                      attribute.DynamicVisualDensity = Enumerable.Repeat(2.0f' 20).ToList();                  else                      attribute.DynamicVisualDensity = new List<float> {                          4.5f' 4.3000001907348633f' 4.0999999046325684f' 3.9000000953674316f' 3.7000000476837158f'                          3.5f' 3.2999999523162842f' 3.0999999046325684f' 2.9000000953674316f' 2.7000000476837158f'                          2.5f' 2.2999999523162842f' 2.0999999046325684f'                          2.0f' 2.0f' 2.0f' 2.0f' 2.0f' 2.0f' 2.0f                      };              }              else              {                  const float floorLimit = 5f;                  attribute.DynamicVisualDensity = new List<float>(20);                  float endSpeed = Math.Min(45f' Math.Max(floorLimit' arrangement.ScrollSpeed)) / 10f;                  if (song.Levels.Length == 1)                  {                      attribute.DynamicVisualDensity = Enumerable.Repeat(endSpeed' 20).ToList();                  }                  else                  {                      double beginSpeed = 4.5d;                      double maxLevel = Math.Min(song.Levels.Length' 20d) - 1;                      double factor = maxLevel > 0 ? Math.Pow(endSpeed / beginSpeed' 1d / maxLevel) : 1d;                      for (int i = 0; i < 20; i++)                      {                          if (i >= maxLevel)                          {                              attribute.DynamicVisualDensity.Add(endSpeed);                          }                          else                          {                              attribute.DynamicVisualDensity.Add((float)(beginSpeed * Math.Pow(factor' i)));                          }                      }                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest.Functions,ManifestFunctions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Functions\ManifestFunctions.cs,GenerateDynamicVisualDensity,The following statement contains a magic number: if (arrangement.ArrangementType == ArrangementType.Vocal)              {                  if (version == GameVersion.RS2014)                      attribute.DynamicVisualDensity = Enumerable.Repeat(2.0f' 20).ToList();                  else                      attribute.DynamicVisualDensity = new List<float> {                          4.5f' 4.3000001907348633f' 4.0999999046325684f' 3.9000000953674316f' 3.7000000476837158f'                          3.5f' 3.2999999523162842f' 3.0999999046325684f' 2.9000000953674316f' 2.7000000476837158f'                          2.5f' 2.2999999523162842f' 2.0999999046325684f'                          2.0f' 2.0f' 2.0f' 2.0f' 2.0f' 2.0f' 2.0f                      };              }              else              {                  const float floorLimit = 5f;                  attribute.DynamicVisualDensity = new List<float>(20);                  float endSpeed = Math.Min(45f' Math.Max(floorLimit' arrangement.ScrollSpeed)) / 10f;                  if (song.Levels.Length == 1)                  {                      attribute.DynamicVisualDensity = Enumerable.Repeat(endSpeed' 20).ToList();                  }                  else                  {                      double beginSpeed = 4.5d;                      double maxLevel = Math.Min(song.Levels.Length' 20d) - 1;                      double factor = maxLevel > 0 ? Math.Pow(endSpeed / beginSpeed' 1d / maxLevel) : 1d;                      for (int i = 0; i < 20; i++)                      {                          if (i >= maxLevel)                          {                              attribute.DynamicVisualDensity.Add(endSpeed);                          }                          else                          {                              attribute.DynamicVisualDensity.Add((float)(beginSpeed * Math.Pow(factor' i)));                          }                      }                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest.Functions,ManifestFunctions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Functions\ManifestFunctions.cs,GenerateDynamicVisualDensity,The following statement contains a magic number: if (arrangement.ArrangementType == ArrangementType.Vocal)              {                  if (version == GameVersion.RS2014)                      attribute.DynamicVisualDensity = Enumerable.Repeat(2.0f' 20).ToList();                  else                      attribute.DynamicVisualDensity = new List<float> {                          4.5f' 4.3000001907348633f' 4.0999999046325684f' 3.9000000953674316f' 3.7000000476837158f'                          3.5f' 3.2999999523162842f' 3.0999999046325684f' 2.9000000953674316f' 2.7000000476837158f'                          2.5f' 2.2999999523162842f' 2.0999999046325684f'                          2.0f' 2.0f' 2.0f' 2.0f' 2.0f' 2.0f' 2.0f                      };              }              else              {                  const float floorLimit = 5f;                  attribute.DynamicVisualDensity = new List<float>(20);                  float endSpeed = Math.Min(45f' Math.Max(floorLimit' arrangement.ScrollSpeed)) / 10f;                  if (song.Levels.Length == 1)                  {                      attribute.DynamicVisualDensity = Enumerable.Repeat(endSpeed' 20).ToList();                  }                  else                  {                      double beginSpeed = 4.5d;                      double maxLevel = Math.Min(song.Levels.Length' 20d) - 1;                      double factor = maxLevel > 0 ? Math.Pow(endSpeed / beginSpeed' 1d / maxLevel) : 1d;                      for (int i = 0; i < 20; i++)                      {                          if (i >= maxLevel)                          {                              attribute.DynamicVisualDensity.Add(endSpeed);                          }                          else                          {                              attribute.DynamicVisualDensity.Add((float)(beginSpeed * Math.Pow(factor' i)));                          }                      }                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest.Functions,ManifestFunctions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Functions\ManifestFunctions.cs,GenerateDynamicVisualDensity,The following statement contains a magic number: if (arrangement.ArrangementType == ArrangementType.Vocal)              {                  if (version == GameVersion.RS2014)                      attribute.DynamicVisualDensity = Enumerable.Repeat(2.0f' 20).ToList();                  else                      attribute.DynamicVisualDensity = new List<float> {                          4.5f' 4.3000001907348633f' 4.0999999046325684f' 3.9000000953674316f' 3.7000000476837158f'                          3.5f' 3.2999999523162842f' 3.0999999046325684f' 2.9000000953674316f' 2.7000000476837158f'                          2.5f' 2.2999999523162842f' 2.0999999046325684f'                          2.0f' 2.0f' 2.0f' 2.0f' 2.0f' 2.0f' 2.0f                      };              }              else              {                  const float floorLimit = 5f;                  attribute.DynamicVisualDensity = new List<float>(20);                  float endSpeed = Math.Min(45f' Math.Max(floorLimit' arrangement.ScrollSpeed)) / 10f;                  if (song.Levels.Length == 1)                  {                      attribute.DynamicVisualDensity = Enumerable.Repeat(endSpeed' 20).ToList();                  }                  else                  {                      double beginSpeed = 4.5d;                      double maxLevel = Math.Min(song.Levels.Length' 20d) - 1;                      double factor = maxLevel > 0 ? Math.Pow(endSpeed / beginSpeed' 1d / maxLevel) : 1d;                      for (int i = 0; i < 20; i++)                      {                          if (i >= maxLevel)                          {                              attribute.DynamicVisualDensity.Add(endSpeed);                          }                          else                          {                              attribute.DynamicVisualDensity.Add((float)(beginSpeed * Math.Pow(factor' i)));                          }                      }                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage.AggregateGraph2014,AggregateGraph2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph2014\AggregateGraph2014.cs,DoLikeSongPack,The following statement contains a magic number: foreach (var xml in xmlFiles)              {                  // completely skip dlc.xml template files                  if (xml.EndsWith("_RS2014.dlc.xml"))                      continue;                    var xmlSongPack = Path.Combine(songsArrDir' Path.GetFileName(xml));                  File.Copy(xml' xmlSongPack);                    // skip vocal and showlight xml files                  if (xml.EndsWith("_vocals.xml") || xml.EndsWith("_showlights.xml"))                      continue;                    // add DDC to xml arrangement                  if (addDD)                  {                      // check if arrangment has pre existing DD and do not overwrite                      var songXml = Song2014.LoadFromFile(xml);                      var mf = new ManifestFunctions(GameVersion.RS2014);                      if (mf.GetMaxDifficulty(songXml) == 0)                      {                          var consoleOutput = String.Empty;                          // apply DD to xml arrangments... 0 = Ends normally with no error                          var result = DDCreator.ApplyDD(xmlSongPack' phraseLen' removeSus' rampPath' cfgPath' out consoleOutput' true);                          if (result == 1)                              Debug.WriteLine(String.Format("Arrangement file '{0}' => {1}"' Path.GetFileNameWithoutExtension(xml)' "DDC ended with system error " + consoleOutput));                          else if (result == 2)                              Debug.WriteLine(String.Format("Arrangement file '{0}' => {1}"' Path.GetFileNameWithoutExtension(xml)' "DDC ended with application error " + consoleOutput));                      }                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage.AggregateGraph2014,GraphPart,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph2014\GraphPart.cs,GraphPart,The following statement contains a magic number: Value = values[2];
Magic Number,RocksmithToolkitLib.DLCPackage.AggregateGraph2014,GraphItemLLID,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph2014\GraphItem.cs,GraphItemLLID,The following statement contains a magic number: foreach (var graph in graphPartList) {                  var value = graph.Value.Split(new Char[] { '"' })[1];                  switch (graph.Type.Split(new Char[] { '/'' '>' })[5]) {                      case "llid":                          LLID = Guid.Parse(value);                          break;                      case "logpath":                          LogPathDirectory = Canonical;                          LogPathFile = value.Substring(Canonical.Length + 1);                          break;                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage.AggregateGraph2014,GraphItem,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph2014\GraphItem.cs,GraphItem,The following statement contains a magic number: foreach (var graph in graphPartList) {                  var value = graph.Value.Split(new Char[] { '"' })[1];                  switch (graph.Type.Split(new Char[] { '/'' '>' })[5]) {                      case "tag":                          Tag.Add(value);                          break;                      case "canonical":                          Canonical = value;                          break;                      case "name":                          Name = value;                          break;                      case "relpath":                          RelPathDirectory = Canonical;                          RelPathFile = value.Substring(Canonical.Length + 1);                          break;                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage.AggregateGraph,AggregateGraph,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph\AggregateGraph.cs,ReadFromFile,The following statement contains a magic number: using (StreamReader reader = new StreamReader(ntFilePath))              {                  while (true)                  {                      string line = reader.ReadLine();                      if (line == null)                          break;                        var ntParts = line.Split(new Char[] { ' ' });                      if (ntParts.Length != 3) // spaces in a song file name                          for (int i = 3; i < ntParts.Length; i++)                              ntParts[2] = String.Format("{0} {1}"' ntParts[2]' ntParts[i]);                        var agUrn = ntParts[0].Split(new Char[] { ':'' '>' })[2];                      var agType = ntParts[1].Split(new Char[] { '/'' '>' })[5];                      var agValue = ntParts[2].Split(new Char[] { '"'' '"' })[1];                        agGraphNt.Add(new AgGraphNt()                      {                          AgUrn = agUrn'                          AgType = agType'                          AgValue = agValue                      });                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage.AggregateGraph,AggregateGraph,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph\AggregateGraph.cs,ReadFromFile,The following statement contains a magic number: using (StreamReader reader = new StreamReader(ntFilePath))              {                  while (true)                  {                      string line = reader.ReadLine();                      if (line == null)                          break;                        var ntParts = line.Split(new Char[] { ' ' });                      if (ntParts.Length != 3) // spaces in a song file name                          for (int i = 3; i < ntParts.Length; i++)                              ntParts[2] = String.Format("{0} {1}"' ntParts[2]' ntParts[i]);                        var agUrn = ntParts[0].Split(new Char[] { ':'' '>' })[2];                      var agType = ntParts[1].Split(new Char[] { '/'' '>' })[5];                      var agValue = ntParts[2].Split(new Char[] { '"'' '"' })[1];                        agGraphNt.Add(new AgGraphNt()                      {                          AgUrn = agUrn'                          AgType = agType'                          AgValue = agValue                      });                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage.AggregateGraph,AggregateGraph,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph\AggregateGraph.cs,ReadFromFile,The following statement contains a magic number: using (StreamReader reader = new StreamReader(ntFilePath))              {                  while (true)                  {                      string line = reader.ReadLine();                      if (line == null)                          break;                        var ntParts = line.Split(new Char[] { ' ' });                      if (ntParts.Length != 3) // spaces in a song file name                          for (int i = 3; i < ntParts.Length; i++)                              ntParts[2] = String.Format("{0} {1}"' ntParts[2]' ntParts[i]);                        var agUrn = ntParts[0].Split(new Char[] { ':'' '>' })[2];                      var agType = ntParts[1].Split(new Char[] { '/'' '>' })[5];                      var agValue = ntParts[2].Split(new Char[] { '"'' '"' })[1];                        agGraphNt.Add(new AgGraphNt()                      {                          AgUrn = agUrn'                          AgType = agType'                          AgValue = agValue                      });                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage.AggregateGraph,AggregateGraph,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph\AggregateGraph.cs,ReadFromFile,The following statement contains a magic number: using (StreamReader reader = new StreamReader(ntFilePath))              {                  while (true)                  {                      string line = reader.ReadLine();                      if (line == null)                          break;                        var ntParts = line.Split(new Char[] { ' ' });                      if (ntParts.Length != 3) // spaces in a song file name                          for (int i = 3; i < ntParts.Length; i++)                              ntParts[2] = String.Format("{0} {1}"' ntParts[2]' ntParts[i]);                        var agUrn = ntParts[0].Split(new Char[] { ':'' '>' })[2];                      var agType = ntParts[1].Split(new Char[] { '/'' '>' })[5];                      var agValue = ntParts[2].Split(new Char[] { '"'' '"' })[1];                        agGraphNt.Add(new AgGraphNt()                      {                          AgUrn = agUrn'                          AgType = agType'                          AgValue = agValue                      });                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage.AggregateGraph,AggregateGraph,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph\AggregateGraph.cs,ReadFromFile,The following statement contains a magic number: using (StreamReader reader = new StreamReader(ntFilePath))              {                  while (true)                  {                      string line = reader.ReadLine();                      if (line == null)                          break;                        var ntParts = line.Split(new Char[] { ' ' });                      if (ntParts.Length != 3) // spaces in a song file name                          for (int i = 3; i < ntParts.Length; i++)                              ntParts[2] = String.Format("{0} {1}"' ntParts[2]' ntParts[i]);                        var agUrn = ntParts[0].Split(new Char[] { ':'' '>' })[2];                      var agType = ntParts[1].Split(new Char[] { '/'' '>' })[5];                      var agValue = ntParts[2].Split(new Char[] { '"'' '"' })[1];                        agGraphNt.Add(new AgGraphNt()                      {                          AgUrn = agUrn'                          AgType = agType'                          AgValue = agValue                      });                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage.AggregateGraph,AggregateGraph,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph\AggregateGraph.cs,ReadFromFile,The following statement contains a magic number: using (StreamReader reader = new StreamReader(ntFilePath))              {                  while (true)                  {                      string line = reader.ReadLine();                      if (line == null)                          break;                        var ntParts = line.Split(new Char[] { ' ' });                      if (ntParts.Length != 3) // spaces in a song file name                          for (int i = 3; i < ntParts.Length; i++)                              ntParts[2] = String.Format("{0} {1}"' ntParts[2]' ntParts[i]);                        var agUrn = ntParts[0].Split(new Char[] { ':'' '>' })[2];                      var agType = ntParts[1].Split(new Char[] { '/'' '>' })[5];                      var agValue = ntParts[2].Split(new Char[] { '"'' '"' })[1];                        agGraphNt.Add(new AgGraphNt()                      {                          AgUrn = agUrn'                          AgType = agType'                          AgValue = agValue                      });                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage.AggregateGraph,AggregateGraph,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph\AggregateGraph.cs,ReadFromFile,The following statement contains a magic number: using (StreamReader reader = new StreamReader(ntFilePath))              {                  while (true)                  {                      string line = reader.ReadLine();                      if (line == null)                          break;                        var ntParts = line.Split(new Char[] { ' ' });                      if (ntParts.Length != 3) // spaces in a song file name                          for (int i = 3; i < ntParts.Length; i++)                              ntParts[2] = String.Format("{0} {1}"' ntParts[2]' ntParts[i]);                        var agUrn = ntParts[0].Split(new Char[] { ':'' '>' })[2];                      var agType = ntParts[1].Split(new Char[] { '/'' '>' })[5];                      var agValue = ntParts[2].Split(new Char[] { '"'' '"' })[1];                        agGraphNt.Add(new AgGraphNt()                      {                          AgUrn = agUrn'                          AgType = agType'                          AgValue = agValue                      });                  }              }
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest2014.Header,AttributesHeader2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest2014\Header\AttributesHeader2014.cs,AttributesHeader2014,The following statement contains a magic number: NotesHard = arrangement.Sng2014.NoteCount[2];
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest2014.Header,AttributesHeader2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest2014\Header\AttributesHeader2014.cs,AttributesHeader2014,The following statement contains a magic number: SongLength = Math.Round(SongContent.SongLength' 3' MidpointRounding.AwayFromZero);
Magic Number,RocksmithToolkitLib.DLCPackage.Manifest2014.Header,ManifestHeader2014<T>,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest2014\Header\ManifestHeader2014.cs,ManifestHeader2014,The following statement contains a magic number: switch (dlcType) {                  case DLCPackageType.Song:                      if (platform.IsConsole) {                          ModelName = "RSEnumerable_Song_Header";                          IterationVersion = 2;                      }                      InsertRoot = "Static.Songs.Headers";                      Entries = new Dictionary<string' Dictionary<string' T>>();                      break;                  case DLCPackageType.Lesson:                      throw new NotImplementedException("Lesson package type not implemented yet :(");                  case DLCPackageType.Inlay:                      if (platform.IsConsole) {                          ModelName = "RSEnumerable_Guitar_Header";                      }                      InsertRoot = "Static.Guitars.Headers";                      Entries = new Dictionary<string' Dictionary<string' T>>();                      break;              }
Magic Number,RocksmithToolkitLib.PSARC,BigEndianBinaryReader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\BigEndianBinaryReader.cs,ReadDouble,The following statement contains a magic number: byte[] array = new byte[8];
Magic Number,RocksmithToolkitLib.PSARC,BigEndianBinaryReader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\BigEndianBinaryReader.cs,ReadDouble,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				array[7 - i] = this.ReadByte();  			}
Magic Number,RocksmithToolkitLib.PSARC,BigEndianBinaryReader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\BigEndianBinaryReader.cs,ReadDouble,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				array[7 - i] = this.ReadByte();  			}
Magic Number,RocksmithToolkitLib.PSARC,BigEndianBinaryReader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\BigEndianBinaryReader.cs,ReadInt16,The following statement contains a magic number: return (short)((int)this.ReadByte() << 8 | (int)this.ReadByte());
Magic Number,RocksmithToolkitLib.PSARC,BigEndianBinaryReader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\BigEndianBinaryReader.cs,ReadInt32,The following statement contains a magic number: return (int)this.ReadByte() << 24 | (int)this.ReadByte() << 16 | (int)this.ReadByte() << 8 | (int)this.ReadByte();
Magic Number,RocksmithToolkitLib.PSARC,BigEndianBinaryReader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\BigEndianBinaryReader.cs,ReadInt32,The following statement contains a magic number: return (int)this.ReadByte() << 24 | (int)this.ReadByte() << 16 | (int)this.ReadByte() << 8 | (int)this.ReadByte();
Magic Number,RocksmithToolkitLib.PSARC,BigEndianBinaryReader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\BigEndianBinaryReader.cs,ReadInt32,The following statement contains a magic number: return (int)this.ReadByte() << 24 | (int)this.ReadByte() << 16 | (int)this.ReadByte() << 8 | (int)this.ReadByte();
Magic Number,RocksmithToolkitLib.PSARC,BigEndianBinaryReader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\BigEndianBinaryReader.cs,ReadInt64,The following statement contains a magic number: byte[] array = new byte[8];
Magic Number,RocksmithToolkitLib.PSARC,BigEndianBinaryReader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\BigEndianBinaryReader.cs,ReadInt64,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				array[7 - i] = this.ReadByte();  			}
Magic Number,RocksmithToolkitLib.PSARC,BigEndianBinaryReader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\BigEndianBinaryReader.cs,ReadInt64,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				array[7 - i] = this.ReadByte();  			}
Magic Number,RocksmithToolkitLib.PSARC,BigEndianBinaryReader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\BigEndianBinaryReader.cs,ReadSingle,The following statement contains a magic number: byte[] array = new byte[4];
Magic Number,RocksmithToolkitLib.PSARC,BigEndianBinaryReader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\BigEndianBinaryReader.cs,ReadSingle,The following statement contains a magic number: for (int i = 0; i < 4; i++)  			{  				array[3 - i] = this.ReadByte();  			}
Magic Number,RocksmithToolkitLib.PSARC,BigEndianBinaryReader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\BigEndianBinaryReader.cs,ReadSingle,The following statement contains a magic number: for (int i = 0; i < 4; i++)  			{  				array[3 - i] = this.ReadByte();  			}
Magic Number,RocksmithToolkitLib.PSARC,BigEndianBinaryReader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\BigEndianBinaryReader.cs,ReadUInt16,The following statement contains a magic number: byte[] array = new byte[2];
Magic Number,RocksmithToolkitLib.PSARC,BigEndianBinaryReader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\BigEndianBinaryReader.cs,ReadUInt16,The following statement contains a magic number: for (int i = 0; i < 2; i++)  			{  				array[1 - i] = this.ReadByte();  			}
Magic Number,RocksmithToolkitLib.PSARC,BigEndianBinaryReader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\BigEndianBinaryReader.cs,ReadUInt32,The following statement contains a magic number: byte[] array = new byte[4];
Magic Number,RocksmithToolkitLib.PSARC,BigEndianBinaryReader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\BigEndianBinaryReader.cs,ReadUInt32,The following statement contains a magic number: for (int i = 0; i < 4; i++)  			{  				array[3 - i] = this.ReadByte();  			}
Magic Number,RocksmithToolkitLib.PSARC,BigEndianBinaryReader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\BigEndianBinaryReader.cs,ReadUInt32,The following statement contains a magic number: for (int i = 0; i < 4; i++)  			{  				array[3 - i] = this.ReadByte();  			}
Magic Number,RocksmithToolkitLib.PSARC,BigEndianBinaryReader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\BigEndianBinaryReader.cs,ReadUInt64,The following statement contains a magic number: byte[] array = new byte[8];
Magic Number,RocksmithToolkitLib.PSARC,BigEndianBinaryReader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\BigEndianBinaryReader.cs,ReadUInt64,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				array[7 - i] = this.ReadByte();  			}
Magic Number,RocksmithToolkitLib.PSARC,BigEndianBinaryReader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\BigEndianBinaryReader.cs,ReadUInt64,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				array[7 - i] = this.ReadByte();  			}
Magic Number,RocksmithToolkitLib.PSARC,BigEndianBinaryReader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\BigEndianBinaryReader.cs,ReadUInt40,The following statement contains a magic number: byte[] array = new byte[8];
Magic Number,RocksmithToolkitLib.PSARC,BigEndianBinaryReader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\BigEndianBinaryReader.cs,ReadUInt40,The following statement contains a magic number: for (int i = 0; i < 5; i++)  			{  				array[4 - i] = this.ReadByte();  			}
Magic Number,RocksmithToolkitLib.PSARC,BigEndianBinaryReader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\BigEndianBinaryReader.cs,ReadUInt40,The following statement contains a magic number: for (int i = 0; i < 5; i++)  			{  				array[4 - i] = this.ReadByte();  			}
Magic Number,RocksmithToolkitLib.PSARC,BigEndianBinaryReader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\BigEndianBinaryReader.cs,ReadUInt24,The following statement contains a magic number: byte[] array = new byte[4];
Magic Number,RocksmithToolkitLib.PSARC,BigEndianBinaryReader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\BigEndianBinaryReader.cs,ReadUInt24,The following statement contains a magic number: for (int i = 0; i < 3; i++)  			{  				array[2 - i] = this.ReadByte();  			}
Magic Number,RocksmithToolkitLib.PSARC,BigEndianBinaryReader,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\BigEndianBinaryReader.cs,ReadUInt24,The following statement contains a magic number: for (int i = 0; i < 3; i++)  			{  				array[2 - i] = this.ReadByte();  			}
Magic Number,RocksmithToolkitLib.PSARC,BigEndianBinaryWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\BigEndianBinaryWriter.cs,WriteUInt40,The following statement contains a magic number: for (int i = 3; i < bytes.Length; i++)              {                  this.Write(bytes[bytes.Length - i - 1]);              }
Magic Number,RocksmithToolkitLib.PSARC,Entry,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\Entry.cs,UpdateNameMD5,The following statement contains a magic number: MD5 = (Name == String.Empty)? new byte[16] : new MD5CryptoServiceProvider().ComputeHash(Encoding.ASCII.GetBytes(Name));
Magic Number,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,DeflateEntries,The following statement contains a magic number: var step = Math.Round(1.0 / (_toc.Count + 2) * 100' 3);
Magic Number,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,DeflateEntries,The following statement contains a magic number: var step = Math.Round(1.0 / (_toc.Count + 2) * 100' 3);
Magic Number,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,DeflateEntries,The following statement contains a magic number: var step = Math.Round(1.0 / (_toc.Count + 2) * 100' 3);
Magic Number,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,DeflateEntries,The following statement contains a magic number: foreach (Entry entry in _toc)              {                  var zList = new List<Tuple<byte[]' int>>();                  entry.zIndexBegin = (uint)zLengths.Count;                  entry.Data.Seek(0' SeekOrigin.Begin);                    while (entry.Data.Position < entry.Data.Length)                  {                      var array_i = new byte[blockSize];                      var array_o = new byte[blockSize * 2];                      var memoryStream = new MemoryStream(array_o);                        int plain_len = entry.Data.Read(array_i' 0' array_i.Length);                      int packed_len = (int)RijndaelEncryptor.Zip(array_i' memoryStream' plain_len' false);                        if (packed_len >= plain_len)                      {// If packed data "worse" than plain (i.e. already packed) z = 0                          zList.Add(new Tuple<byte[]' int>(array_i' plain_len));                      }                      else                      {// If packed data is good                          if (packed_len < (blockSize - 1))                          {// If packed data fits maximum packed block size z = packed_len                              zList.Add(new Tuple<byte[]' int>(array_o' packed_len));                          }                          else                          {// Write plain. z = 0                              zList.Add(new Tuple<byte[]' int>(array_i' plain_len));                          }                      }                  }                    int zSisesSum = 0;                  foreach (var zSize in zList)                  {                      zSisesSum += zSize.Item2;                      zLengths.Add((uint)zSize.Item2);                  }                    var array3 = new byte[zSisesSum];                  var memoryStream2 = new MemoryStream(array3);                  foreach (var entryblock in zList)                  {                      memoryStream2.Write(entryblock.Item1' 0' entryblock.Item2);                  }                    entryDeflatedData.Add(entry' array3);                  progress += step;                  GlobalExtension.UpdateProgress.Value = (int)progress;                  Console.WriteLine("Deflating: " + ndx++);              }
Magic Number,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,ParseTOC,The following statement contains a magic number: for (int i = 0' tocFiles = (int)_header.NumFiles; i < tocFiles; i++)              {                  _toc.Add(new Entry                  {                      Id = i'                      MD5 = _reader.ReadBytes(16)'                      zIndexBegin = _reader.ReadUInt32()'                      Length = _reader.ReadUInt40()'                      Offset = _reader.ReadUInt40()                  });/* FIXME: general idea was to implement parallel inflate route' still need to re-think this.                  if (i == 0) continue;                  if (i == tocFiles - 1)                      _toc[i].zDatalen = (ulong)_reader.BaseStream.Length - _toc[i].Offset; //HACK: fails if psarc is truncated.                  _toc[i-1].zDatalen = _toc[i].Offset - _toc[i-1].Offset; */              }
Magic Number,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Read,The following statement contains a magic number: if (_header.MagicNumber == 1347633490U)//PSAR (BE)              {                  //Parse Header                  _header.VersionNumber = _reader.ReadUInt32();                  _header.CompressionMethod = _reader.ReadUInt32();                  _header.TotalTOCSize = _reader.ReadUInt32();                  _header.TOCEntrySize = _reader.ReadUInt32();                  _header.NumFiles = _reader.ReadUInt32();                  _header.BlockSizeAlloc = _reader.ReadUInt32();                  _header.ArchiveFlags = _reader.ReadUInt32();                  //Read TOC                  int tocSize = (int)(_header.TotalTOCSize - 32U);                  if (_header.ArchiveFlags == 4)//TOC_ENCRYPTED                  {// Decrypt TOC                      var tocStream = new MemoryStream();                      using (var decStream = new MemoryStream())                      {                          RijndaelEncryptor.DecryptPSARC(psarc' decStream' _header.TotalTOCSize);                            int bytesRead;                          int decSize = 0;                          var buffer = new byte[_header.BlockSizeAlloc];                          while ((bytesRead = decStream.Read(buffer' 0' buffer.Length)) > 0)                          {                              decSize += bytesRead;                              if (decSize > tocSize)                                  bytesRead = tocSize - (decSize - bytesRead);                              tocStream.Write(buffer' 0' bytesRead);                          }                      }                      tocStream.Position = 0;                      _reader = new BigEndianBinaryReader(tocStream);                  }                  ParseTOC();                  //Parse zBlocksSizeList                  int tocChunkSize = (int)(_header.NumFiles * _header.TOCEntrySize);//(int)_reader.BaseStream.Position //don't alter this with. causes issues                  int zNum = (tocSize - tocChunkSize) / bNum;                  var zLengths = new uint[zNum];                  for (int i = 0; i < zNum; i++)                  {                      switch (bNum)                      {                          case 2://64KB                              zLengths[i] = _reader.ReadUInt16();                              break;                          case 3://16MB                              zLengths[i] = _reader.ReadUInt24();                              break;                          case 4://4GB                              zLengths[i] = _reader.ReadUInt32();                              break;                      }                  }                  _zBlocksSizeList = zLengths;//TODO: validate                    _reader.BaseStream.Flush();//Free tocStream resources                  _reader = new BigEndianBinaryReader(psarc);                    // Validate psarc size                  // if (psarc.Length < RequiredPsarcSize())                  // throw new InvalidDataException("Truncated psarc.");                  // try to unpack corrupt CDLC for now                    switch (_header.CompressionMethod)                  {                      case 2053925218: //zlib (BE)                          ReadManifest();                          psarc.Seek(_header.TotalTOCSize' SeekOrigin.Begin);                          if (!lazy)                          {// Decompress Data                              InflateEntries();                          }                          break;                      case 1819962721: //lzma (BE)                          throw new NotImplementedException("LZMA compression not supported.");                      default:                          throw new InvalidDataException("Unknown compression.");                  }              }
Magic Number,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Read,The following statement contains a magic number: if (_header.MagicNumber == 1347633490U)//PSAR (BE)              {                  //Parse Header                  _header.VersionNumber = _reader.ReadUInt32();                  _header.CompressionMethod = _reader.ReadUInt32();                  _header.TotalTOCSize = _reader.ReadUInt32();                  _header.TOCEntrySize = _reader.ReadUInt32();                  _header.NumFiles = _reader.ReadUInt32();                  _header.BlockSizeAlloc = _reader.ReadUInt32();                  _header.ArchiveFlags = _reader.ReadUInt32();                  //Read TOC                  int tocSize = (int)(_header.TotalTOCSize - 32U);                  if (_header.ArchiveFlags == 4)//TOC_ENCRYPTED                  {// Decrypt TOC                      var tocStream = new MemoryStream();                      using (var decStream = new MemoryStream())                      {                          RijndaelEncryptor.DecryptPSARC(psarc' decStream' _header.TotalTOCSize);                            int bytesRead;                          int decSize = 0;                          var buffer = new byte[_header.BlockSizeAlloc];                          while ((bytesRead = decStream.Read(buffer' 0' buffer.Length)) > 0)                          {                              decSize += bytesRead;                              if (decSize > tocSize)                                  bytesRead = tocSize - (decSize - bytesRead);                              tocStream.Write(buffer' 0' bytesRead);                          }                      }                      tocStream.Position = 0;                      _reader = new BigEndianBinaryReader(tocStream);                  }                  ParseTOC();                  //Parse zBlocksSizeList                  int tocChunkSize = (int)(_header.NumFiles * _header.TOCEntrySize);//(int)_reader.BaseStream.Position //don't alter this with. causes issues                  int zNum = (tocSize - tocChunkSize) / bNum;                  var zLengths = new uint[zNum];                  for (int i = 0; i < zNum; i++)                  {                      switch (bNum)                      {                          case 2://64KB                              zLengths[i] = _reader.ReadUInt16();                              break;                          case 3://16MB                              zLengths[i] = _reader.ReadUInt24();                              break;                          case 4://4GB                              zLengths[i] = _reader.ReadUInt32();                              break;                      }                  }                  _zBlocksSizeList = zLengths;//TODO: validate                    _reader.BaseStream.Flush();//Free tocStream resources                  _reader = new BigEndianBinaryReader(psarc);                    // Validate psarc size                  // if (psarc.Length < RequiredPsarcSize())                  // throw new InvalidDataException("Truncated psarc.");                  // try to unpack corrupt CDLC for now                    switch (_header.CompressionMethod)                  {                      case 2053925218: //zlib (BE)                          ReadManifest();                          psarc.Seek(_header.TotalTOCSize' SeekOrigin.Begin);                          if (!lazy)                          {// Decompress Data                              InflateEntries();                          }                          break;                      case 1819962721: //lzma (BE)                          throw new NotImplementedException("LZMA compression not supported.");                      default:                          throw new InvalidDataException("Unknown compression.");                  }              }
Magic Number,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Read,The following statement contains a magic number: if (_header.MagicNumber == 1347633490U)//PSAR (BE)              {                  //Parse Header                  _header.VersionNumber = _reader.ReadUInt32();                  _header.CompressionMethod = _reader.ReadUInt32();                  _header.TotalTOCSize = _reader.ReadUInt32();                  _header.TOCEntrySize = _reader.ReadUInt32();                  _header.NumFiles = _reader.ReadUInt32();                  _header.BlockSizeAlloc = _reader.ReadUInt32();                  _header.ArchiveFlags = _reader.ReadUInt32();                  //Read TOC                  int tocSize = (int)(_header.TotalTOCSize - 32U);                  if (_header.ArchiveFlags == 4)//TOC_ENCRYPTED                  {// Decrypt TOC                      var tocStream = new MemoryStream();                      using (var decStream = new MemoryStream())                      {                          RijndaelEncryptor.DecryptPSARC(psarc' decStream' _header.TotalTOCSize);                            int bytesRead;                          int decSize = 0;                          var buffer = new byte[_header.BlockSizeAlloc];                          while ((bytesRead = decStream.Read(buffer' 0' buffer.Length)) > 0)                          {                              decSize += bytesRead;                              if (decSize > tocSize)                                  bytesRead = tocSize - (decSize - bytesRead);                              tocStream.Write(buffer' 0' bytesRead);                          }                      }                      tocStream.Position = 0;                      _reader = new BigEndianBinaryReader(tocStream);                  }                  ParseTOC();                  //Parse zBlocksSizeList                  int tocChunkSize = (int)(_header.NumFiles * _header.TOCEntrySize);//(int)_reader.BaseStream.Position //don't alter this with. causes issues                  int zNum = (tocSize - tocChunkSize) / bNum;                  var zLengths = new uint[zNum];                  for (int i = 0; i < zNum; i++)                  {                      switch (bNum)                      {                          case 2://64KB                              zLengths[i] = _reader.ReadUInt16();                              break;                          case 3://16MB                              zLengths[i] = _reader.ReadUInt24();                              break;                          case 4://4GB                              zLengths[i] = _reader.ReadUInt32();                              break;                      }                  }                  _zBlocksSizeList = zLengths;//TODO: validate                    _reader.BaseStream.Flush();//Free tocStream resources                  _reader = new BigEndianBinaryReader(psarc);                    // Validate psarc size                  // if (psarc.Length < RequiredPsarcSize())                  // throw new InvalidDataException("Truncated psarc.");                  // try to unpack corrupt CDLC for now                    switch (_header.CompressionMethod)                  {                      case 2053925218: //zlib (BE)                          ReadManifest();                          psarc.Seek(_header.TotalTOCSize' SeekOrigin.Begin);                          if (!lazy)                          {// Decompress Data                              InflateEntries();                          }                          break;                      case 1819962721: //lzma (BE)                          throw new NotImplementedException("LZMA compression not supported.");                      default:                          throw new InvalidDataException("Unknown compression.");                  }              }
Magic Number,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Read,The following statement contains a magic number: if (_header.MagicNumber == 1347633490U)//PSAR (BE)              {                  //Parse Header                  _header.VersionNumber = _reader.ReadUInt32();                  _header.CompressionMethod = _reader.ReadUInt32();                  _header.TotalTOCSize = _reader.ReadUInt32();                  _header.TOCEntrySize = _reader.ReadUInt32();                  _header.NumFiles = _reader.ReadUInt32();                  _header.BlockSizeAlloc = _reader.ReadUInt32();                  _header.ArchiveFlags = _reader.ReadUInt32();                  //Read TOC                  int tocSize = (int)(_header.TotalTOCSize - 32U);                  if (_header.ArchiveFlags == 4)//TOC_ENCRYPTED                  {// Decrypt TOC                      var tocStream = new MemoryStream();                      using (var decStream = new MemoryStream())                      {                          RijndaelEncryptor.DecryptPSARC(psarc' decStream' _header.TotalTOCSize);                            int bytesRead;                          int decSize = 0;                          var buffer = new byte[_header.BlockSizeAlloc];                          while ((bytesRead = decStream.Read(buffer' 0' buffer.Length)) > 0)                          {                              decSize += bytesRead;                              if (decSize > tocSize)                                  bytesRead = tocSize - (decSize - bytesRead);                              tocStream.Write(buffer' 0' bytesRead);                          }                      }                      tocStream.Position = 0;                      _reader = new BigEndianBinaryReader(tocStream);                  }                  ParseTOC();                  //Parse zBlocksSizeList                  int tocChunkSize = (int)(_header.NumFiles * _header.TOCEntrySize);//(int)_reader.BaseStream.Position //don't alter this with. causes issues                  int zNum = (tocSize - tocChunkSize) / bNum;                  var zLengths = new uint[zNum];                  for (int i = 0; i < zNum; i++)                  {                      switch (bNum)                      {                          case 2://64KB                              zLengths[i] = _reader.ReadUInt16();                              break;                          case 3://16MB                              zLengths[i] = _reader.ReadUInt24();                              break;                          case 4://4GB                              zLengths[i] = _reader.ReadUInt32();                              break;                      }                  }                  _zBlocksSizeList = zLengths;//TODO: validate                    _reader.BaseStream.Flush();//Free tocStream resources                  _reader = new BigEndianBinaryReader(psarc);                    // Validate psarc size                  // if (psarc.Length < RequiredPsarcSize())                  // throw new InvalidDataException("Truncated psarc.");                  // try to unpack corrupt CDLC for now                    switch (_header.CompressionMethod)                  {                      case 2053925218: //zlib (BE)                          ReadManifest();                          psarc.Seek(_header.TotalTOCSize' SeekOrigin.Begin);                          if (!lazy)                          {// Decompress Data                              InflateEntries();                          }                          break;                      case 1819962721: //lzma (BE)                          throw new NotImplementedException("LZMA compression not supported.");                      default:                          throw new InvalidDataException("Unknown compression.");                  }              }
Magic Number,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Read,The following statement contains a magic number: if (_header.MagicNumber == 1347633490U)//PSAR (BE)              {                  //Parse Header                  _header.VersionNumber = _reader.ReadUInt32();                  _header.CompressionMethod = _reader.ReadUInt32();                  _header.TotalTOCSize = _reader.ReadUInt32();                  _header.TOCEntrySize = _reader.ReadUInt32();                  _header.NumFiles = _reader.ReadUInt32();                  _header.BlockSizeAlloc = _reader.ReadUInt32();                  _header.ArchiveFlags = _reader.ReadUInt32();                  //Read TOC                  int tocSize = (int)(_header.TotalTOCSize - 32U);                  if (_header.ArchiveFlags == 4)//TOC_ENCRYPTED                  {// Decrypt TOC                      var tocStream = new MemoryStream();                      using (var decStream = new MemoryStream())                      {                          RijndaelEncryptor.DecryptPSARC(psarc' decStream' _header.TotalTOCSize);                            int bytesRead;                          int decSize = 0;                          var buffer = new byte[_header.BlockSizeAlloc];                          while ((bytesRead = decStream.Read(buffer' 0' buffer.Length)) > 0)                          {                              decSize += bytesRead;                              if (decSize > tocSize)                                  bytesRead = tocSize - (decSize - bytesRead);                              tocStream.Write(buffer' 0' bytesRead);                          }                      }                      tocStream.Position = 0;                      _reader = new BigEndianBinaryReader(tocStream);                  }                  ParseTOC();                  //Parse zBlocksSizeList                  int tocChunkSize = (int)(_header.NumFiles * _header.TOCEntrySize);//(int)_reader.BaseStream.Position //don't alter this with. causes issues                  int zNum = (tocSize - tocChunkSize) / bNum;                  var zLengths = new uint[zNum];                  for (int i = 0; i < zNum; i++)                  {                      switch (bNum)                      {                          case 2://64KB                              zLengths[i] = _reader.ReadUInt16();                              break;                          case 3://16MB                              zLengths[i] = _reader.ReadUInt24();                              break;                          case 4://4GB                              zLengths[i] = _reader.ReadUInt32();                              break;                      }                  }                  _zBlocksSizeList = zLengths;//TODO: validate                    _reader.BaseStream.Flush();//Free tocStream resources                  _reader = new BigEndianBinaryReader(psarc);                    // Validate psarc size                  // if (psarc.Length < RequiredPsarcSize())                  // throw new InvalidDataException("Truncated psarc.");                  // try to unpack corrupt CDLC for now                    switch (_header.CompressionMethod)                  {                      case 2053925218: //zlib (BE)                          ReadManifest();                          psarc.Seek(_header.TotalTOCSize' SeekOrigin.Begin);                          if (!lazy)                          {// Decompress Data                              InflateEntries();                          }                          break;                      case 1819962721: //lzma (BE)                          throw new NotImplementedException("LZMA compression not supported.");                      default:                          throw new InvalidDataException("Unknown compression.");                  }              }
Magic Number,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Read,The following statement contains a magic number: if (_header.MagicNumber == 1347633490U)//PSAR (BE)              {                  //Parse Header                  _header.VersionNumber = _reader.ReadUInt32();                  _header.CompressionMethod = _reader.ReadUInt32();                  _header.TotalTOCSize = _reader.ReadUInt32();                  _header.TOCEntrySize = _reader.ReadUInt32();                  _header.NumFiles = _reader.ReadUInt32();                  _header.BlockSizeAlloc = _reader.ReadUInt32();                  _header.ArchiveFlags = _reader.ReadUInt32();                  //Read TOC                  int tocSize = (int)(_header.TotalTOCSize - 32U);                  if (_header.ArchiveFlags == 4)//TOC_ENCRYPTED                  {// Decrypt TOC                      var tocStream = new MemoryStream();                      using (var decStream = new MemoryStream())                      {                          RijndaelEncryptor.DecryptPSARC(psarc' decStream' _header.TotalTOCSize);                            int bytesRead;                          int decSize = 0;                          var buffer = new byte[_header.BlockSizeAlloc];                          while ((bytesRead = decStream.Read(buffer' 0' buffer.Length)) > 0)                          {                              decSize += bytesRead;                              if (decSize > tocSize)                                  bytesRead = tocSize - (decSize - bytesRead);                              tocStream.Write(buffer' 0' bytesRead);                          }                      }                      tocStream.Position = 0;                      _reader = new BigEndianBinaryReader(tocStream);                  }                  ParseTOC();                  //Parse zBlocksSizeList                  int tocChunkSize = (int)(_header.NumFiles * _header.TOCEntrySize);//(int)_reader.BaseStream.Position //don't alter this with. causes issues                  int zNum = (tocSize - tocChunkSize) / bNum;                  var zLengths = new uint[zNum];                  for (int i = 0; i < zNum; i++)                  {                      switch (bNum)                      {                          case 2://64KB                              zLengths[i] = _reader.ReadUInt16();                              break;                          case 3://16MB                              zLengths[i] = _reader.ReadUInt24();                              break;                          case 4://4GB                              zLengths[i] = _reader.ReadUInt32();                              break;                      }                  }                  _zBlocksSizeList = zLengths;//TODO: validate                    _reader.BaseStream.Flush();//Free tocStream resources                  _reader = new BigEndianBinaryReader(psarc);                    // Validate psarc size                  // if (psarc.Length < RequiredPsarcSize())                  // throw new InvalidDataException("Truncated psarc.");                  // try to unpack corrupt CDLC for now                    switch (_header.CompressionMethod)                  {                      case 2053925218: //zlib (BE)                          ReadManifest();                          psarc.Seek(_header.TotalTOCSize' SeekOrigin.Begin);                          if (!lazy)                          {// Decompress Data                              InflateEntries();                          }                          break;                      case 1819962721: //lzma (BE)                          throw new NotImplementedException("LZMA compression not supported.");                      default:                          throw new InvalidDataException("Unknown compression.");                  }              }
Magic Number,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Write,The following statement contains a magic number: _header.TotalTOCSize = (uint)(32 + _toc.Count * _header.TOCEntrySize + zLengths.Count * bNum);
Magic Number,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Write,The following statement contains a magic number: foreach (uint zLen in zLengths)              {                  switch (bNum)                  {                      case 2://16bit                          _writer.Write((ushort)zLen);                          break;                      case 3://24bit                          _writer.WriteUInt24(zLen);                          break;                      case 4://32bit                          _writer.Write(zLen);                          break;                  }              }
Magic Number,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Write,The following statement contains a magic number: foreach (uint zLen in zLengths)              {                  switch (bNum)                  {                      case 2://16bit                          _writer.Write((ushort)zLen);                          break;                      case 3://24bit                          _writer.WriteUInt24(zLen);                          break;                      case 4://32bit                          _writer.Write(zLen);                          break;                  }              }
Magic Number,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Write,The following statement contains a magic number: foreach (uint zLen in zLengths)              {                  switch (bNum)                  {                      case 2://16bit                          _writer.Write((ushort)zLen);                          break;                      case 3://24bit                          _writer.WriteUInt24(zLen);                          break;                      case 4://32bit                          _writer.Write(zLen);                          break;                  }              }
Magic Number,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Write,The following statement contains a magic number: var step = Math.Round(1D / (this.TOC.Count + 2) * 100' 3);
Magic Number,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Write,The following statement contains a magic number: var step = Math.Round(1D / (this.TOC.Count + 2) * 100' 3);
Magic Number,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Write,The following statement contains a magic number: var step = Math.Round(1D / (this.TOC.Count + 2) * 100' 3);
Magic Number,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Write,The following statement contains a magic number: if (encrypt) // Encrypt TOC              {                  using (var outputStream = new MemoryStreamExtension())                  {                      var encStream = new MemoryStreamExtension();                      inputStream.Position = 32L;                      RijndaelEncryptor.EncryptPSARC(inputStream' outputStream' _header.TotalTOCSize);                      inputStream.Position = 0L;                        // quick copy header from input stream                      var buffer = new byte[32];                      encStream.Write(buffer' 0' inputStream.Read(buffer' 0' buffer.Length));                      encStream.Position = 32; //sanity check ofc                      inputStream.Flush();                        int tocSize = (int)_header.TotalTOCSize - 32;                      int decSize = 0;                      buffer = new byte[1024 * 16]; // more efficient use of memory                        ndx = 0; // for debugging                      step = Math.Round(1D / (((double)tocSize / buffer.Length) + 2) * 100' 3);                      progress = 0;                      GlobalExtension.ShowProgress("Writing Encrypted Data ...");                        int bytesRead;                      while ((bytesRead = outputStream.Read(buffer' 0' buffer.Length)) > 0)                      {                          decSize += bytesRead;                          if (decSize > tocSize)                              bytesRead = tocSize - (decSize - bytesRead);                            encStream.Write(buffer' 0' bytesRead);                            progress += step;                          GlobalExtension.UpdateProgress.Value = (int)progress;                          Console.WriteLine("Encrypted: " + ndx++);                      }                        inputStream.Position = 0;                      encStream.Position = 0;                      encStream.CopyTo(inputStream' (int)_header.BlockSizeAlloc);                  }              }
Magic Number,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Write,The following statement contains a magic number: if (encrypt) // Encrypt TOC              {                  using (var outputStream = new MemoryStreamExtension())                  {                      var encStream = new MemoryStreamExtension();                      inputStream.Position = 32L;                      RijndaelEncryptor.EncryptPSARC(inputStream' outputStream' _header.TotalTOCSize);                      inputStream.Position = 0L;                        // quick copy header from input stream                      var buffer = new byte[32];                      encStream.Write(buffer' 0' inputStream.Read(buffer' 0' buffer.Length));                      encStream.Position = 32; //sanity check ofc                      inputStream.Flush();                        int tocSize = (int)_header.TotalTOCSize - 32;                      int decSize = 0;                      buffer = new byte[1024 * 16]; // more efficient use of memory                        ndx = 0; // for debugging                      step = Math.Round(1D / (((double)tocSize / buffer.Length) + 2) * 100' 3);                      progress = 0;                      GlobalExtension.ShowProgress("Writing Encrypted Data ...");                        int bytesRead;                      while ((bytesRead = outputStream.Read(buffer' 0' buffer.Length)) > 0)                      {                          decSize += bytesRead;                          if (decSize > tocSize)                              bytesRead = tocSize - (decSize - bytesRead);                            encStream.Write(buffer' 0' bytesRead);                            progress += step;                          GlobalExtension.UpdateProgress.Value = (int)progress;                          Console.WriteLine("Encrypted: " + ndx++);                      }                        inputStream.Position = 0;                      encStream.Position = 0;                      encStream.CopyTo(inputStream' (int)_header.BlockSizeAlloc);                  }              }
Magic Number,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Write,The following statement contains a magic number: if (encrypt) // Encrypt TOC              {                  using (var outputStream = new MemoryStreamExtension())                  {                      var encStream = new MemoryStreamExtension();                      inputStream.Position = 32L;                      RijndaelEncryptor.EncryptPSARC(inputStream' outputStream' _header.TotalTOCSize);                      inputStream.Position = 0L;                        // quick copy header from input stream                      var buffer = new byte[32];                      encStream.Write(buffer' 0' inputStream.Read(buffer' 0' buffer.Length));                      encStream.Position = 32; //sanity check ofc                      inputStream.Flush();                        int tocSize = (int)_header.TotalTOCSize - 32;                      int decSize = 0;                      buffer = new byte[1024 * 16]; // more efficient use of memory                        ndx = 0; // for debugging                      step = Math.Round(1D / (((double)tocSize / buffer.Length) + 2) * 100' 3);                      progress = 0;                      GlobalExtension.ShowProgress("Writing Encrypted Data ...");                        int bytesRead;                      while ((bytesRead = outputStream.Read(buffer' 0' buffer.Length)) > 0)                      {                          decSize += bytesRead;                          if (decSize > tocSize)                              bytesRead = tocSize - (decSize - bytesRead);                            encStream.Write(buffer' 0' bytesRead);                            progress += step;                          GlobalExtension.UpdateProgress.Value = (int)progress;                          Console.WriteLine("Encrypted: " + ndx++);                      }                        inputStream.Position = 0;                      encStream.Position = 0;                      encStream.CopyTo(inputStream' (int)_header.BlockSizeAlloc);                  }              }
Magic Number,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Write,The following statement contains a magic number: if (encrypt) // Encrypt TOC              {                  using (var outputStream = new MemoryStreamExtension())                  {                      var encStream = new MemoryStreamExtension();                      inputStream.Position = 32L;                      RijndaelEncryptor.EncryptPSARC(inputStream' outputStream' _header.TotalTOCSize);                      inputStream.Position = 0L;                        // quick copy header from input stream                      var buffer = new byte[32];                      encStream.Write(buffer' 0' inputStream.Read(buffer' 0' buffer.Length));                      encStream.Position = 32; //sanity check ofc                      inputStream.Flush();                        int tocSize = (int)_header.TotalTOCSize - 32;                      int decSize = 0;                      buffer = new byte[1024 * 16]; // more efficient use of memory                        ndx = 0; // for debugging                      step = Math.Round(1D / (((double)tocSize / buffer.Length) + 2) * 100' 3);                      progress = 0;                      GlobalExtension.ShowProgress("Writing Encrypted Data ...");                        int bytesRead;                      while ((bytesRead = outputStream.Read(buffer' 0' buffer.Length)) > 0)                      {                          decSize += bytesRead;                          if (decSize > tocSize)                              bytesRead = tocSize - (decSize - bytesRead);                            encStream.Write(buffer' 0' bytesRead);                            progress += step;                          GlobalExtension.UpdateProgress.Value = (int)progress;                          Console.WriteLine("Encrypted: " + ndx++);                      }                        inputStream.Position = 0;                      encStream.Position = 0;                      encStream.CopyTo(inputStream' (int)_header.BlockSizeAlloc);                  }              }
Magic Number,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Write,The following statement contains a magic number: if (encrypt) // Encrypt TOC              {                  using (var outputStream = new MemoryStreamExtension())                  {                      var encStream = new MemoryStreamExtension();                      inputStream.Position = 32L;                      RijndaelEncryptor.EncryptPSARC(inputStream' outputStream' _header.TotalTOCSize);                      inputStream.Position = 0L;                        // quick copy header from input stream                      var buffer = new byte[32];                      encStream.Write(buffer' 0' inputStream.Read(buffer' 0' buffer.Length));                      encStream.Position = 32; //sanity check ofc                      inputStream.Flush();                        int tocSize = (int)_header.TotalTOCSize - 32;                      int decSize = 0;                      buffer = new byte[1024 * 16]; // more efficient use of memory                        ndx = 0; // for debugging                      step = Math.Round(1D / (((double)tocSize / buffer.Length) + 2) * 100' 3);                      progress = 0;                      GlobalExtension.ShowProgress("Writing Encrypted Data ...");                        int bytesRead;                      while ((bytesRead = outputStream.Read(buffer' 0' buffer.Length)) > 0)                      {                          decSize += bytesRead;                          if (decSize > tocSize)                              bytesRead = tocSize - (decSize - bytesRead);                            encStream.Write(buffer' 0' bytesRead);                            progress += step;                          GlobalExtension.UpdateProgress.Value = (int)progress;                          Console.WriteLine("Encrypted: " + ndx++);                      }                        inputStream.Position = 0;                      encStream.Position = 0;                      encStream.CopyTo(inputStream' (int)_header.BlockSizeAlloc);                  }              }
Magic Number,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Write,The following statement contains a magic number: if (encrypt) // Encrypt TOC              {                  using (var outputStream = new MemoryStreamExtension())                  {                      var encStream = new MemoryStreamExtension();                      inputStream.Position = 32L;                      RijndaelEncryptor.EncryptPSARC(inputStream' outputStream' _header.TotalTOCSize);                      inputStream.Position = 0L;                        // quick copy header from input stream                      var buffer = new byte[32];                      encStream.Write(buffer' 0' inputStream.Read(buffer' 0' buffer.Length));                      encStream.Position = 32; //sanity check ofc                      inputStream.Flush();                        int tocSize = (int)_header.TotalTOCSize - 32;                      int decSize = 0;                      buffer = new byte[1024 * 16]; // more efficient use of memory                        ndx = 0; // for debugging                      step = Math.Round(1D / (((double)tocSize / buffer.Length) + 2) * 100' 3);                      progress = 0;                      GlobalExtension.ShowProgress("Writing Encrypted Data ...");                        int bytesRead;                      while ((bytesRead = outputStream.Read(buffer' 0' buffer.Length)) > 0)                      {                          decSize += bytesRead;                          if (decSize > tocSize)                              bytesRead = tocSize - (decSize - bytesRead);                            encStream.Write(buffer' 0' bytesRead);                            progress += step;                          GlobalExtension.UpdateProgress.Value = (int)progress;                          Console.WriteLine("Encrypted: " + ndx++);                      }                        inputStream.Position = 0;                      encStream.Position = 0;                      encStream.CopyTo(inputStream' (int)_header.BlockSizeAlloc);                  }              }
Magic Number,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Write,The following statement contains a magic number: if (encrypt) // Encrypt TOC              {                  using (var outputStream = new MemoryStreamExtension())                  {                      var encStream = new MemoryStreamExtension();                      inputStream.Position = 32L;                      RijndaelEncryptor.EncryptPSARC(inputStream' outputStream' _header.TotalTOCSize);                      inputStream.Position = 0L;                        // quick copy header from input stream                      var buffer = new byte[32];                      encStream.Write(buffer' 0' inputStream.Read(buffer' 0' buffer.Length));                      encStream.Position = 32; //sanity check ofc                      inputStream.Flush();                        int tocSize = (int)_header.TotalTOCSize - 32;                      int decSize = 0;                      buffer = new byte[1024 * 16]; // more efficient use of memory                        ndx = 0; // for debugging                      step = Math.Round(1D / (((double)tocSize / buffer.Length) + 2) * 100' 3);                      progress = 0;                      GlobalExtension.ShowProgress("Writing Encrypted Data ...");                        int bytesRead;                      while ((bytesRead = outputStream.Read(buffer' 0' buffer.Length)) > 0)                      {                          decSize += bytesRead;                          if (decSize > tocSize)                              bytesRead = tocSize - (decSize - bytesRead);                            encStream.Write(buffer' 0' bytesRead);                            progress += step;                          GlobalExtension.UpdateProgress.Value = (int)progress;                          Console.WriteLine("Encrypted: " + ndx++);                      }                        inputStream.Position = 0;                      encStream.Position = 0;                      encStream.CopyTo(inputStream' (int)_header.BlockSizeAlloc);                  }              }
Magic Number,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Write,The following statement contains a magic number: if (encrypt) // Encrypt TOC              {                  using (var outputStream = new MemoryStreamExtension())                  {                      var encStream = new MemoryStreamExtension();                      inputStream.Position = 32L;                      RijndaelEncryptor.EncryptPSARC(inputStream' outputStream' _header.TotalTOCSize);                      inputStream.Position = 0L;                        // quick copy header from input stream                      var buffer = new byte[32];                      encStream.Write(buffer' 0' inputStream.Read(buffer' 0' buffer.Length));                      encStream.Position = 32; //sanity check ofc                      inputStream.Flush();                        int tocSize = (int)_header.TotalTOCSize - 32;                      int decSize = 0;                      buffer = new byte[1024 * 16]; // more efficient use of memory                        ndx = 0; // for debugging                      step = Math.Round(1D / (((double)tocSize / buffer.Length) + 2) * 100' 3);                      progress = 0;                      GlobalExtension.ShowProgress("Writing Encrypted Data ...");                        int bytesRead;                      while ((bytesRead = outputStream.Read(buffer' 0' buffer.Length)) > 0)                      {                          decSize += bytesRead;                          if (decSize > tocSize)                              bytesRead = tocSize - (decSize - bytesRead);                            encStream.Write(buffer' 0' bytesRead);                            progress += step;                          GlobalExtension.UpdateProgress.Value = (int)progress;                          Console.WriteLine("Encrypted: " + ndx++);                      }                        inputStream.Position = 0;                      encStream.Position = 0;                      encStream.CopyTo(inputStream' (int)_header.BlockSizeAlloc);                  }              }
Magic Number,RocksmithToolkitLib.PSARC,Header,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Header,The following statement contains a magic number: MagicNumber = 1347633490;
Magic Number,RocksmithToolkitLib.PSARC,Header,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Header,The following statement contains a magic number: VersionNumber = 65540;
Magic Number,RocksmithToolkitLib.PSARC,Header,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Header,The following statement contains a magic number: CompressionMethod = 2053925218;
Magic Number,RocksmithToolkitLib.PSARC,Header,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Header,The following statement contains a magic number: TOCEntrySize = 30;
Magic Number,RocksmithToolkitLib.PSARC,Header,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Header,The following statement contains a magic number: BlockSizeAlloc = 65536;
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,ReadSong,The following statement contains a magic number: try              {                  tuning[0] = songXml.Tuning.String0;                  tuning[1] = songXml.Tuning.String1;                  tuning[2] = songXml.Tuning.String2;                  tuning[3] = songXml.Tuning.String3;                  tuning[4] = songXml.Tuning.String4;                  tuning[5] = songXml.Tuning.String5;              }              catch              {                  // just ignore any error and use any tuning that is available from XML file              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,ReadSong,The following statement contains a magic number: try              {                  tuning[0] = songXml.Tuning.String0;                  tuning[1] = songXml.Tuning.String1;                  tuning[2] = songXml.Tuning.String2;                  tuning[3] = songXml.Tuning.String3;                  tuning[4] = songXml.Tuning.String4;                  tuning[5] = songXml.Tuning.String5;              }              catch              {                  // just ignore any error and use any tuning that is available from XML file              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,ReadSong,The following statement contains a magic number: try              {                  tuning[0] = songXml.Tuning.String0;                  tuning[1] = songXml.Tuning.String1;                  tuning[2] = songXml.Tuning.String2;                  tuning[3] = songXml.Tuning.String3;                  tuning[4] = songXml.Tuning.String4;                  tuning[5] = songXml.Tuning.String5;              }              catch              {                  // just ignore any error and use any tuning that is available from XML file              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,ReadSong,The following statement contains a magic number: try              {                  tuning[0] = songXml.Tuning.String0;                  tuning[1] = songXml.Tuning.String1;                  tuning[2] = songXml.Tuning.String2;                  tuning[3] = songXml.Tuning.String3;                  tuning[4] = songXml.Tuning.String4;                  tuning[5] = songXml.Tuning.String5;              }              catch              {                  // just ignore any error and use any tuning that is available from XML file              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,GetMidiNote,The following statement contains a magic number: Int32 note = StandardMidiNotes[str] + tuning[str] + fret - (bass ? 12 : 0);
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,getChordNote,The following statement contains a magic number: if (handShape[crd.ChordId] != null)              {                  List<int> cNote = new List<int>();                  cNote.AddRange(new int[]{                      GetMidiNote(tuning' (Byte)0' (Byte)handShape[crd.ChordId].Fret0' bass' capo)'                      GetMidiNote(tuning' (Byte)1' (Byte)handShape[crd.ChordId].Fret1' bass' capo)'                      GetMidiNote(tuning' (Byte)2' (Byte)handShape[crd.ChordId].Fret2' bass' capo)'                      GetMidiNote(tuning' (Byte)3' (Byte)handShape[crd.ChordId].Fret3' bass' capo)'                      GetMidiNote(tuning' (Byte)4' (Byte)handShape[crd.ChordId].Fret4' bass' capo)'                      GetMidiNote(tuning' (Byte)5' (Byte)handShape[crd.ChordId].Fret5' bass' capo)                  });                  // Cleanup for -1 notes                  var cOut = cNote.Where(c => c > 0).ToList();                  if (cOut.Count < 1)                      return 35;                  // Return bass note for doublestops                  if (cOut.Count < 3 && cOut[0] > cOut[1])                      return cOut[1];                  // Return most used note                  return cOut.Count > 3 ? cOut.FirstOrDefault(n => cOut.Any(t => t > n)) : cOut[0];              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,getChordNote,The following statement contains a magic number: if (handShape[crd.ChordId] != null)              {                  List<int> cNote = new List<int>();                  cNote.AddRange(new int[]{                      GetMidiNote(tuning' (Byte)0' (Byte)handShape[crd.ChordId].Fret0' bass' capo)'                      GetMidiNote(tuning' (Byte)1' (Byte)handShape[crd.ChordId].Fret1' bass' capo)'                      GetMidiNote(tuning' (Byte)2' (Byte)handShape[crd.ChordId].Fret2' bass' capo)'                      GetMidiNote(tuning' (Byte)3' (Byte)handShape[crd.ChordId].Fret3' bass' capo)'                      GetMidiNote(tuning' (Byte)4' (Byte)handShape[crd.ChordId].Fret4' bass' capo)'                      GetMidiNote(tuning' (Byte)5' (Byte)handShape[crd.ChordId].Fret5' bass' capo)                  });                  // Cleanup for -1 notes                  var cOut = cNote.Where(c => c > 0).ToList();                  if (cOut.Count < 1)                      return 35;                  // Return bass note for doublestops                  if (cOut.Count < 3 && cOut[0] > cOut[1])                      return cOut[1];                  // Return most used note                  return cOut.Count > 3 ? cOut.FirstOrDefault(n => cOut.Any(t => t > n)) : cOut[0];              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,getChordNote,The following statement contains a magic number: if (handShape[crd.ChordId] != null)              {                  List<int> cNote = new List<int>();                  cNote.AddRange(new int[]{                      GetMidiNote(tuning' (Byte)0' (Byte)handShape[crd.ChordId].Fret0' bass' capo)'                      GetMidiNote(tuning' (Byte)1' (Byte)handShape[crd.ChordId].Fret1' bass' capo)'                      GetMidiNote(tuning' (Byte)2' (Byte)handShape[crd.ChordId].Fret2' bass' capo)'                      GetMidiNote(tuning' (Byte)3' (Byte)handShape[crd.ChordId].Fret3' bass' capo)'                      GetMidiNote(tuning' (Byte)4' (Byte)handShape[crd.ChordId].Fret4' bass' capo)'                      GetMidiNote(tuning' (Byte)5' (Byte)handShape[crd.ChordId].Fret5' bass' capo)                  });                  // Cleanup for -1 notes                  var cOut = cNote.Where(c => c > 0).ToList();                  if (cOut.Count < 1)                      return 35;                  // Return bass note for doublestops                  if (cOut.Count < 3 && cOut[0] > cOut[1])                      return cOut[1];                  // Return most used note                  return cOut.Count > 3 ? cOut.FirstOrDefault(n => cOut.Any(t => t > n)) : cOut[0];              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,getChordNote,The following statement contains a magic number: if (handShape[crd.ChordId] != null)              {                  List<int> cNote = new List<int>();                  cNote.AddRange(new int[]{                      GetMidiNote(tuning' (Byte)0' (Byte)handShape[crd.ChordId].Fret0' bass' capo)'                      GetMidiNote(tuning' (Byte)1' (Byte)handShape[crd.ChordId].Fret1' bass' capo)'                      GetMidiNote(tuning' (Byte)2' (Byte)handShape[crd.ChordId].Fret2' bass' capo)'                      GetMidiNote(tuning' (Byte)3' (Byte)handShape[crd.ChordId].Fret3' bass' capo)'                      GetMidiNote(tuning' (Byte)4' (Byte)handShape[crd.ChordId].Fret4' bass' capo)'                      GetMidiNote(tuning' (Byte)5' (Byte)handShape[crd.ChordId].Fret5' bass' capo)                  });                  // Cleanup for -1 notes                  var cOut = cNote.Where(c => c > 0).ToList();                  if (cOut.Count < 1)                      return 35;                  // Return bass note for doublestops                  if (cOut.Count < 3 && cOut[0] > cOut[1])                      return cOut[1];                  // Return most used note                  return cOut.Count > 3 ? cOut.FirstOrDefault(n => cOut.Any(t => t > n)) : cOut[0];              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,getChordNote,The following statement contains a magic number: if (handShape[crd.ChordId] != null)              {                  List<int> cNote = new List<int>();                  cNote.AddRange(new int[]{                      GetMidiNote(tuning' (Byte)0' (Byte)handShape[crd.ChordId].Fret0' bass' capo)'                      GetMidiNote(tuning' (Byte)1' (Byte)handShape[crd.ChordId].Fret1' bass' capo)'                      GetMidiNote(tuning' (Byte)2' (Byte)handShape[crd.ChordId].Fret2' bass' capo)'                      GetMidiNote(tuning' (Byte)3' (Byte)handShape[crd.ChordId].Fret3' bass' capo)'                      GetMidiNote(tuning' (Byte)4' (Byte)handShape[crd.ChordId].Fret4' bass' capo)'                      GetMidiNote(tuning' (Byte)5' (Byte)handShape[crd.ChordId].Fret5' bass' capo)                  });                  // Cleanup for -1 notes                  var cOut = cNote.Where(c => c > 0).ToList();                  if (cOut.Count < 1)                      return 35;                  // Return bass note for doublestops                  if (cOut.Count < 3 && cOut[0] > cOut[1])                      return cOut[1];                  // Return most used note                  return cOut.Count > 3 ? cOut.FirstOrDefault(n => cOut.Any(t => t > n)) : cOut[0];              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,getChordNote,The following statement contains a magic number: if (handShape[crd.ChordId] != null)              {                  List<int> cNote = new List<int>();                  cNote.AddRange(new int[]{                      GetMidiNote(tuning' (Byte)0' (Byte)handShape[crd.ChordId].Fret0' bass' capo)'                      GetMidiNote(tuning' (Byte)1' (Byte)handShape[crd.ChordId].Fret1' bass' capo)'                      GetMidiNote(tuning' (Byte)2' (Byte)handShape[crd.ChordId].Fret2' bass' capo)'                      GetMidiNote(tuning' (Byte)3' (Byte)handShape[crd.ChordId].Fret3' bass' capo)'                      GetMidiNote(tuning' (Byte)4' (Byte)handShape[crd.ChordId].Fret4' bass' capo)'                      GetMidiNote(tuning' (Byte)5' (Byte)handShape[crd.ChordId].Fret5' bass' capo)                  });                  // Cleanup for -1 notes                  var cOut = cNote.Where(c => c > 0).ToList();                  if (cOut.Count < 1)                      return 35;                  // Return bass note for doublestops                  if (cOut.Count < 3 && cOut[0] > cOut[1])                      return cOut[1];                  // Return most used note                  return cOut.Count > 3 ? cOut.FirstOrDefault(n => cOut.Any(t => t > n)) : cOut[0];              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,getChordNote,The following statement contains a magic number: if (handShape[crd.ChordId] != null)              {                  List<int> cNote = new List<int>();                  cNote.AddRange(new int[]{                      GetMidiNote(tuning' (Byte)0' (Byte)handShape[crd.ChordId].Fret0' bass' capo)'                      GetMidiNote(tuning' (Byte)1' (Byte)handShape[crd.ChordId].Fret1' bass' capo)'                      GetMidiNote(tuning' (Byte)2' (Byte)handShape[crd.ChordId].Fret2' bass' capo)'                      GetMidiNote(tuning' (Byte)3' (Byte)handShape[crd.ChordId].Fret3' bass' capo)'                      GetMidiNote(tuning' (Byte)4' (Byte)handShape[crd.ChordId].Fret4' bass' capo)'                      GetMidiNote(tuning' (Byte)5' (Byte)handShape[crd.ChordId].Fret5' bass' capo)                  });                  // Cleanup for -1 notes                  var cOut = cNote.Where(c => c > 0).ToList();                  if (cOut.Count < 1)                      return 35;                  // Return bass note for doublestops                  if (cOut.Count < 3 && cOut[0] > cOut[1])                      return cOut[1];                  // Return most used note                  return cOut.Count > 3 ? cOut.FirstOrDefault(n => cOut.Any(t => t > n)) : cOut[0];              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,getChordNote,The following statement contains a magic number: return 35;
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseMetadata,The following statement contains a magic number: NoteCount = new int[3];
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseMetadata,The following statement contains a magic number: NoteCount[2] = getNoteCount(sng' 2);
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseMetadata,The following statement contains a magic number: NoteCount[2] = getNoteCount(sng' 2);
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseMetadata,The following statement contains a magic number: sng.Metadata.MaxScore = 100000;
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseMetadata,The following statement contains a magic number: sng.Metadata.MaxNotesAndChords = NoteCount[2];
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseMetadata,The following statement contains a magic number: sng.Metadata.StringCount = 6;
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseEbeats,The following statement contains a magic number: for (int i = 0; i < sng.BPMs.Count; i++)              {                  var ebeat = xml.Ebeats[i];                  var bpm = new Bpm();                  bpm.Time = ebeat.Time;                  if (ebeat.Measure >= 0)                  {                      measure = ebeat.Measure;                      beat = 0;                  }                  else                  {                      beat++;                  }                  bpm.Measure = measure;                  bpm.Beat = beat;                  bpm.PhraseIteration = getPhraseIterationId(xml' bpm.Time' true);                  if (beat == 0)                  {                      bpm.Mask |= 1;                      if (measure % 2 == 0)                          bpm.Mask |= 2;                  }                  sng.BPMs.BPMs[i] = bpm;              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseEbeats,The following statement contains a magic number: for (int i = 0; i < sng.BPMs.Count; i++)              {                  var ebeat = xml.Ebeats[i];                  var bpm = new Bpm();                  bpm.Time = ebeat.Time;                  if (ebeat.Measure >= 0)                  {                      measure = ebeat.Measure;                      beat = 0;                  }                  else                  {                      beat++;                  }                  bpm.Measure = measure;                  bpm.Beat = beat;                  bpm.PhraseIteration = getPhraseIterationId(xml' bpm.Time' true);                  if (beat == 0)                  {                      bpm.Mask |= 1;                      if (measure % 2 == 0)                          bpm.Mask |= 2;                  }                  sng.BPMs.BPMs[i] = bpm;              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseChords,The following statement contains a magic number: for (int i = 0; i < sng.Chords.Count; i++)              {                  var chord = xml.ChordTemplates[i];                  var c = new Chord();                    // fix for 'Object reference not set to an instance of an object' error                  if (chord.DisplayName == null)                      chord.DisplayName = String.Empty;                    if (chord.DisplayName.EndsWith("arp"))                      c.Mask |= CON.CHORD_MASK_ARPEGGIO;                  else if (chord.DisplayName.EndsWith("nop"))                      c.Mask |= CON.CHORD_MASK_NOP;                    c.Frets[0] = (Byte)chord.Fret0;                  c.Frets[1] = (Byte)chord.Fret1;                  c.Frets[2] = (Byte)chord.Fret2;                  c.Frets[3] = (Byte)chord.Fret3;                  c.Frets[4] = (Byte)chord.Fret4;                  c.Frets[5] = (Byte)chord.Fret5;                  c.Fingers[0] = (Byte)chord.Finger0;                  c.Fingers[1] = (Byte)chord.Finger1;                  c.Fingers[2] = (Byte)chord.Finger2;                  c.Fingers[3] = (Byte)chord.Finger3;                  c.Fingers[4] = (Byte)chord.Finger4;                  c.Fingers[5] = (Byte)chord.Finger5;                  for (Byte s = 0; s < 6; s++)                      c.Notes[s] = GetMidiNote(tuning' s' c.Frets[s]' bass' xml.Capo' template: true);                  readString(chord.ChordName' c.Name);                  sng.Chords.Chords[i] = c;              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseChords,The following statement contains a magic number: for (int i = 0; i < sng.Chords.Count; i++)              {                  var chord = xml.ChordTemplates[i];                  var c = new Chord();                    // fix for 'Object reference not set to an instance of an object' error                  if (chord.DisplayName == null)                      chord.DisplayName = String.Empty;                    if (chord.DisplayName.EndsWith("arp"))                      c.Mask |= CON.CHORD_MASK_ARPEGGIO;                  else if (chord.DisplayName.EndsWith("nop"))                      c.Mask |= CON.CHORD_MASK_NOP;                    c.Frets[0] = (Byte)chord.Fret0;                  c.Frets[1] = (Byte)chord.Fret1;                  c.Frets[2] = (Byte)chord.Fret2;                  c.Frets[3] = (Byte)chord.Fret3;                  c.Frets[4] = (Byte)chord.Fret4;                  c.Frets[5] = (Byte)chord.Fret5;                  c.Fingers[0] = (Byte)chord.Finger0;                  c.Fingers[1] = (Byte)chord.Finger1;                  c.Fingers[2] = (Byte)chord.Finger2;                  c.Fingers[3] = (Byte)chord.Finger3;                  c.Fingers[4] = (Byte)chord.Finger4;                  c.Fingers[5] = (Byte)chord.Finger5;                  for (Byte s = 0; s < 6; s++)                      c.Notes[s] = GetMidiNote(tuning' s' c.Frets[s]' bass' xml.Capo' template: true);                  readString(chord.ChordName' c.Name);                  sng.Chords.Chords[i] = c;              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseChords,The following statement contains a magic number: for (int i = 0; i < sng.Chords.Count; i++)              {                  var chord = xml.ChordTemplates[i];                  var c = new Chord();                    // fix for 'Object reference not set to an instance of an object' error                  if (chord.DisplayName == null)                      chord.DisplayName = String.Empty;                    if (chord.DisplayName.EndsWith("arp"))                      c.Mask |= CON.CHORD_MASK_ARPEGGIO;                  else if (chord.DisplayName.EndsWith("nop"))                      c.Mask |= CON.CHORD_MASK_NOP;                    c.Frets[0] = (Byte)chord.Fret0;                  c.Frets[1] = (Byte)chord.Fret1;                  c.Frets[2] = (Byte)chord.Fret2;                  c.Frets[3] = (Byte)chord.Fret3;                  c.Frets[4] = (Byte)chord.Fret4;                  c.Frets[5] = (Byte)chord.Fret5;                  c.Fingers[0] = (Byte)chord.Finger0;                  c.Fingers[1] = (Byte)chord.Finger1;                  c.Fingers[2] = (Byte)chord.Finger2;                  c.Fingers[3] = (Byte)chord.Finger3;                  c.Fingers[4] = (Byte)chord.Finger4;                  c.Fingers[5] = (Byte)chord.Finger5;                  for (Byte s = 0; s < 6; s++)                      c.Notes[s] = GetMidiNote(tuning' s' c.Frets[s]' bass' xml.Capo' template: true);                  readString(chord.ChordName' c.Name);                  sng.Chords.Chords[i] = c;              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseChords,The following statement contains a magic number: for (int i = 0; i < sng.Chords.Count; i++)              {                  var chord = xml.ChordTemplates[i];                  var c = new Chord();                    // fix for 'Object reference not set to an instance of an object' error                  if (chord.DisplayName == null)                      chord.DisplayName = String.Empty;                    if (chord.DisplayName.EndsWith("arp"))                      c.Mask |= CON.CHORD_MASK_ARPEGGIO;                  else if (chord.DisplayName.EndsWith("nop"))                      c.Mask |= CON.CHORD_MASK_NOP;                    c.Frets[0] = (Byte)chord.Fret0;                  c.Frets[1] = (Byte)chord.Fret1;                  c.Frets[2] = (Byte)chord.Fret2;                  c.Frets[3] = (Byte)chord.Fret3;                  c.Frets[4] = (Byte)chord.Fret4;                  c.Frets[5] = (Byte)chord.Fret5;                  c.Fingers[0] = (Byte)chord.Finger0;                  c.Fingers[1] = (Byte)chord.Finger1;                  c.Fingers[2] = (Byte)chord.Finger2;                  c.Fingers[3] = (Byte)chord.Finger3;                  c.Fingers[4] = (Byte)chord.Finger4;                  c.Fingers[5] = (Byte)chord.Finger5;                  for (Byte s = 0; s < 6; s++)                      c.Notes[s] = GetMidiNote(tuning' s' c.Frets[s]' bass' xml.Capo' template: true);                  readString(chord.ChordName' c.Name);                  sng.Chords.Chords[i] = c;              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseChords,The following statement contains a magic number: for (int i = 0; i < sng.Chords.Count; i++)              {                  var chord = xml.ChordTemplates[i];                  var c = new Chord();                    // fix for 'Object reference not set to an instance of an object' error                  if (chord.DisplayName == null)                      chord.DisplayName = String.Empty;                    if (chord.DisplayName.EndsWith("arp"))                      c.Mask |= CON.CHORD_MASK_ARPEGGIO;                  else if (chord.DisplayName.EndsWith("nop"))                      c.Mask |= CON.CHORD_MASK_NOP;                    c.Frets[0] = (Byte)chord.Fret0;                  c.Frets[1] = (Byte)chord.Fret1;                  c.Frets[2] = (Byte)chord.Fret2;                  c.Frets[3] = (Byte)chord.Fret3;                  c.Frets[4] = (Byte)chord.Fret4;                  c.Frets[5] = (Byte)chord.Fret5;                  c.Fingers[0] = (Byte)chord.Finger0;                  c.Fingers[1] = (Byte)chord.Finger1;                  c.Fingers[2] = (Byte)chord.Finger2;                  c.Fingers[3] = (Byte)chord.Finger3;                  c.Fingers[4] = (Byte)chord.Finger4;                  c.Fingers[5] = (Byte)chord.Finger5;                  for (Byte s = 0; s < 6; s++)                      c.Notes[s] = GetMidiNote(tuning' s' c.Frets[s]' bass' xml.Capo' template: true);                  readString(chord.ChordName' c.Name);                  sng.Chords.Chords[i] = c;              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseChords,The following statement contains a magic number: for (int i = 0; i < sng.Chords.Count; i++)              {                  var chord = xml.ChordTemplates[i];                  var c = new Chord();                    // fix for 'Object reference not set to an instance of an object' error                  if (chord.DisplayName == null)                      chord.DisplayName = String.Empty;                    if (chord.DisplayName.EndsWith("arp"))                      c.Mask |= CON.CHORD_MASK_ARPEGGIO;                  else if (chord.DisplayName.EndsWith("nop"))                      c.Mask |= CON.CHORD_MASK_NOP;                    c.Frets[0] = (Byte)chord.Fret0;                  c.Frets[1] = (Byte)chord.Fret1;                  c.Frets[2] = (Byte)chord.Fret2;                  c.Frets[3] = (Byte)chord.Fret3;                  c.Frets[4] = (Byte)chord.Fret4;                  c.Frets[5] = (Byte)chord.Fret5;                  c.Fingers[0] = (Byte)chord.Finger0;                  c.Fingers[1] = (Byte)chord.Finger1;                  c.Fingers[2] = (Byte)chord.Finger2;                  c.Fingers[3] = (Byte)chord.Finger3;                  c.Fingers[4] = (Byte)chord.Finger4;                  c.Fingers[5] = (Byte)chord.Finger5;                  for (Byte s = 0; s < 6; s++)                      c.Notes[s] = GetMidiNote(tuning' s' c.Frets[s]' bass' xml.Capo' template: true);                  readString(chord.ChordName' c.Name);                  sng.Chords.Chords[i] = c;              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseChords,The following statement contains a magic number: for (int i = 0; i < sng.Chords.Count; i++)              {                  var chord = xml.ChordTemplates[i];                  var c = new Chord();                    // fix for 'Object reference not set to an instance of an object' error                  if (chord.DisplayName == null)                      chord.DisplayName = String.Empty;                    if (chord.DisplayName.EndsWith("arp"))                      c.Mask |= CON.CHORD_MASK_ARPEGGIO;                  else if (chord.DisplayName.EndsWith("nop"))                      c.Mask |= CON.CHORD_MASK_NOP;                    c.Frets[0] = (Byte)chord.Fret0;                  c.Frets[1] = (Byte)chord.Fret1;                  c.Frets[2] = (Byte)chord.Fret2;                  c.Frets[3] = (Byte)chord.Fret3;                  c.Frets[4] = (Byte)chord.Fret4;                  c.Frets[5] = (Byte)chord.Fret5;                  c.Fingers[0] = (Byte)chord.Finger0;                  c.Fingers[1] = (Byte)chord.Finger1;                  c.Fingers[2] = (Byte)chord.Finger2;                  c.Fingers[3] = (Byte)chord.Finger3;                  c.Fingers[4] = (Byte)chord.Finger4;                  c.Fingers[5] = (Byte)chord.Finger5;                  for (Byte s = 0; s < 6; s++)                      c.Notes[s] = GetMidiNote(tuning' s' c.Frets[s]' bass' xml.Capo' template: true);                  readString(chord.ChordName' c.Name);                  sng.Chords.Chords[i] = c;              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseChords,The following statement contains a magic number: for (int i = 0; i < sng.Chords.Count; i++)              {                  var chord = xml.ChordTemplates[i];                  var c = new Chord();                    // fix for 'Object reference not set to an instance of an object' error                  if (chord.DisplayName == null)                      chord.DisplayName = String.Empty;                    if (chord.DisplayName.EndsWith("arp"))                      c.Mask |= CON.CHORD_MASK_ARPEGGIO;                  else if (chord.DisplayName.EndsWith("nop"))                      c.Mask |= CON.CHORD_MASK_NOP;                    c.Frets[0] = (Byte)chord.Fret0;                  c.Frets[1] = (Byte)chord.Fret1;                  c.Frets[2] = (Byte)chord.Fret2;                  c.Frets[3] = (Byte)chord.Fret3;                  c.Frets[4] = (Byte)chord.Fret4;                  c.Frets[5] = (Byte)chord.Fret5;                  c.Fingers[0] = (Byte)chord.Finger0;                  c.Fingers[1] = (Byte)chord.Finger1;                  c.Fingers[2] = (Byte)chord.Finger2;                  c.Fingers[3] = (Byte)chord.Finger3;                  c.Fingers[4] = (Byte)chord.Finger4;                  c.Fingers[5] = (Byte)chord.Finger5;                  for (Byte s = 0; s < 6; s++)                      c.Notes[s] = GetMidiNote(tuning' s' c.Frets[s]' bass' xml.Capo' template: true);                  readString(chord.ChordName' c.Name);                  sng.Chords.Chords[i] = c;              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseChords,The following statement contains a magic number: for (int i = 0; i < sng.Chords.Count; i++)              {                  var chord = xml.ChordTemplates[i];                  var c = new Chord();                    // fix for 'Object reference not set to an instance of an object' error                  if (chord.DisplayName == null)                      chord.DisplayName = String.Empty;                    if (chord.DisplayName.EndsWith("arp"))                      c.Mask |= CON.CHORD_MASK_ARPEGGIO;                  else if (chord.DisplayName.EndsWith("nop"))                      c.Mask |= CON.CHORD_MASK_NOP;                    c.Frets[0] = (Byte)chord.Fret0;                  c.Frets[1] = (Byte)chord.Fret1;                  c.Frets[2] = (Byte)chord.Fret2;                  c.Frets[3] = (Byte)chord.Fret3;                  c.Frets[4] = (Byte)chord.Fret4;                  c.Frets[5] = (Byte)chord.Fret5;                  c.Fingers[0] = (Byte)chord.Finger0;                  c.Fingers[1] = (Byte)chord.Finger1;                  c.Fingers[2] = (Byte)chord.Finger2;                  c.Fingers[3] = (Byte)chord.Finger3;                  c.Fingers[4] = (Byte)chord.Finger4;                  c.Fingers[5] = (Byte)chord.Finger5;                  for (Byte s = 0; s < 6; s++)                      c.Notes[s] = GetMidiNote(tuning' s' c.Frets[s]' bass' xml.Capo' template: true);                  readString(chord.ChordName' c.Name);                  sng.Chords.Chords[i] = c;              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,addChordNotes,The following statement contains a magic number: for (int i = 0; i < 6; i++)              {                  SongNote2014 n = null;                  foreach (var cn in chord.ChordNotes)                  {                      if (cn.String == i)                      {                          n = cn;                          break;                      }                  }                  // TODO: need to figure out which masks are not applied                  c.NoteMask[i] = parseNoteMask(n' false);                  c.BendData[i] = new BendData();                  c.BendData[i].BendData32 = parseBendData(n' false);                  if (n != null && n.BendValues != null)                      c.BendData[i].UsedCount = n.BendValues.Length;                  if (n != null)                  {                      c.SlideTo[i] = (Byte)n.SlideTo;                      c.SlideUnpitchTo[i] = (Byte)n.SlideUnpitchTo;                  }                  else                  {                      c.SlideTo[i] = unchecked((Byte)(-1));                      c.SlideUnpitchTo[i] = unchecked((Byte)(-1));                  }                  if (n != null)                      c.Vibrato[i] = n.Vibrato;              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parsePhraseIterations,The following statement contains a magic number: for (int i = 0; i < sng.PhraseIterations.Count; i++)              {                  var piter = xml.PhraseIterations[i];                  var p = new PhraseIteration();                  p.PhraseId = piter.PhraseId;                  p.StartTime = piter.Time;                  if (i + 1 < sng.PhraseIterations.Count)                      p.NextPhraseTime = xml.PhraseIterations[i + 1].Time;                  else                      p.NextPhraseTime = xml.SongLength;                  // default to (0' 0' max)                  // they use Medium (previous) value if there is hero=3 missing                  p.Difficulty[2] = xml.Phrases[p.PhraseId].MaxDifficulty;                  if (piter.HeroLevels != null)                      foreach (var h in piter.HeroLevels)                          p.Difficulty[h.Hero - 1] = h.Difficulty;                  sng.PhraseIterations.PhraseIterations[i] = p;              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseTones,The following statement contains a magic number: for (int i = 0; i < sng.Tones.Count; i++)              {                  var tn = xml.Tones[i];                  var t = new Tone { Time = tn.Time };                    try                  {                      if (String.IsNullOrEmpty(xml.ToneBase))                          throw new InvalidDataException("ToneBase must be defined.");                        // fix for undefined tone name (tone name should be shorter)                      if (xml.ToneBase.ToLower() == tn.Name.ToLower())                          t.ToneId = 0;                        if (xml.ToneA.ToLower() == tn.Name.ToLower())                          t.ToneId = 0;                      else if (xml.ToneB.ToLower() == tn.Name.ToLower())                          t.ToneId = 1;                      else if (xml.ToneC.ToLower() == tn.Name.ToLower())                          t.ToneId = 2;                      else if (xml.ToneD.ToLower() == tn.Name.ToLower())                          t.ToneId = 3;                        sng.Tones.Tones[i] = t;                  }                  catch (Exception)                  {                      throw new InvalidDataException("There is tone name error in XML Arrangement: " + xml.Arrangement + "  " + tn.Name + " is not properly defined." + Environment.NewLine +                           "Use EOF to re-author custom tones or Notepad to attempt manual repair.");                  }              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseTones,The following statement contains a magic number: for (int i = 0; i < sng.Tones.Count; i++)              {                  var tn = xml.Tones[i];                  var t = new Tone { Time = tn.Time };                    try                  {                      if (String.IsNullOrEmpty(xml.ToneBase))                          throw new InvalidDataException("ToneBase must be defined.");                        // fix for undefined tone name (tone name should be shorter)                      if (xml.ToneBase.ToLower() == tn.Name.ToLower())                          t.ToneId = 0;                        if (xml.ToneA.ToLower() == tn.Name.ToLower())                          t.ToneId = 0;                      else if (xml.ToneB.ToLower() == tn.Name.ToLower())                          t.ToneId = 1;                      else if (xml.ToneC.ToLower() == tn.Name.ToLower())                          t.ToneId = 2;                      else if (xml.ToneD.ToLower() == tn.Name.ToLower())                          t.ToneId = 3;                        sng.Tones.Tones[i] = t;                  }                  catch (Exception)                  {                      throw new InvalidDataException("There is tone name error in XML Arrangement: " + xml.Arrangement + "  " + tn.Name + " is not properly defined." + Environment.NewLine +                           "Use EOF to re-author custom tones or Notepad to attempt manual repair.");                  }              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseDNAs,The following statement contains a magic number: DNACount = new int[4];
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseDNAs,The following statement contains a magic number: foreach (var e in xml.Events)              {                  Int32 id = -1;                  switch (e.Code)                  {                      case "dna_none":                          id = 0;                          break;                      case "dna_solo":                          id = 1;                          break;                      case "dna_riff":                          id = 2;                          break;                      case "dna_chord":                          id = 3;                          break;                  }                    if (id != -1)                  {                      var dna = new Dna();                      dna.Time = e.Time;                      dna.DnaId = id;                      DNACount[id] += 1;                      dnas.Add(dna);                  }              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseDNAs,The following statement contains a magic number: foreach (var e in xml.Events)              {                  Int32 id = -1;                  switch (e.Code)                  {                      case "dna_none":                          id = 0;                          break;                      case "dna_solo":                          id = 1;                          break;                      case "dna_riff":                          id = 2;                          break;                      case "dna_chord":                          id = 3;                          break;                  }                    if (id != -1)                  {                      var dna = new Dna();                      dna.Time = e.Time;                      dna.DnaId = id;                      DNACount[id] += 1;                      dnas.Add(dna);                  }              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseSections,The following statement contains a magic number: for (int i = 0; i < sng.Sections.Count; i++)              {                  var section = xml.Sections[i];                  var s = new Section();                  readString(section.Name' s.Name);                  s.Number = section.Number;                  s.StartTime = section.StartTime;                  if (i + 1 < sng.Sections.Count)                      s.EndTime = xml.Sections[i + 1].StartTime;                  else                      s.EndTime = xml.SongLength;                  s.StartPhraseIterationId = getPhraseIterationId(xml' s.StartTime' false);                  s.EndPhraseIterationId = getPhraseIterationId(xml' s.EndTime' true);                  for (int j = getMaxDifficulty(xml); j >= 0; j--)                  {                      // used string mask for section at all difficulty j                      Byte mask = 0;                      foreach (var note in xml.Levels[j].Notes)                          if (note.Time >= s.StartTime && note.Time < s.EndTime)                          {                              mask |= (Byte)(1 << note.String);                          }                      foreach (var chord in xml.Levels[j].Chords)                          if (chord.Time >= s.StartTime && chord.Time < s.EndTime)                          {                              var ch = xml.ChordTemplates[chord.ChordId];                              if (ch.Fret0 != -1)                                  mask |= (Byte)(1 << 0);                              if (ch.Fret1 != -1)                                  mask |= (Byte)(1 << 1);                              if (ch.Fret2 != -1)                                  mask |= (Byte)(1 << 2);                              if (ch.Fret3 != -1)                                  mask |= (Byte)(1 << 3);                              if (ch.Fret4 != -1)                                  mask |= (Byte)(1 << 4);                              if (ch.Fret5 != -1)                                  mask |= (Byte)(1 << 5);                                if (mask == 0x3F)                                  break;                          }                        // use mask from next section if there are no notes                      if (mask == 0 && j < getMaxDifficulty(xml))                          mask = s.StringMask[j + 1];                        s.StringMask[j] = mask;                  }                  sng.Sections.Sections[i] = s;              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseSections,The following statement contains a magic number: for (int i = 0; i < sng.Sections.Count; i++)              {                  var section = xml.Sections[i];                  var s = new Section();                  readString(section.Name' s.Name);                  s.Number = section.Number;                  s.StartTime = section.StartTime;                  if (i + 1 < sng.Sections.Count)                      s.EndTime = xml.Sections[i + 1].StartTime;                  else                      s.EndTime = xml.SongLength;                  s.StartPhraseIterationId = getPhraseIterationId(xml' s.StartTime' false);                  s.EndPhraseIterationId = getPhraseIterationId(xml' s.EndTime' true);                  for (int j = getMaxDifficulty(xml); j >= 0; j--)                  {                      // used string mask for section at all difficulty j                      Byte mask = 0;                      foreach (var note in xml.Levels[j].Notes)                          if (note.Time >= s.StartTime && note.Time < s.EndTime)                          {                              mask |= (Byte)(1 << note.String);                          }                      foreach (var chord in xml.Levels[j].Chords)                          if (chord.Time >= s.StartTime && chord.Time < s.EndTime)                          {                              var ch = xml.ChordTemplates[chord.ChordId];                              if (ch.Fret0 != -1)                                  mask |= (Byte)(1 << 0);                              if (ch.Fret1 != -1)                                  mask |= (Byte)(1 << 1);                              if (ch.Fret2 != -1)                                  mask |= (Byte)(1 << 2);                              if (ch.Fret3 != -1)                                  mask |= (Byte)(1 << 3);                              if (ch.Fret4 != -1)                                  mask |= (Byte)(1 << 4);                              if (ch.Fret5 != -1)                                  mask |= (Byte)(1 << 5);                                if (mask == 0x3F)                                  break;                          }                        // use mask from next section if there are no notes                      if (mask == 0 && j < getMaxDifficulty(xml))                          mask = s.StringMask[j + 1];                        s.StringMask[j] = mask;                  }                  sng.Sections.Sections[i] = s;              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseSections,The following statement contains a magic number: for (int i = 0; i < sng.Sections.Count; i++)              {                  var section = xml.Sections[i];                  var s = new Section();                  readString(section.Name' s.Name);                  s.Number = section.Number;                  s.StartTime = section.StartTime;                  if (i + 1 < sng.Sections.Count)                      s.EndTime = xml.Sections[i + 1].StartTime;                  else                      s.EndTime = xml.SongLength;                  s.StartPhraseIterationId = getPhraseIterationId(xml' s.StartTime' false);                  s.EndPhraseIterationId = getPhraseIterationId(xml' s.EndTime' true);                  for (int j = getMaxDifficulty(xml); j >= 0; j--)                  {                      // used string mask for section at all difficulty j                      Byte mask = 0;                      foreach (var note in xml.Levels[j].Notes)                          if (note.Time >= s.StartTime && note.Time < s.EndTime)                          {                              mask |= (Byte)(1 << note.String);                          }                      foreach (var chord in xml.Levels[j].Chords)                          if (chord.Time >= s.StartTime && chord.Time < s.EndTime)                          {                              var ch = xml.ChordTemplates[chord.ChordId];                              if (ch.Fret0 != -1)                                  mask |= (Byte)(1 << 0);                              if (ch.Fret1 != -1)                                  mask |= (Byte)(1 << 1);                              if (ch.Fret2 != -1)                                  mask |= (Byte)(1 << 2);                              if (ch.Fret3 != -1)                                  mask |= (Byte)(1 << 3);                              if (ch.Fret4 != -1)                                  mask |= (Byte)(1 << 4);                              if (ch.Fret5 != -1)                                  mask |= (Byte)(1 << 5);                                if (mask == 0x3F)                                  break;                          }                        // use mask from next section if there are no notes                      if (mask == 0 && j < getMaxDifficulty(xml))                          mask = s.StringMask[j + 1];                        s.StringMask[j] = mask;                  }                  sng.Sections.Sections[i] = s;              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseSections,The following statement contains a magic number: for (int i = 0; i < sng.Sections.Count; i++)              {                  var section = xml.Sections[i];                  var s = new Section();                  readString(section.Name' s.Name);                  s.Number = section.Number;                  s.StartTime = section.StartTime;                  if (i + 1 < sng.Sections.Count)                      s.EndTime = xml.Sections[i + 1].StartTime;                  else                      s.EndTime = xml.SongLength;                  s.StartPhraseIterationId = getPhraseIterationId(xml' s.StartTime' false);                  s.EndPhraseIterationId = getPhraseIterationId(xml' s.EndTime' true);                  for (int j = getMaxDifficulty(xml); j >= 0; j--)                  {                      // used string mask for section at all difficulty j                      Byte mask = 0;                      foreach (var note in xml.Levels[j].Notes)                          if (note.Time >= s.StartTime && note.Time < s.EndTime)                          {                              mask |= (Byte)(1 << note.String);                          }                      foreach (var chord in xml.Levels[j].Chords)                          if (chord.Time >= s.StartTime && chord.Time < s.EndTime)                          {                              var ch = xml.ChordTemplates[chord.ChordId];                              if (ch.Fret0 != -1)                                  mask |= (Byte)(1 << 0);                              if (ch.Fret1 != -1)                                  mask |= (Byte)(1 << 1);                              if (ch.Fret2 != -1)                                  mask |= (Byte)(1 << 2);                              if (ch.Fret3 != -1)                                  mask |= (Byte)(1 << 3);                              if (ch.Fret4 != -1)                                  mask |= (Byte)(1 << 4);                              if (ch.Fret5 != -1)                                  mask |= (Byte)(1 << 5);                                if (mask == 0x3F)                                  break;                          }                        // use mask from next section if there are no notes                      if (mask == 0 && j < getMaxDifficulty(xml))                          mask = s.StringMask[j + 1];                        s.StringMask[j] = mask;                  }                  sng.Sections.Sections[i] = s;              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseChord,The following statement contains a magic number: for (int str = 0; str < 6; str++)                  if (sng.Chords.Chords[chord.ChordId].Frets[str] != 255)                      ++cnt;
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseChord,The following statement contains a magic number: for (int str = 0; str < 6; str++)                  if (sng.Chords.Chords[chord.ChordId].Frets[str] != 255)                      ++cnt;
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseChord,The following statement contains a magic number: if (cnt == 2)                  n.NoteMask |= CON.NOTE_MASK_DOUBLESTOP;
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseBendData,The following statement contains a magic number: Int32 count = 32;
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseArrangements,The following statement contains a magic number: for (int i = 0; i < sng.Arrangements.Count; i++)              {                  var level = xml.Levels[i];                  var a = new Arrangement();                  a.Difficulty = level.Difficulty;                    var anchors = new AnchorSection();                  anchors.Count = level.Anchors.Length;                  anchors.Anchors = new Anchor[anchors.Count];                      for (int j = 0; j < anchors.Count; j++)                  {                      var anchor = new Anchor();                      anchor.StartBeatTime = level.Anchors[j].Time;                      if (j + 1 < anchors.Count)                          anchor.EndBeatTime = level.Anchors[j + 1].Time;                      else                          // last phrase iteration = noguitar/end                          anchor.EndBeatTime = xml.PhraseIterations[xml.PhraseIterations.Length - 1].Time;                      // TODO: not 100% clear                      // times will be updated later                      // these "garbage" values are everywhere!                      //anchor.Unk3_FirstNoteTime = (float) 3.4028234663852886e+38;                      //anchor.Unk4_LastNoteTime = (float) 1.1754943508222875e-38;                      anchor.FretId = (byte)level.Anchors[j].Fret;                      anchor.Width = (Int32)level.Anchors[j].Width;                      anchor.PhraseIterationId = getPhraseIterationId(xml' anchor.StartBeatTime' false);                      anchors.Anchors[j] = anchor;                  }                    a.Anchors = anchors;                  // each slideTo will get anchor extension                  a.AnchorExtensions = new AnchorExtensionSection();                    foreach (var note in level.Notes)                      if (note.SlideTo != -1)                          ++a.AnchorExtensions.Count;                    a.AnchorExtensions.AnchorExtensions = new AnchorExtension[a.AnchorExtensions.Count];                  // Fingerprints1 is for handshapes without "arp" displayName                  a.Fingerprints1 = new FingerprintSection();                  // Fingerprints2 is for handshapes with "arp" displayName                  a.Fingerprints2 = new FingerprintSection();                    var fp1 = new List<Fingerprint>();                  var fp2 = new List<Fingerprint>();                  foreach (var h in level.HandShapes)                  {                      if (h.ChordId < 0) continue;                      var fp = new Fingerprint                      {                          ChordId = h.ChordId'                          StartTime = h.StartTime'                          EndTime = h.EndTime                          // TODO: not always StartTime                          //fp.Unk3_FirstNoteTime = fp.StartTime;                          //fp.Unk4_LastNoteTime = fp.StartTime;                      };                        if (xml.ChordTemplates[fp.ChordId].DisplayName.EndsWith("arp"))                          fp2.Add(fp);                      else                          fp1.Add(fp);                  }                    a.Fingerprints1.Count = fp1.Count;                  a.Fingerprints1.Fingerprints = fp1.ToArray();                  a.Fingerprints2.Count = fp2.Count;                  a.Fingerprints2.Fingerprints = fp2.ToArray();                    // calculated as we go through notes' seems to work                  // NotesInIteration1 is count without ignore="1" notes                  a.PhraseIterationCount1 = xml.PhraseIterations.Length;                  a.NotesInIteration1 = new Int32[a.PhraseIterationCount1];                  // NotesInIteration2 seems to be the full count                  a.PhraseIterationCount2 = a.PhraseIterationCount1;                  a.NotesInIteration2 = new Int32[a.PhraseIterationCount2];                    // notes and chords sorted by time                  List<Notes> notes = new List<Notes>();                  int acent = 0;                  foreach (var note in level.Notes)                  {                      var n = new Notes();                      Notes prev = null;                      if (notes.Count > 0)                          prev = notes.Last();                      parseNote(xml' note' n' prev);                      notes.Add(n);                        for (int j = 0; j < xml.PhraseIterations.Length; j++)                      {                          var piter = xml.PhraseIterations[j];                            // fix for 100% bug issue and improve mastery                          if (piter.Time > note.Time && j > 0)                          {                              if (note.Ignore == 0)                                  ++a.NotesInIteration1[j - 1];                              ++a.NotesInIteration2[j - 1];                              break;                          }                      }                                    if (note.SlideTo != -1)                      {                          var ae = new AnchorExtension();                          ae.FretId = (Byte)note.SlideTo;                          ae.BeatTime = note.Time + note.Sustain;                          a.AnchorExtensions.AnchorExtensions[acent++] = ae;                      }                  }                    foreach (var chord in level.Chords)                  {                      var cn = new Notes();                      Int32 id = -1;                      if (chord.ChordNotes != null && chord.ChordNotes.Length > 0)                          id = addChordNotes(sng' chord);                      parseChord(xml' sng' chord' cn' id);                      notes.Add(cn);                        for (int j = 0; j < xml.PhraseIterations.Length; j++)                      {                          var piter = xml.PhraseIterations[j];                            // fix for 100% bug issue and improve mastery                          if (piter.Time > chord.Time && j > 0)                          {                              if (chord.Ignore == 0)                                  ++a.NotesInIteration1[j - 1];                                    ++a.NotesInIteration2[j - 1];                              break;                          }                      }                  }                    // exception handler for some poorly formed RS1 CDLC                  try                  {                      // need to be sorted before anchor note times are updated                      notes.Sort((x' y) => x.Time.CompareTo(y.Time));                        // check for RS1 CDLC note time errors                       // if (notes.Count > 0) // alt method to deal with the exception                      if ((int)first_note_time == 0 || first_note_time > notes[0].Time)                          first_note_time = notes[0].Time;                  }                  catch (Exception)                  {                      // show error in convert2012CLI command window and continue                      Console.WriteLine(@" -- CDLC contains note time errors and may not play properly"); // + ex.Message);                  }                    // TODO: new phylosophy ... charting tweaks should be done in EOF by the charter                  foreach (var n in notes)                  {                      for (Int16 id = 0; id < fp1.Count; id++) //FingerPrints 1st level (common handshapes?)                          if (n.Time >= fp1[id].StartTime && n.Time < fp1[id].EndTime)                          {                              n.FingerPrintId[0] = id;                              // add STRUM to chords if highDensity = 0                              if (n.ChordId != -1 && (n.NoteMask & CON.NOTE_MASK_HIGHDENSITY) != CON.NOTE_MASK_HIGHDENSITY)                                  n.NoteMask |= CON.NOTE_MASK_STRUM;                              if (fp1[id].Unk3_FirstNoteTime == 0)                                  fp1[id].Unk3_FirstNoteTime = n.Time;                                float sustain = 0;                              if (n.Time + n.Sustain < fp1[id].EndTime)                                  sustain = n.Sustain;                              fp1[id].Unk4_LastNoteTime = n.Time + sustain;                              break;                          }                        for (Int16 id = 0; id < fp2.Count; id++) //FingerPrints 2nd level (used for -arp(eggio) handshapes)                          if (n.Time >= fp2[id].StartTime && n.Time < fp2[id].EndTime)                          {                              n.FingerPrintId[1] = id;                              // add STRUM to chords                              if (fp2[id].StartTime == n.Time && n.ChordId != -1)                                  n.NoteMask |= CON.NOTE_MASK_STRUM;                              n.NoteMask |= CON.NOTE_MASK_ARPEGGIO;                              if (fp2[id].Unk3_FirstNoteTime == 0)                                  fp2[id].Unk3_FirstNoteTime = n.Time;                                float sustain = 0;                              if (n.Time + n.Sustain < fp2[id].EndTime)                                  sustain = n.Sustain;                              fp2[id].Unk4_LastNoteTime = n.Time + sustain;                              break;                          }                        for (int j = 0; j < a.Anchors.Count; j++)                          if (n.Time >= a.Anchors.Anchors[j].StartBeatTime && n.Time < a.Anchors.Anchors[j].EndBeatTime)                          {                              n.AnchorWidth = (Byte)a.Anchors.Anchors[j].Width;                              // anchor fret                              n.AnchorFretId = (Byte)a.Anchors.Anchors[j].FretId;                              if (a.Anchors.Anchors[j].Unk3_FirstNoteTime == 0)                                  a.Anchors.Anchors[j].Unk3_FirstNoteTime = n.Time;                                float sustain = 0;                              if (n.Time + n.Sustain < a.Anchors.Anchors[j].EndBeatTime - 0.1)                                  sustain = n.Sustain;                              a.Anchors.Anchors[j].Unk4_LastNoteTime = n.Time + sustain;                              break;                          }                  }                    // initialize times for empty anchors' based on 'lrocknroll'                  foreach (var anchor in a.Anchors.Anchors)                      if (anchor.Unk3_FirstNoteTime == 0)                      {                          anchor.Unk3_FirstNoteTime = anchor.StartBeatTime;                          anchor.Unk4_LastNoteTime = anchor.StartBeatTime + (float)0.1;                      }                    a.Notes = new NotesSection();                  a.Notes.Count = notes.Count;                  a.Notes.Notes = notes.ToArray();                    foreach (var piter in sng.PhraseIterations.PhraseIterations)                  {                      int count = 0;                      int j = 0;                      for (; j < a.Notes.Count; j++)                      {                          // skip notes outside of a phraseiteration                          if (a.Notes.Notes[j].Time < piter.StartTime)                              continue;                          if (a.Notes.Notes[j].Time >= piter.NextPhraseTime)                          {                              break;                          }                          // set to next arrangement note                          a.Notes.Notes[j].NextIterNote = (Int16)(j + 1);                          // set all but first note to previous note                          if (count > 0)                              a.Notes.Notes[j].PrevIterNote = (Int16)(j - 1);                          ++count;                      }                      // fix last phrase note                      if (count > 0)                          a.Notes.Notes[j - 1].NextIterNote = -1;                  }                    for (int j = 1; j < a.Notes.Notes.Length; j++)                  {                      var n = a.Notes.Notes[j];                      var p = a.Notes.Notes[j - 1];                      int prvnote = 1; //set current + prev note + initialize prvnote variable                      //do not do this searching for a parent' if the previous note timestamp != current time stamp                      if (n.Time != p.Time) prvnote = 1;                      else                      {                          for (int x = 1; x < (a.Notes.Notes.Length); x++) //search up till the beginning of iteration                           {                              if (j - x < 1) //don't search past the first note in iteration                              {                                  prvnote = x;                                  x = a.Notes.Notes.Length + 2;                                  break; // stop searching for a match we reached the beginning                              }                              var prv = a.Notes.Notes[j - x]; // get the info for the note we are checking against                              if (prv.Time != n.Time)                              {                                  //now check the timestamp if its the same timestamp then keep looking                                  if (prv.ChordId != -1)                                  {                                      //check if its a chord                                      prvnote = x;                                      x = a.Notes.Notes.Length + 2;                                      break; //stop here' its a chord so don't need to check the strings                                  }                                  if (prv.StringIndex == n.StringIndex)                                  {                                      //check to see if we are looking at the same string                                      prvnote = x;                                      x = a.Notes.Notes.Length + 2;                                      break; //stop here we found the same string' at a different timestamp' thats not a chord                                  }                              }                          }                      }                        var prev = a.Notes.Notes[j - prvnote]; //this will be either the first note of piter' or the last note on the same string at previous timestamp                      if ((prev.NoteMask & CON.NOTE_MASK_PARENT) != 0)                      {                          n.ParentPrevNote = (short)(prev.NextIterNote - 1);                          n.NoteMask |= CON.NOTE_MASK_CHILD; //set the ParentPrevNote# = the matched Note#//add CHILD flag                      }                  }                    a.PhraseCount = xml.Phrases.Length;                  a.AverageNotesPerIteration = new float[a.PhraseCount];                  var iter_count = new float[a.PhraseCount];                  for (int j = 0; j < xml.PhraseIterations.Length; j++)                  {                      var piter = xml.PhraseIterations[j];                      // using NotesInIteration2 to calculate                      a.AverageNotesPerIteration[piter.PhraseId] += a.NotesInIteration2[j];                      ++iter_count[piter.PhraseId];                  }                    for (int j = 0; j < iter_count.Length; j++)                  {                      if (iter_count[j] > 0)                          a.AverageNotesPerIteration[j] /= iter_count[j];                  }                    // this is some kind of optimization in RS2 where they                  // hash all note data but their position in phrase iteration                  // to mark otherwise unchanged notes                  foreach (var n in a.Notes.Notes)                  {                      MemoryStream data = sng.CopyStruct(n);                      var r = new EndianBinaryReader(EndianBitConverter.Little' data);                      var ncopy = new Notes();                      ncopy.read(r);                      ncopy.NextIterNote = 0;                      ncopy.PrevIterNote = 0;                      ncopy.ParentPrevNote = 0;                      UInt32 crc = sng.HashStruct(ncopy);                      if (!note_id.ContainsKey(crc))                          note_id[crc] = (UInt32)note_id.Count;                      n.Hash = note_id[crc];                  }                    numberNotes(sng' a.Notes.Notes);                  sng.Arrangements.Arrangements[i] = a;              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseArrangements,The following statement contains a magic number: for (int i = 0; i < sng.Arrangements.Count; i++)              {                  var level = xml.Levels[i];                  var a = new Arrangement();                  a.Difficulty = level.Difficulty;                    var anchors = new AnchorSection();                  anchors.Count = level.Anchors.Length;                  anchors.Anchors = new Anchor[anchors.Count];                      for (int j = 0; j < anchors.Count; j++)                  {                      var anchor = new Anchor();                      anchor.StartBeatTime = level.Anchors[j].Time;                      if (j + 1 < anchors.Count)                          anchor.EndBeatTime = level.Anchors[j + 1].Time;                      else                          // last phrase iteration = noguitar/end                          anchor.EndBeatTime = xml.PhraseIterations[xml.PhraseIterations.Length - 1].Time;                      // TODO: not 100% clear                      // times will be updated later                      // these "garbage" values are everywhere!                      //anchor.Unk3_FirstNoteTime = (float) 3.4028234663852886e+38;                      //anchor.Unk4_LastNoteTime = (float) 1.1754943508222875e-38;                      anchor.FretId = (byte)level.Anchors[j].Fret;                      anchor.Width = (Int32)level.Anchors[j].Width;                      anchor.PhraseIterationId = getPhraseIterationId(xml' anchor.StartBeatTime' false);                      anchors.Anchors[j] = anchor;                  }                    a.Anchors = anchors;                  // each slideTo will get anchor extension                  a.AnchorExtensions = new AnchorExtensionSection();                    foreach (var note in level.Notes)                      if (note.SlideTo != -1)                          ++a.AnchorExtensions.Count;                    a.AnchorExtensions.AnchorExtensions = new AnchorExtension[a.AnchorExtensions.Count];                  // Fingerprints1 is for handshapes without "arp" displayName                  a.Fingerprints1 = new FingerprintSection();                  // Fingerprints2 is for handshapes with "arp" displayName                  a.Fingerprints2 = new FingerprintSection();                    var fp1 = new List<Fingerprint>();                  var fp2 = new List<Fingerprint>();                  foreach (var h in level.HandShapes)                  {                      if (h.ChordId < 0) continue;                      var fp = new Fingerprint                      {                          ChordId = h.ChordId'                          StartTime = h.StartTime'                          EndTime = h.EndTime                          // TODO: not always StartTime                          //fp.Unk3_FirstNoteTime = fp.StartTime;                          //fp.Unk4_LastNoteTime = fp.StartTime;                      };                        if (xml.ChordTemplates[fp.ChordId].DisplayName.EndsWith("arp"))                          fp2.Add(fp);                      else                          fp1.Add(fp);                  }                    a.Fingerprints1.Count = fp1.Count;                  a.Fingerprints1.Fingerprints = fp1.ToArray();                  a.Fingerprints2.Count = fp2.Count;                  a.Fingerprints2.Fingerprints = fp2.ToArray();                    // calculated as we go through notes' seems to work                  // NotesInIteration1 is count without ignore="1" notes                  a.PhraseIterationCount1 = xml.PhraseIterations.Length;                  a.NotesInIteration1 = new Int32[a.PhraseIterationCount1];                  // NotesInIteration2 seems to be the full count                  a.PhraseIterationCount2 = a.PhraseIterationCount1;                  a.NotesInIteration2 = new Int32[a.PhraseIterationCount2];                    // notes and chords sorted by time                  List<Notes> notes = new List<Notes>();                  int acent = 0;                  foreach (var note in level.Notes)                  {                      var n = new Notes();                      Notes prev = null;                      if (notes.Count > 0)                          prev = notes.Last();                      parseNote(xml' note' n' prev);                      notes.Add(n);                        for (int j = 0; j < xml.PhraseIterations.Length; j++)                      {                          var piter = xml.PhraseIterations[j];                            // fix for 100% bug issue and improve mastery                          if (piter.Time > note.Time && j > 0)                          {                              if (note.Ignore == 0)                                  ++a.NotesInIteration1[j - 1];                              ++a.NotesInIteration2[j - 1];                              break;                          }                      }                                    if (note.SlideTo != -1)                      {                          var ae = new AnchorExtension();                          ae.FretId = (Byte)note.SlideTo;                          ae.BeatTime = note.Time + note.Sustain;                          a.AnchorExtensions.AnchorExtensions[acent++] = ae;                      }                  }                    foreach (var chord in level.Chords)                  {                      var cn = new Notes();                      Int32 id = -1;                      if (chord.ChordNotes != null && chord.ChordNotes.Length > 0)                          id = addChordNotes(sng' chord);                      parseChord(xml' sng' chord' cn' id);                      notes.Add(cn);                        for (int j = 0; j < xml.PhraseIterations.Length; j++)                      {                          var piter = xml.PhraseIterations[j];                            // fix for 100% bug issue and improve mastery                          if (piter.Time > chord.Time && j > 0)                          {                              if (chord.Ignore == 0)                                  ++a.NotesInIteration1[j - 1];                                    ++a.NotesInIteration2[j - 1];                              break;                          }                      }                  }                    // exception handler for some poorly formed RS1 CDLC                  try                  {                      // need to be sorted before anchor note times are updated                      notes.Sort((x' y) => x.Time.CompareTo(y.Time));                        // check for RS1 CDLC note time errors                       // if (notes.Count > 0) // alt method to deal with the exception                      if ((int)first_note_time == 0 || first_note_time > notes[0].Time)                          first_note_time = notes[0].Time;                  }                  catch (Exception)                  {                      // show error in convert2012CLI command window and continue                      Console.WriteLine(@" -- CDLC contains note time errors and may not play properly"); // + ex.Message);                  }                    // TODO: new phylosophy ... charting tweaks should be done in EOF by the charter                  foreach (var n in notes)                  {                      for (Int16 id = 0; id < fp1.Count; id++) //FingerPrints 1st level (common handshapes?)                          if (n.Time >= fp1[id].StartTime && n.Time < fp1[id].EndTime)                          {                              n.FingerPrintId[0] = id;                              // add STRUM to chords if highDensity = 0                              if (n.ChordId != -1 && (n.NoteMask & CON.NOTE_MASK_HIGHDENSITY) != CON.NOTE_MASK_HIGHDENSITY)                                  n.NoteMask |= CON.NOTE_MASK_STRUM;                              if (fp1[id].Unk3_FirstNoteTime == 0)                                  fp1[id].Unk3_FirstNoteTime = n.Time;                                float sustain = 0;                              if (n.Time + n.Sustain < fp1[id].EndTime)                                  sustain = n.Sustain;                              fp1[id].Unk4_LastNoteTime = n.Time + sustain;                              break;                          }                        for (Int16 id = 0; id < fp2.Count; id++) //FingerPrints 2nd level (used for -arp(eggio) handshapes)                          if (n.Time >= fp2[id].StartTime && n.Time < fp2[id].EndTime)                          {                              n.FingerPrintId[1] = id;                              // add STRUM to chords                              if (fp2[id].StartTime == n.Time && n.ChordId != -1)                                  n.NoteMask |= CON.NOTE_MASK_STRUM;                              n.NoteMask |= CON.NOTE_MASK_ARPEGGIO;                              if (fp2[id].Unk3_FirstNoteTime == 0)                                  fp2[id].Unk3_FirstNoteTime = n.Time;                                float sustain = 0;                              if (n.Time + n.Sustain < fp2[id].EndTime)                                  sustain = n.Sustain;                              fp2[id].Unk4_LastNoteTime = n.Time + sustain;                              break;                          }                        for (int j = 0; j < a.Anchors.Count; j++)                          if (n.Time >= a.Anchors.Anchors[j].StartBeatTime && n.Time < a.Anchors.Anchors[j].EndBeatTime)                          {                              n.AnchorWidth = (Byte)a.Anchors.Anchors[j].Width;                              // anchor fret                              n.AnchorFretId = (Byte)a.Anchors.Anchors[j].FretId;                              if (a.Anchors.Anchors[j].Unk3_FirstNoteTime == 0)                                  a.Anchors.Anchors[j].Unk3_FirstNoteTime = n.Time;                                float sustain = 0;                              if (n.Time + n.Sustain < a.Anchors.Anchors[j].EndBeatTime - 0.1)                                  sustain = n.Sustain;                              a.Anchors.Anchors[j].Unk4_LastNoteTime = n.Time + sustain;                              break;                          }                  }                    // initialize times for empty anchors' based on 'lrocknroll'                  foreach (var anchor in a.Anchors.Anchors)                      if (anchor.Unk3_FirstNoteTime == 0)                      {                          anchor.Unk3_FirstNoteTime = anchor.StartBeatTime;                          anchor.Unk4_LastNoteTime = anchor.StartBeatTime + (float)0.1;                      }                    a.Notes = new NotesSection();                  a.Notes.Count = notes.Count;                  a.Notes.Notes = notes.ToArray();                    foreach (var piter in sng.PhraseIterations.PhraseIterations)                  {                      int count = 0;                      int j = 0;                      for (; j < a.Notes.Count; j++)                      {                          // skip notes outside of a phraseiteration                          if (a.Notes.Notes[j].Time < piter.StartTime)                              continue;                          if (a.Notes.Notes[j].Time >= piter.NextPhraseTime)                          {                              break;                          }                          // set to next arrangement note                          a.Notes.Notes[j].NextIterNote = (Int16)(j + 1);                          // set all but first note to previous note                          if (count > 0)                              a.Notes.Notes[j].PrevIterNote = (Int16)(j - 1);                          ++count;                      }                      // fix last phrase note                      if (count > 0)                          a.Notes.Notes[j - 1].NextIterNote = -1;                  }                    for (int j = 1; j < a.Notes.Notes.Length; j++)                  {                      var n = a.Notes.Notes[j];                      var p = a.Notes.Notes[j - 1];                      int prvnote = 1; //set current + prev note + initialize prvnote variable                      //do not do this searching for a parent' if the previous note timestamp != current time stamp                      if (n.Time != p.Time) prvnote = 1;                      else                      {                          for (int x = 1; x < (a.Notes.Notes.Length); x++) //search up till the beginning of iteration                           {                              if (j - x < 1) //don't search past the first note in iteration                              {                                  prvnote = x;                                  x = a.Notes.Notes.Length + 2;                                  break; // stop searching for a match we reached the beginning                              }                              var prv = a.Notes.Notes[j - x]; // get the info for the note we are checking against                              if (prv.Time != n.Time)                              {                                  //now check the timestamp if its the same timestamp then keep looking                                  if (prv.ChordId != -1)                                  {                                      //check if its a chord                                      prvnote = x;                                      x = a.Notes.Notes.Length + 2;                                      break; //stop here' its a chord so don't need to check the strings                                  }                                  if (prv.StringIndex == n.StringIndex)                                  {                                      //check to see if we are looking at the same string                                      prvnote = x;                                      x = a.Notes.Notes.Length + 2;                                      break; //stop here we found the same string' at a different timestamp' thats not a chord                                  }                              }                          }                      }                        var prev = a.Notes.Notes[j - prvnote]; //this will be either the first note of piter' or the last note on the same string at previous timestamp                      if ((prev.NoteMask & CON.NOTE_MASK_PARENT) != 0)                      {                          n.ParentPrevNote = (short)(prev.NextIterNote - 1);                          n.NoteMask |= CON.NOTE_MASK_CHILD; //set the ParentPrevNote# = the matched Note#//add CHILD flag                      }                  }                    a.PhraseCount = xml.Phrases.Length;                  a.AverageNotesPerIteration = new float[a.PhraseCount];                  var iter_count = new float[a.PhraseCount];                  for (int j = 0; j < xml.PhraseIterations.Length; j++)                  {                      var piter = xml.PhraseIterations[j];                      // using NotesInIteration2 to calculate                      a.AverageNotesPerIteration[piter.PhraseId] += a.NotesInIteration2[j];                      ++iter_count[piter.PhraseId];                  }                    for (int j = 0; j < iter_count.Length; j++)                  {                      if (iter_count[j] > 0)                          a.AverageNotesPerIteration[j] /= iter_count[j];                  }                    // this is some kind of optimization in RS2 where they                  // hash all note data but their position in phrase iteration                  // to mark otherwise unchanged notes                  foreach (var n in a.Notes.Notes)                  {                      MemoryStream data = sng.CopyStruct(n);                      var r = new EndianBinaryReader(EndianBitConverter.Little' data);                      var ncopy = new Notes();                      ncopy.read(r);                      ncopy.NextIterNote = 0;                      ncopy.PrevIterNote = 0;                      ncopy.ParentPrevNote = 0;                      UInt32 crc = sng.HashStruct(ncopy);                      if (!note_id.ContainsKey(crc))                          note_id[crc] = (UInt32)note_id.Count;                      n.Hash = note_id[crc];                  }                    numberNotes(sng' a.Notes.Notes);                  sng.Arrangements.Arrangements[i] = a;              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseArrangements,The following statement contains a magic number: for (int i = 0; i < sng.Arrangements.Count; i++)              {                  var level = xml.Levels[i];                  var a = new Arrangement();                  a.Difficulty = level.Difficulty;                    var anchors = new AnchorSection();                  anchors.Count = level.Anchors.Length;                  anchors.Anchors = new Anchor[anchors.Count];                      for (int j = 0; j < anchors.Count; j++)                  {                      var anchor = new Anchor();                      anchor.StartBeatTime = level.Anchors[j].Time;                      if (j + 1 < anchors.Count)                          anchor.EndBeatTime = level.Anchors[j + 1].Time;                      else                          // last phrase iteration = noguitar/end                          anchor.EndBeatTime = xml.PhraseIterations[xml.PhraseIterations.Length - 1].Time;                      // TODO: not 100% clear                      // times will be updated later                      // these "garbage" values are everywhere!                      //anchor.Unk3_FirstNoteTime = (float) 3.4028234663852886e+38;                      //anchor.Unk4_LastNoteTime = (float) 1.1754943508222875e-38;                      anchor.FretId = (byte)level.Anchors[j].Fret;                      anchor.Width = (Int32)level.Anchors[j].Width;                      anchor.PhraseIterationId = getPhraseIterationId(xml' anchor.StartBeatTime' false);                      anchors.Anchors[j] = anchor;                  }                    a.Anchors = anchors;                  // each slideTo will get anchor extension                  a.AnchorExtensions = new AnchorExtensionSection();                    foreach (var note in level.Notes)                      if (note.SlideTo != -1)                          ++a.AnchorExtensions.Count;                    a.AnchorExtensions.AnchorExtensions = new AnchorExtension[a.AnchorExtensions.Count];                  // Fingerprints1 is for handshapes without "arp" displayName                  a.Fingerprints1 = new FingerprintSection();                  // Fingerprints2 is for handshapes with "arp" displayName                  a.Fingerprints2 = new FingerprintSection();                    var fp1 = new List<Fingerprint>();                  var fp2 = new List<Fingerprint>();                  foreach (var h in level.HandShapes)                  {                      if (h.ChordId < 0) continue;                      var fp = new Fingerprint                      {                          ChordId = h.ChordId'                          StartTime = h.StartTime'                          EndTime = h.EndTime                          // TODO: not always StartTime                          //fp.Unk3_FirstNoteTime = fp.StartTime;                          //fp.Unk4_LastNoteTime = fp.StartTime;                      };                        if (xml.ChordTemplates[fp.ChordId].DisplayName.EndsWith("arp"))                          fp2.Add(fp);                      else                          fp1.Add(fp);                  }                    a.Fingerprints1.Count = fp1.Count;                  a.Fingerprints1.Fingerprints = fp1.ToArray();                  a.Fingerprints2.Count = fp2.Count;                  a.Fingerprints2.Fingerprints = fp2.ToArray();                    // calculated as we go through notes' seems to work                  // NotesInIteration1 is count without ignore="1" notes                  a.PhraseIterationCount1 = xml.PhraseIterations.Length;                  a.NotesInIteration1 = new Int32[a.PhraseIterationCount1];                  // NotesInIteration2 seems to be the full count                  a.PhraseIterationCount2 = a.PhraseIterationCount1;                  a.NotesInIteration2 = new Int32[a.PhraseIterationCount2];                    // notes and chords sorted by time                  List<Notes> notes = new List<Notes>();                  int acent = 0;                  foreach (var note in level.Notes)                  {                      var n = new Notes();                      Notes prev = null;                      if (notes.Count > 0)                          prev = notes.Last();                      parseNote(xml' note' n' prev);                      notes.Add(n);                        for (int j = 0; j < xml.PhraseIterations.Length; j++)                      {                          var piter = xml.PhraseIterations[j];                            // fix for 100% bug issue and improve mastery                          if (piter.Time > note.Time && j > 0)                          {                              if (note.Ignore == 0)                                  ++a.NotesInIteration1[j - 1];                              ++a.NotesInIteration2[j - 1];                              break;                          }                      }                                    if (note.SlideTo != -1)                      {                          var ae = new AnchorExtension();                          ae.FretId = (Byte)note.SlideTo;                          ae.BeatTime = note.Time + note.Sustain;                          a.AnchorExtensions.AnchorExtensions[acent++] = ae;                      }                  }                    foreach (var chord in level.Chords)                  {                      var cn = new Notes();                      Int32 id = -1;                      if (chord.ChordNotes != null && chord.ChordNotes.Length > 0)                          id = addChordNotes(sng' chord);                      parseChord(xml' sng' chord' cn' id);                      notes.Add(cn);                        for (int j = 0; j < xml.PhraseIterations.Length; j++)                      {                          var piter = xml.PhraseIterations[j];                            // fix for 100% bug issue and improve mastery                          if (piter.Time > chord.Time && j > 0)                          {                              if (chord.Ignore == 0)                                  ++a.NotesInIteration1[j - 1];                                    ++a.NotesInIteration2[j - 1];                              break;                          }                      }                  }                    // exception handler for some poorly formed RS1 CDLC                  try                  {                      // need to be sorted before anchor note times are updated                      notes.Sort((x' y) => x.Time.CompareTo(y.Time));                        // check for RS1 CDLC note time errors                       // if (notes.Count > 0) // alt method to deal with the exception                      if ((int)first_note_time == 0 || first_note_time > notes[0].Time)                          first_note_time = notes[0].Time;                  }                  catch (Exception)                  {                      // show error in convert2012CLI command window and continue                      Console.WriteLine(@" -- CDLC contains note time errors and may not play properly"); // + ex.Message);                  }                    // TODO: new phylosophy ... charting tweaks should be done in EOF by the charter                  foreach (var n in notes)                  {                      for (Int16 id = 0; id < fp1.Count; id++) //FingerPrints 1st level (common handshapes?)                          if (n.Time >= fp1[id].StartTime && n.Time < fp1[id].EndTime)                          {                              n.FingerPrintId[0] = id;                              // add STRUM to chords if highDensity = 0                              if (n.ChordId != -1 && (n.NoteMask & CON.NOTE_MASK_HIGHDENSITY) != CON.NOTE_MASK_HIGHDENSITY)                                  n.NoteMask |= CON.NOTE_MASK_STRUM;                              if (fp1[id].Unk3_FirstNoteTime == 0)                                  fp1[id].Unk3_FirstNoteTime = n.Time;                                float sustain = 0;                              if (n.Time + n.Sustain < fp1[id].EndTime)                                  sustain = n.Sustain;                              fp1[id].Unk4_LastNoteTime = n.Time + sustain;                              break;                          }                        for (Int16 id = 0; id < fp2.Count; id++) //FingerPrints 2nd level (used for -arp(eggio) handshapes)                          if (n.Time >= fp2[id].StartTime && n.Time < fp2[id].EndTime)                          {                              n.FingerPrintId[1] = id;                              // add STRUM to chords                              if (fp2[id].StartTime == n.Time && n.ChordId != -1)                                  n.NoteMask |= CON.NOTE_MASK_STRUM;                              n.NoteMask |= CON.NOTE_MASK_ARPEGGIO;                              if (fp2[id].Unk3_FirstNoteTime == 0)                                  fp2[id].Unk3_FirstNoteTime = n.Time;                                float sustain = 0;                              if (n.Time + n.Sustain < fp2[id].EndTime)                                  sustain = n.Sustain;                              fp2[id].Unk4_LastNoteTime = n.Time + sustain;                              break;                          }                        for (int j = 0; j < a.Anchors.Count; j++)                          if (n.Time >= a.Anchors.Anchors[j].StartBeatTime && n.Time < a.Anchors.Anchors[j].EndBeatTime)                          {                              n.AnchorWidth = (Byte)a.Anchors.Anchors[j].Width;                              // anchor fret                              n.AnchorFretId = (Byte)a.Anchors.Anchors[j].FretId;                              if (a.Anchors.Anchors[j].Unk3_FirstNoteTime == 0)                                  a.Anchors.Anchors[j].Unk3_FirstNoteTime = n.Time;                                float sustain = 0;                              if (n.Time + n.Sustain < a.Anchors.Anchors[j].EndBeatTime - 0.1)                                  sustain = n.Sustain;                              a.Anchors.Anchors[j].Unk4_LastNoteTime = n.Time + sustain;                              break;                          }                  }                    // initialize times for empty anchors' based on 'lrocknroll'                  foreach (var anchor in a.Anchors.Anchors)                      if (anchor.Unk3_FirstNoteTime == 0)                      {                          anchor.Unk3_FirstNoteTime = anchor.StartBeatTime;                          anchor.Unk4_LastNoteTime = anchor.StartBeatTime + (float)0.1;                      }                    a.Notes = new NotesSection();                  a.Notes.Count = notes.Count;                  a.Notes.Notes = notes.ToArray();                    foreach (var piter in sng.PhraseIterations.PhraseIterations)                  {                      int count = 0;                      int j = 0;                      for (; j < a.Notes.Count; j++)                      {                          // skip notes outside of a phraseiteration                          if (a.Notes.Notes[j].Time < piter.StartTime)                              continue;                          if (a.Notes.Notes[j].Time >= piter.NextPhraseTime)                          {                              break;                          }                          // set to next arrangement note                          a.Notes.Notes[j].NextIterNote = (Int16)(j + 1);                          // set all but first note to previous note                          if (count > 0)                              a.Notes.Notes[j].PrevIterNote = (Int16)(j - 1);                          ++count;                      }                      // fix last phrase note                      if (count > 0)                          a.Notes.Notes[j - 1].NextIterNote = -1;                  }                    for (int j = 1; j < a.Notes.Notes.Length; j++)                  {                      var n = a.Notes.Notes[j];                      var p = a.Notes.Notes[j - 1];                      int prvnote = 1; //set current + prev note + initialize prvnote variable                      //do not do this searching for a parent' if the previous note timestamp != current time stamp                      if (n.Time != p.Time) prvnote = 1;                      else                      {                          for (int x = 1; x < (a.Notes.Notes.Length); x++) //search up till the beginning of iteration                           {                              if (j - x < 1) //don't search past the first note in iteration                              {                                  prvnote = x;                                  x = a.Notes.Notes.Length + 2;                                  break; // stop searching for a match we reached the beginning                              }                              var prv = a.Notes.Notes[j - x]; // get the info for the note we are checking against                              if (prv.Time != n.Time)                              {                                  //now check the timestamp if its the same timestamp then keep looking                                  if (prv.ChordId != -1)                                  {                                      //check if its a chord                                      prvnote = x;                                      x = a.Notes.Notes.Length + 2;                                      break; //stop here' its a chord so don't need to check the strings                                  }                                  if (prv.StringIndex == n.StringIndex)                                  {                                      //check to see if we are looking at the same string                                      prvnote = x;                                      x = a.Notes.Notes.Length + 2;                                      break; //stop here we found the same string' at a different timestamp' thats not a chord                                  }                              }                          }                      }                        var prev = a.Notes.Notes[j - prvnote]; //this will be either the first note of piter' or the last note on the same string at previous timestamp                      if ((prev.NoteMask & CON.NOTE_MASK_PARENT) != 0)                      {                          n.ParentPrevNote = (short)(prev.NextIterNote - 1);                          n.NoteMask |= CON.NOTE_MASK_CHILD; //set the ParentPrevNote# = the matched Note#//add CHILD flag                      }                  }                    a.PhraseCount = xml.Phrases.Length;                  a.AverageNotesPerIteration = new float[a.PhraseCount];                  var iter_count = new float[a.PhraseCount];                  for (int j = 0; j < xml.PhraseIterations.Length; j++)                  {                      var piter = xml.PhraseIterations[j];                      // using NotesInIteration2 to calculate                      a.AverageNotesPerIteration[piter.PhraseId] += a.NotesInIteration2[j];                      ++iter_count[piter.PhraseId];                  }                    for (int j = 0; j < iter_count.Length; j++)                  {                      if (iter_count[j] > 0)                          a.AverageNotesPerIteration[j] /= iter_count[j];                  }                    // this is some kind of optimization in RS2 where they                  // hash all note data but their position in phrase iteration                  // to mark otherwise unchanged notes                  foreach (var n in a.Notes.Notes)                  {                      MemoryStream data = sng.CopyStruct(n);                      var r = new EndianBinaryReader(EndianBitConverter.Little' data);                      var ncopy = new Notes();                      ncopy.read(r);                      ncopy.NextIterNote = 0;                      ncopy.PrevIterNote = 0;                      ncopy.ParentPrevNote = 0;                      UInt32 crc = sng.HashStruct(ncopy);                      if (!note_id.ContainsKey(crc))                          note_id[crc] = (UInt32)note_id.Count;                      n.Hash = note_id[crc];                  }                    numberNotes(sng' a.Notes.Notes);                  sng.Arrangements.Arrangements[i] = a;              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseArrangements,The following statement contains a magic number: for (int i = 0; i < sng.Arrangements.Count; i++)              {                  var level = xml.Levels[i];                  var a = new Arrangement();                  a.Difficulty = level.Difficulty;                    var anchors = new AnchorSection();                  anchors.Count = level.Anchors.Length;                  anchors.Anchors = new Anchor[anchors.Count];                      for (int j = 0; j < anchors.Count; j++)                  {                      var anchor = new Anchor();                      anchor.StartBeatTime = level.Anchors[j].Time;                      if (j + 1 < anchors.Count)                          anchor.EndBeatTime = level.Anchors[j + 1].Time;                      else                          // last phrase iteration = noguitar/end                          anchor.EndBeatTime = xml.PhraseIterations[xml.PhraseIterations.Length - 1].Time;                      // TODO: not 100% clear                      // times will be updated later                      // these "garbage" values are everywhere!                      //anchor.Unk3_FirstNoteTime = (float) 3.4028234663852886e+38;                      //anchor.Unk4_LastNoteTime = (float) 1.1754943508222875e-38;                      anchor.FretId = (byte)level.Anchors[j].Fret;                      anchor.Width = (Int32)level.Anchors[j].Width;                      anchor.PhraseIterationId = getPhraseIterationId(xml' anchor.StartBeatTime' false);                      anchors.Anchors[j] = anchor;                  }                    a.Anchors = anchors;                  // each slideTo will get anchor extension                  a.AnchorExtensions = new AnchorExtensionSection();                    foreach (var note in level.Notes)                      if (note.SlideTo != -1)                          ++a.AnchorExtensions.Count;                    a.AnchorExtensions.AnchorExtensions = new AnchorExtension[a.AnchorExtensions.Count];                  // Fingerprints1 is for handshapes without "arp" displayName                  a.Fingerprints1 = new FingerprintSection();                  // Fingerprints2 is for handshapes with "arp" displayName                  a.Fingerprints2 = new FingerprintSection();                    var fp1 = new List<Fingerprint>();                  var fp2 = new List<Fingerprint>();                  foreach (var h in level.HandShapes)                  {                      if (h.ChordId < 0) continue;                      var fp = new Fingerprint                      {                          ChordId = h.ChordId'                          StartTime = h.StartTime'                          EndTime = h.EndTime                          // TODO: not always StartTime                          //fp.Unk3_FirstNoteTime = fp.StartTime;                          //fp.Unk4_LastNoteTime = fp.StartTime;                      };                        if (xml.ChordTemplates[fp.ChordId].DisplayName.EndsWith("arp"))                          fp2.Add(fp);                      else                          fp1.Add(fp);                  }                    a.Fingerprints1.Count = fp1.Count;                  a.Fingerprints1.Fingerprints = fp1.ToArray();                  a.Fingerprints2.Count = fp2.Count;                  a.Fingerprints2.Fingerprints = fp2.ToArray();                    // calculated as we go through notes' seems to work                  // NotesInIteration1 is count without ignore="1" notes                  a.PhraseIterationCount1 = xml.PhraseIterations.Length;                  a.NotesInIteration1 = new Int32[a.PhraseIterationCount1];                  // NotesInIteration2 seems to be the full count                  a.PhraseIterationCount2 = a.PhraseIterationCount1;                  a.NotesInIteration2 = new Int32[a.PhraseIterationCount2];                    // notes and chords sorted by time                  List<Notes> notes = new List<Notes>();                  int acent = 0;                  foreach (var note in level.Notes)                  {                      var n = new Notes();                      Notes prev = null;                      if (notes.Count > 0)                          prev = notes.Last();                      parseNote(xml' note' n' prev);                      notes.Add(n);                        for (int j = 0; j < xml.PhraseIterations.Length; j++)                      {                          var piter = xml.PhraseIterations[j];                            // fix for 100% bug issue and improve mastery                          if (piter.Time > note.Time && j > 0)                          {                              if (note.Ignore == 0)                                  ++a.NotesInIteration1[j - 1];                              ++a.NotesInIteration2[j - 1];                              break;                          }                      }                                    if (note.SlideTo != -1)                      {                          var ae = new AnchorExtension();                          ae.FretId = (Byte)note.SlideTo;                          ae.BeatTime = note.Time + note.Sustain;                          a.AnchorExtensions.AnchorExtensions[acent++] = ae;                      }                  }                    foreach (var chord in level.Chords)                  {                      var cn = new Notes();                      Int32 id = -1;                      if (chord.ChordNotes != null && chord.ChordNotes.Length > 0)                          id = addChordNotes(sng' chord);                      parseChord(xml' sng' chord' cn' id);                      notes.Add(cn);                        for (int j = 0; j < xml.PhraseIterations.Length; j++)                      {                          var piter = xml.PhraseIterations[j];                            // fix for 100% bug issue and improve mastery                          if (piter.Time > chord.Time && j > 0)                          {                              if (chord.Ignore == 0)                                  ++a.NotesInIteration1[j - 1];                                    ++a.NotesInIteration2[j - 1];                              break;                          }                      }                  }                    // exception handler for some poorly formed RS1 CDLC                  try                  {                      // need to be sorted before anchor note times are updated                      notes.Sort((x' y) => x.Time.CompareTo(y.Time));                        // check for RS1 CDLC note time errors                       // if (notes.Count > 0) // alt method to deal with the exception                      if ((int)first_note_time == 0 || first_note_time > notes[0].Time)                          first_note_time = notes[0].Time;                  }                  catch (Exception)                  {                      // show error in convert2012CLI command window and continue                      Console.WriteLine(@" -- CDLC contains note time errors and may not play properly"); // + ex.Message);                  }                    // TODO: new phylosophy ... charting tweaks should be done in EOF by the charter                  foreach (var n in notes)                  {                      for (Int16 id = 0; id < fp1.Count; id++) //FingerPrints 1st level (common handshapes?)                          if (n.Time >= fp1[id].StartTime && n.Time < fp1[id].EndTime)                          {                              n.FingerPrintId[0] = id;                              // add STRUM to chords if highDensity = 0                              if (n.ChordId != -1 && (n.NoteMask & CON.NOTE_MASK_HIGHDENSITY) != CON.NOTE_MASK_HIGHDENSITY)                                  n.NoteMask |= CON.NOTE_MASK_STRUM;                              if (fp1[id].Unk3_FirstNoteTime == 0)                                  fp1[id].Unk3_FirstNoteTime = n.Time;                                float sustain = 0;                              if (n.Time + n.Sustain < fp1[id].EndTime)                                  sustain = n.Sustain;                              fp1[id].Unk4_LastNoteTime = n.Time + sustain;                              break;                          }                        for (Int16 id = 0; id < fp2.Count; id++) //FingerPrints 2nd level (used for -arp(eggio) handshapes)                          if (n.Time >= fp2[id].StartTime && n.Time < fp2[id].EndTime)                          {                              n.FingerPrintId[1] = id;                              // add STRUM to chords                              if (fp2[id].StartTime == n.Time && n.ChordId != -1)                                  n.NoteMask |= CON.NOTE_MASK_STRUM;                              n.NoteMask |= CON.NOTE_MASK_ARPEGGIO;                              if (fp2[id].Unk3_FirstNoteTime == 0)                                  fp2[id].Unk3_FirstNoteTime = n.Time;                                float sustain = 0;                              if (n.Time + n.Sustain < fp2[id].EndTime)                                  sustain = n.Sustain;                              fp2[id].Unk4_LastNoteTime = n.Time + sustain;                              break;                          }                        for (int j = 0; j < a.Anchors.Count; j++)                          if (n.Time >= a.Anchors.Anchors[j].StartBeatTime && n.Time < a.Anchors.Anchors[j].EndBeatTime)                          {                              n.AnchorWidth = (Byte)a.Anchors.Anchors[j].Width;                              // anchor fret                              n.AnchorFretId = (Byte)a.Anchors.Anchors[j].FretId;                              if (a.Anchors.Anchors[j].Unk3_FirstNoteTime == 0)                                  a.Anchors.Anchors[j].Unk3_FirstNoteTime = n.Time;                                float sustain = 0;                              if (n.Time + n.Sustain < a.Anchors.Anchors[j].EndBeatTime - 0.1)                                  sustain = n.Sustain;                              a.Anchors.Anchors[j].Unk4_LastNoteTime = n.Time + sustain;                              break;                          }                  }                    // initialize times for empty anchors' based on 'lrocknroll'                  foreach (var anchor in a.Anchors.Anchors)                      if (anchor.Unk3_FirstNoteTime == 0)                      {                          anchor.Unk3_FirstNoteTime = anchor.StartBeatTime;                          anchor.Unk4_LastNoteTime = anchor.StartBeatTime + (float)0.1;                      }                    a.Notes = new NotesSection();                  a.Notes.Count = notes.Count;                  a.Notes.Notes = notes.ToArray();                    foreach (var piter in sng.PhraseIterations.PhraseIterations)                  {                      int count = 0;                      int j = 0;                      for (; j < a.Notes.Count; j++)                      {                          // skip notes outside of a phraseiteration                          if (a.Notes.Notes[j].Time < piter.StartTime)                              continue;                          if (a.Notes.Notes[j].Time >= piter.NextPhraseTime)                          {                              break;                          }                          // set to next arrangement note                          a.Notes.Notes[j].NextIterNote = (Int16)(j + 1);                          // set all but first note to previous note                          if (count > 0)                              a.Notes.Notes[j].PrevIterNote = (Int16)(j - 1);                          ++count;                      }                      // fix last phrase note                      if (count > 0)                          a.Notes.Notes[j - 1].NextIterNote = -1;                  }                    for (int j = 1; j < a.Notes.Notes.Length; j++)                  {                      var n = a.Notes.Notes[j];                      var p = a.Notes.Notes[j - 1];                      int prvnote = 1; //set current + prev note + initialize prvnote variable                      //do not do this searching for a parent' if the previous note timestamp != current time stamp                      if (n.Time != p.Time) prvnote = 1;                      else                      {                          for (int x = 1; x < (a.Notes.Notes.Length); x++) //search up till the beginning of iteration                           {                              if (j - x < 1) //don't search past the first note in iteration                              {                                  prvnote = x;                                  x = a.Notes.Notes.Length + 2;                                  break; // stop searching for a match we reached the beginning                              }                              var prv = a.Notes.Notes[j - x]; // get the info for the note we are checking against                              if (prv.Time != n.Time)                              {                                  //now check the timestamp if its the same timestamp then keep looking                                  if (prv.ChordId != -1)                                  {                                      //check if its a chord                                      prvnote = x;                                      x = a.Notes.Notes.Length + 2;                                      break; //stop here' its a chord so don't need to check the strings                                  }                                  if (prv.StringIndex == n.StringIndex)                                  {                                      //check to see if we are looking at the same string                                      prvnote = x;                                      x = a.Notes.Notes.Length + 2;                                      break; //stop here we found the same string' at a different timestamp' thats not a chord                                  }                              }                          }                      }                        var prev = a.Notes.Notes[j - prvnote]; //this will be either the first note of piter' or the last note on the same string at previous timestamp                      if ((prev.NoteMask & CON.NOTE_MASK_PARENT) != 0)                      {                          n.ParentPrevNote = (short)(prev.NextIterNote - 1);                          n.NoteMask |= CON.NOTE_MASK_CHILD; //set the ParentPrevNote# = the matched Note#//add CHILD flag                      }                  }                    a.PhraseCount = xml.Phrases.Length;                  a.AverageNotesPerIteration = new float[a.PhraseCount];                  var iter_count = new float[a.PhraseCount];                  for (int j = 0; j < xml.PhraseIterations.Length; j++)                  {                      var piter = xml.PhraseIterations[j];                      // using NotesInIteration2 to calculate                      a.AverageNotesPerIteration[piter.PhraseId] += a.NotesInIteration2[j];                      ++iter_count[piter.PhraseId];                  }                    for (int j = 0; j < iter_count.Length; j++)                  {                      if (iter_count[j] > 0)                          a.AverageNotesPerIteration[j] /= iter_count[j];                  }                    // this is some kind of optimization in RS2 where they                  // hash all note data but their position in phrase iteration                  // to mark otherwise unchanged notes                  foreach (var n in a.Notes.Notes)                  {                      MemoryStream data = sng.CopyStruct(n);                      var r = new EndianBinaryReader(EndianBitConverter.Little' data);                      var ncopy = new Notes();                      ncopy.read(r);                      ncopy.NextIterNote = 0;                      ncopy.PrevIterNote = 0;                      ncopy.ParentPrevNote = 0;                      UInt32 crc = sng.HashStruct(ncopy);                      if (!note_id.ContainsKey(crc))                          note_id[crc] = (UInt32)note_id.Count;                      n.Hash = note_id[crc];                  }                    numberNotes(sng' a.Notes.Notes);                  sng.Arrangements.Arrangements[i] = a;              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseArrangements,The following statement contains a magic number: for (int i = 0; i < sng.Arrangements.Count; i++)              {                  var level = xml.Levels[i];                  var a = new Arrangement();                  a.Difficulty = level.Difficulty;                    var anchors = new AnchorSection();                  anchors.Count = level.Anchors.Length;                  anchors.Anchors = new Anchor[anchors.Count];                      for (int j = 0; j < anchors.Count; j++)                  {                      var anchor = new Anchor();                      anchor.StartBeatTime = level.Anchors[j].Time;                      if (j + 1 < anchors.Count)                          anchor.EndBeatTime = level.Anchors[j + 1].Time;                      else                          // last phrase iteration = noguitar/end                          anchor.EndBeatTime = xml.PhraseIterations[xml.PhraseIterations.Length - 1].Time;                      // TODO: not 100% clear                      // times will be updated later                      // these "garbage" values are everywhere!                      //anchor.Unk3_FirstNoteTime = (float) 3.4028234663852886e+38;                      //anchor.Unk4_LastNoteTime = (float) 1.1754943508222875e-38;                      anchor.FretId = (byte)level.Anchors[j].Fret;                      anchor.Width = (Int32)level.Anchors[j].Width;                      anchor.PhraseIterationId = getPhraseIterationId(xml' anchor.StartBeatTime' false);                      anchors.Anchors[j] = anchor;                  }                    a.Anchors = anchors;                  // each slideTo will get anchor extension                  a.AnchorExtensions = new AnchorExtensionSection();                    foreach (var note in level.Notes)                      if (note.SlideTo != -1)                          ++a.AnchorExtensions.Count;                    a.AnchorExtensions.AnchorExtensions = new AnchorExtension[a.AnchorExtensions.Count];                  // Fingerprints1 is for handshapes without "arp" displayName                  a.Fingerprints1 = new FingerprintSection();                  // Fingerprints2 is for handshapes with "arp" displayName                  a.Fingerprints2 = new FingerprintSection();                    var fp1 = new List<Fingerprint>();                  var fp2 = new List<Fingerprint>();                  foreach (var h in level.HandShapes)                  {                      if (h.ChordId < 0) continue;                      var fp = new Fingerprint                      {                          ChordId = h.ChordId'                          StartTime = h.StartTime'                          EndTime = h.EndTime                          // TODO: not always StartTime                          //fp.Unk3_FirstNoteTime = fp.StartTime;                          //fp.Unk4_LastNoteTime = fp.StartTime;                      };                        if (xml.ChordTemplates[fp.ChordId].DisplayName.EndsWith("arp"))                          fp2.Add(fp);                      else                          fp1.Add(fp);                  }                    a.Fingerprints1.Count = fp1.Count;                  a.Fingerprints1.Fingerprints = fp1.ToArray();                  a.Fingerprints2.Count = fp2.Count;                  a.Fingerprints2.Fingerprints = fp2.ToArray();                    // calculated as we go through notes' seems to work                  // NotesInIteration1 is count without ignore="1" notes                  a.PhraseIterationCount1 = xml.PhraseIterations.Length;                  a.NotesInIteration1 = new Int32[a.PhraseIterationCount1];                  // NotesInIteration2 seems to be the full count                  a.PhraseIterationCount2 = a.PhraseIterationCount1;                  a.NotesInIteration2 = new Int32[a.PhraseIterationCount2];                    // notes and chords sorted by time                  List<Notes> notes = new List<Notes>();                  int acent = 0;                  foreach (var note in level.Notes)                  {                      var n = new Notes();                      Notes prev = null;                      if (notes.Count > 0)                          prev = notes.Last();                      parseNote(xml' note' n' prev);                      notes.Add(n);                        for (int j = 0; j < xml.PhraseIterations.Length; j++)                      {                          var piter = xml.PhraseIterations[j];                            // fix for 100% bug issue and improve mastery                          if (piter.Time > note.Time && j > 0)                          {                              if (note.Ignore == 0)                                  ++a.NotesInIteration1[j - 1];                              ++a.NotesInIteration2[j - 1];                              break;                          }                      }                                    if (note.SlideTo != -1)                      {                          var ae = new AnchorExtension();                          ae.FretId = (Byte)note.SlideTo;                          ae.BeatTime = note.Time + note.Sustain;                          a.AnchorExtensions.AnchorExtensions[acent++] = ae;                      }                  }                    foreach (var chord in level.Chords)                  {                      var cn = new Notes();                      Int32 id = -1;                      if (chord.ChordNotes != null && chord.ChordNotes.Length > 0)                          id = addChordNotes(sng' chord);                      parseChord(xml' sng' chord' cn' id);                      notes.Add(cn);                        for (int j = 0; j < xml.PhraseIterations.Length; j++)                      {                          var piter = xml.PhraseIterations[j];                            // fix for 100% bug issue and improve mastery                          if (piter.Time > chord.Time && j > 0)                          {                              if (chord.Ignore == 0)                                  ++a.NotesInIteration1[j - 1];                                    ++a.NotesInIteration2[j - 1];                              break;                          }                      }                  }                    // exception handler for some poorly formed RS1 CDLC                  try                  {                      // need to be sorted before anchor note times are updated                      notes.Sort((x' y) => x.Time.CompareTo(y.Time));                        // check for RS1 CDLC note time errors                       // if (notes.Count > 0) // alt method to deal with the exception                      if ((int)first_note_time == 0 || first_note_time > notes[0].Time)                          first_note_time = notes[0].Time;                  }                  catch (Exception)                  {                      // show error in convert2012CLI command window and continue                      Console.WriteLine(@" -- CDLC contains note time errors and may not play properly"); // + ex.Message);                  }                    // TODO: new phylosophy ... charting tweaks should be done in EOF by the charter                  foreach (var n in notes)                  {                      for (Int16 id = 0; id < fp1.Count; id++) //FingerPrints 1st level (common handshapes?)                          if (n.Time >= fp1[id].StartTime && n.Time < fp1[id].EndTime)                          {                              n.FingerPrintId[0] = id;                              // add STRUM to chords if highDensity = 0                              if (n.ChordId != -1 && (n.NoteMask & CON.NOTE_MASK_HIGHDENSITY) != CON.NOTE_MASK_HIGHDENSITY)                                  n.NoteMask |= CON.NOTE_MASK_STRUM;                              if (fp1[id].Unk3_FirstNoteTime == 0)                                  fp1[id].Unk3_FirstNoteTime = n.Time;                                float sustain = 0;                              if (n.Time + n.Sustain < fp1[id].EndTime)                                  sustain = n.Sustain;                              fp1[id].Unk4_LastNoteTime = n.Time + sustain;                              break;                          }                        for (Int16 id = 0; id < fp2.Count; id++) //FingerPrints 2nd level (used for -arp(eggio) handshapes)                          if (n.Time >= fp2[id].StartTime && n.Time < fp2[id].EndTime)                          {                              n.FingerPrintId[1] = id;                              // add STRUM to chords                              if (fp2[id].StartTime == n.Time && n.ChordId != -1)                                  n.NoteMask |= CON.NOTE_MASK_STRUM;                              n.NoteMask |= CON.NOTE_MASK_ARPEGGIO;                              if (fp2[id].Unk3_FirstNoteTime == 0)                                  fp2[id].Unk3_FirstNoteTime = n.Time;                                float sustain = 0;                              if (n.Time + n.Sustain < fp2[id].EndTime)                                  sustain = n.Sustain;                              fp2[id].Unk4_LastNoteTime = n.Time + sustain;                              break;                          }                        for (int j = 0; j < a.Anchors.Count; j++)                          if (n.Time >= a.Anchors.Anchors[j].StartBeatTime && n.Time < a.Anchors.Anchors[j].EndBeatTime)                          {                              n.AnchorWidth = (Byte)a.Anchors.Anchors[j].Width;                              // anchor fret                              n.AnchorFretId = (Byte)a.Anchors.Anchors[j].FretId;                              if (a.Anchors.Anchors[j].Unk3_FirstNoteTime == 0)                                  a.Anchors.Anchors[j].Unk3_FirstNoteTime = n.Time;                                float sustain = 0;                              if (n.Time + n.Sustain < a.Anchors.Anchors[j].EndBeatTime - 0.1)                                  sustain = n.Sustain;                              a.Anchors.Anchors[j].Unk4_LastNoteTime = n.Time + sustain;                              break;                          }                  }                    // initialize times for empty anchors' based on 'lrocknroll'                  foreach (var anchor in a.Anchors.Anchors)                      if (anchor.Unk3_FirstNoteTime == 0)                      {                          anchor.Unk3_FirstNoteTime = anchor.StartBeatTime;                          anchor.Unk4_LastNoteTime = anchor.StartBeatTime + (float)0.1;                      }                    a.Notes = new NotesSection();                  a.Notes.Count = notes.Count;                  a.Notes.Notes = notes.ToArray();                    foreach (var piter in sng.PhraseIterations.PhraseIterations)                  {                      int count = 0;                      int j = 0;                      for (; j < a.Notes.Count; j++)                      {                          // skip notes outside of a phraseiteration                          if (a.Notes.Notes[j].Time < piter.StartTime)                              continue;                          if (a.Notes.Notes[j].Time >= piter.NextPhraseTime)                          {                              break;                          }                          // set to next arrangement note                          a.Notes.Notes[j].NextIterNote = (Int16)(j + 1);                          // set all but first note to previous note                          if (count > 0)                              a.Notes.Notes[j].PrevIterNote = (Int16)(j - 1);                          ++count;                      }                      // fix last phrase note                      if (count > 0)                          a.Notes.Notes[j - 1].NextIterNote = -1;                  }                    for (int j = 1; j < a.Notes.Notes.Length; j++)                  {                      var n = a.Notes.Notes[j];                      var p = a.Notes.Notes[j - 1];                      int prvnote = 1; //set current + prev note + initialize prvnote variable                      //do not do this searching for a parent' if the previous note timestamp != current time stamp                      if (n.Time != p.Time) prvnote = 1;                      else                      {                          for (int x = 1; x < (a.Notes.Notes.Length); x++) //search up till the beginning of iteration                           {                              if (j - x < 1) //don't search past the first note in iteration                              {                                  prvnote = x;                                  x = a.Notes.Notes.Length + 2;                                  break; // stop searching for a match we reached the beginning                              }                              var prv = a.Notes.Notes[j - x]; // get the info for the note we are checking against                              if (prv.Time != n.Time)                              {                                  //now check the timestamp if its the same timestamp then keep looking                                  if (prv.ChordId != -1)                                  {                                      //check if its a chord                                      prvnote = x;                                      x = a.Notes.Notes.Length + 2;                                      break; //stop here' its a chord so don't need to check the strings                                  }                                  if (prv.StringIndex == n.StringIndex)                                  {                                      //check to see if we are looking at the same string                                      prvnote = x;                                      x = a.Notes.Notes.Length + 2;                                      break; //stop here we found the same string' at a different timestamp' thats not a chord                                  }                              }                          }                      }                        var prev = a.Notes.Notes[j - prvnote]; //this will be either the first note of piter' or the last note on the same string at previous timestamp                      if ((prev.NoteMask & CON.NOTE_MASK_PARENT) != 0)                      {                          n.ParentPrevNote = (short)(prev.NextIterNote - 1);                          n.NoteMask |= CON.NOTE_MASK_CHILD; //set the ParentPrevNote# = the matched Note#//add CHILD flag                      }                  }                    a.PhraseCount = xml.Phrases.Length;                  a.AverageNotesPerIteration = new float[a.PhraseCount];                  var iter_count = new float[a.PhraseCount];                  for (int j = 0; j < xml.PhraseIterations.Length; j++)                  {                      var piter = xml.PhraseIterations[j];                      // using NotesInIteration2 to calculate                      a.AverageNotesPerIteration[piter.PhraseId] += a.NotesInIteration2[j];                      ++iter_count[piter.PhraseId];                  }                    for (int j = 0; j < iter_count.Length; j++)                  {                      if (iter_count[j] > 0)                          a.AverageNotesPerIteration[j] /= iter_count[j];                  }                    // this is some kind of optimization in RS2 where they                  // hash all note data but their position in phrase iteration                  // to mark otherwise unchanged notes                  foreach (var n in a.Notes.Notes)                  {                      MemoryStream data = sng.CopyStruct(n);                      var r = new EndianBinaryReader(EndianBitConverter.Little' data);                      var ncopy = new Notes();                      ncopy.read(r);                      ncopy.NextIterNote = 0;                      ncopy.PrevIterNote = 0;                      ncopy.ParentPrevNote = 0;                      UInt32 crc = sng.HashStruct(ncopy);                      if (!note_id.ContainsKey(crc))                          note_id[crc] = (UInt32)note_id.Count;                      n.Hash = note_id[crc];                  }                    numberNotes(sng' a.Notes.Notes);                  sng.Arrangements.Arrangements[i] = a;              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,numberNotes,The following statement contains a magic number: for (int o = 0; o < notes.Length; o++)              {                  var current = notes[o];                    // skip open strings                  if (current.FretId == 0)                  {                      continue;                  }                    // are we past phrase iteration boundary?                  if (current.Time > sng.PhraseIterations.PhraseIterations[p].NextPhraseTime)                  {                      // advance and re-run                      // will be repeated through empty iterations                      ++p;                      o = o - 1;                      continue;                  }                    bool repeat = false;                  int start = o - 8;                  if (start < 0)                      start = 0;                  // search last 8 notes                  for (int i = o - 1; i >= start; i--)                  {                      // ignore notes which are too far away                      if (notes[i].Time + 2.0 < current.Time)                          continue;                      // ignore notes outside of iteration                      if (notes[i].Time < sng.PhraseIterations.PhraseIterations[p].StartTime)                          continue;                        // count as repeat if this fret/chord was numbered recently                      if ((current.ChordId == -1 && notes[i].FretId == current.FretId) ||                          (current.ChordId != -1 && notes[i].ChordId == current.ChordId))                      {                          if ((notes[i].NoteFlags & CON.NOTE_FLAGS_NUMBERED) != 0)                          {                              repeat = true;                              break;                          }                      }                  }                    // change                  if (!repeat)                      current.NoteFlags |= CON.NOTE_FLAGS_NUMBERED;              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,numberNotes,The following statement contains a magic number: for (int o = 0; o < notes.Length; o++)              {                  var current = notes[o];                    // skip open strings                  if (current.FretId == 0)                  {                      continue;                  }                    // are we past phrase iteration boundary?                  if (current.Time > sng.PhraseIterations.PhraseIterations[p].NextPhraseTime)                  {                      // advance and re-run                      // will be repeated through empty iterations                      ++p;                      o = o - 1;                      continue;                  }                    bool repeat = false;                  int start = o - 8;                  if (start < 0)                      start = 0;                  // search last 8 notes                  for (int i = o - 1; i >= start; i--)                  {                      // ignore notes which are too far away                      if (notes[i].Time + 2.0 < current.Time)                          continue;                      // ignore notes outside of iteration                      if (notes[i].Time < sng.PhraseIterations.PhraseIterations[p].StartTime)                          continue;                        // count as repeat if this fret/chord was numbered recently                      if ((current.ChordId == -1 && notes[i].FretId == current.FretId) ||                          (current.ChordId != -1 && notes[i].ChordId == current.ChordId))                      {                          if ((notes[i].NoteFlags & CON.NOTE_FLAGS_NUMBERED) != 0)                          {                              repeat = true;                              break;                          }                      }                  }                    // change                  if (!repeat)                      current.NoteFlags |= CON.NOTE_FLAGS_NUMBERED;              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014File,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014File.cs,UnpackSng,The following statement contains a magic number: using (var decrypted = new MemoryStream())              using (var ebrDec = new EndianBinaryReader(conv' decrypted)) {                  byte[] key;                  switch (platform.platform) {                      case GamePlatform.Mac:                          key = RijndaelEncryptor.SngKeyMac;                          break;                      case GamePlatform.Pc:                          key = RijndaelEncryptor.SngKeyPC;                          break;                      default:                          key = null;                          break;                  }                  if (key != null)                      RijndaelEncryptor.DecryptSngData(input' decrypted' key' conv);                  else {                      input.CopyTo(decrypted);                      decrypted.Seek(8' SeekOrigin.Begin);                  }                  //unZip                  long plainLen = ebrDec.ReadUInt32();                  ushort xU = ebrDec.ReadUInt16();                  decrypted.Position -= 2;                  if (xU == 0x78DA || xU == 0xDA78) {//LE 55928 //BE 30938                      RijndaelEncryptor.Unzip(decrypted' output' false);                  }              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014File,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014File.cs,UnpackSng,The following statement contains a magic number: using (var decrypted = new MemoryStream())              using (var ebrDec = new EndianBinaryReader(conv' decrypted)) {                  byte[] key;                  switch (platform.platform) {                      case GamePlatform.Mac:                          key = RijndaelEncryptor.SngKeyMac;                          break;                      case GamePlatform.Pc:                          key = RijndaelEncryptor.SngKeyPC;                          break;                      default:                          key = null;                          break;                  }                  if (key != null)                      RijndaelEncryptor.DecryptSngData(input' decrypted' key' conv);                  else {                      input.CopyTo(decrypted);                      decrypted.Seek(8' SeekOrigin.Begin);                  }                  //unZip                  long plainLen = ebrDec.ReadUInt32();                  ushort xU = ebrDec.ReadUInt16();                  decrypted.Position -= 2;                  if (xU == 0x78DA || xU == 0xDA78) {//LE 55928 //BE 30938                      RijndaelEncryptor.Unzip(decrypted' output' false);                  }              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014File,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014File.cs,PackSng,The following statement contains a magic number: Int32 platformHeader = (conv == EndianBitConverter.Big)? 1 : 3;
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014File,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014File.cs,PackSng,The following statement contains a magic number: using( var w = new EndianBinaryWriter(conv' output) )              using( var zData = new MemoryStream() )              using( var plain = new MemoryStream() )              using( var encrypted = new MemoryStream() )              using( var encw = new EndianBinaryWriter(conv' plain) )              {                  w.Write((Int32) 0x4A);                  w.Write(platformHeader);                    // pack with zlib TODO: better packing required!                  RijndaelEncryptor.Zip(input' zData' input.Length);                    if (platformHeader == 3) {                      // write size of uncompressed data and packed data itself | already there                      encw.Write((Int32)input.Length);                      encw.Write(zData.GetBuffer());                      encw.Flush();                        // choose key                      byte[] key;                      switch (platform.platform) {                          case GamePlatform.Mac:                              key = RijndaelEncryptor.SngKeyMac;                              break;                          default: //PC                              key = RijndaelEncryptor.SngKeyPC;                              break;                      }                      // encrypt (writes 16B IV and encrypted data)                      plain.Position = 0;                      RijndaelEncryptor.EncryptSngData(plain' encrypted' key);                      w.Write(encrypted.GetBuffer());                      w.Write(new Byte[56]); // append zero signature                  } else {                      // unencrypted and unsigned                      w.Write((Int32)input.Length);                      w.Write(zData.GetBuffer());                  }                    output.Flush();              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Sng2014File,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014File.cs,PackSng,The following statement contains a magic number: using( var w = new EndianBinaryWriter(conv' output) )              using( var zData = new MemoryStream() )              using( var plain = new MemoryStream() )              using( var encrypted = new MemoryStream() )              using( var encw = new EndianBinaryWriter(conv' plain) )              {                  w.Write((Int32) 0x4A);                  w.Write(platformHeader);                    // pack with zlib TODO: better packing required!                  RijndaelEncryptor.Zip(input' zData' input.Length);                    if (platformHeader == 3) {                      // write size of uncompressed data and packed data itself | already there                      encw.Write((Int32)input.Length);                      encw.Write(zData.GetBuffer());                      encw.Flush();                        // choose key                      byte[] key;                      switch (platform.platform) {                          case GamePlatform.Mac:                              key = RijndaelEncryptor.SngKeyMac;                              break;                          default: //PC                              key = RijndaelEncryptor.SngKeyPC;                              break;                      }                      // encrypt (writes 16B IV and encrypted data)                      plain.Position = 0;                      RijndaelEncryptor.EncryptSngData(plain' encrypted' key);                      w.Write(encrypted.GetBuffer());                      w.Write(new Byte[56]); // append zero signature                  } else {                      // unencrypted and unsigned                      w.Write((Int32)input.Length);                      w.Write(zData.GetBuffer());                  }                    output.Flush();              }
Magic Number,RocksmithToolkitLib.Sng2014HSL,Phrase,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The following statement contains a magic number: Name = r.ReadBytes(32);
Magic Number,RocksmithToolkitLib.Sng2014HSL,Chord,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The following statement contains a magic number: Frets = r.ReadBytes(6);
Magic Number,RocksmithToolkitLib.Sng2014HSL,Chord,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The following statement contains a magic number: Fingers = r.ReadBytes(6);
Magic Number,RocksmithToolkitLib.Sng2014HSL,Chord,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The following statement contains a magic number: Notes = new Int32[6];
Magic Number,RocksmithToolkitLib.Sng2014HSL,Chord,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The following statement contains a magic number: for (int i = 0; i < 6; i++) Notes[i] = r.ReadInt32();
Magic Number,RocksmithToolkitLib.Sng2014HSL,Chord,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The following statement contains a magic number: Name = r.ReadBytes(32);
Magic Number,RocksmithToolkitLib.Sng2014HSL,BendData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The following statement contains a magic number: BendData32 = new BendData32[32];
Magic Number,RocksmithToolkitLib.Sng2014HSL,BendData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The following statement contains a magic number: for (int i = 0; i < 32; i++) { var obj = new BendData32(); obj.read(r); BendData32[i] = obj; }
Magic Number,RocksmithToolkitLib.Sng2014HSL,ChordNotes,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The following statement contains a magic number: NoteMask = new UInt32[6];
Magic Number,RocksmithToolkitLib.Sng2014HSL,ChordNotes,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The following statement contains a magic number: for (int i = 0; i < 6; i++) NoteMask[i] = r.ReadUInt32();
Magic Number,RocksmithToolkitLib.Sng2014HSL,ChordNotes,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The following statement contains a magic number: BendData = new BendData[6];
Magic Number,RocksmithToolkitLib.Sng2014HSL,ChordNotes,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The following statement contains a magic number: for (int i = 0; i < 6; i++) { var obj = new BendData(); obj.read(r); BendData[i] = obj; }
Magic Number,RocksmithToolkitLib.Sng2014HSL,ChordNotes,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The following statement contains a magic number: SlideTo = r.ReadBytes(6);
Magic Number,RocksmithToolkitLib.Sng2014HSL,ChordNotes,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The following statement contains a magic number: SlideUnpitchTo = r.ReadBytes(6);
Magic Number,RocksmithToolkitLib.Sng2014HSL,ChordNotes,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The following statement contains a magic number: Vibrato = new Int16[6];
Magic Number,RocksmithToolkitLib.Sng2014HSL,ChordNotes,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The following statement contains a magic number: for (int i = 0; i < 6; i++) Vibrato[i] = r.ReadInt16();
Magic Number,RocksmithToolkitLib.Sng2014HSL,Vocal,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The following statement contains a magic number: Lyric = r.ReadBytes(48);
Magic Number,RocksmithToolkitLib.Sng2014HSL,SymbolsTexture,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The following statement contains a magic number: Font = r.ReadBytes(128);
Magic Number,RocksmithToolkitLib.Sng2014HSL,SymbolDefinition,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The following statement contains a magic number: Text = r.ReadBytes(12);
Magic Number,RocksmithToolkitLib.Sng2014HSL,PhraseIteration,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The following statement contains a magic number: Difficulty = new Int32[3];
Magic Number,RocksmithToolkitLib.Sng2014HSL,PhraseIteration,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The following statement contains a magic number: for (int i = 0; i < 3; i++) Difficulty[i] = r.ReadInt32();
Magic Number,RocksmithToolkitLib.Sng2014HSL,Action,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The following statement contains a magic number: ActionName = r.ReadBytes(256);
Magic Number,RocksmithToolkitLib.Sng2014HSL,Event,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The following statement contains a magic number: EventName = r.ReadBytes(256);
Magic Number,RocksmithToolkitLib.Sng2014HSL,Section,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The following statement contains a magic number: Name = r.ReadBytes(32);
Magic Number,RocksmithToolkitLib.Sng2014HSL,Section,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The following statement contains a magic number: StringMask = r.ReadBytes(36);
Magic Number,RocksmithToolkitLib.Sng2014HSL,Anchor,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The following statement contains a magic number: Padding = r.ReadBytes(3);
Magic Number,RocksmithToolkitLib.Sng2014HSL,Notes,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The following statement contains a magic number: FingerPrintId = new Int16[2];
Magic Number,RocksmithToolkitLib.Sng2014HSL,Notes,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The following statement contains a magic number: for (int i = 0; i < 2; i++) FingerPrintId[i] = r.ReadInt16();
Magic Number,RocksmithToolkitLib.Sng2014HSL,Metadata,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014HSL.cs,read,The following statement contains a magic number: LastConversionDateTime = r.ReadBytes(32);
Duplicate Code,RocksmithToolkitLib.Conversion,Rs1Converter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Conversion\Rs1Converter.cs,ToneToTone2014,The method contains a code clone-set at the following line numbers (starting from the method definition): ((126' 151)' (172' 197))
Missing Default,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,Generate,The following switch statement is missing a default case: switch (platform.platform)              {                  case GamePlatform.XBox360:                      if (!Directory.Exists(XBOX_WORKDIR))                          Directory.CreateDirectory(XBOX_WORKDIR);                      break;                  case GamePlatform.PS3:                      if (!Directory.Exists(PS3_WORKDIR))                          Directory.CreateDirectory(PS3_WORKDIR);                      break;              }
Missing Default,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,Generate,The following switch statement is missing a default case: switch (platform.version)                  {                      case GameVersion.RS2014:                          switch (dlcType)                          {                              case DLCPackageType.Song:                                  GenerateRS2014SongPsarc(packPsarcStream' info' platform' pnum);                                  break;                              case DLCPackageType.Lesson:                                  throw new NotImplementedException("Lesson package type not implemented yet :(");                              case DLCPackageType.Inlay:                                  GenerateRS2014InlayPsarc(packPsarcStream' info' platform);                                  break;                          }                          break;                      case GameVersion.RS2012:                          GeneratePsarcsForRS1(packPsarcStream' info' platform);                          break;                      case GameVersion.None:                          throw new InvalidOperationException("Unexpected game version value");                  }
Missing Default,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,Generate,The following switch statement is missing a default case: switch (dlcType)                          {                              case DLCPackageType.Song:                                  GenerateRS2014SongPsarc(packPsarcStream' info' platform' pnum);                                  break;                              case DLCPackageType.Lesson:                                  throw new NotImplementedException("Lesson package type not implemented yet :(");                              case DLCPackageType.Inlay:                                  GenerateRS2014InlayPsarc(packPsarcStream' info' platform);                                  break;                          }
Missing Default,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GetSTFSHeader,The following switch statement is missing a default case: switch (dlcType)              {                  case DLCPackageType.Song:                      displayName = String.Format("{0} by {1}"' info.SongInfo.SongDisplayName' info.SongInfo.Artist);                      break;                  case DLCPackageType.Lesson:                      throw new NotImplementedException("Lesson package type not implemented yet :(");                  case DLCPackageType.Inlay:                      displayName = "Custom Inlay by Song Creator";                      break;              }
Missing Default,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,GetSTFSHeader,The following switch statement is missing a default case: switch (gameVersion)              {                  case GameVersion.RS2012:                      hd.Title_Package = "Rocksmith";                      hd.TitleID = 1431505011; //55530873 in HEXA for RS1                      hd.PackageImageBinary = Resources.XBox360_DLC_image;                      break;                  case GameVersion.RS2014:                      hd.Title_Package = "Rocksmith 2014";                      hd.TitleID = 1431505088; //555308C0 in HEXA for RS2014                      hd.PackageImageBinary = Resources.XBox360_DLC_image2014;                      break;              }
Missing Default,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,ToDDS,The following switch statement is missing a default case: switch (dlcType)              {                  case DLCPackageType.Song:                      args = "-file \"{0}\" -output \"{1}\" -prescale {2} {3} -nomipmap -RescaleBox -dxt1a -overwrite -forcewrite";                      break;                  case DLCPackageType.Lesson:                      throw new NotImplementedException("Lesson package type not implemented yet :(");                  case DLCPackageType.Inlay:                      // CRITICAL - DO NOT CHANGE ARGS                      args = "-file \"{0}\" -output \"{1}\" -prescale {2} {3} -quality_highest -max -dxt5 -nomipmap -alpha -overwrite -forcewrite";                      break;              }
Missing Default,RocksmithToolkitLib.DLCPackage,DLCPackageCreator,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageCreator.cs,WriteTmpFile,The following switch statement is missing a default case: switch (platform.platform)                  {                      case GamePlatform.XBox360:                          FILES_XBOX.Add(filePath);                          break;                      case GamePlatform.PS3:                          FILES_PS3.Add(filePath);                          break;                  }
Missing Default,RocksmithToolkitLib.DLCPackage,DLCPackageData,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\DLCPackageData.cs,LoadFromFolder,The following switch statement is missing a default case: switch (Path.GetFileNameWithoutExtension(file).Split('_')[2])                      {                            case "256":                              data.AlbumArtPath = file;                              ddsFilesC.Add(new DDSConvertedFile() { sizeX = 256' sizeY = 256' sourceFile = file' destinationFile = file.CopyToTempFile(".dds") });                              break;                          case "128":                              ddsFilesC.Add(new DDSConvertedFile() { sizeX = 128' sizeY = 128' sourceFile = file' destinationFile = file.CopyToTempFile(".dds") });                              break;                          case "64":                              ddsFilesC.Add(new DDSConvertedFile() { sizeX = 64' sizeY = 64' sourceFile = file' destinationFile = file.CopyToTempFile(".dds") });                              break;                      }
Missing Default,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,Pack,The following switch statement is missing a default case: switch (platform.platform)              {                  case GamePlatform.Pc:                  case GamePlatform.Mac:                      if (platform.version == GameVersion.RS2012)                          PackPC(sourcePath' saveFileName' true' updateSng);                      else if (platform.version == GameVersion.RS2014)                          Pack2014(sourcePath' saveFileName' platform' updateSng' updateManifest);                      break;                  case GamePlatform.XBox360:                      PackXBox360(sourcePath' saveFileName' platform' updateSng' updateManifest);                      break;                  case GamePlatform.PS3:                      PackPS3(sourcePath' saveFileName' platform' updateSng' updateManifest);                      break;                  case GamePlatform.None:                      throw new InvalidOperationException(String.Format("Invalid directory structure of package. {0}Directory: {1}"' Environment.NewLine' sourcePath));              }
Missing Default,RocksmithToolkitLib.DLCPackage,Packer,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Packer.cs,Unpack,The following switch statement is missing a default case: switch (platform.platform)              {                  case GamePlatform.Pc:                  case GamePlatform.Mac:                      if (platform.version == GameVersion.RS2014)                          using (var inputStream = File.OpenRead(sourceFileName))                              ExtractPSARC(sourceFileName' savePath' inputStream' platform);                      else                      {                          using (var inputFileStream = File.OpenRead(sourceFileName))                          using (var inputStream = new MemoryStream())                          {                              if (useCryptography)                                  RijndaelEncryptor.DecryptFile(inputFileStream' inputStream' RijndaelEncryptor.DLCKey);                              else                                  inputFileStream.CopyTo(inputStream);                                ExtractPSARC(sourceFileName' savePath' inputStream' platform);                          }                      }                      break;                  case GamePlatform.XBox360:                      UnpackXBox360Package(sourceFileName' savePath' platform);                      break;                  case GamePlatform.PS3:                      UnpackPS3Package(sourceFileName' savePath' platform);                      break;                  case GamePlatform.None:                      throw new InvalidOperationException("Platform not found :(");              }
Missing Default,RocksmithToolkitLib.DLCPackage.Manifest2014,Manifest2014<T>,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest2014\Manifest2014.cs,Manifest2014,The following switch statement is missing a default case: switch (dlcType) {                  case DLCPackageType.Song:                      ModelName = "RSEnumerable_Song";                      IterationVersion = 2;                      InsertRoot = "Static.Songs.Entries";                      Entries = new Dictionary<string' Dictionary<string' T>>();                      break;                  case DLCPackageType.Lesson:                      throw new NotImplementedException("Lesson package type not implemented yet :(");                  case DLCPackageType.Inlay:                      ModelName = "RSEnumerable_Guitars";                      IterationVersion = 2;                      InsertRoot = "Static.Guitars.Entries";                      Entries = new Dictionary<string' Dictionary<string' T>>();                      break;              }
Missing Default,RocksmithToolkitLib.DLCPackage.XBlock,GameXblock<T>,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\XBlock\GameXblock.cs,Generate2014,The following switch statement is missing a default case: switch (dlcType)              {                  case DLCPackageType.Song:                      foreach (var arrangement in info.Arrangements)                      {                          if (arrangement.ArrangementType == ArrangementType.ShowLight) continue;                            var entity = new Entity2014();                          var arrangementFileName = songPartition.GetArrangementFileName(arrangement.Name' arrangement.ArrangementType);                            entity.Id = arrangement.Id.ToLowerId();                          entity.ModelName = "RSEnumerable_Song";                          entity.Name = String.Format("{0}_{1}"' info.Name' arrangementFileName);                          entity.Iterations = 0;                            entity.Properties = new List<Property2014>();                          if (platform.IsConsole)                              entity.Properties.Add(new Property2014() { Name = "Header"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Database.GetDescription()' TagValue.HsonDB.GetDescription()' String.Format(AggregateGraph2014.AggregateGraph2014.NAME_ARRANGEMENT' dlcName' arrangementFileName.ToLower())) } });                          else                              entity.Properties.Add(new Property2014() { Name = "Header"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Database.GetDescription()' TagValue.HsanDB.GetDescription()' String.Format("songs_dlc_{0}"' dlcName)) } });                          entity.Properties.Add(new Property2014() { Name = "Manifest"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Database.GetDescription()' TagValue.JsonDB.GetDescription()' String.Format(AggregateGraph2014.AggregateGraph2014.NAME_ARRANGEMENT' dlcName' arrangementFileName.ToLower())) } });                          entity.Properties.Add(new Property2014() { Name = "SngAsset"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Application.GetDescription()' TagValue.MusicgameSong.GetDescription()' String.Format(AggregateGraph2014.AggregateGraph2014.NAME_ARRANGEMENT' dlcName' arrangementFileName.ToLower())) } });                          entity.Properties.Add(new Property2014() { Name = "AlbumArtSmall"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Image.GetDescription()' TagValue.DDS.GetDescription()' String.Format("album_{0}_64"' dlcName)) } });                          entity.Properties.Add(new Property2014() { Name = "AlbumArtMedium"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Image.GetDescription()' TagValue.DDS.GetDescription()' String.Format("album_{0}_128"' dlcName)) } });                          entity.Properties.Add(new Property2014() { Name = "AlbumArtLarge"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Image.GetDescription()' TagValue.DDS.GetDescription()' String.Format("album_{0}_256"' dlcName)) } });                          if (arrangement.ArrangementType == ArrangementType.Vocal && arrangement.CustomFont) // One per song                              entity.Properties.Add(new Property2014() { Name = "LyricArt"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Image.GetDescription()' TagValue.DDS.GetDescription()' String.Format("lyrics_{0}"' dlcName)) } });                          else                              entity.Properties.Add(new Property2014() { Name = "LyricArt"' Set = new Set() { Value = "" } });                          entity.Properties.Add(new Property2014() { Name = "ShowLightsXMLAsset"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Application.GetDescription()' TagValue.XML.GetDescription()' String.Format(AggregateGraph2014.AggregateGraph2014.NAME_SHOWLIGHT' dlcName)) } });                          entity.Properties.Add(new Property2014() { Name = "SoundBank"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Audio.GetDescription()' TagValue.WwiseSoundBank.GetDescription()' String.Format("song_{0}"' dlcName)) } });                          entity.Properties.Add(new Property2014() { Name = "PreviewSoundBank"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Audio.GetDescription()' TagValue.WwiseSoundBank.GetDescription()' String.Format("song_{0}_preview"' dlcName)) } });                            game.EntitySet.Add(entity);                      }                      break;                  case DLCPackageType.Lesson:                      throw new NotImplementedException("Lesson package type not implemented yet :(");                  case DLCPackageType.Inlay:                      dlcName = info.Inlay.DLCSixName;                      var inlayEntity = new Entity2014();                        inlayEntity.Id = info.Inlay.Id.ToLowerId();                      inlayEntity.ModelName = "RSEnumerable_Guitars";                      inlayEntity.Name = info.Name;                      inlayEntity.Iterations = 0;                        inlayEntity.Properties = new List<Property2014>();                      if (platform.IsConsole)                          inlayEntity.Properties.Add(new Property2014() { Name = "Header"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Database.GetDescription()' TagValue.HsonDB.GetDescription()' String.Format("dlc_{0}"' dlcName)) } });                      else                          inlayEntity.Properties.Add(new Property2014() { Name = "Header"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Database.GetDescription()' TagValue.HsanDB.GetDescription()' String.Format("dlc_{0}"' dlcName)) } });                      inlayEntity.Properties.Add(new Property2014() { Name = "Manifest"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Database.GetDescription()' TagValue.JsonDB.GetDescription()' String.Format("dlc_guitar_{0}"' dlcName)) } });                      inlayEntity.Properties.Add(new Property2014() { Name = "PreviewArt"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Image.GetDescription()' TagValue.DDS.GetDescription()' String.Format("reward_inlay_{0}"' dlcName)) } });                      //                       inlayEntity.Properties.Add(new Property2014() { Name = "DecorativeInlays"' Set = new Set() { Value = String.Format(URN_TEMPLATE' TagValue.Application.GetDescription()' TagValue.GamebryoSceneGraph.GetDescription()' dlcName) } });                      game.EntitySet.Add(inlayEntity);                      break;              }
Missing Default,RocksmithToolkitLib.Extensions,MemoryStreamExtension,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Extensions\MemoryStreamExtension.cs,Seek,The following switch statement is missing a default case: switch (origin)              {                  case SeekOrigin.Begin:                      Position = offset;                      break;                  case SeekOrigin.Current:                      Position += offset;                      break;                  case SeekOrigin.End:                      Position = Length - offset;                      break;              }
Missing Default,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Read,The following switch statement is missing a default case: switch (bNum)                      {                          case 2: //64KB                              zLengths[i] = _reader.ReadUInt16();                              break;                          case 3: //16MB                              zLengths[i] = _reader.ReadUInt24();                              break;                          case 4: //4GB                              zLengths[i] = _reader.ReadUInt32();                              break;                      }
Missing Default,RocksmithToolkitLib.PsarcLoader,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Write,The following switch statement is missing a default case: switch (bNum)                  {                      case 2:                          _writer.Write((ushort)zLen);                          break;                      case 3:                          _writer.WriteUInt24(zLen);                          break;                      case 4:                          _writer.Write(zLen);                          break;                  }
Missing Default,RocksmithToolkitLib.PsarcLoader,MemoryStreamExtension,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PSARC.cs,Seek,The following switch statement is missing a default case: switch (origin)              {                  case SeekOrigin.Begin:                      Position = offset;                      break;                  case SeekOrigin.Current:                      Position += offset;                      break;                  case SeekOrigin.End:                      Position = Length - offset;                      break;              }
Missing Default,RocksmithToolkitLib.PsarcLoader,PsarcExtensions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PsarcLoader\PsarcExtensions.cs,InjectArchiveEntry,The following switch statement is missing a default case: switch (i)                          {                              case 0:                                  using (var sourceStream = File.OpenRead(sourcePath))                                      sourceStream.CopyTo(entryStream);                                  break;                              case 1:                                  DLCPackageCreator.GenerateToolkitVersion(entryStream' packageAuthor' packageVersion' packageComment);                                  entryName = "toolkit.version";                                  break;                          }
Missing Default,RocksmithToolkitLib.DLCPackage.Manifest.Functions,ManifestFunctions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Functions\ManifestFunctions.cs,ManifestFunctions,The following switch statement is missing a default case: switch (gameVersion)              {                  case GameVersion.RS2012:                      SectionUINames = new Dictionary<string' string>(StringComparer.OrdinalIgnoreCase);                      SectionUINames.Add("intro"' "$[6005] Intro [1]");                      SectionUINames.Add("outro"' "$[6006] Outro [1]");                      SectionUINames.Add("verse"' "$[6007] Verse [1]");                      SectionUINames.Add("chorus"' "$[6008] Chorus [1]");                      SectionUINames.Add("bridge"' "$[6009] Bridge [1]");                      SectionUINames.Add("solo"' "$[6010] Solo [1]");                      SectionUINames.Add("ambient"' "$[6011] Ambient [1]");                      SectionUINames.Add("breakdown"' "$[6012] Breakdown [1]");                      SectionUINames.Add("interlude"' "$[6013] Interlude [1]");                      SectionUINames.Add("prechorus"' "$[6014] Pre Chorus [1]");                      SectionUINames.Add("transition"' "$[6015] Transition [1]");                      SectionUINames.Add("postchorus"' "$[6016] Post Chorus [1]");                      SectionUINames.Add("hook"' "$[6017] Hook [1]");                      SectionUINames.Add("riff"' "$[6018] Riff [1]");                      SectionUINames.Add("fadein"' "$[6077] Fade In [1]");                      SectionUINames.Add("fadeout"' "$[6078] Fade Out [1]");                      SectionUINames.Add("buildup"' "$[6079] Buildup [1]");                      SectionUINames.Add("preverse"' "$[6080] Pre Verse [1]");                      SectionUINames.Add("modverse"' "$[6081] Modulated Verse [1]");                      SectionUINames.Add("postvs"' "$[6082] Post Verse [1]");                      SectionUINames.Add("variation"' "$[6083] Variation [1]");                      SectionUINames.Add("modchorus"' "$[6084] Modulated Chorus [1]");                      SectionUINames.Add("head"' "$[6085] Head [1]");                      SectionUINames.Add("modbridge"' "$[6086] Modulated Bridge [1]");                      SectionUINames.Add("melody"' "$[6087] Melody [1]");                      SectionUINames.Add("postbrdg"' "$[6088] Post Bridge [1]");                      SectionUINames.Add("prebrdg"' "$[6089] Pre Bridge [1]");                      SectionUINames.Add("vamp"' "$[6090] Vamp [1]");                      SectionUINames.Add("noguitar"' "$[6091] No Guitar [1]");                      SectionUINames.Add("silence"' "$[6092] Silence [1]");                      break;                  case GameVersion.RS2014:                      SectionUINames = new Dictionary<string' string>(StringComparer.OrdinalIgnoreCase);                      SectionUINames.Add("fadein"' "$[34276] Fade In [1]");                      SectionUINames.Add("fadeout"' "$[34277] Fade Out [1]");                      SectionUINames.Add("buildup"' "$[34278] Buildup [1]");                      SectionUINames.Add("chorus"' "$[34279] Chorus [1]");                      SectionUINames.Add("hook"' "$[34280] Hook [1]");                      SectionUINames.Add("head"' "$[34281] Head [1]");                      SectionUINames.Add("bridge"' "$[34282] Bridge [1]");                      SectionUINames.Add("ambient"' "$[34283] Ambient [1]");                      SectionUINames.Add("breakdown"' "$[34284] Breakdown [1]");                      SectionUINames.Add("interlude"' "$[34285] Interlude [1]");                      SectionUINames.Add("intro"' "$[34286] Intro [1]");                      SectionUINames.Add("melody"' "$[34287] Melody [1]");                      SectionUINames.Add("modbridge"' "$[34288] Modulated Bridge [1]");                      SectionUINames.Add("modchorus"' "$[34289] Modulated Chorus [1]");                      SectionUINames.Add("modverse"' "$[34290] Modulated Verse [1]");                      SectionUINames.Add("outro"' "$[34291] Outro [1]");                      SectionUINames.Add("postbrdg"' "$[34292] Post Bridge [1]");                      SectionUINames.Add("postchorus"' "$[34293] Post Chorus [1]");                      SectionUINames.Add("postvs"' "$[34294] Post Verse [1]");                      SectionUINames.Add("prebrdg"' "$[34295] Pre Bridge [1]");                      SectionUINames.Add("prechorus"' "$[34296] Pre Chorus [1]");                      SectionUINames.Add("preverse"' "$[34297] Pre Verse [1]");                      SectionUINames.Add("riff"' "$[34298] Riff [1]");                      SectionUINames.Add("rifff"' "$[34298] Riff [1]"); //incorrect name in some adverse cases                      SectionUINames.Add("silence"' "$[34299] Silence [1]");                      SectionUINames.Add("shifts"' "$[34308] Shifts [1]");                      SectionUINames.Add("slides"' "$[35872] Slides [1]");                      SectionUINames.Add("solo"' "$[34300] Solo [1]");                      SectionUINames.Add("tapping"' "$[34305] Tapping [1]");                      SectionUINames.Add("taps"' "$[34313] Taps [1]");                      SectionUINames.Add("transition"' "$[34301] Transition [1]");                      SectionUINames.Add("vamp"' "$[34302] Vamp [1]");                      SectionUINames.Add("variation"' "$[34303] Variation [1]");                      SectionUINames.Add("verse"' "$[34304] Verse [1]");                      SectionUINames.Add("noguitar"' "$[6091] No Guitar [1]");                      break;              }
Missing Default,RocksmithToolkitLib.DLCPackage.Manifest.Functions,ManifestFunctions,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest\Functions\ManifestFunctions.cs,GetSongDifficulty,The following switch statement is missing a default case: switch (h.Hero)                          {                              case 1:                                  easyArray.Add(h.Difficulty);                                  break;                              case 2:                                  mediumArray.Add(h.Difficulty);                                  break;                              case 3:                                  hard = h.Difficulty;                                  break;                          }
Missing Default,RocksmithToolkitLib.DLCPackage.AggregateGraph2014,AggregateGraph2014,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph2014\AggregateGraph2014.cs,AggregateGraph2014,The following switch statement is missing a default case: switch (dlcType)              {                  case DLCPackageType.Song:                      SongAggregateGraph(info' dlcType);                      break;                  case DLCPackageType.Lesson:                      throw new NotImplementedException("Lesson package type not implemented yet :(");                  case DLCPackageType.Inlay:                      InlayAggregateGraph(info' dlcType);                      break;              }
Missing Default,RocksmithToolkitLib.DLCPackage.AggregateGraph2014,GraphItemLLID,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph2014\GraphItem.cs,GraphItemLLID,The following switch statement is missing a default case: switch (graph.Type.Split(new Char[] { '/'' '>' })[5]) {                      case "llid":                          LLID = Guid.Parse(value);                          break;                      case "logpath":                          LogPathDirectory = Canonical;                          LogPathFile = value.Substring(Canonical.Length + 1);                          break;                  }
Missing Default,RocksmithToolkitLib.DLCPackage.AggregateGraph2014,GraphItem,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\AggregateGraph2014\GraphItem.cs,GraphItem,The following switch statement is missing a default case: switch (graph.Type.Split(new Char[] { '/'' '>' })[5]) {                      case "tag":                          Tag.Add(value);                          break;                      case "canonical":                          Canonical = value;                          break;                      case "name":                          Name = value;                          break;                      case "relpath":                          RelPathDirectory = Canonical;                          RelPathFile = value.Substring(Canonical.Length + 1);                          break;                  }
Missing Default,RocksmithToolkitLib.DLCPackage.Manifest2014.Header,ManifestHeader2014<T>,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\DLCPackage\Manifest2014\Header\ManifestHeader2014.cs,ManifestHeader2014,The following switch statement is missing a default case: switch (dlcType) {                  case DLCPackageType.Song:                      if (platform.IsConsole) {                          ModelName = "RSEnumerable_Song_Header";                          IterationVersion = 2;                      }                      InsertRoot = "Static.Songs.Headers";                      Entries = new Dictionary<string' Dictionary<string' T>>();                      break;                  case DLCPackageType.Lesson:                      throw new NotImplementedException("Lesson package type not implemented yet :(");                  case DLCPackageType.Inlay:                      if (platform.IsConsole) {                          ModelName = "RSEnumerable_Guitar_Header";                      }                      InsertRoot = "Static.Guitars.Headers";                      Entries = new Dictionary<string' Dictionary<string' T>>();                      break;              }
Missing Default,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Read,The following switch statement is missing a default case: switch (bNum)                      {                          case 2://64KB                              zLengths[i] = _reader.ReadUInt16();                              break;                          case 3://16MB                              zLengths[i] = _reader.ReadUInt24();                              break;                          case 4://4GB                              zLengths[i] = _reader.ReadUInt32();                              break;                      }
Missing Default,RocksmithToolkitLib.PSARC,PSARC,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\PSARC\PSARC.cs,Write,The following switch statement is missing a default case: switch (bNum)                  {                      case 2://16bit                          _writer.Write((ushort)zLen);                          break;                      case 3://24bit                          _writer.WriteUInt24(zLen);                          break;                      case 4://32bit                          _writer.Write(zLen);                          break;                  }
Missing Default,RocksmithToolkitLib.Sng2014HSL,Sng2014FileWriter,C:\repos\rscustom_rocksmith-custom-song-toolkit\RocksmithToolkitLib\Sng\Sng2014FileWriter.cs,parseDNAs,The following switch statement is missing a default case: switch (e.Code)                  {                      case "dna_none":                          id = 0;                          break;                      case "dna_solo":                          id = 1;                          break;                      case "dna_riff":                          id = 2;                          break;                      case "dna_chord":                          id = 3;                          break;                  }
