Implementation smell,Namespace,Class,File,Method,Description
Long Method,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,CollidePolygons,The method has 104 lines of code.
Long Method,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,CollideEdgeAndCircle,The method has 108 lines of code.
Long Method,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,CollideEdgeAndPolygon,The method has 215 lines of code.
Long Method,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,Solve3,The method has 113 lines of code.
Long Method,FarseerPhysics.Collision,Distance,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,ComputeDistance,The method has 116 lines of code.
Long Method,FarseerPhysics.Collision,TimeOfImpact,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\TimeOfImpact.cs,CalculateTimeOfImpact,The method has 146 lines of code.
Long Method,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The method has 104 lines of code.
Long Method,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,TriangulatePolygon,The method has 101 lines of code.
Long Method,FarseerPhysics.Common,WorldXmlSerializer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Serialization.cs,SerializeJoint,The method has 135 lines of code.
Long Method,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Serialization.cs,Deserialize,The method has 532 lines of code.
Long Method,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,DetectSquares,The method has 175 lines of code.
Long Method,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,TraceEdge,The method has 147 lines of code.
Long Method,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The method has 241 lines of code.
Long Method,FarseerPhysics.Dynamics,Island,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Island.cs,Solve,The method has 184 lines of code.
Long Method,FarseerPhysics.Dynamics,World,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\World.cs,Solve,The method has 129 lines of code.
Long Method,FarseerPhysics.Dynamics,World,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\World.cs,SolveTOI,The method has 223 lines of code.
Long Method,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\ContactSolver.cs,SolveVelocityConstraints,The method has 257 lines of code.
Complex Method,FarseerPhysics.Collision,AABB,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,RayCast,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,GetWorldManifold,Cyclomatic complexity of the method is 16
Complex Method,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,CollidePolygonAndCircle,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,CollideEdgeAndCircle,Cyclomatic complexity of the method is 11
Complex Method,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,CollideEdgeAndPolygon,Cyclomatic complexity of the method is 22
Complex Method,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,FindMaxSeparation,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Collision,DistanceProxy,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,Set,Cyclomatic complexity of the method is 16
Complex Method,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,GetWitnessPoints,Cyclomatic complexity of the method is 19
Complex Method,FarseerPhysics.Collision,Distance,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,ComputeDistance,Cyclomatic complexity of the method is 21
Complex Method,FarseerPhysics.Collision,DynamicTree,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\DynamicTree.cs,RayCast,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Collision,DynamicTree,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\DynamicTree.cs,InsertLeaf,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Collision,SeparationFunction,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\TimeOfImpact.cs,FindMinSeparation,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Collision,SeparationFunction,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\TimeOfImpact.cs,Evaluate,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Collision,TimeOfImpact,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\TimeOfImpact.cs,CalculateTimeOfImpact,Cyclomatic complexity of the method is 17
Complex Method,FarseerPhysics.Collision.Shapes,PolygonShape,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Shapes\PolygonShape.cs,RayCast,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Collision.Shapes,PolygonShape,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Shapes\PolygonShape.cs,ComputeSubmergedArea,Cyclomatic complexity of the method is 16
Complex Method,FarseerPhysics.Common.ConvexHull,ChainHull,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\ConvexHull\ChainHull.cs,GetConvexHull,Cyclomatic complexity of the method is 21
Complex Method,FarseerPhysics.Common.ConvexHull,GiftWrap,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\ConvexHull\GiftWrap.cs,GetConvexHull,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\ConvexHull\Melkman.cs,GetConvexHull,Cyclomatic complexity of the method is 16
Complex Method,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,Cyclomatic complexity of the method is 22
Complex Method,FarseerPhysics.Common.Decomposition,CDTDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDTDecomposer.cs,ConvexPartition,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,Cyclomatic complexity of the method is 19
Complex Method,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,TriangulatePolygon,Cyclomatic complexity of the method is 15
Complex Method,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,ResolvePinchPoint,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,AddTriangle,Cyclomatic complexity of the method is 14
Complex Method,FarseerPhysics.Common.Decomposition,FlipcodeDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\FlipcodeDecomposer.cs,ConvexPartition,Cyclomatic complexity of the method is 13
Complex Method,FarseerPhysics.Common.Decomposition,TrapezoidalMap,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\SeidelDecomposer.cs,BoundingBox,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Common.Decomposition,Triangulator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\SeidelDecomposer.cs,Process,Cyclomatic complexity of the method is 10
Complex Method,Poly2Tri.Triangulation.Delaunay.Sweep,AdvancingFront,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\Sweep\AdvancingFront.cs,LocateNode,Cyclomatic complexity of the method is 8
Complex Method,Poly2Tri.Triangulation.Delaunay.Sweep,AdvancingFront,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\Sweep\AdvancingFront.cs,LocatePoint,Cyclomatic complexity of the method is 10
Complex Method,Poly2Tri.Triangulation.Delaunay.Sweep,DTSweep,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\Sweep\DTSweep.cs,EdgeEvent,Cyclomatic complexity of the method is 10
Complex Method,Poly2Tri.Triangulation.Delaunay.Sweep,DTSweep,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\Sweep\DTSweep.cs,FlipEdgeEvent,Cyclomatic complexity of the method is 8
Complex Method,Poly2Tri.Triangulation.Delaunay.Sweep,DTSweep,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\Sweep\DTSweep.cs,FillBasinReq,Cyclomatic complexity of the method is 8
Complex Method,Poly2Tri.Triangulation.Delaunay.Sweep,DTSweep,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\Sweep\DTSweep.cs,Legalize,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Common,Path,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Path.cs,GetPosition,Cyclomatic complexity of the method is 19
Complex Method,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateCapsule,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Common,WorldXmlSerializer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Serialization.cs,SerializeShape,Cyclomatic complexity of the method is 13
Complex Method,FarseerPhysics.Common,WorldXmlSerializer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Serialization.cs,SerializeJoint,Cyclomatic complexity of the method is 35
Complex Method,FarseerPhysics.Common,WorldXmlSerializer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Serialization.cs,Serialize,Cyclomatic complexity of the method is 13
Complex Method,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Serialization.cs,Deserialize,Cyclomatic complexity of the method is 381
Complex Method,FarseerPhysics.Common,XMLFragmentParser,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Serialization.cs,NextToken,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Common,XMLFragmentParser,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Serialization.cs,TryParseNode,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,DetectSquares,Cyclomatic complexity of the method is 36
Complex Method,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,Cyclomatic complexity of the method is 16
Complex Method,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,combLeft,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Common,MSTerrain,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MSTerrain.cs,ApplyTexture,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Common,MSTerrain,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MSTerrain.cs,ApplyData,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Common,MSTerrain,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MSTerrain.cs,RegenerateTerrain,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Common,MSTerrain,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MSTerrain.cs,GenerateTerrain,Cyclomatic complexity of the method is 20
Complex Method,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,Initialize,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,DetectVertices,Cyclomatic complexity of the method is 31
Complex Method,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,Cyclomatic complexity of the method is 14
Complex Method,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,DistanceToHullAcceptable,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,SearchCrossingEdges,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,SplitPolygonEdge,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,CreateSimplePolygon,Cyclomatic complexity of the method is 14
Complex Method,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,IsSimple2,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,CheckPolygon,Cyclomatic complexity of the method is 36
Complex Method,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,TraceEdge,Cyclomatic complexity of the method is 27
Complex Method,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,Cyclomatic complexity of the method is 31
Complex Method,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\CuttingTools.cs,SplitShape,Cyclomatic complexity of the method is 13
Complex Method,FarseerPhysics.Common.PolygonManipulation,YuPengClipper,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\YuPengClipper.cs,CalculateIntersections,Cyclomatic complexity of the method is 12
Complex Method,FarseerPhysics.Common.PolygonManipulation,YuPengClipper,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\YuPengClipper.cs,CalculateResultChain,Cyclomatic complexity of the method is 16
Complex Method,FarseerPhysics.Common.PolygonManipulation,YuPengClipper,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\YuPengClipper.cs,BuildPolygonsFromChain,Cyclomatic complexity of the method is 11
Complex Method,FarseerPhysics.Controllers,AbstractForceController,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Controllers\AbstractForceController.cs,AbstractForceController,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Controllers,AbstractForceController,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Controllers\AbstractForceController.cs,GetDecayMultiplier,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Controllers,AbstractForceController,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Controllers\AbstractForceController.cs,Update,Cyclomatic complexity of the method is 11
Complex Method,FarseerPhysics.Controllers,GravityController,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Controllers\GravityController.cs,Update,Cyclomatic complexity of the method is 20
Complex Method,FarseerPhysics.Dynamics,ContactManager,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\ContactManager.cs,AddPair,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Dynamics,ContactManager,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\ContactManager.cs,Destroy,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Dynamics,ContactManager,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\ContactManager.cs,Collide,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Dynamics,Island,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Island.cs,Solve,Cyclomatic complexity of the method is 34
Complex Method,FarseerPhysics.Dynamics,Island,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Island.cs,SolveTOI,Cyclomatic complexity of the method is 11
Complex Method,FarseerPhysics.Dynamics,World,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\World.cs,ProcessRemovedJoints,Cyclomatic complexity of the method is 16
Complex Method,FarseerPhysics.Dynamics,World,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\World.cs,ProcessAddedJoints,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Dynamics,World,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\World.cs,Step,Cyclomatic complexity of the method is 15
Complex Method,FarseerPhysics.Dynamics,World,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\World.cs,Solve,Cyclomatic complexity of the method is 26
Complex Method,FarseerPhysics.Dynamics,World,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\World.cs,SolveTOI,Cyclomatic complexity of the method is 33
Complex Method,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\Contact.cs,Update,Cyclomatic complexity of the method is 18
Complex Method,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\Contact.cs,Evaluate,Cyclomatic complexity of the method is 25
Complex Method,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\ContactSolver.cs,SolveVelocityConstraints,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\ContactSolver.cs,Solve,Cyclomatic complexity of the method is 14
Complex Method,FarseerPhysics.Dynamics.Joints,FixedLineJoint,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Joints\FixedLineJoint.cs,InitVelocityConstraints,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Dynamics.Joints,FixedPrismaticJoint,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Joints\FixedPrismaticJoint.cs,InitVelocityConstraints,Cyclomatic complexity of the method is 12
Complex Method,FarseerPhysics.Dynamics.Joints,FixedRevoluteJoint,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Joints\FixedRevoluteJoint.cs,InitVelocityConstraints,Cyclomatic complexity of the method is 11
Complex Method,FarseerPhysics.Dynamics.Joints,FixedRevoluteJoint,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Joints\FixedRevoluteJoint.cs,SolveVelocityConstraints,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Dynamics.Joints,GearJoint,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Joints\GearJoint.cs,GearJoint,Cyclomatic complexity of the method is 49
Complex Method,FarseerPhysics.Dynamics.Joints,GearJoint,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Joints\GearJoint.cs,SolvePositionConstraints,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Dynamics.Joints,LineJoint,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Joints\LineJoint.cs,InitVelocityConstraints,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Dynamics.Joints,PrismaticJoint,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Joints\PrismaticJoint.cs,InitVelocityConstraints,Cyclomatic complexity of the method is 12
Complex Method,FarseerPhysics.Dynamics.Joints,PulleyJoint,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Joints\PulleyJoint.cs,SolvePositionConstraints,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Dynamics.Joints,RevoluteJoint,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Joints\RevoluteJoint.cs,InitVelocityConstraints,Cyclomatic complexity of the method is 11
Complex Method,FarseerPhysics.Dynamics.Joints,RevoluteJoint,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Joints\RevoluteJoint.cs,SolveVelocityConstraints,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Helpers,Camera2D,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Helpers\Camera2D.cs,Update,Cyclomatic complexity of the method is 10
Long Parameter List,FarseerPhysics.Collision,AABB,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,TestOverlap,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,GetWorldManifold,The method has 7 parameters.
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,CollideCircles,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,CollidePolygonAndCircle,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,CollidePolygons,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,CollideEdgeAndCircle,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,CollideEdgeAndPolygon,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,ClipSegmentToLine,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,EdgeSeparation,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,FindMaxSeparation,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,FindIncidentEdge,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,ReadCache,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Collision,SeparationFunction,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\TimeOfImpact.cs,Set,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,Triangle,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Common.Decomposition,FlipcodeDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\FlipcodeDecomposer.cs,Snip,The method has 6 parameters.
Long Parameter List,Poly2Tri.Triangulation.Delaunay.Sweep,DTSweep,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\Sweep\DTSweep.cs,EdgeEvent,The method has 5 parameters.
Long Parameter List,Poly2Tri.Triangulation.Delaunay.Sweep,DTSweep,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\Sweep\DTSweep.cs,FlipEdgeEvent,The method has 5 parameters.
Long Parameter List,Poly2Tri.Triangulation.Delaunay.Sweep,DTSweep,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\Sweep\DTSweep.cs,NextFlipTriangle,The method has 6 parameters.
Long Parameter List,Poly2Tri.Triangulation.Delaunay.Sweep,DTSweep,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\Sweep\DTSweep.cs,FlipScanEdgeEvent,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Common,LineTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\LineTools.cs,LineIntersect2,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Common,LineTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\LineTools.cs,LineIntersect,The method has 7 parameters.
Long Parameter List,FarseerPhysics.Common,LineTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\LineTools.cs,LineIntersect,The method has 7 parameters.
Long Parameter List,FarseerPhysics.Common,LineTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\LineTools.cs,LineIntersect,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Common,LineTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\LineTools.cs,LineIntersect,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateRoundedRectangle,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateCapsule,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreatePolygon,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,DetectSquares,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,Xlerp,The method has 7 parameters.
Long Parameter List,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,Ylerp,The method has 7 parameters.
Long Parameter List,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The method has 10 parameters.
Long Parameter List,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,TextureConverter,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,TextureConverter,The method has 8 parameters.
Long Parameter List,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,Initialize,The method has 8 parameters.
Long Parameter List,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,DetectVertices,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Factories,PathManager,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PathManager.cs,EvenlyDistributeShapesAlongPath,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Factories,PathManager,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PathManager.cs,EvenlyDistributeShapesAlongPath,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Factories,PathManager,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PathManager.cs,EvenlyDistributeShapesAlongPath,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Factories,PathManager,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PathManager.cs,EvenlyDistributeShapesAlongPath,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Factories,PathManager,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PathManager.cs,MoveBodyOnPath,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Factories,PathManager,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PathManager.cs,AttachBodiesWithRevoluteJoint,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Factories,PathManager,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PathManager.cs,AttachBodiesWithSliderJoint,The method has 8 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\BodyFactory.cs,CreateRectangle,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\BodyFactory.cs,CreateRectangle,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\BodyFactory.cs,CreateRectangle,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\BodyFactory.cs,CreateCircle,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\BodyFactory.cs,CreateEllipse,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\BodyFactory.cs,CreateEllipse,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\BodyFactory.cs,CreateEllipse,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\BodyFactory.cs,CreateEllipse,The method has 7 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\BodyFactory.cs,CreatePolygon,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\BodyFactory.cs,CreateCompoundPolygon,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\BodyFactory.cs,CreateGear,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\BodyFactory.cs,CreateGear,The method has 7 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\BodyFactory.cs,CreateCapsule,The method has 9 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\BodyFactory.cs,CreateCapsule,The method has 8 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\BodyFactory.cs,CreateCapsule,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\BodyFactory.cs,CreateRoundedRectangle,The method has 9 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\BodyFactory.cs,CreateRoundedRectangle,The method has 8 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\BodyFactory.cs,CreateRoundedRectangle,The method has 7 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\BodyFactory.cs,CreateRoundedRectangle,The method has 8 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\BodyFactory.cs,CreateBreakableBody,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\BodyFactory.cs,CreateLineArc,The method has 7 parameters.
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\BodyFactory.cs,CreateSolidArc,The method has 7 parameters.
Long Parameter List,FarseerPhysics.Factories,FixtureFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\FixtureFactory.cs,AttachRectangle,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Factories,FixtureFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\FixtureFactory.cs,AttachRectangle,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Factories,FixtureFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\FixtureFactory.cs,AttachCircle,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Factories,FixtureFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\FixtureFactory.cs,AttachEllipse,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Factories,FixtureFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\FixtureFactory.cs,AttachEllipse,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Factories,FixtureFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\FixtureFactory.cs,AttachLineArc,The method has 7 parameters.
Long Parameter List,FarseerPhysics.Factories,FixtureFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\FixtureFactory.cs,AttachSolidArc,The method has 7 parameters.
Long Parameter List,FarseerPhysics.Factories,JointFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\JointFactory.cs,CreateWeldJoint,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Factories,JointFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\JointFactory.cs,CreatePrismaticJoint,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Factories,JointFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\JointFactory.cs,CreateLineJoint,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Factories,JointFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\JointFactory.cs,CreateDistanceJoint,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Factories,JointFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\JointFactory.cs,CreateFrictionJoint,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Factories,JointFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\JointFactory.cs,CreatePulleyJoint,The method has 8 parameters.
Long Parameter List,FarseerPhysics.Factories,JointFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\JointFactory.cs,CreateSliderJoint,The method has 7 parameters.
Long Parameter List,FarseerPhysics.Factories,LinkFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\LinkFactory.cs,CreateChain,The method has 9 parameters.
Long Parameter List,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The method has 8 parameters.
Long Parameter List,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\CuttingTools.cs,SplitShape,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\CuttingTools.cs,Cut,The method has 12 parameters.
Long Parameter List,FarseerPhysics.Common.PolygonManipulation,YuPengClipper,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\YuPengClipper.cs,CalculateResultChain,The method has 6 parameters.
Long Parameter List,FarseerPhysics.Controllers,BuoyancyController,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Controllers\BuoyancyController.cs,BuoyancyController,The method has 5 parameters.
Long Parameter List,FarseerPhysics,DebugView,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\DebugView.cs,DrawPolygon,The method has 5 parameters.
Long Parameter List,FarseerPhysics,DebugView,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\DebugView.cs,DrawSolidPolygon,The method has 5 parameters.
Long Parameter List,FarseerPhysics,DebugView,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\DebugView.cs,DrawCircle,The method has 5 parameters.
Long Parameter List,FarseerPhysics,DebugView,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\DebugView.cs,DrawSolidCircle,The method has 6 parameters.
Long Parameter List,FarseerPhysics,DebugView,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\DebugView.cs,DrawSegment,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Dynamics,World,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\World.cs,RayCast,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\ContactSolver.cs,Solve,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Dynamics.Joints,PrismaticJoint,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Joints\PrismaticJoint.cs,PrismaticJoint,The method has 5 parameters.
Long Parameter List,FarseerPhysics.Dynamics.Joints,PulleyJoint,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Joints\PulleyJoint.cs,PulleyJoint,The method has 7 parameters.
Long Parameter List,FarseerPhysics.Dynamics.Joints,SliderJoint,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Joints\SliderJoint.cs,SliderJoint,The method has 6 parameters.
Long Statement,FarseerPhysics.Collision,AABB,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,Contains,The length of the statement  "	if ((point.X > (LowerBound.X + Settings.Epsilon) && point.X < (UpperBound.X - Settings.Epsilon) && (point.Y > (LowerBound.Y + Settings.Epsilon) && point.Y < (UpperBound.Y - Settings.Epsilon)))) { " is 195.
Long Statement,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,GetWorldManifold,The length of the statement  "			float pointAx = transformA.Position.X + transformA.R.Col1.X * manifold.LocalPoint.X + transformA.R.Col2.X * manifold.LocalPoint.Y; " is 130.
Long Statement,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,GetWorldManifold,The length of the statement  "			float pointAy = transformA.Position.Y + transformA.R.Col1.Y * manifold.LocalPoint.X + transformA.R.Col2.Y * manifold.LocalPoint.Y; " is 130.
Long Statement,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,GetWorldManifold,The length of the statement  "			float planePointx = transformA.Position.X + transformA.R.Col1.X * manifold.LocalPoint.X + transformA.R.Col2.X * manifold.LocalPoint.Y; " is 134.
Long Statement,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,GetWorldManifold,The length of the statement  "			float planePointy = transformA.Position.Y + transformA.R.Col1.Y * manifold.LocalPoint.X + transformA.R.Col2.Y * manifold.LocalPoint.Y; " is 134.
Long Statement,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,GetWorldManifold,The length of the statement  "			float planePointx = transformB.Position.X + transformB.R.Col1.X * manifold.LocalPoint.X + transformB.R.Col2.X * manifold.LocalPoint.Y; " is 134.
Long Statement,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,GetWorldManifold,The length of the statement  "			float planePointy = transformB.Position.Y + transformB.R.Col1.Y * manifold.LocalPoint.X + transformB.R.Col2.Y * manifold.LocalPoint.Y; " is 134.
Long Statement,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,CollidePolygonAndCircle,The length of the statement  "	Vector2 c = new Vector2 (transformB.Position.X + transformB.R.Col1.X * circleB.Position.X + transformB.R.Col2.X * circleB.Position.Y' transformB.Position.Y + transformB.R.Col1.Y * circleB.Position.X + transformB.R.Col2.Y * circleB.Position.Y); " is 243.
Long Statement,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,CollidePolygonAndCircle,The length of the statement  "	Vector2 cLocal = new Vector2 ((c.X - transformA.Position.X) * transformA.R.Col1.X + (c.Y - transformA.Position.Y) * transformA.R.Col1.Y' (c.X - transformA.Position.X) * transformA.R.Col2.X + (c.Y - transformA.Position.Y) * transformA.R.Col2.Y); " is 244.
Long Statement,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,CollidePolygonAndCircle,The length of the statement  "		float factor = 1f / (float)Math.Sqrt (manifold.LocalNormal.X * manifold.LocalNormal.X + manifold.LocalNormal.Y * manifold.LocalNormal.Y); " is 137.
Long Statement,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,CollidePolygonAndCircle,The length of the statement  "		float factor = 1f / (float)Math.Sqrt (manifold.LocalNormal.X * manifold.LocalNormal.X + manifold.LocalNormal.Y * manifold.LocalNormal.Y); " is 137.
Long Statement,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,CollidePolygons,The length of the statement  "	Vector2 tangent = new Vector2 (xf1.R.Col1.X * localTangentX + xf1.R.Col2.X * localTangentY' xf1.R.Col1.Y * localTangentX + xf1.R.Col2.Y * localTangentY); " is 153.
Long Statement,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,CollidePolygons,The length of the statement  "	v11 = new Vector2 (xf1.Position.X + xf1.R.Col1.X * v11.X + xf1.R.Col2.X * v11.Y' xf1.Position.Y + xf1.R.Col1.Y * v11.X + xf1.R.Col2.Y * v11.Y); " is 143.
Long Statement,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,CollidePolygons,The length of the statement  "	v12 = new Vector2 (xf1.Position.X + xf1.R.Col1.X * v12.X + xf1.R.Col2.X * v12.Y' xf1.Position.Y + xf1.R.Col1.Y * v12.X + xf1.R.Col2.Y * v12.Y); " is 143.
Long Statement,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,ComputeEdgeSeparation,The length of the statement  "		bool valid1 = MathUtils.Cross (n' _limit11) >= -Settings.AngularSlop && MathUtils.Cross (_limit12' n) >= -Settings.AngularSlop; " is 127.
Long Statement,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,ComputeEdgeSeparation,The length of the statement  "		bool valid2 = MathUtils.Cross (n' _limit21) >= -Settings.AngularSlop && MathUtils.Cross (_limit22' n) >= -Settings.AngularSlop; " is 127.
Long Statement,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,ComputePolygonSeparation,The length of the statement  "		bool valid1 = MathUtils.Cross (n' _limit11) >= -Settings.AngularSlop && MathUtils.Cross (_limit12' n) >= -Settings.AngularSlop; " is 127.
Long Statement,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,ComputePolygonSeparation,The length of the statement  "		bool valid2 = MathUtils.Cross (n' _limit21) >= -Settings.AngularSlop && MathUtils.Cross (_limit22' n) >= -Settings.AngularSlop; " is 127.
Long Statement,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,EdgeSeparation,The length of the statement  "	Vector2 normal = new Vector2 (normalWorldx * xf2.R.Col1.X + normalWorldy * xf2.R.Col1.Y' normalWorldx * xf2.R.Col2.X + normalWorldy * xf2.R.Col2.Y); " is 148.
Long Statement,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,EdgeSeparation,The length of the statement  "	return ((xf2.Position.X + xf2.R.Col1.X * p2vi.X + xf2.R.Col2.X * p2vi.Y) - (xf1.Position.X + xf1.R.Col1.X * p1ve.X + xf1.R.Col2.X * p1ve.Y)) * normalWorldx + ((xf2.Position.Y + xf2.R.Col1.Y * p2vi.X + xf2.R.Col2.Y * p2vi.Y) - (xf1.Position.Y + xf1.R.Col1.Y * p1ve.X + xf1.R.Col2.Y * p1ve.Y)) * normalWorldy; " is 307.
Long Statement,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,FindMaxSeparation,The length of the statement  "	float dx = (xf2.Position.X + xf2.R.Col1.X * poly2.MassData.Centroid.X + xf2.R.Col2.X * poly2.MassData.Centroid.Y) - (xf1.Position.X + xf1.R.Col1.X * poly1.MassData.Centroid.X + xf1.R.Col2.X * poly1.MassData.Centroid.Y); " is 219.
Long Statement,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,FindMaxSeparation,The length of the statement  "	float dy = (xf2.Position.Y + xf2.R.Col1.Y * poly2.MassData.Centroid.X + xf2.R.Col2.Y * poly2.MassData.Centroid.Y) - (xf1.Position.Y + xf1.R.Col1.Y * poly1.MassData.Centroid.X + xf1.R.Col2.Y * poly1.MassData.Centroid.Y); " is 219.
Long Statement,FarseerPhysics.Collision.Shapes,EdgeShape,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Shapes\EdgeShape.cs,CompareTo,The length of the statement  "	return (HasVertex0 == shape.HasVertex0 && HasVertex3 == shape.HasVertex3 && Vertex0 == shape.Vertex0 && Vertex1 == shape.Vertex1 && Vertex2 == shape.Vertex2 && Vertex3 == shape.Vertex3); " is 186.
Long Statement,FarseerPhysics.Collision.Shapes,PolygonShape,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Shapes\PolygonShape.cs,ComputeSubmergedArea,The length of the statement  "	Vector2 intoVec = new Vector2 (Vertices [intoIndex].X * (1 - intoLambda) + Vertices [intoIndex2].X * intoLambda' Vertices [intoIndex].Y * (1 - intoLambda) + Vertices [intoIndex2].Y * intoLambda); " is 195.
Long Statement,FarseerPhysics.Collision.Shapes,PolygonShape,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Shapes\PolygonShape.cs,ComputeSubmergedArea,The length of the statement  "	Vector2 outoVec = new Vector2 (Vertices [outoIndex].X * (1 - outoLambda) + Vertices [outoIndex2].X * outoLambda' Vertices [outoIndex].Y * (1 - outoLambda) + Vertices [outoIndex2].Y * outoLambda); " is 195.
Long Statement,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\ConvexHull\Melkman.cs,GetConvexHull,The length of the statement  "		if (MathUtils.Area (ref deque [qfm1]' ref deque [qf]' ref nextPt) > 0 && MathUtils.Area (ref deque [qb]' ref deque [qbm1]' ref nextPt) > 0) " is 139.
Long Statement,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The length of the statement  "				if (Left (At (i - 1' vertices)' At (i' vertices)' At (j' vertices)) && RightOn (At (i - 1' vertices)' At (i' vertices)' At (j - 1' vertices))) { " is 144.
Long Statement,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The length of the statement  "				if (Left (At (i + 1' vertices)' At (i' vertices)' At (j + 1' vertices)) && RightOn (At (i + 1' vertices)' At (i' vertices)' At (j' vertices))) { " is 144.
Long Statement,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The length of the statement  "							if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices))) { " is 142.
Long Statement,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,CanSee,The length of the statement  "		if (LeftOn (At (i' vertices)' At (i - 1' vertices)' At (j' vertices)) && RightOn (At (i' vertices)' At (i + 1' vertices)' At (j' vertices))) " is 140.
Long Statement,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,CanSee,The length of the statement  "		if (RightOn (At (i' vertices)' At (i + 1' vertices)' At (j' vertices)) || LeftOn (At (i' vertices)' At (i - 1' vertices)' At (j' vertices))) " is 140.
Long Statement,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,CanSee,The length of the statement  "		if (LeftOn (At (j' vertices)' At (j - 1' vertices)' At (i' vertices)) && RightOn (At (j' vertices)' At (j + 1' vertices)' At (i' vertices))) " is 140.
Long Statement,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,CanSee,The length of the statement  "		if (RightOn (At (j' vertices)' At (j + 1' vertices)' At (i' vertices)) || LeftOn (At (j' vertices)' At (j - 1' vertices)' At (i' vertices))) " is 140.
Long Statement,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,CanSee,The length of the statement  "		if (LineTools.LineIntersect (At (i' vertices)' At (j' vertices)' At (k' vertices)' At (k + 1' vertices)' out intersectionPoint)) { " is 130.
Long Statement,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The length of the statement  "		if (((triangulated [i].X [0] == triangulated [i].X [1]) && (triangulated [i].Y [0] == triangulated [i].Y [1])) || ((triangulated [i].X [1] == triangulated [i].X [2]) && (triangulated [i].Y [1] == triangulated [i].Y [2])) || ((triangulated [i].X [0] == triangulated [i].X [2]) && (triangulated [i].Y [0] == triangulated [i].Y [2]))) { " is 333.
Long Statement,Poly2Tri.Triangulation.Polygon,Polygon,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Polygon\Polygon.cs,InsertPointAfter,The length of the statement  "		throw new ArgumentException ("Tried to insert a point into a Polygon after a point not belonging to the Polygon"' "point"); " is 123.
Long Statement,FarseerPhysics.Common,LineTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\LineTools.cs,LineIntersect,The length of the statement  "	return LineIntersect (ref point1' ref point2' ref point3' ref point4' firstIsSegment' secondIsSegment' out intersectionPoint); " is 126.
Long Statement,FarseerPhysics.Common,MathUtils,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Math.cs,Multiply,The length of the statement  "	return new Vector2 (T.Position.X + T.R.Col1.X * v.X + T.R.Col2.X * v.Y' T.Position.Y + T.R.Col1.Y * v.X + T.R.Col2.Y * v.Y); " is 124.
Long Statement,FarseerPhysics.Common,Mat33,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Math.cs,Solve33,The length of the statement  "	return new Vector3 (det * Vector3.Dot (b' Vector3.Cross (Col2' Col3))' det * Vector3.Dot (Col1' Vector3.Cross (b' Col3))' det * Vector3.Dot (Col1' Vector3.Cross (Col2' b))); " is 173.
Long Statement,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateRoundedRectangle,The length of the statement  "			vertices.Add (posOffset + new Vector2 (xRadius * (float)Math.Cos (stepSize * -(i + phase))' -yRadius * (float)Math.Sin (stepSize * -(i + phase)))); " is 147.
Long Statement,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateCapsule,The length of the statement  "		throw new ArgumentException ("The radius must be lower than height / 2. Higher values of radius would create a circle' and not a half circle."' "endRadius"); " is 157.
Long Statement,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateCapsule,The length of the statement  "		throw new ArgumentException ("The top radius must be lower than height / 2. Higher values of top radius would create a circle' and not a half circle."' "topRadius"); " is 165.
Long Statement,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateCapsule,The length of the statement  "		throw new ArgumentException ("The bottom radius must be lower than height / 2. Higher values of bottom radius would create a circle' and not a half circle."' "bottomRadius"); " is 174.
Long Statement,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateCapsule,The length of the statement  "		vertices.Add (new Vector2 (topRadius * (float)Math.Cos (stepSize * i)' topRadius * (float)Math.Sin (stepSize * i) + newHeight)); " is 128.
Long Statement,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateCapsule,The length of the statement  "		vertices.Add (new Vector2 (-bottomRadius * (float)Math.Cos (stepSize * i)' -bottomRadius * (float)Math.Sin (stepSize * i) - newHeight)); " is 136.
Long Statement,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateGear,The length of the statement  "			vertices.Add (new Vector2 (radius * (float)Math.Cos (stepSize * i + toothAngleStepSize * 2f + toothTipStepSize)' -radius * (float)Math.Sin (stepSize * i + toothAngleStepSize * 2f + toothTipStepSize))); " is 201.
Long Statement,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateGear,The length of the statement  "			vertices.Add (new Vector2 ((radius + toothHeight) * (float)Math.Cos (stepSize * i + toothAngleStepSize + toothTipStepSize)' -(radius + toothHeight) * (float)Math.Sin (stepSize * i + toothAngleStepSize + toothTipStepSize))); " is 223.
Long Statement,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateGear,The length of the statement  "		vertices.Add (new Vector2 ((radius + toothHeight) * (float)Math.Cos (stepSize * i + toothAngleStepSize)' -(radius + toothHeight) * (float)Math.Sin (stepSize * i + toothAngleStepSize))); " is 185.
Long Statement,FarseerPhysics.Common,MSTerrain,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MSTerrain.cs,GenerateTerrain,The length of the statement  "	List<Vertices> polys = MarchingSquares.DetectSquares (new AABB (new Vector2 (ax' ay)' new Vector2 (ax + CellSize' ay + CellSize))' SubCellSize' SubCellSize' _terrainMap' Iterations' true); " is 188.
Long Statement,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,SetTextureData,The length of the statement  "		throw new ArgumentOutOfRangeException ("data"' "'data' length can't be less then 4. Your texture must be at least 2 x 2 pixels in size."); " is 138.
Long Statement,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,SetTextureData,The length of the statement  "		throw new ArgumentOutOfRangeException ("width"' "'width' can't be less then 2. Your texture must be at least 2 x 2 pixels in size."); " is 133.
Long Statement,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,DetectVertices,The length of the statement  "		throw new Exception ("'_data' can't be null. You have to use SetTextureData(uint[] data' int width) before calling this method."); " is 130.
Long Statement,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,DetectVertices,The length of the statement  "		throw new Exception ("'_data' length can't be less then 4. Your texture must be at least 2 x 2 pixels in size. " + "You have to use SetTextureData(uint[] data' int width) before calling this method."); " is 201.
Long Statement,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,DetectVertices,The length of the statement  "		throw new Exception ("'_width' can't be less then 2. Your texture must be at least 2 x 2 pixels in size. " + "You have to use SetTextureData(uint[] data' int width) before calling this method."); " is 195.
Long Statement,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,DetectVertices,The length of the statement  "		throw new Exception ("'_width' has an invalid value. You have to use SetTextureData(uint[] data' int width) before calling this method."); " is 138.
Long Statement,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,DetectVertices,The length of the statement  "			polygon = new DetectedVertices (CreateSimplePolygon (polygonEntrance.Value' new Vector2 (polygonEntrance.Value.X - 1f' polygonEntrance.Value.Y))); " is 146.
Long Statement,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,DistanceToHullAcceptable,The length of the statement  "			if (LineTools.DistanceBetweenPointAndLineSegment (ref point' ref edgeVertex1' ref edgeVertex2) <= _hullTolerance || LineTools.DistanceBetweenPointAndPoint (ref point' ref edgeVertex1) <= _hullTolerance) { " is 204.
Long Statement,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,SearchForOutstandingVertex,The length of the statement  "			if (LineTools.DistanceBetweenPointAndLineSegment (ref tempVector1' ref tempVector2' ref tempVector3) >= _hullTolerance) { " is 121.
Long Statement,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,TraceEdge,The length of the statement  "						bool crosses = LineTools.LineIntersect (nodes [i].Position' nodes [i].Connected [j].Position' nodes [k].Position' nodes [k].Connected [l].Position' out intersectPt); " is 165.
Long Statement,FarseerPhysics.Factories,PathManager,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PathManager.cs,AttachBodiesWithSliderJoint,The length of the statement  "		SliderJoint lastjoint = new SliderJoint (bodies [0]' bodies [bodies.Count - 1]' localAnchorA' localAnchorB' minLength' maxLength); " is 130.
Long Statement,FarseerPhysics.Factories,LinkFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\LinkFactory.cs,CreateChain,The length of the statement  "	List<Body> chainLinks = PathManager.EvenlyDistributeShapesAlongPath (world' path' shape' BodyType.Dynamic' numberOfLinks); " is 122.
Long Statement,FarseerPhysics.Factories,LinkFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\LinkFactory.cs,CreateChain,The length of the statement  "		JointFactory.CreateFixedRevoluteJoint (world' chainLinks [0]' new Vector2 (0' -(linkHeight / 2))' chainLinks [0].Position); " is 123.
Long Statement,FarseerPhysics.Factories,LinkFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\LinkFactory.cs,CreateChain,The length of the statement  "		JointFactory.CreateFixedRevoluteJoint (world' chainLinks [chainLinks.Count - 1]' new Vector2 (0' (linkHeight / 2))' chainLinks [chainLinks.Count - 1].Position); " is 160.
Long Statement,FarseerPhysics.Factories,LinkFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\LinkFactory.cs,CreateChain,The length of the statement  "	PathManager.AttachBodiesWithRevoluteJoint (world' chainLinks' new Vector2 (0' -linkHeight)' new Vector2 (0' linkHeight)' false' false); " is 135.
Long Statement,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The length of the statement  "			if ((_data.Count () > 1) && (i == valIndex - 1) && (_data.Last ().Body == _data.First ().Body) && (_data.Last ().Max == _data.First ().Min)) { " is 142.
Long Statement,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The length of the statement  "		for (float j = _data [i].Min + first; j < _data [i].Max || MathUtils.FloatEquals (j' _data [i].Max' 0.0001f); j += offset) { " is 124.
Long Statement,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The length of the statement  "				float impulse = (arclen / (MinRays + insertedRays)) * maxForce * 180.0f / MathHelper.Pi * (1.0f - Math.Min (1.0f' minlambda)); " is 126.
Long Statement,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The length of the statement  "				Vector2 vectImp = Vector2.Dot (impulse * new Vector2 ((float)Math.Cos (j)' (float)Math.Sin (j))' -ro.Normal) * new Vector2 ((float)Math.Cos (j)' (float)Math.Sin (j)); " is 166.
Long Statement,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\CuttingTools.cs,SplitShape,The length of the statement  "		if (Vector2.Dot (MathUtils.Cross (localExitPoint - localEntryPoint' 1)' vertices [i] - localEntryPoint) > Settings.Epsilon) " is 123.
Long Statement,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\SimplifyTools.cs,DistancePointLine,The length of the statement  "	        */double r = ((p.X - A.X) * (B.X - A.X) + (p.Y - A.Y) * (B.Y - A.Y)) / ((B.X - A.X) * (B.X - A.X) + (B.Y - A.Y) * (B.Y - A.Y)); " is 127.
Long Statement,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\SimplifyTools.cs,DistancePointLine,The length of the statement  "	        */double s = ((A.Y - p.Y) * (B.X - A.X) - (A.X - p.X) * (B.Y - A.Y)) / ((B.X - A.X) * (B.X - A.X) + (B.Y - A.Y) * (B.Y - A.Y)); " is 127.
Long Statement,FarseerPhysics.Common.PolygonManipulation,YuPengClipper,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\YuPengClipper.cs,Execute,The length of the statement  "	            Debug.Assert(subject.IsSimple() && clip.IsSimple()' "Non simple input! Input polygons must be simple (cannot intersect themselves).");" is 134.
Long Statement,FarseerPhysics.Common.PolygonManipulation,YuPengClipper,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\YuPengClipper.cs,Execute,The length of the statement  "	Debug.Assert (subject.IsSimple () && clip.IsSimple ()' "Non simple input!"' "Input polygons must be simple (cannot intersect themselves)."); " is 140.
Long Statement,FarseerPhysics.Common.PolygonManipulation,YuPengClipper,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\YuPengClipper.cs,CalculateResultChain,The length of the statement  "		if (poly2Simplicies.Contains (poly1Simplicies [i]) || (poly2Simplicies.Contains (-poly1Simplicies [i]) && clipType == PolyClipType.Union)) { " is 140.
Long Statement,FarseerPhysics.Common.PolygonManipulation,YuPengClipper,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\YuPengClipper.cs,CalculateResultChain,The length of the statement  "			if (poly1Simplicies.Contains (poly2Simplicies [i]) || (poly1Simplicies.Contains (-poly2Simplicies [i]) && clipType == PolyClipType.Union)) { " is 140.
Long Statement,FarseerPhysics.Common.PolygonManipulation,YuPengClipper,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\YuPengClipper.cs,PointOnLineSegment,The length of the statement  "	return MathUtils.Area (ref start' ref end' ref point) == 0f && Vector2.Dot (point - start' segment) >= 0f && Vector2.Dot (point - end' segment) <= 0f; " is 150.
Long Statement,FarseerPhysics.Controllers,SimpleWindForce,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Controllers\SimpleWindForce.cs,ApplyForce,The length of the statement  "			//forceVector = Vector2.Transform(forceVector' Matrix.CreateRotationZ((MathHelper.Pi - MathHelper.Pi/2) * (float)Randomize.NextDouble())); " is 138.
Long Statement,FarseerPhysics.Dynamics,Body,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Body.cs,SetTransformIgnoreContacts,The length of the statement  "	Sweep.C0 = Sweep.C = new Vector2 (Xf.Position.X + Xf.R.Col1.X * Sweep.LocalCenter.X + Xf.R.Col2.X * Sweep.LocalCenter.Y' Xf.Position.Y + Xf.R.Col1.Y * Sweep.LocalCenter.X + Xf.R.Col2.Y * Sweep.LocalCenter.Y); " is 208.
Long Statement,FarseerPhysics.Dynamics,Body,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Body.cs,GetWorldPoint,The length of the statement  "	return new Vector2 (Xf.Position.X + Xf.R.Col1.X * localPoint.X + Xf.R.Col2.X * localPoint.Y' Xf.Position.Y + Xf.R.Col1.Y * localPoint.X + Xf.R.Col2.Y * localPoint.Y); " is 166.
Long Statement,FarseerPhysics.Dynamics,Body,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Body.cs,GetWorldVector,The length of the statement  "	return new Vector2 (Xf.R.Col1.X * localVector.X + Xf.R.Col2.X * localVector.Y' Xf.R.Col1.Y * localVector.X + Xf.R.Col2.Y * localVector.Y); " is 138.
Long Statement,FarseerPhysics.Dynamics,Body,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Body.cs,GetLocalPoint,The length of the statement  "	return new Vector2 ((worldPoint.X - Xf.Position.X) * Xf.R.Col1.X + (worldPoint.Y - Xf.Position.Y) * Xf.R.Col1.Y' (worldPoint.X - Xf.Position.X) * Xf.R.Col2.X + (worldPoint.Y - Xf.Position.Y) * Xf.R.Col2.Y); " is 206.
Long Statement,FarseerPhysics.Dynamics,Body,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Body.cs,GetLocalVector,The length of the statement  "	return new Vector2 (worldVector.X * Xf.R.Col1.X + worldVector.Y * Xf.R.Col1.Y' worldVector.X * Xf.R.Col2.X + worldVector.Y * Xf.R.Col2.Y); " is 138.
Long Statement,FarseerPhysics.Dynamics,Body,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Body.cs,GetLinearVelocityFromWorldPoint,The length of the statement  "	return LinearVelocityInternal + new Vector2 (-AngularVelocityInternal * (worldPoint.Y - Sweep.C.Y)' AngularVelocityInternal * (worldPoint.X - Sweep.C.X)); " is 154.
Long Statement,FarseerPhysics.Dynamics,ContactManager,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\ContactManager.cs,ShouldCollide,The length of the statement  "		if ((fixtureA.CollisionGroup == fixtureB.CollisionGroup) && fixtureA.CollisionGroup != 0 && fixtureB.CollisionGroup != 0) " is 121.
Long Statement,FarseerPhysics.Dynamics,ContactManager,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\ContactManager.cs,ShouldCollide,The length of the statement  "		if (((fixtureA.CollisionCategories & fixtureB.CollidesWith) == Category.None) & ((fixtureB.CollisionCategories & fixtureA.CollidesWith) == Category.None)) " is 154.
Long Statement,FarseerPhysics.Dynamics,ContactManager,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\ContactManager.cs,ShouldCollide,The length of the statement  "	bool collide = (fixtureA.CollidesWith & fixtureB.CollisionCategories) != 0 && (fixtureA.CollisionCategories & fixtureB.CollidesWith) != 0; " is 138.
Long Statement,FarseerPhysics.Dynamics,Fixture,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Fixture.cs,CompareTo,The length of the statement  "	return (CollidesWith == fixture.CollidesWith && CollisionCategories == fixture.CollisionCategories && CollisionGroup == fixture.CollisionGroup && Friction == fixture.Friction && IsSensor == fixture.IsSensor && Restitution == fixture.Restitution && Shape.CompareTo (fixture.Shape) && UserData == fixture.UserData); " is 313.
Long Statement,FarseerPhysics.Dynamics,Island,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Island.cs,Solve,The length of the statement  "			if ((b.Flags & BodyFlags.AutoSleep) == 0 || b.AngularVelocityInternal * b.AngularVelocityInternal > AngTolSqr || Vector2.Dot (b.LinearVelocityInternal' b.LinearVelocityInternal) > LinTolSqr) { " is 192.
Long Statement,FarseerPhysics.Dynamics,World,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\World.cs,RemoveBody,The length of the statement  "	Debug.Assert (!_bodyRemoveList.Contains (body)' "The body is already marked for removal. You are removing the body more than once."); " is 133.
Long Statement,FarseerPhysics.Dynamics,World,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\World.cs,RemoveJoint,The length of the statement  "		Debug.Assert (!_jointRemoveList.Contains (joint)' "The joint is already marked for removal. You are removing the joint more than once."); " is 137.
Long Statement,FarseerPhysics.Dynamics,World,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\World.cs,Step,The length of the statement  "		ContinuousPhysicsTime = _watch.ElapsedTicks - (AddRemoveTime + ControllersUpdateTime + ContactsUpdateTime + SolveUpdateTime); " is 125.
Long Statement,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\Contact.cs,GetWorldManifold,The length of the statement  "	Collision.Collision.GetWorldManifold (ref Manifold' ref bodyA.Xf' shapeA.Radius' ref bodyB.Xf' shapeB.Radius' out normal' out points); " is 134.
Long Statement,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\Contact.cs,Evaluate,The length of the statement  "		Collision.Collision.CollidePolygons (ref manifold' (PolygonShape)FixtureA.Shape' ref transformA' (PolygonShape)FixtureB.Shape' ref transformB); " is 143.
Long Statement,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\Contact.cs,Evaluate,The length of the statement  "		Collision.Collision.CollidePolygonAndCircle (ref manifold' (PolygonShape)FixtureA.Shape' ref transformA' (CircleShape)FixtureB.Shape' ref transformB); " is 150.
Long Statement,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\Contact.cs,Evaluate,The length of the statement  "		Collision.Collision.CollideEdgeAndCircle (ref manifold' (EdgeShape)FixtureA.Shape' ref transformA' (CircleShape)FixtureB.Shape' ref transformB); " is 144.
Long Statement,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\Contact.cs,Evaluate,The length of the statement  "		Collision.Collision.CollideEdgeAndPolygon (ref manifold' (EdgeShape)FixtureA.Shape' ref transformA' (PolygonShape)FixtureB.Shape' ref transformB); " is 146.
Long Statement,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\Contact.cs,Evaluate,The length of the statement  "		Collision.Collision.CollideEdgeAndCircle (ref manifold' _edge' ref transformA' (CircleShape)FixtureB.Shape' ref transformB); " is 124.
Long Statement,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\Contact.cs,Evaluate,The length of the statement  "		Collision.Collision.CollideEdgeAndPolygon (ref manifold' _edge' ref transformA' (PolygonShape)FixtureB.Shape' ref transformB); " is 126.
Long Statement,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\Contact.cs,Evaluate,The length of the statement  "		Collision.Collision.CollideCircles (ref manifold' (CircleShape)FixtureA.Shape' ref transformA' (CircleShape)FixtureB.Shape' ref transformB); " is 140.
Long Statement,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\Contact.cs,Create,The length of the statement  "		if ((type1 >= type2 || (type1 == ShapeType.Edge && type2 == ShapeType.Polygon)) && !(type2 == ShapeType.Edge && type1 == ShapeType.Polygon)) { " is 142.
Long Statement,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\Contact.cs,Create,The length of the statement  "		if ((type1 >= type2 || (type1 == ShapeType.Edge && type2 == ShapeType.Polygon)) && !(type2 == ShapeType.Edge && type1 == ShapeType.Polygon)) { " is 142.
Long Statement,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\ContactSolver.cs,InitializeVelocityConstraints,The length of the statement  "		Collision.Collision.GetWorldManifold (ref manifold' ref bodyA.Xf' radiusA' ref bodyB.Xf' radiusB' out cc.Normal' out points); " is 125.
Long Statement,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\ContactSolver.cs,InitializeVelocityConstraints,The length of the statement  "			float vRel = cc.Normal.X * (vB.X + -wB * ccp.rB.Y - vA.X - -wA * ccp.rA.Y) + cc.Normal.Y * (vB.Y + wB * ccp.rB.X - vA.Y - wA * ccp.rA.X); " is 137.
Long Statement,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\ContactSolver.cs,SolveVelocityConstraints,The length of the statement  "			float lambda = ccp.TangentMass * -((c.BodyB.LinearVelocityInternal.X + (-wB * ccp.rB.Y) - c.BodyA.LinearVelocityInternal.X - (-wA * ccp.rA.Y)) * tangentx + (c.BodyB.LinearVelocityInternal.Y + (wB * ccp.rB.X) - c.BodyA.LinearVelocityInternal.Y - (wA * ccp.rA.X)) * tangenty); " is 274.
Long Statement,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\ContactSolver.cs,SolveVelocityConstraints,The length of the statement  "			float lambda = -ccp.NormalMass * ((c.BodyB.LinearVelocityInternal.X + (-wB * ccp.rB.Y) - c.BodyA.LinearVelocityInternal.X - (-wA * ccp.rA.Y)) * c.Normal.X + (c.BodyB.LinearVelocityInternal.Y + (wB * ccp.rB.X) - c.BodyA.LinearVelocityInternal.Y - (wA * ccp.rA.X)) * c.Normal.Y - ccp.VelocityBias); " is 296.
Long Statement,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\ContactSolver.cs,SolveVelocityConstraints,The length of the statement  "			// In order to account of the accumulated impulse 'a' (because of the iterative nature of the solver which only requires " is 120.
Long Statement,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\ContactSolver.cs,SolveVelocityConstraints,The length of the statement  "			float vn1 = (c.BodyB.LinearVelocityInternal.X + (-wB * cp1.rB.Y) - c.BodyA.LinearVelocityInternal.X - (-wA * cp1.rA.Y)) * c.Normal.X + (c.BodyB.LinearVelocityInternal.Y + (wB * cp1.rB.X) - c.BodyA.LinearVelocityInternal.Y - (wA * cp1.rA.X)) * c.Normal.Y; " is 254.
Long Statement,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\ContactSolver.cs,SolveVelocityConstraints,The length of the statement  "			float vn2 = (c.BodyB.LinearVelocityInternal.X + (-wB * cp2.rB.Y) - c.BodyA.LinearVelocityInternal.X - (-wA * cp2.rA.Y)) * c.Normal.X + (c.BodyB.LinearVelocityInternal.Y + (wB * cp2.rB.X) - c.BodyA.LinearVelocityInternal.Y - (wA * cp2.rA.X)) * c.Normal.Y; " is 254.
Long Statement,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\ContactSolver.cs,Solve,The length of the statement  "			separation = (clipPoint.X - planePoint.X) * normal.X + (clipPoint.Y - planePoint.Y) * normal.Y - cc.RadiusA - cc.RadiusB; " is 121.
Long Statement,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\ContactSolver.cs,Solve,The length of the statement  "			separation = (clipPoint.X - planePoint.X) * normal.X + (clipPoint.Y - planePoint.Y) * normal.Y - cc.RadiusA - cc.RadiusB; " is 121.
Long Statement,FarseerPhysics.Dynamics.Joints,FixedMouseJoint,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Joints\FixedMouseJoint.cs,InitVelocityConstraints,The length of the statement  "	Mat22 K2 = new Mat22 (new Vector2 (invI * r.Y * r.Y' -invI * r.X * r.Y)' new Vector2 (-invI * r.X * r.Y' invI * r.X * r.X)); " is 124.
Long Statement,FarseerPhysics.Dynamics.Joints,FixedRevoluteJoint,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Joints\FixedRevoluteJoint.cs,SolvePositionConstraints,The length of the statement  "		Mat22 K2 = new Mat22 (new Vector2 (invI1 * r1.Y * r1.Y' -invI1 * r1.X * r1.Y)' new Vector2 (-invI1 * r1.X * r1.Y' invI1 * r1.X * r1.X)); " is 136.
Long Statement,FarseerPhysics.Dynamics.Joints,FixedRevoluteJoint,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Joints\FixedRevoluteJoint.cs,SolvePositionConstraints,The length of the statement  "		Mat22 K3 = new Mat22 (new Vector2 (invI2 * r2.Y * r2.Y' -invI2 * r2.X * r2.Y)' new Vector2 (-invI2 * r2.X * r2.Y' invI2 * r2.X * r2.X)); " is 136.
Long Statement,FarseerPhysics.Dynamics.Joints,GearJoint,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Joints\GearJoint.cs,SolveVelocityConstraints,The length of the statement  "	float Cdot = _J.Compute (b1.LinearVelocityInternal' b1.AngularVelocityInternal' b2.LinearVelocityInternal' b2.AngularVelocityInternal); " is 135.
Long Statement,FarseerPhysics.Dynamics.Joints,Joint,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Joints\Joint.cs,IsFixedType,The length of the statement  "	return JointType == JointType.FixedRevolute || JointType == JointType.FixedDistance || JointType == JointType.FixedPrismatic || JointType == JointType.FixedLine || JointType == JointType.FixedMouse || JointType == JointType.FixedAngle || JointType == JointType.FixedFriction; " is 275.
Long Statement,FarseerPhysics.Dynamics.Joints,RevoluteJoint,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Joints\RevoluteJoint.cs,SolvePositionConstraints,The length of the statement  "		Mat22 K2 = new Mat22 (new Vector2 (invI1 * r1.Y * r1.Y' -invI1 * r1.X * r1.Y)' new Vector2 (-invI1 * r1.X * r1.Y' invI1 * r1.X * r1.X)); " is 136.
Long Statement,FarseerPhysics.Dynamics.Joints,RevoluteJoint,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Joints\RevoluteJoint.cs,SolvePositionConstraints,The length of the statement  "		Mat22 K3 = new Mat22 (new Vector2 (invI2 * r2.Y * r2.Y' -invI2 * r2.X * r2.Y)' new Vector2 (-invI2 * r2.X * r2.Y' invI2 * r2.X * r2.X)); " is 136.
Long Statement,FarseerPhysics.Helpers,Camera2D,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Helpers\Camera2D.cs,SetView,The length of the statement  "	_batchView = Matrix.CreateTranslation (translateBody) * matRotation * matZoom * Matrix.CreateTranslation (translateCenter); " is 123.
Complex Conditional,FarseerPhysics.Collision,AABB,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,Contains,The conditional expression  "(point.X > (LowerBound.X + Settings.Epsilon) && point.X < (UpperBound.X - Settings.Epsilon) && (point.Y > (LowerBound.Y + Settings.Epsilon) && point.Y < (UpperBound.Y - Settings.Epsilon)))"  is complex.
Complex Conditional,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,CanSee,The conditional expression  "(k + 1) % vertices.Count == i || k == i || (k + 1) % vertices.Count == j || k == j"  is complex.
Complex Conditional,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The conditional expression  "((triangulated [i].X [0] == triangulated [i].X [1]) && (triangulated [i].Y [0] == triangulated [i].Y [1])) || ((triangulated [i].X [1] == triangulated [i].X [2]) && (triangulated [i].Y [1] == triangulated [i].Y [2])) || ((triangulated [i].X [0] == triangulated [i].X [2]) && (triangulated [i].Y [0] == triangulated [i].Y [2]))"  is complex.
Complex Conditional,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The conditional expression  "(p1 == Points [2] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [2])"  is complex.
Complex Conditional,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The conditional expression  "(p1 == Points [0] && p2 == Points [2]) || (p1 == Points [2] && p2 == Points [0])"  is complex.
Complex Conditional,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The conditional expression  "(p1 == Points [0] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [0])"  is complex.
Complex Conditional,FarseerPhysics.Common,LineTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\LineTools.cs,LineIntersect2,The conditional expression  "a0 == b0 || a0 == b1 || a1 == b0 || a1 == b1"  is complex.
Complex Conditional,FarseerPhysics.Common,LineTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\LineTools.cs,LineIntersect2,The conditional expression  "(0 < ua) && (ua < 1) && (0 < ub) && (ub < 1)"  is complex.
Complex Conditional,FarseerPhysics.Common,MSTerrain,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MSTerrain.cs,ApplyTexture,The conditional expression  "x >= 0 && x < _localWidth && y >= 0 && y < _localHeight"  is complex.
Complex Conditional,FarseerPhysics.Common,MSTerrain,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MSTerrain.cs,ApplyData,The conditional expression  "x >= 0 && x < _localWidth && y >= 0 && y < _localHeight"  is complex.
Complex Conditional,FarseerPhysics.Common,MSTerrain,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MSTerrain.cs,ModifyTerrain,The conditional expression  "p.X >= 0 && p.X < _localWidth && p.Y >= 0 && p.Y < _localHeight"  is complex.
Complex Conditional,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,IsSolid,The conditional expression  "_tempIsSolidX >= 0 && _tempIsSolidX < _width && _tempIsSolidY >= 0 && _tempIsSolidY < _height"  is complex.
Complex Conditional,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,IsSolid,The conditional expression  "x >= 0 && x < _width && y >= 0 && y < _height"  is complex.
Complex Conditional,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The conditional expression  "startY > 0 && startY < _height && endY > 0 && endY < _height"  is complex.
Complex Conditional,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,SearchCrossingEdges,The conditional expression  "(vertex1.Y >= y && vertex2.Y <= y) || (vertex1.Y <= y && vertex2.Y >= y)"  is complex.
Complex Conditional,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,IsNearPixel,The conditional expression  "x >= 0 && x <= _width && y >= 0 && y <= _height"  is complex.
Complex Conditional,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,GetNextHullPoint,The conditional expression  "x >= 0 && x < _width && y >= 0 && y <= _height"  is complex.
Complex Conditional,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The conditional expression  "(_data.Count () > 1) && (i == valIndex - 1) && (_data.Last ().Body == _data.First ().Body) && (_data.Last ().Max == _data.First ().Min)"  is complex.
Complex Conditional,FarseerPhysics.Controllers,GravityController,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Controllers\GravityController.cs,Update,The conditional expression  "body1 == body2 || (body1.IsStatic && body2.IsStatic) || !body2.Enabled"  is complex.
Complex Conditional,FarseerPhysics.Dynamics,ContactManager,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\ContactManager.cs,AddPair,The conditional expression  "fA == fixtureA && fB == fixtureB && iA == indexA && iB == indexB"  is complex.
Complex Conditional,FarseerPhysics.Dynamics,ContactManager,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\ContactManager.cs,AddPair,The conditional expression  "fA == fixtureB && fB == fixtureA && iA == indexB && iB == indexA"  is complex.
Complex Conditional,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\Contact.cs,Create,The conditional expression  "(type1 >= type2 || (type1 == ShapeType.Edge && type2 == ShapeType.Polygon)) && !(type2 == ShapeType.Edge && type1 == ShapeType.Polygon)"  is complex.
Complex Conditional,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\Contact.cs,Create,The conditional expression  "(type1 >= type2 || (type1 == ShapeType.Edge && type2 == ShapeType.Polygon)) && !(type2 == ShapeType.Edge && type1 == ShapeType.Polygon)"  is complex.
Virtual Method Call from Constructor,FarseerPhysics.Dynamics,Fixture,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Fixture.cs,Fixture,The constructor "Fixture" calls a virtual method "Clone".
Magic Number,FarseerPhysics.Collision,AABB,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,AABB,The following statement contains a magic number: LowerBound = center - new Vector2 (width / 2' height / 2);  
Magic Number,FarseerPhysics.Collision,AABB,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,AABB,The following statement contains a magic number: LowerBound = center - new Vector2 (width / 2' height / 2);  
Magic Number,FarseerPhysics.Collision,AABB,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,AABB,The following statement contains a magic number: UpperBound = center + new Vector2 (width / 2' height / 2);  
Magic Number,FarseerPhysics.Collision,AABB,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,AABB,The following statement contains a magic number: UpperBound = center + new Vector2 (width / 2' height / 2);  
Magic Number,FarseerPhysics.Collision,AABB,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,RayCast,The following statement contains a magic number: for (int i = 0; i < 2; ++i) {  	float absD_i = i == 0 ? absD.X : absD.Y;  	float lowerBound_i = i == 0 ? LowerBound.X : LowerBound.Y;  	float upperBound_i = i == 0 ? UpperBound.X : UpperBound.Y;  	float p_i = i == 0 ? p.X : p.Y;  	if (absD_i < Settings.Epsilon) {  		// Parallel.  		if (p_i < lowerBound_i || upperBound_i < p_i) {  			return false;  		}  	}  	else {  		float d_i = i == 0 ? d.X : d.Y;  		float inv_d = 1.0f / d_i;  		float t1 = (lowerBound_i - p_i) * inv_d;  		float t2 = (upperBound_i - p_i) * inv_d;  		// Sign of the normal vector.  		float s = -1.0f;  		if (t1 > t2) {  			MathUtils.Swap (ref t1' ref t2);  			s = 1.0f;  		}  		// Push the min up  		if (t1 > tmin) {  			if (i == 0) {  				normal.X = s;  			}  			else {  				normal.Y = s;  			}  			tmin = t1;  		}  		// Pull the max down  		tmax = Math.Min (tmax' t2);  		if (tmin > tmax) {  			return false;  		}  	}  }  
Magic Number,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,CollidePolygons,The following statement contains a magic number: if (np < 2)  	return;  
Magic Number,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,CollidePolygons,The following statement contains a magic number: if (np < 2) {  	return;  }  
Magic Number,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,CollideEdgeAndPolygon,The following statement contains a magic number: _proxyA.Count = 2;  
Magic Number,FarseerPhysics.Collision,Collision,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Collision.cs,ComputeEdgeSeparation,The following statement contains a magic number: for (int i = 0; i < 2; ++i) {  	Vector2 n = _tmpNormals [i];  	// Adjacency  	bool valid1 = MathUtils.Cross (n' _limit11) >= -Settings.AngularSlop && MathUtils.Cross (_limit12' n) >= -Settings.AngularSlop;  	bool valid2 = MathUtils.Cross (n' _limit21) >= -Settings.AngularSlop && MathUtils.Cross (_limit22' n) >= -Settings.AngularSlop;  	if (valid1 == false || valid2 == false) {  		continue;  	}  	EPAxis axis;  	axis.Type = EPAxisType.EdgeA;  	axis.Index = i;  	axis.Separation = Settings.MaxFloat;  	for (int j = 0; j < _proxyB.Count; ++j) {  		float s = Vector2.Dot (n' _proxyB.Vertices [j] - _edgeA.V1);  		if (s < axis.Separation) {  			axis.Separation = s;  		}  	}  	if (axis.Separation > _radius) {  		return axis;  	}  	if (axis.Separation > bestAxis.Separation) {  		bestAxis = axis;  	}  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,ReadCache,The following statement contains a magic number: Debug.Assert (cache.Count <= 3);  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,GetSearchDirection,The following statement contains a magic number: switch (Count) {  case 1:  	return -V [0].W;  case 2: {  	Vector2 e12 = V [1].W - V [0].W;  	float sgn = MathUtils.Cross (e12' -V [0].W);  	if (sgn > 0.0f) {  		// Origin is left of e12.  		return new Vector2 (-e12.Y' e12.X);  	}  	else {  		// Origin is right of e12.  		return new Vector2 (e12.Y' -e12.X);  	}  }  default:  	Debug.Assert (false);  	return Vector2.Zero;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,GetClosestPoint,The following statement contains a magic number: switch (Count) {  case 0:  	Debug.Assert (false);  	return Vector2.Zero;  case 1:  	return V [0].W;  case 2:  	return V [0].A * V [0].W + V [1].A * V [1].W;  case 3:  	return Vector2.Zero;  default:  	Debug.Assert (false);  	return Vector2.Zero;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,GetClosestPoint,The following statement contains a magic number: switch (Count) {  case 0:  	Debug.Assert (false);  	return Vector2.Zero;  case 1:  	return V [0].W;  case 2:  	return V [0].A * V [0].W + V [1].A * V [1].W;  case 3:  	return Vector2.Zero;  default:  	Debug.Assert (false);  	return Vector2.Zero;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,GetWitnessPoints,The following statement contains a magic number: switch (Count) {  case 0:  	pA = Vector2.Zero;  	pB = Vector2.Zero;  	Debug.Assert (false);  	break;  case 1:  	pA = V [0].WA;  	pB = V [0].WB;  	break;  case 2:  	pA = V [0].A * V [0].WA + V [1].A * V [1].WA;  	pB = V [0].A * V [0].WB + V [1].A * V [1].WB;  	break;  case 3:  	pA = V [0].A * V [0].WA + V [1].A * V [1].WA + V [2].A * V [2].WA;  	pB = pA;  	break;  default:  	throw new Exception ();  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,GetWitnessPoints,The following statement contains a magic number: switch (Count) {  case 0:  	pA = Vector2.Zero;  	pB = Vector2.Zero;  	Debug.Assert (false);  	break;  case 1:  	pA = V [0].WA;  	pB = V [0].WB;  	break;  case 2:  	pA = V [0].A * V [0].WA + V [1].A * V [1].WA;  	pB = V [0].A * V [0].WB + V [1].A * V [1].WB;  	break;  case 3:  	pA = V [0].A * V [0].WA + V [1].A * V [1].WA + V [2].A * V [2].WA;  	pB = pA;  	break;  default:  	throw new Exception ();  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,GetWitnessPoints,The following statement contains a magic number: switch (Count) {  case 0:  	pA = Vector2.Zero;  	pB = Vector2.Zero;  	Debug.Assert (false);  	break;  case 1:  	pA = V [0].WA;  	pB = V [0].WB;  	break;  case 2:  	pA = V [0].A * V [0].WA + V [1].A * V [1].WA;  	pB = V [0].A * V [0].WB + V [1].A * V [1].WB;  	break;  case 3:  	pA = V [0].A * V [0].WA + V [1].A * V [1].WA + V [2].A * V [2].WA;  	pB = pA;  	break;  default:  	throw new Exception ();  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,GetWitnessPoints,The following statement contains a magic number: switch (Count) {  case 0:  	pA = Vector2.Zero;  	pB = Vector2.Zero;  	Debug.Assert (false);  	break;  case 1:  	pA = V [0].WA;  	pB = V [0].WB;  	break;  case 2:  	pA = V [0].A * V [0].WA + V [1].A * V [1].WA;  	pB = V [0].A * V [0].WB + V [1].A * V [1].WB;  	break;  case 3:  	pA = V [0].A * V [0].WA + V [1].A * V [1].WA + V [2].A * V [2].WA;  	pB = pA;  	break;  default:  	throw new Exception ();  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,GetWitnessPoints,The following statement contains a magic number: pA = V [0].A * V [0].WA + V [1].A * V [1].WA + V [2].A * V [2].WA;  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,GetWitnessPoints,The following statement contains a magic number: pA = V [0].A * V [0].WA + V [1].A * V [1].WA + V [2].A * V [2].WA;  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,GetMetric,The following statement contains a magic number: switch (Count) {  case 0:  	Debug.Assert (false);  	return 0.0f;  case 1:  	return 0.0f;  case 2:  	return (V [0].W - V [1].W).Length ();  case 3:  	return MathUtils.Cross (V [1].W - V [0].W' V [2].W - V [0].W);  default:  	Debug.Assert (false);  	return 0.0f;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,GetMetric,The following statement contains a magic number: switch (Count) {  case 0:  	Debug.Assert (false);  	return 0.0f;  case 1:  	return 0.0f;  case 2:  	return (V [0].W - V [1].W).Length ();  case 3:  	return MathUtils.Cross (V [1].W - V [0].W' V [2].W - V [0].W);  default:  	Debug.Assert (false);  	return 0.0f;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,GetMetric,The following statement contains a magic number: switch (Count) {  case 0:  	Debug.Assert (false);  	return 0.0f;  case 1:  	return 0.0f;  case 2:  	return (V [0].W - V [1].W).Length ();  case 3:  	return MathUtils.Cross (V [1].W - V [0].W' V [2].W - V [0].W);  default:  	Debug.Assert (false);  	return 0.0f;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,GetMetric,The following statement contains a magic number: return MathUtils.Cross (V [1].W - V [0].W' V [2].W - V [0].W);  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,Solve2,The following statement contains a magic number: Count = 2;  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d12_1 > 0.0f && d12_2 > 0.0f && d123_3 <= 0.0f) {  	float inv_d12 = 1.0f / (d12_1 + d12_2);  	SimplexVertex v0_2 = V [0];  	SimplexVertex v1_2 = V [1];  	v0_2.A = d12_1 * inv_d12;  	v1_2.A = d12_2 * inv_d12;  	V [0] = v0_2;  	V [1] = v1_2;  	Count = 2;  	return;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,Solve3,The following statement contains a magic number: Count = 2;  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d13_1 > 0.0f && d13_2 > 0.0f && d123_2 <= 0.0f) {  	float inv_d13 = 1.0f / (d13_1 + d13_2);  	SimplexVertex v0_3 = V [0];  	SimplexVertex v2_3 = V [2];  	v0_3.A = d13_1 * inv_d13;  	v2_3.A = d13_2 * inv_d13;  	V [0] = v0_3;  	V [2] = v2_3;  	Count = 2;  	V [1] = V [2];  	return;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d13_1 > 0.0f && d13_2 > 0.0f && d123_2 <= 0.0f) {  	float inv_d13 = 1.0f / (d13_1 + d13_2);  	SimplexVertex v0_3 = V [0];  	SimplexVertex v2_3 = V [2];  	v0_3.A = d13_1 * inv_d13;  	v2_3.A = d13_2 * inv_d13;  	V [0] = v0_3;  	V [2] = v2_3;  	Count = 2;  	V [1] = V [2];  	return;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d13_1 > 0.0f && d13_2 > 0.0f && d123_2 <= 0.0f) {  	float inv_d13 = 1.0f / (d13_1 + d13_2);  	SimplexVertex v0_3 = V [0];  	SimplexVertex v2_3 = V [2];  	v0_3.A = d13_1 * inv_d13;  	v2_3.A = d13_2 * inv_d13;  	V [0] = v0_3;  	V [2] = v2_3;  	Count = 2;  	V [1] = V [2];  	return;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d13_1 > 0.0f && d13_2 > 0.0f && d123_2 <= 0.0f) {  	float inv_d13 = 1.0f / (d13_1 + d13_2);  	SimplexVertex v0_3 = V [0];  	SimplexVertex v2_3 = V [2];  	v0_3.A = d13_1 * inv_d13;  	v2_3.A = d13_2 * inv_d13;  	V [0] = v0_3;  	V [2] = v2_3;  	Count = 2;  	V [1] = V [2];  	return;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,Solve3,The following statement contains a magic number: V [2] = v2_3;  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,Solve3,The following statement contains a magic number: Count = 2;  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,Solve3,The following statement contains a magic number: V [1] = V [2];  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d13_1 <= 0.0f && d23_1 <= 0.0f) {  	SimplexVertex v2_5 = V [2];  	v2_5.A = 1.0f;  	V [2] = v2_5;  	Count = 1;  	V [0] = V [2];  	return;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d13_1 <= 0.0f && d23_1 <= 0.0f) {  	SimplexVertex v2_5 = V [2];  	v2_5.A = 1.0f;  	V [2] = v2_5;  	Count = 1;  	V [0] = V [2];  	return;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d13_1 <= 0.0f && d23_1 <= 0.0f) {  	SimplexVertex v2_5 = V [2];  	v2_5.A = 1.0f;  	V [2] = v2_5;  	Count = 1;  	V [0] = V [2];  	return;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,Solve3,The following statement contains a magic number: V [2] = v2_5;  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,Solve3,The following statement contains a magic number: V [0] = V [2];  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d23_1 > 0.0f && d23_2 > 0.0f && d123_1 <= 0.0f) {  	float inv_d23 = 1.0f / (d23_1 + d23_2);  	SimplexVertex v1_6 = V [1];  	SimplexVertex v2_6 = V [2];  	v1_6.A = d23_1 * inv_d23;  	v2_6.A = d23_2 * inv_d23;  	V [1] = v1_6;  	V [2] = v2_6;  	Count = 2;  	V [0] = V [2];  	return;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d23_1 > 0.0f && d23_2 > 0.0f && d123_1 <= 0.0f) {  	float inv_d23 = 1.0f / (d23_1 + d23_2);  	SimplexVertex v1_6 = V [1];  	SimplexVertex v2_6 = V [2];  	v1_6.A = d23_1 * inv_d23;  	v2_6.A = d23_2 * inv_d23;  	V [1] = v1_6;  	V [2] = v2_6;  	Count = 2;  	V [0] = V [2];  	return;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d23_1 > 0.0f && d23_2 > 0.0f && d123_1 <= 0.0f) {  	float inv_d23 = 1.0f / (d23_1 + d23_2);  	SimplexVertex v1_6 = V [1];  	SimplexVertex v2_6 = V [2];  	v1_6.A = d23_1 * inv_d23;  	v2_6.A = d23_2 * inv_d23;  	V [1] = v1_6;  	V [2] = v2_6;  	Count = 2;  	V [0] = V [2];  	return;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d23_1 > 0.0f && d23_2 > 0.0f && d123_1 <= 0.0f) {  	float inv_d23 = 1.0f / (d23_1 + d23_2);  	SimplexVertex v1_6 = V [1];  	SimplexVertex v2_6 = V [2];  	v1_6.A = d23_1 * inv_d23;  	v2_6.A = d23_2 * inv_d23;  	V [1] = v1_6;  	V [2] = v2_6;  	Count = 2;  	V [0] = V [2];  	return;  }  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,Solve3,The following statement contains a magic number: V [2] = v2_6;  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,Solve3,The following statement contains a magic number: Count = 2;  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,Solve3,The following statement contains a magic number: V [0] = V [2];  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,Solve3,The following statement contains a magic number: V [2] = v2_7;  
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,Solve3,The following statement contains a magic number: Count = 3;  
Magic Number,FarseerPhysics.Collision,Distance,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,ComputeDistance,The following statement contains a magic number: while (iter < k_maxIters) {  	// Copy simplex so we can identify duplicates.  	int saveCount = simplex.Count;  	for (int i = 0; i < saveCount; ++i) {  		saveA [i] = simplex.V [i].IndexA;  		saveB [i] = simplex.V [i].IndexB;  	}  	switch (simplex.Count) {  	case 1:  		break;  	case 2:  		simplex.Solve2 ();  		break;  	case 3:  		simplex.Solve3 ();  		break;  	default:  		Debug.Assert (false);  		break;  	}  	// If we have 3 points' then the origin is in the corresponding triangle.  	if (simplex.Count == 3) {  		break;  	}  	// Compute closest point.  	Vector2 p = simplex.GetClosestPoint ();  	distanceSqr2 = p.LengthSquared ();  	// Ensure progress  	if (distanceSqr2 >= distanceSqr1) {  		//break;  	}  	distanceSqr1 = distanceSqr2;  	// Get search direction.  	Vector2 d = simplex.GetSearchDirection ();  	// Ensure the search direction is numerically fit.  	if (d.LengthSquared () < Settings.Epsilon * Settings.Epsilon) {  		// The origin is probably contained by a line segment  		// or triangle. Thus the shapes are overlapped.  		// We can't return zero here even though there may be overlap.  		// In case the simplex is a point' segment' or triangle it is difficult  		// to determine if the origin is contained in the CSO or very close to it.  		break;  	}  	// Compute a tentative new simplex vertex using support points.  	SimplexVertex vertex = simplex.V [simplex.Count];  	vertex.IndexA = input.ProxyA.GetSupport (MathUtils.MultiplyT (ref input.TransformA.R' -d));  	vertex.WA = MathUtils.Multiply (ref input.TransformA' input.ProxyA.Vertices [vertex.IndexA]);  	vertex.IndexB = input.ProxyB.GetSupport (MathUtils.MultiplyT (ref input.TransformB.R' d));  	vertex.WB = MathUtils.Multiply (ref input.TransformB' input.ProxyB.Vertices [vertex.IndexB]);  	vertex.W = vertex.WB - vertex.WA;  	simplex.V [simplex.Count] = vertex;  	// Iteration count is equated to the number of support point calls.  	++iter;  	++GJKIters;  	// Check for duplicate support points. This is the main termination criteria.  	bool duplicate = false;  	for (int i = 0; i < saveCount; ++i) {  		if (vertex.IndexA == saveA [i] && vertex.IndexB == saveB [i]) {  			duplicate = true;  			break;  		}  	}  	// If we found a duplicate support point we must exit to avoid cycling.  	if (duplicate) {  		break;  	}  	// New vertex is ok and needed.  	++simplex.Count;  }  
Magic Number,FarseerPhysics.Collision,Distance,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,ComputeDistance,The following statement contains a magic number: while (iter < k_maxIters) {  	// Copy simplex so we can identify duplicates.  	int saveCount = simplex.Count;  	for (int i = 0; i < saveCount; ++i) {  		saveA [i] = simplex.V [i].IndexA;  		saveB [i] = simplex.V [i].IndexB;  	}  	switch (simplex.Count) {  	case 1:  		break;  	case 2:  		simplex.Solve2 ();  		break;  	case 3:  		simplex.Solve3 ();  		break;  	default:  		Debug.Assert (false);  		break;  	}  	// If we have 3 points' then the origin is in the corresponding triangle.  	if (simplex.Count == 3) {  		break;  	}  	// Compute closest point.  	Vector2 p = simplex.GetClosestPoint ();  	distanceSqr2 = p.LengthSquared ();  	// Ensure progress  	if (distanceSqr2 >= distanceSqr1) {  		//break;  	}  	distanceSqr1 = distanceSqr2;  	// Get search direction.  	Vector2 d = simplex.GetSearchDirection ();  	// Ensure the search direction is numerically fit.  	if (d.LengthSquared () < Settings.Epsilon * Settings.Epsilon) {  		// The origin is probably contained by a line segment  		// or triangle. Thus the shapes are overlapped.  		// We can't return zero here even though there may be overlap.  		// In case the simplex is a point' segment' or triangle it is difficult  		// to determine if the origin is contained in the CSO or very close to it.  		break;  	}  	// Compute a tentative new simplex vertex using support points.  	SimplexVertex vertex = simplex.V [simplex.Count];  	vertex.IndexA = input.ProxyA.GetSupport (MathUtils.MultiplyT (ref input.TransformA.R' -d));  	vertex.WA = MathUtils.Multiply (ref input.TransformA' input.ProxyA.Vertices [vertex.IndexA]);  	vertex.IndexB = input.ProxyB.GetSupport (MathUtils.MultiplyT (ref input.TransformB.R' d));  	vertex.WB = MathUtils.Multiply (ref input.TransformB' input.ProxyB.Vertices [vertex.IndexB]);  	vertex.W = vertex.WB - vertex.WA;  	simplex.V [simplex.Count] = vertex;  	// Iteration count is equated to the number of support point calls.  	++iter;  	++GJKIters;  	// Check for duplicate support points. This is the main termination criteria.  	bool duplicate = false;  	for (int i = 0; i < saveCount; ++i) {  		if (vertex.IndexA == saveA [i] && vertex.IndexB == saveB [i]) {  			duplicate = true;  			break;  		}  	}  	// If we found a duplicate support point we must exit to avoid cycling.  	if (duplicate) {  		break;  	}  	// New vertex is ok and needed.  	++simplex.Count;  }  
Magic Number,FarseerPhysics.Collision,Distance,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,ComputeDistance,The following statement contains a magic number: while (iter < k_maxIters) {  	// Copy simplex so we can identify duplicates.  	int saveCount = simplex.Count;  	for (int i = 0; i < saveCount; ++i) {  		saveA [i] = simplex.V [i].IndexA;  		saveB [i] = simplex.V [i].IndexB;  	}  	switch (simplex.Count) {  	case 1:  		break;  	case 2:  		simplex.Solve2 ();  		break;  	case 3:  		simplex.Solve3 ();  		break;  	default:  		Debug.Assert (false);  		break;  	}  	// If we have 3 points' then the origin is in the corresponding triangle.  	if (simplex.Count == 3) {  		break;  	}  	// Compute closest point.  	Vector2 p = simplex.GetClosestPoint ();  	distanceSqr2 = p.LengthSquared ();  	// Ensure progress  	if (distanceSqr2 >= distanceSqr1) {  		//break;  	}  	distanceSqr1 = distanceSqr2;  	// Get search direction.  	Vector2 d = simplex.GetSearchDirection ();  	// Ensure the search direction is numerically fit.  	if (d.LengthSquared () < Settings.Epsilon * Settings.Epsilon) {  		// The origin is probably contained by a line segment  		// or triangle. Thus the shapes are overlapped.  		// We can't return zero here even though there may be overlap.  		// In case the simplex is a point' segment' or triangle it is difficult  		// to determine if the origin is contained in the CSO or very close to it.  		break;  	}  	// Compute a tentative new simplex vertex using support points.  	SimplexVertex vertex = simplex.V [simplex.Count];  	vertex.IndexA = input.ProxyA.GetSupport (MathUtils.MultiplyT (ref input.TransformA.R' -d));  	vertex.WA = MathUtils.Multiply (ref input.TransformA' input.ProxyA.Vertices [vertex.IndexA]);  	vertex.IndexB = input.ProxyB.GetSupport (MathUtils.MultiplyT (ref input.TransformB.R' d));  	vertex.WB = MathUtils.Multiply (ref input.TransformB' input.ProxyB.Vertices [vertex.IndexB]);  	vertex.W = vertex.WB - vertex.WA;  	simplex.V [simplex.Count] = vertex;  	// Iteration count is equated to the number of support point calls.  	++iter;  	++GJKIters;  	// Check for duplicate support points. This is the main termination criteria.  	bool duplicate = false;  	for (int i = 0; i < saveCount; ++i) {  		if (vertex.IndexA == saveA [i] && vertex.IndexB == saveB [i]) {  			duplicate = true;  			break;  		}  	}  	// If we found a duplicate support point we must exit to avoid cycling.  	if (duplicate) {  		break;  	}  	// New vertex is ok and needed.  	++simplex.Count;  }  
Magic Number,FarseerPhysics.Collision,Distance,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,ComputeDistance,The following statement contains a magic number: switch (simplex.Count) {  case 1:  	break;  case 2:  	simplex.Solve2 ();  	break;  case 3:  	simplex.Solve3 ();  	break;  default:  	Debug.Assert (false);  	break;  }  
Magic Number,FarseerPhysics.Collision,Distance,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,ComputeDistance,The following statement contains a magic number: switch (simplex.Count) {  case 1:  	break;  case 2:  	simplex.Solve2 ();  	break;  case 3:  	simplex.Solve3 ();  	break;  default:  	Debug.Assert (false);  	break;  }  
Magic Number,FarseerPhysics.Collision,Distance,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Distance.cs,ComputeDistance,The following statement contains a magic number: if (simplex.Count == 3) {  	break;  }  
Magic Number,FarseerPhysics.Collision,DynamicTree,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\DynamicTree.cs,DynamicTree,The following statement contains a magic number: _nodeCapacity = 16;  
Magic Number,FarseerPhysics.Collision,DynamicTree,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\DynamicTree.cs,AllocateNode,The following statement contains a magic number: if (_freeList == NullNode) {  	Debug.Assert (_nodeCount == _nodeCapacity);  	// The free list is empty. Rebuild a bigger pool.  	DynamicTreeNode<T>[] oldNodes = _nodes;  	_nodeCapacity *= 2;  	_nodes = new DynamicTreeNode<T>[_nodeCapacity];  	Array.Copy (oldNodes' _nodes' _nodeCount);  	// Build a linked list for the free list. The parent  	// pointer becomes the "next" pointer.  	for (int i = _nodeCount; i < _nodeCapacity - 1; ++i) {  		_nodes [i].ParentOrNext = i + 1;  	}  	_nodes [_nodeCapacity - 1].ParentOrNext = NullNode;  	_freeList = _nodeCount;  }  
Magic Number,FarseerPhysics.Collision,DynamicTree,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\DynamicTree.cs,AllocateNode,The following statement contains a magic number: _nodeCapacity *= 2;  
Magic Number,FarseerPhysics.Collision,DynamicTreeBroadPhase,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\DynamicTreeBroadPhase.cs,DynamicTreeBroadPhase,The following statement contains a magic number: _pairCapacity = 16;  
Magic Number,FarseerPhysics.Collision,DynamicTreeBroadPhase,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\DynamicTreeBroadPhase.cs,DynamicTreeBroadPhase,The following statement contains a magic number: _moveCapacity = 16;  
Magic Number,FarseerPhysics.Collision,DynamicTreeBroadPhase,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\DynamicTreeBroadPhase.cs,UpdatePairs,The following statement contains a magic number: _tree.Rebalance (4);  
Magic Number,FarseerPhysics.Collision,DynamicTreeBroadPhase,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\DynamicTreeBroadPhase.cs,BufferMove,The following statement contains a magic number: if (_moveCount == _moveCapacity) {  	int[] oldBuffer = _moveBuffer;  	_moveCapacity *= 2;  	_moveBuffer = new int[_moveCapacity];  	Array.Copy (oldBuffer' _moveBuffer' _moveCount);  }  
Magic Number,FarseerPhysics.Collision,DynamicTreeBroadPhase,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\DynamicTreeBroadPhase.cs,BufferMove,The following statement contains a magic number: _moveCapacity *= 2;  
Magic Number,FarseerPhysics.Collision,DynamicTreeBroadPhase,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\DynamicTreeBroadPhase.cs,QueryCallback,The following statement contains a magic number: if (_pairCount == _pairCapacity) {  	Pair[] oldBuffer = _pairBuffer;  	_pairCapacity *= 2;  	_pairBuffer = new Pair[_pairCapacity];  	Array.Copy (oldBuffer' _pairBuffer' _pairCount);  }  
Magic Number,FarseerPhysics.Collision,DynamicTreeBroadPhase,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\DynamicTreeBroadPhase.cs,QueryCallback,The following statement contains a magic number: _pairCapacity *= 2;  
Magic Number,FarseerPhysics.Collision,SeparationFunction,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\TimeOfImpact.cs,Set,The following statement contains a magic number: Debug.Assert (0 < count && count < 3);  
Magic Number,FarseerPhysics.Collision,TimeOfImpact,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\TimeOfImpact.cs,CalculateTimeOfImpact,The following statement contains a magic number: for (; ;) {  	Transform xfA' xfB;  	sweepA.GetTransform (out xfA' t1);  	sweepB.GetTransform (out xfB' t1);  	// Get the distance between shapes. We can also use the results  	// to get a separating axis.  	_distanceInput.TransformA = xfA;  	_distanceInput.TransformB = xfB;  	DistanceOutput distanceOutput;  	Distance.ComputeDistance (out distanceOutput' out cache' _distanceInput);  	// If the shapes are overlapped' we give up on continuous collision.  	if (distanceOutput.Distance <= 0.0f) {  		// Failure!  		output.State = TOIOutputState.Overlapped;  		output.T = 0.0f;  		break;  	}  	if (distanceOutput.Distance < target + tolerance) {  		// Victory!  		output.State = TOIOutputState.Touching;  		output.T = t1;  		break;  	}  	SeparationFunction.Set (ref cache' input.ProxyA' ref sweepA' input.ProxyB' ref sweepB' t1);  	// Compute the TOI on the separating axis. We do this by successively  	// resolving the deepest point. This loop is bounded by the number of vertices.  	bool done = false;  	float t2 = tMax;  	int pushBackIter = 0;  	for (; ;) {  		// Find the deepest point at t2. Store the witness point indices.  		int indexA' indexB;  		float s2 = SeparationFunction.FindMinSeparation (out indexA' out indexB' t2);  		// Is the final configuration separated?  		if (s2 > target + tolerance) {  			// Victory!  			output.State = TOIOutputState.Seperated;  			output.T = tMax;  			done = true;  			break;  		}  		// Has the separation reached tolerance?  		if (s2 > target - tolerance) {  			// Advance the sweeps  			t1 = t2;  			break;  		}  		// Compute the initial separation of the witness points.  		float s1 = SeparationFunction.Evaluate (indexA' indexB' t1);  		// Check for initial overlap. This might happen if the root finder  		// runs out of iterations.  		if (s1 < target - tolerance) {  			output.State = TOIOutputState.Failed;  			output.T = t1;  			done = true;  			break;  		}  		// Check for touching  		if (s1 <= target + tolerance) {  			// Victory! t1 should hold the TOI (could be 0.0).  			output.State = TOIOutputState.Touching;  			output.T = t1;  			done = true;  			break;  		}  		// Compute 1D root of: f(x) - target = 0  		int rootIterCount = 0;  		float a1 = t1' a2 = t2;  		for (; ;) {  			// Use a mix of the secant rule and bisection.  			float t;  			if ((rootIterCount & 1) != 0) {  				// Secant rule to improve convergence.  				t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);  			}  			else {  				// Bisection to guarantee progress.  				t = 0.5f * (a1 + a2);  			}  			float s = SeparationFunction.Evaluate (indexA' indexB' t);  			if (Math.Abs (s - target) < tolerance) {  				// t2 holds a tentative value for t1  				t2 = t;  				break;  			}  			// Ensure we continue to bracket the root.  			if (s > target) {  				a1 = t;  				s1 = s;  			}  			else {  				a2 = t;  				s2 = s;  			}  			++rootIterCount;  			++TOIRootIters;  			if (rootIterCount == 50) {  				break;  			}  		}  		TOIMaxRootIters = Math.Max (TOIMaxRootIters' rootIterCount);  		++pushBackIter;  		if (pushBackIter == Settings.MaxPolygonVertices) {  			break;  		}  	}  	++iter;  	++TOIIters;  	if (done) {  		break;  	}  	if (iter == k_maxIterations) {  		// Root finder got stuck. Semi-victory.  		output.State = TOIOutputState.Failed;  		output.T = t1;  		break;  	}  }  
Magic Number,FarseerPhysics.Collision,TimeOfImpact,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\TimeOfImpact.cs,CalculateTimeOfImpact,The following statement contains a magic number: for (; ;) {  	// Find the deepest point at t2. Store the witness point indices.  	int indexA' indexB;  	float s2 = SeparationFunction.FindMinSeparation (out indexA' out indexB' t2);  	// Is the final configuration separated?  	if (s2 > target + tolerance) {  		// Victory!  		output.State = TOIOutputState.Seperated;  		output.T = tMax;  		done = true;  		break;  	}  	// Has the separation reached tolerance?  	if (s2 > target - tolerance) {  		// Advance the sweeps  		t1 = t2;  		break;  	}  	// Compute the initial separation of the witness points.  	float s1 = SeparationFunction.Evaluate (indexA' indexB' t1);  	// Check for initial overlap. This might happen if the root finder  	// runs out of iterations.  	if (s1 < target - tolerance) {  		output.State = TOIOutputState.Failed;  		output.T = t1;  		done = true;  		break;  	}  	// Check for touching  	if (s1 <= target + tolerance) {  		// Victory! t1 should hold the TOI (could be 0.0).  		output.State = TOIOutputState.Touching;  		output.T = t1;  		done = true;  		break;  	}  	// Compute 1D root of: f(x) - target = 0  	int rootIterCount = 0;  	float a1 = t1' a2 = t2;  	for (; ;) {  		// Use a mix of the secant rule and bisection.  		float t;  		if ((rootIterCount & 1) != 0) {  			// Secant rule to improve convergence.  			t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);  		}  		else {  			// Bisection to guarantee progress.  			t = 0.5f * (a1 + a2);  		}  		float s = SeparationFunction.Evaluate (indexA' indexB' t);  		if (Math.Abs (s - target) < tolerance) {  			// t2 holds a tentative value for t1  			t2 = t;  			break;  		}  		// Ensure we continue to bracket the root.  		if (s > target) {  			a1 = t;  			s1 = s;  		}  		else {  			a2 = t;  			s2 = s;  		}  		++rootIterCount;  		++TOIRootIters;  		if (rootIterCount == 50) {  			break;  		}  	}  	TOIMaxRootIters = Math.Max (TOIMaxRootIters' rootIterCount);  	++pushBackIter;  	if (pushBackIter == Settings.MaxPolygonVertices) {  		break;  	}  }  
Magic Number,FarseerPhysics.Collision,TimeOfImpact,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\TimeOfImpact.cs,CalculateTimeOfImpact,The following statement contains a magic number: for (; ;) {  	// Use a mix of the secant rule and bisection.  	float t;  	if ((rootIterCount & 1) != 0) {  		// Secant rule to improve convergence.  		t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);  	}  	else {  		// Bisection to guarantee progress.  		t = 0.5f * (a1 + a2);  	}  	float s = SeparationFunction.Evaluate (indexA' indexB' t);  	if (Math.Abs (s - target) < tolerance) {  		// t2 holds a tentative value for t1  		t2 = t;  		break;  	}  	// Ensure we continue to bracket the root.  	if (s > target) {  		a1 = t;  		s1 = s;  	}  	else {  		a2 = t;  		s2 = s;  	}  	++rootIterCount;  	++TOIRootIters;  	if (rootIterCount == 50) {  		break;  	}  }  
Magic Number,FarseerPhysics.Collision,TimeOfImpact,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\TimeOfImpact.cs,CalculateTimeOfImpact,The following statement contains a magic number: if (rootIterCount == 50) {  	break;  }  
Magic Number,FarseerPhysics.Collision.Shapes,LoopShape,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Shapes\LoopShape.cs,GetChildEdge,The following statement contains a magic number: Debug.Assert (2 <= Vertices.Count);  
Magic Number,FarseerPhysics.Collision.Shapes,PolygonShape,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Shapes\PolygonShape.cs,Set,The following statement contains a magic number: Debug.Assert (vertices.Count >= 3 && vertices.Count <= Settings.MaxPolygonVertices);  
Magic Number,FarseerPhysics.Collision.Shapes,PolygonShape,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Shapes\PolygonShape.cs,ComputeProperties,The following statement contains a magic number: Debug.Assert (Vertices.Count >= 3);  
Magic Number,FarseerPhysics.Collision.Shapes,MassData,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Shapes\Shape.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = Area.GetHashCode ();  	result = (result * 397) ^ Centroid.GetHashCode ();  	result = (result * 397) ^ Inertia.GetHashCode ();  	result = (result * 397) ^ Mass.GetHashCode ();  	return result;  }  
Magic Number,FarseerPhysics.Collision.Shapes,MassData,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Shapes\Shape.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = Area.GetHashCode ();  	result = (result * 397) ^ Centroid.GetHashCode ();  	result = (result * 397) ^ Inertia.GetHashCode ();  	result = (result * 397) ^ Mass.GetHashCode ();  	return result;  }  
Magic Number,FarseerPhysics.Collision.Shapes,MassData,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Shapes\Shape.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = Area.GetHashCode ();  	result = (result * 397) ^ Centroid.GetHashCode ();  	result = (result * 397) ^ Inertia.GetHashCode ();  	result = (result * 397) ^ Mass.GetHashCode ();  	return result;  }  
Magic Number,FarseerPhysics.Collision.Shapes,MassData,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Shapes\Shape.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ Centroid.GetHashCode ();  
Magic Number,FarseerPhysics.Collision.Shapes,MassData,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Shapes\Shape.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ Inertia.GetHashCode ();  
Magic Number,FarseerPhysics.Collision.Shapes,MassData,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Shapes\Shape.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ Mass.GetHashCode ();  
Magic Number,FarseerPhysics.Common.ConvexHull,ChainHull,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\ConvexHull\ChainHull.cs,GetConvexHull,The following statement contains a magic number: for (i = n - 2; i >= 0; i--)  	if (P [i].X != xmax)  		break;  
Magic Number,FarseerPhysics.Common.ConvexHull,ChainHull,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\ConvexHull\ChainHull.cs,GetConvexHull,The following statement contains a magic number: i = n - 2
Magic Number,FarseerPhysics.Common.ConvexHull,GiftWrap,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\ConvexHull\GiftWrap.cs,GetConvexHull,The following statement contains a magic number: if (vertices.Count < 3)  	return vertices;  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (vertices.Count < 3)  	return vertices;  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (k == 0) {  	//Vertices are collinear.  	deque [0] = vertices [0];  	deque [1] = vertices [2];  	//We can skip vertex 1 because it should be between 0 and 2  	deque [2] = vertices [0];  	qf = 2;  	//Go until the end of the collinear sequence of vertices  	for (startIndex = 3; startIndex < vertices.Count; startIndex++) {  		Vector2 tmp = vertices [startIndex];  		if (MathUtils.Area (ref deque [0]' ref deque [1]' ref tmp) == 0)  			//This point is also collinear  			deque [1] = vertices [startIndex];  		else  			break;  	}  }  else {  	deque [0] = deque [3] = vertices [2];  	if (k > 0) {  		//Is Left.  Set deque = {2' 0' 1' 2}  		deque [1] = vertices [0];  		deque [2] = vertices [1];  	}  	else {  		//Is Right. Set deque = {2' 1' 0' 2}  		deque [1] = vertices [1];  		deque [2] = vertices [0];  	}  }  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (k == 0) {  	//Vertices are collinear.  	deque [0] = vertices [0];  	deque [1] = vertices [2];  	//We can skip vertex 1 because it should be between 0 and 2  	deque [2] = vertices [0];  	qf = 2;  	//Go until the end of the collinear sequence of vertices  	for (startIndex = 3; startIndex < vertices.Count; startIndex++) {  		Vector2 tmp = vertices [startIndex];  		if (MathUtils.Area (ref deque [0]' ref deque [1]' ref tmp) == 0)  			//This point is also collinear  			deque [1] = vertices [startIndex];  		else  			break;  	}  }  else {  	deque [0] = deque [3] = vertices [2];  	if (k > 0) {  		//Is Left.  Set deque = {2' 0' 1' 2}  		deque [1] = vertices [0];  		deque [2] = vertices [1];  	}  	else {  		//Is Right. Set deque = {2' 1' 0' 2}  		deque [1] = vertices [1];  		deque [2] = vertices [0];  	}  }  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (k == 0) {  	//Vertices are collinear.  	deque [0] = vertices [0];  	deque [1] = vertices [2];  	//We can skip vertex 1 because it should be between 0 and 2  	deque [2] = vertices [0];  	qf = 2;  	//Go until the end of the collinear sequence of vertices  	for (startIndex = 3; startIndex < vertices.Count; startIndex++) {  		Vector2 tmp = vertices [startIndex];  		if (MathUtils.Area (ref deque [0]' ref deque [1]' ref tmp) == 0)  			//This point is also collinear  			deque [1] = vertices [startIndex];  		else  			break;  	}  }  else {  	deque [0] = deque [3] = vertices [2];  	if (k > 0) {  		//Is Left.  Set deque = {2' 0' 1' 2}  		deque [1] = vertices [0];  		deque [2] = vertices [1];  	}  	else {  		//Is Right. Set deque = {2' 1' 0' 2}  		deque [1] = vertices [1];  		deque [2] = vertices [0];  	}  }  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (k == 0) {  	//Vertices are collinear.  	deque [0] = vertices [0];  	deque [1] = vertices [2];  	//We can skip vertex 1 because it should be between 0 and 2  	deque [2] = vertices [0];  	qf = 2;  	//Go until the end of the collinear sequence of vertices  	for (startIndex = 3; startIndex < vertices.Count; startIndex++) {  		Vector2 tmp = vertices [startIndex];  		if (MathUtils.Area (ref deque [0]' ref deque [1]' ref tmp) == 0)  			//This point is also collinear  			deque [1] = vertices [startIndex];  		else  			break;  	}  }  else {  	deque [0] = deque [3] = vertices [2];  	if (k > 0) {  		//Is Left.  Set deque = {2' 0' 1' 2}  		deque [1] = vertices [0];  		deque [2] = vertices [1];  	}  	else {  		//Is Right. Set deque = {2' 1' 0' 2}  		deque [1] = vertices [1];  		deque [2] = vertices [0];  	}  }  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (k == 0) {  	//Vertices are collinear.  	deque [0] = vertices [0];  	deque [1] = vertices [2];  	//We can skip vertex 1 because it should be between 0 and 2  	deque [2] = vertices [0];  	qf = 2;  	//Go until the end of the collinear sequence of vertices  	for (startIndex = 3; startIndex < vertices.Count; startIndex++) {  		Vector2 tmp = vertices [startIndex];  		if (MathUtils.Area (ref deque [0]' ref deque [1]' ref tmp) == 0)  			//This point is also collinear  			deque [1] = vertices [startIndex];  		else  			break;  	}  }  else {  	deque [0] = deque [3] = vertices [2];  	if (k > 0) {  		//Is Left.  Set deque = {2' 0' 1' 2}  		deque [1] = vertices [0];  		deque [2] = vertices [1];  	}  	else {  		//Is Right. Set deque = {2' 1' 0' 2}  		deque [1] = vertices [1];  		deque [2] = vertices [0];  	}  }  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (k == 0) {  	//Vertices are collinear.  	deque [0] = vertices [0];  	deque [1] = vertices [2];  	//We can skip vertex 1 because it should be between 0 and 2  	deque [2] = vertices [0];  	qf = 2;  	//Go until the end of the collinear sequence of vertices  	for (startIndex = 3; startIndex < vertices.Count; startIndex++) {  		Vector2 tmp = vertices [startIndex];  		if (MathUtils.Area (ref deque [0]' ref deque [1]' ref tmp) == 0)  			//This point is also collinear  			deque [1] = vertices [startIndex];  		else  			break;  	}  }  else {  	deque [0] = deque [3] = vertices [2];  	if (k > 0) {  		//Is Left.  Set deque = {2' 0' 1' 2}  		deque [1] = vertices [0];  		deque [2] = vertices [1];  	}  	else {  		//Is Right. Set deque = {2' 1' 0' 2}  		deque [1] = vertices [1];  		deque [2] = vertices [0];  	}  }  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (k == 0) {  	//Vertices are collinear.  	deque [0] = vertices [0];  	deque [1] = vertices [2];  	//We can skip vertex 1 because it should be between 0 and 2  	deque [2] = vertices [0];  	qf = 2;  	//Go until the end of the collinear sequence of vertices  	for (startIndex = 3; startIndex < vertices.Count; startIndex++) {  		Vector2 tmp = vertices [startIndex];  		if (MathUtils.Area (ref deque [0]' ref deque [1]' ref tmp) == 0)  			//This point is also collinear  			deque [1] = vertices [startIndex];  		else  			break;  	}  }  else {  	deque [0] = deque [3] = vertices [2];  	if (k > 0) {  		//Is Left.  Set deque = {2' 0' 1' 2}  		deque [1] = vertices [0];  		deque [2] = vertices [1];  	}  	else {  		//Is Right. Set deque = {2' 1' 0' 2}  		deque [1] = vertices [1];  		deque [2] = vertices [0];  	}  }  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (k == 0) {  	//Vertices are collinear.  	deque [0] = vertices [0];  	deque [1] = vertices [2];  	//We can skip vertex 1 because it should be between 0 and 2  	deque [2] = vertices [0];  	qf = 2;  	//Go until the end of the collinear sequence of vertices  	for (startIndex = 3; startIndex < vertices.Count; startIndex++) {  		Vector2 tmp = vertices [startIndex];  		if (MathUtils.Area (ref deque [0]' ref deque [1]' ref tmp) == 0)  			//This point is also collinear  			deque [1] = vertices [startIndex];  		else  			break;  	}  }  else {  	deque [0] = deque [3] = vertices [2];  	if (k > 0) {  		//Is Left.  Set deque = {2' 0' 1' 2}  		deque [1] = vertices [0];  		deque [2] = vertices [1];  	}  	else {  		//Is Right. Set deque = {2' 1' 0' 2}  		deque [1] = vertices [1];  		deque [2] = vertices [0];  	}  }  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: deque [1] = vertices [2];  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: deque [2] = vertices [0];  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: qf = 2;  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: for (startIndex = 3; startIndex < vertices.Count; startIndex++) {  	Vector2 tmp = vertices [startIndex];  	if (MathUtils.Area (ref deque [0]' ref deque [1]' ref tmp) == 0)  		//This point is also collinear  		deque [1] = vertices [startIndex];  	else  		break;  }  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: startIndex = 3
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: deque [0] = deque [3] = vertices [2];  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: deque [0] = deque [3] = vertices [2];  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (k > 0) {  	//Is Left.  Set deque = {2' 0' 1' 2}  	deque [1] = vertices [0];  	deque [2] = vertices [1];  }  else {  	//Is Right. Set deque = {2' 1' 0' 2}  	deque [1] = vertices [1];  	deque [2] = vertices [0];  }  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (k > 0) {  	//Is Left.  Set deque = {2' 0' 1' 2}  	deque [1] = vertices [0];  	deque [2] = vertices [1];  }  else {  	//Is Right. Set deque = {2' 1' 0' 2}  	deque [1] = vertices [1];  	deque [2] = vertices [0];  }  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: deque [2] = vertices [1];  
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: deque [2] = vertices [0];  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The following statement contains a magic number: for (int i = 0; i < vertices.Count; ++i) {  	if (Reflex (i' vertices)) {  		lowerDist = upperDist = float.MaxValue;  		// std::numeric_limits<qreal>::max();  		for (int j = 0; j < vertices.Count; ++j) {  			// if line intersects with an edge  			if (Left (At (i - 1' vertices)' At (i' vertices)' At (j' vertices)) && RightOn (At (i - 1' vertices)' At (i' vertices)' At (j - 1' vertices))) {  				// find the point of intersection  				p = LineTools.LineIntersect (At (i - 1' vertices)' At (i' vertices)' At (j' vertices)' At (j - 1' vertices));  				if (Right (At (i + 1' vertices)' At (i' vertices)' p)) {  					// make sure it's inside the poly  					d = SquareDist (At (i' vertices)' p);  					if (d < lowerDist) {  						// keep only the closest intersection  						lowerDist = d;  						lowerInt = p;  						lowerIndex = j;  					}  				}  			}  			if (Left (At (i + 1' vertices)' At (i' vertices)' At (j + 1' vertices)) && RightOn (At (i + 1' vertices)' At (i' vertices)' At (j' vertices))) {  				p = LineTools.LineIntersect (At (i + 1' vertices)' At (i' vertices)' At (j' vertices)' At (j + 1' vertices));  				if (Left (At (i - 1' vertices)' At (i' vertices)' p)) {  					d = SquareDist (At (i' vertices)' p);  					if (d < upperDist) {  						upperDist = d;  						upperIndex = j;  						upperInt = p;  					}  				}  			}  		}  		// if there are no vertices to connect to' choose a point in the middle  		if (lowerIndex == (upperIndex + 1) % vertices.Count) {  			Vector2 sp = ((lowerInt + upperInt) / 2);  			lowerPoly = Copy (i' upperIndex' vertices);  			lowerPoly.Add (sp);  			upperPoly = Copy (lowerIndex' i' vertices);  			upperPoly.Add (sp);  		}  		else {  			double highestScore = 0' bestIndex = lowerIndex;  			while (upperIndex < lowerIndex)  				upperIndex += vertices.Count;  			for (int j = lowerIndex; j <= upperIndex; ++j) {  				if (CanSee (i' j' vertices)) {  					double score = 1 / (SquareDist (At (i' vertices)' At (j' vertices)) + 1);  					if (Reflex (j' vertices)) {  						if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices))) {  							score += 3;  						}  						else {  							score += 2;  						}  					}  					else {  						score += 1;  					}  					if (score > highestScore) {  						bestIndex = j;  						highestScore = score;  					}  				}  			}  			lowerPoly = Copy (i' (int)bestIndex' vertices);  			upperPoly = Copy ((int)bestIndex' i' vertices);  		}  		list.AddRange (ConvexPartition (lowerPoly));  		list.AddRange (ConvexPartition (upperPoly));  		return list;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The following statement contains a magic number: for (int i = 0; i < vertices.Count; ++i) {  	if (Reflex (i' vertices)) {  		lowerDist = upperDist = float.MaxValue;  		// std::numeric_limits<qreal>::max();  		for (int j = 0; j < vertices.Count; ++j) {  			// if line intersects with an edge  			if (Left (At (i - 1' vertices)' At (i' vertices)' At (j' vertices)) && RightOn (At (i - 1' vertices)' At (i' vertices)' At (j - 1' vertices))) {  				// find the point of intersection  				p = LineTools.LineIntersect (At (i - 1' vertices)' At (i' vertices)' At (j' vertices)' At (j - 1' vertices));  				if (Right (At (i + 1' vertices)' At (i' vertices)' p)) {  					// make sure it's inside the poly  					d = SquareDist (At (i' vertices)' p);  					if (d < lowerDist) {  						// keep only the closest intersection  						lowerDist = d;  						lowerInt = p;  						lowerIndex = j;  					}  				}  			}  			if (Left (At (i + 1' vertices)' At (i' vertices)' At (j + 1' vertices)) && RightOn (At (i + 1' vertices)' At (i' vertices)' At (j' vertices))) {  				p = LineTools.LineIntersect (At (i + 1' vertices)' At (i' vertices)' At (j' vertices)' At (j + 1' vertices));  				if (Left (At (i - 1' vertices)' At (i' vertices)' p)) {  					d = SquareDist (At (i' vertices)' p);  					if (d < upperDist) {  						upperDist = d;  						upperIndex = j;  						upperInt = p;  					}  				}  			}  		}  		// if there are no vertices to connect to' choose a point in the middle  		if (lowerIndex == (upperIndex + 1) % vertices.Count) {  			Vector2 sp = ((lowerInt + upperInt) / 2);  			lowerPoly = Copy (i' upperIndex' vertices);  			lowerPoly.Add (sp);  			upperPoly = Copy (lowerIndex' i' vertices);  			upperPoly.Add (sp);  		}  		else {  			double highestScore = 0' bestIndex = lowerIndex;  			while (upperIndex < lowerIndex)  				upperIndex += vertices.Count;  			for (int j = lowerIndex; j <= upperIndex; ++j) {  				if (CanSee (i' j' vertices)) {  					double score = 1 / (SquareDist (At (i' vertices)' At (j' vertices)) + 1);  					if (Reflex (j' vertices)) {  						if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices))) {  							score += 3;  						}  						else {  							score += 2;  						}  					}  					else {  						score += 1;  					}  					if (score > highestScore) {  						bestIndex = j;  						highestScore = score;  					}  				}  			}  			lowerPoly = Copy (i' (int)bestIndex' vertices);  			upperPoly = Copy ((int)bestIndex' i' vertices);  		}  		list.AddRange (ConvexPartition (lowerPoly));  		list.AddRange (ConvexPartition (upperPoly));  		return list;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The following statement contains a magic number: for (int i = 0; i < vertices.Count; ++i) {  	if (Reflex (i' vertices)) {  		lowerDist = upperDist = float.MaxValue;  		// std::numeric_limits<qreal>::max();  		for (int j = 0; j < vertices.Count; ++j) {  			// if line intersects with an edge  			if (Left (At (i - 1' vertices)' At (i' vertices)' At (j' vertices)) && RightOn (At (i - 1' vertices)' At (i' vertices)' At (j - 1' vertices))) {  				// find the point of intersection  				p = LineTools.LineIntersect (At (i - 1' vertices)' At (i' vertices)' At (j' vertices)' At (j - 1' vertices));  				if (Right (At (i + 1' vertices)' At (i' vertices)' p)) {  					// make sure it's inside the poly  					d = SquareDist (At (i' vertices)' p);  					if (d < lowerDist) {  						// keep only the closest intersection  						lowerDist = d;  						lowerInt = p;  						lowerIndex = j;  					}  				}  			}  			if (Left (At (i + 1' vertices)' At (i' vertices)' At (j + 1' vertices)) && RightOn (At (i + 1' vertices)' At (i' vertices)' At (j' vertices))) {  				p = LineTools.LineIntersect (At (i + 1' vertices)' At (i' vertices)' At (j' vertices)' At (j + 1' vertices));  				if (Left (At (i - 1' vertices)' At (i' vertices)' p)) {  					d = SquareDist (At (i' vertices)' p);  					if (d < upperDist) {  						upperDist = d;  						upperIndex = j;  						upperInt = p;  					}  				}  			}  		}  		// if there are no vertices to connect to' choose a point in the middle  		if (lowerIndex == (upperIndex + 1) % vertices.Count) {  			Vector2 sp = ((lowerInt + upperInt) / 2);  			lowerPoly = Copy (i' upperIndex' vertices);  			lowerPoly.Add (sp);  			upperPoly = Copy (lowerIndex' i' vertices);  			upperPoly.Add (sp);  		}  		else {  			double highestScore = 0' bestIndex = lowerIndex;  			while (upperIndex < lowerIndex)  				upperIndex += vertices.Count;  			for (int j = lowerIndex; j <= upperIndex; ++j) {  				if (CanSee (i' j' vertices)) {  					double score = 1 / (SquareDist (At (i' vertices)' At (j' vertices)) + 1);  					if (Reflex (j' vertices)) {  						if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices))) {  							score += 3;  						}  						else {  							score += 2;  						}  					}  					else {  						score += 1;  					}  					if (score > highestScore) {  						bestIndex = j;  						highestScore = score;  					}  				}  			}  			lowerPoly = Copy (i' (int)bestIndex' vertices);  			upperPoly = Copy ((int)bestIndex' i' vertices);  		}  		list.AddRange (ConvexPartition (lowerPoly));  		list.AddRange (ConvexPartition (upperPoly));  		return list;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The following statement contains a magic number: if (Reflex (i' vertices)) {  	lowerDist = upperDist = float.MaxValue;  	// std::numeric_limits<qreal>::max();  	for (int j = 0; j < vertices.Count; ++j) {  		// if line intersects with an edge  		if (Left (At (i - 1' vertices)' At (i' vertices)' At (j' vertices)) && RightOn (At (i - 1' vertices)' At (i' vertices)' At (j - 1' vertices))) {  			// find the point of intersection  			p = LineTools.LineIntersect (At (i - 1' vertices)' At (i' vertices)' At (j' vertices)' At (j - 1' vertices));  			if (Right (At (i + 1' vertices)' At (i' vertices)' p)) {  				// make sure it's inside the poly  				d = SquareDist (At (i' vertices)' p);  				if (d < lowerDist) {  					// keep only the closest intersection  					lowerDist = d;  					lowerInt = p;  					lowerIndex = j;  				}  			}  		}  		if (Left (At (i + 1' vertices)' At (i' vertices)' At (j + 1' vertices)) && RightOn (At (i + 1' vertices)' At (i' vertices)' At (j' vertices))) {  			p = LineTools.LineIntersect (At (i + 1' vertices)' At (i' vertices)' At (j' vertices)' At (j + 1' vertices));  			if (Left (At (i - 1' vertices)' At (i' vertices)' p)) {  				d = SquareDist (At (i' vertices)' p);  				if (d < upperDist) {  					upperDist = d;  					upperIndex = j;  					upperInt = p;  				}  			}  		}  	}  	// if there are no vertices to connect to' choose a point in the middle  	if (lowerIndex == (upperIndex + 1) % vertices.Count) {  		Vector2 sp = ((lowerInt + upperInt) / 2);  		lowerPoly = Copy (i' upperIndex' vertices);  		lowerPoly.Add (sp);  		upperPoly = Copy (lowerIndex' i' vertices);  		upperPoly.Add (sp);  	}  	else {  		double highestScore = 0' bestIndex = lowerIndex;  		while (upperIndex < lowerIndex)  			upperIndex += vertices.Count;  		for (int j = lowerIndex; j <= upperIndex; ++j) {  			if (CanSee (i' j' vertices)) {  				double score = 1 / (SquareDist (At (i' vertices)' At (j' vertices)) + 1);  				if (Reflex (j' vertices)) {  					if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices))) {  						score += 3;  					}  					else {  						score += 2;  					}  				}  				else {  					score += 1;  				}  				if (score > highestScore) {  					bestIndex = j;  					highestScore = score;  				}  			}  		}  		lowerPoly = Copy (i' (int)bestIndex' vertices);  		upperPoly = Copy ((int)bestIndex' i' vertices);  	}  	list.AddRange (ConvexPartition (lowerPoly));  	list.AddRange (ConvexPartition (upperPoly));  	return list;  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The following statement contains a magic number: if (Reflex (i' vertices)) {  	lowerDist = upperDist = float.MaxValue;  	// std::numeric_limits<qreal>::max();  	for (int j = 0; j < vertices.Count; ++j) {  		// if line intersects with an edge  		if (Left (At (i - 1' vertices)' At (i' vertices)' At (j' vertices)) && RightOn (At (i - 1' vertices)' At (i' vertices)' At (j - 1' vertices))) {  			// find the point of intersection  			p = LineTools.LineIntersect (At (i - 1' vertices)' At (i' vertices)' At (j' vertices)' At (j - 1' vertices));  			if (Right (At (i + 1' vertices)' At (i' vertices)' p)) {  				// make sure it's inside the poly  				d = SquareDist (At (i' vertices)' p);  				if (d < lowerDist) {  					// keep only the closest intersection  					lowerDist = d;  					lowerInt = p;  					lowerIndex = j;  				}  			}  		}  		if (Left (At (i + 1' vertices)' At (i' vertices)' At (j + 1' vertices)) && RightOn (At (i + 1' vertices)' At (i' vertices)' At (j' vertices))) {  			p = LineTools.LineIntersect (At (i + 1' vertices)' At (i' vertices)' At (j' vertices)' At (j + 1' vertices));  			if (Left (At (i - 1' vertices)' At (i' vertices)' p)) {  				d = SquareDist (At (i' vertices)' p);  				if (d < upperDist) {  					upperDist = d;  					upperIndex = j;  					upperInt = p;  				}  			}  		}  	}  	// if there are no vertices to connect to' choose a point in the middle  	if (lowerIndex == (upperIndex + 1) % vertices.Count) {  		Vector2 sp = ((lowerInt + upperInt) / 2);  		lowerPoly = Copy (i' upperIndex' vertices);  		lowerPoly.Add (sp);  		upperPoly = Copy (lowerIndex' i' vertices);  		upperPoly.Add (sp);  	}  	else {  		double highestScore = 0' bestIndex = lowerIndex;  		while (upperIndex < lowerIndex)  			upperIndex += vertices.Count;  		for (int j = lowerIndex; j <= upperIndex; ++j) {  			if (CanSee (i' j' vertices)) {  				double score = 1 / (SquareDist (At (i' vertices)' At (j' vertices)) + 1);  				if (Reflex (j' vertices)) {  					if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices))) {  						score += 3;  					}  					else {  						score += 2;  					}  				}  				else {  					score += 1;  				}  				if (score > highestScore) {  					bestIndex = j;  					highestScore = score;  				}  			}  		}  		lowerPoly = Copy (i' (int)bestIndex' vertices);  		upperPoly = Copy ((int)bestIndex' i' vertices);  	}  	list.AddRange (ConvexPartition (lowerPoly));  	list.AddRange (ConvexPartition (upperPoly));  	return list;  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The following statement contains a magic number: if (Reflex (i' vertices)) {  	lowerDist = upperDist = float.MaxValue;  	// std::numeric_limits<qreal>::max();  	for (int j = 0; j < vertices.Count; ++j) {  		// if line intersects with an edge  		if (Left (At (i - 1' vertices)' At (i' vertices)' At (j' vertices)) && RightOn (At (i - 1' vertices)' At (i' vertices)' At (j - 1' vertices))) {  			// find the point of intersection  			p = LineTools.LineIntersect (At (i - 1' vertices)' At (i' vertices)' At (j' vertices)' At (j - 1' vertices));  			if (Right (At (i + 1' vertices)' At (i' vertices)' p)) {  				// make sure it's inside the poly  				d = SquareDist (At (i' vertices)' p);  				if (d < lowerDist) {  					// keep only the closest intersection  					lowerDist = d;  					lowerInt = p;  					lowerIndex = j;  				}  			}  		}  		if (Left (At (i + 1' vertices)' At (i' vertices)' At (j + 1' vertices)) && RightOn (At (i + 1' vertices)' At (i' vertices)' At (j' vertices))) {  			p = LineTools.LineIntersect (At (i + 1' vertices)' At (i' vertices)' At (j' vertices)' At (j + 1' vertices));  			if (Left (At (i - 1' vertices)' At (i' vertices)' p)) {  				d = SquareDist (At (i' vertices)' p);  				if (d < upperDist) {  					upperDist = d;  					upperIndex = j;  					upperInt = p;  				}  			}  		}  	}  	// if there are no vertices to connect to' choose a point in the middle  	if (lowerIndex == (upperIndex + 1) % vertices.Count) {  		Vector2 sp = ((lowerInt + upperInt) / 2);  		lowerPoly = Copy (i' upperIndex' vertices);  		lowerPoly.Add (sp);  		upperPoly = Copy (lowerIndex' i' vertices);  		upperPoly.Add (sp);  	}  	else {  		double highestScore = 0' bestIndex = lowerIndex;  		while (upperIndex < lowerIndex)  			upperIndex += vertices.Count;  		for (int j = lowerIndex; j <= upperIndex; ++j) {  			if (CanSee (i' j' vertices)) {  				double score = 1 / (SquareDist (At (i' vertices)' At (j' vertices)) + 1);  				if (Reflex (j' vertices)) {  					if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices))) {  						score += 3;  					}  					else {  						score += 2;  					}  				}  				else {  					score += 1;  				}  				if (score > highestScore) {  					bestIndex = j;  					highestScore = score;  				}  			}  		}  		lowerPoly = Copy (i' (int)bestIndex' vertices);  		upperPoly = Copy ((int)bestIndex' i' vertices);  	}  	list.AddRange (ConvexPartition (lowerPoly));  	list.AddRange (ConvexPartition (upperPoly));  	return list;  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The following statement contains a magic number: if (lowerIndex == (upperIndex + 1) % vertices.Count) {  	Vector2 sp = ((lowerInt + upperInt) / 2);  	lowerPoly = Copy (i' upperIndex' vertices);  	lowerPoly.Add (sp);  	upperPoly = Copy (lowerIndex' i' vertices);  	upperPoly.Add (sp);  }  else {  	double highestScore = 0' bestIndex = lowerIndex;  	while (upperIndex < lowerIndex)  		upperIndex += vertices.Count;  	for (int j = lowerIndex; j <= upperIndex; ++j) {  		if (CanSee (i' j' vertices)) {  			double score = 1 / (SquareDist (At (i' vertices)' At (j' vertices)) + 1);  			if (Reflex (j' vertices)) {  				if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices))) {  					score += 3;  				}  				else {  					score += 2;  				}  			}  			else {  				score += 1;  			}  			if (score > highestScore) {  				bestIndex = j;  				highestScore = score;  			}  		}  	}  	lowerPoly = Copy (i' (int)bestIndex' vertices);  	upperPoly = Copy ((int)bestIndex' i' vertices);  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The following statement contains a magic number: if (lowerIndex == (upperIndex + 1) % vertices.Count) {  	Vector2 sp = ((lowerInt + upperInt) / 2);  	lowerPoly = Copy (i' upperIndex' vertices);  	lowerPoly.Add (sp);  	upperPoly = Copy (lowerIndex' i' vertices);  	upperPoly.Add (sp);  }  else {  	double highestScore = 0' bestIndex = lowerIndex;  	while (upperIndex < lowerIndex)  		upperIndex += vertices.Count;  	for (int j = lowerIndex; j <= upperIndex; ++j) {  		if (CanSee (i' j' vertices)) {  			double score = 1 / (SquareDist (At (i' vertices)' At (j' vertices)) + 1);  			if (Reflex (j' vertices)) {  				if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices))) {  					score += 3;  				}  				else {  					score += 2;  				}  			}  			else {  				score += 1;  			}  			if (score > highestScore) {  				bestIndex = j;  				highestScore = score;  			}  		}  	}  	lowerPoly = Copy (i' (int)bestIndex' vertices);  	upperPoly = Copy ((int)bestIndex' i' vertices);  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The following statement contains a magic number: if (lowerIndex == (upperIndex + 1) % vertices.Count) {  	Vector2 sp = ((lowerInt + upperInt) / 2);  	lowerPoly = Copy (i' upperIndex' vertices);  	lowerPoly.Add (sp);  	upperPoly = Copy (lowerIndex' i' vertices);  	upperPoly.Add (sp);  }  else {  	double highestScore = 0' bestIndex = lowerIndex;  	while (upperIndex < lowerIndex)  		upperIndex += vertices.Count;  	for (int j = lowerIndex; j <= upperIndex; ++j) {  		if (CanSee (i' j' vertices)) {  			double score = 1 / (SquareDist (At (i' vertices)' At (j' vertices)) + 1);  			if (Reflex (j' vertices)) {  				if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices))) {  					score += 3;  				}  				else {  					score += 2;  				}  			}  			else {  				score += 1;  			}  			if (score > highestScore) {  				bestIndex = j;  				highestScore = score;  			}  		}  	}  	lowerPoly = Copy (i' (int)bestIndex' vertices);  	upperPoly = Copy ((int)bestIndex' i' vertices);  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The following statement contains a magic number: for (int j = lowerIndex; j <= upperIndex; ++j) {  	if (CanSee (i' j' vertices)) {  		double score = 1 / (SquareDist (At (i' vertices)' At (j' vertices)) + 1);  		if (Reflex (j' vertices)) {  			if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices))) {  				score += 3;  			}  			else {  				score += 2;  			}  		}  		else {  			score += 1;  		}  		if (score > highestScore) {  			bestIndex = j;  			highestScore = score;  		}  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The following statement contains a magic number: for (int j = lowerIndex; j <= upperIndex; ++j) {  	if (CanSee (i' j' vertices)) {  		double score = 1 / (SquareDist (At (i' vertices)' At (j' vertices)) + 1);  		if (Reflex (j' vertices)) {  			if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices))) {  				score += 3;  			}  			else {  				score += 2;  			}  		}  		else {  			score += 1;  		}  		if (score > highestScore) {  			bestIndex = j;  			highestScore = score;  		}  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The following statement contains a magic number: if (CanSee (i' j' vertices)) {  	double score = 1 / (SquareDist (At (i' vertices)' At (j' vertices)) + 1);  	if (Reflex (j' vertices)) {  		if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices))) {  			score += 3;  		}  		else {  			score += 2;  		}  	}  	else {  		score += 1;  	}  	if (score > highestScore) {  		bestIndex = j;  		highestScore = score;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The following statement contains a magic number: if (CanSee (i' j' vertices)) {  	double score = 1 / (SquareDist (At (i' vertices)' At (j' vertices)) + 1);  	if (Reflex (j' vertices)) {  		if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices))) {  			score += 3;  		}  		else {  			score += 2;  		}  	}  	else {  		score += 1;  	}  	if (score > highestScore) {  		bestIndex = j;  		highestScore = score;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The following statement contains a magic number: if (Reflex (j' vertices)) {  	if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices))) {  		score += 3;  	}  	else {  		score += 2;  	}  }  else {  	score += 1;  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The following statement contains a magic number: if (Reflex (j' vertices)) {  	if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices))) {  		score += 3;  	}  	else {  		score += 2;  	}  }  else {  	score += 1;  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The following statement contains a magic number: if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices))) {  	score += 3;  }  else {  	score += 2;  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The following statement contains a magic number: if (RightOn (At (j - 1' vertices)' At (j' vertices)' At (i' vertices)) && LeftOn (At (j + 1' vertices)' At (j' vertices)' At (i' vertices))) {  	score += 3;  }  else {  	score += 2;  }  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The following statement contains a magic number: score += 3;  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The following statement contains a magic number: score += 2;  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The following statement contains a magic number: if (vertices.Count > Settings.MaxPolygonVertices) {  	lowerPoly = Copy (0' vertices.Count / 2' vertices);  	upperPoly = Copy (vertices.Count / 2' 0' vertices);  	list.AddRange (ConvexPartition (lowerPoly));  	list.AddRange (ConvexPartition (upperPoly));  }  else  	list.Add (vertices);  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The following statement contains a magic number: if (vertices.Count > Settings.MaxPolygonVertices) {  	lowerPoly = Copy (0' vertices.Count / 2' vertices);  	upperPoly = Copy (vertices.Count / 2' 0' vertices);  	list.AddRange (ConvexPartition (lowerPoly));  	list.AddRange (ConvexPartition (upperPoly));  }  else  	list.Add (vertices);  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The following statement contains a magic number: lowerPoly = Copy (0' vertices.Count / 2' vertices);  
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The following statement contains a magic number: upperPoly = Copy (vertices.Count / 2' 0' vertices);  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,ConvexPartition,The following statement contains a magic number: if (vertices.Count < 3)  	return new List<Vertices> {  		vertices  	};  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: for (int i = 0; i < triangulated.Count; ++i) {  	covered [i] = false;  	//Check here for degenerate triangles  	if (((triangulated [i].X [0] == triangulated [i].X [1]) && (triangulated [i].Y [0] == triangulated [i].Y [1])) || ((triangulated [i].X [1] == triangulated [i].X [2]) && (triangulated [i].Y [1] == triangulated [i].Y [2])) || ((triangulated [i].X [0] == triangulated [i].X [2]) && (triangulated [i].Y [0] == triangulated [i].Y [2]))) {  		covered [i] = true;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: for (int i = 0; i < triangulated.Count; ++i) {  	covered [i] = false;  	//Check here for degenerate triangles  	if (((triangulated [i].X [0] == triangulated [i].X [1]) && (triangulated [i].Y [0] == triangulated [i].Y [1])) || ((triangulated [i].X [1] == triangulated [i].X [2]) && (triangulated [i].Y [1] == triangulated [i].Y [2])) || ((triangulated [i].X [0] == triangulated [i].X [2]) && (triangulated [i].Y [0] == triangulated [i].Y [2]))) {  		covered [i] = true;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: for (int i = 0; i < triangulated.Count; ++i) {  	covered [i] = false;  	//Check here for degenerate triangles  	if (((triangulated [i].X [0] == triangulated [i].X [1]) && (triangulated [i].Y [0] == triangulated [i].Y [1])) || ((triangulated [i].X [1] == triangulated [i].X [2]) && (triangulated [i].Y [1] == triangulated [i].Y [2])) || ((triangulated [i].X [0] == triangulated [i].X [2]) && (triangulated [i].Y [0] == triangulated [i].Y [2]))) {  		covered [i] = true;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: for (int i = 0; i < triangulated.Count; ++i) {  	covered [i] = false;  	//Check here for degenerate triangles  	if (((triangulated [i].X [0] == triangulated [i].X [1]) && (triangulated [i].Y [0] == triangulated [i].Y [1])) || ((triangulated [i].X [1] == triangulated [i].X [2]) && (triangulated [i].Y [1] == triangulated [i].Y [2])) || ((triangulated [i].X [0] == triangulated [i].X [2]) && (triangulated [i].Y [0] == triangulated [i].Y [2]))) {  		covered [i] = true;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: if (((triangulated [i].X [0] == triangulated [i].X [1]) && (triangulated [i].Y [0] == triangulated [i].Y [1])) || ((triangulated [i].X [1] == triangulated [i].X [2]) && (triangulated [i].Y [1] == triangulated [i].Y [2])) || ((triangulated [i].X [0] == triangulated [i].X [2]) && (triangulated [i].Y [0] == triangulated [i].Y [2]))) {  	covered [i] = true;  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: if (((triangulated [i].X [0] == triangulated [i].X [1]) && (triangulated [i].Y [0] == triangulated [i].Y [1])) || ((triangulated [i].X [1] == triangulated [i].X [2]) && (triangulated [i].Y [1] == triangulated [i].Y [2])) || ((triangulated [i].X [0] == triangulated [i].X [2]) && (triangulated [i].Y [0] == triangulated [i].Y [2]))) {  	covered [i] = true;  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: if (((triangulated [i].X [0] == triangulated [i].X [1]) && (triangulated [i].Y [0] == triangulated [i].Y [1])) || ((triangulated [i].X [1] == triangulated [i].X [2]) && (triangulated [i].Y [1] == triangulated [i].Y [2])) || ((triangulated [i].X [0] == triangulated [i].X [2]) && (triangulated [i].Y [0] == triangulated [i].Y [2]))) {  	covered [i] = true;  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: if (((triangulated [i].X [0] == triangulated [i].X [1]) && (triangulated [i].Y [0] == triangulated [i].Y [1])) || ((triangulated [i].X [1] == triangulated [i].X [2]) && (triangulated [i].Y [1] == triangulated [i].Y [2])) || ((triangulated [i].X [0] == triangulated [i].X [2]) && (triangulated [i].Y [0] == triangulated [i].Y [2]))) {  	covered [i] = true;  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: while (notDone) {  	int currTri = -1;  	for (int i = 0; i < triangulated.Count; ++i) {  		if (covered [i])  			continue;  		currTri = i;  		break;  	}  	if (currTri == -1) {  		notDone = false;  	}  	else {  		Vertices poly = new Vertices (3);  		for (int i = 0; i < 3; i++) {  			poly.Add (new Vector2 (triangulated [currTri].X [i]' triangulated [currTri].Y [i]));  		}  		covered [currTri] = true;  		int index = 0;  		for (int i = 0; i < 2 * triangulated.Count; ++i' ++index) {  			while (index >= triangulated.Count)  				index -= triangulated.Count;  			if (covered [index]) {  				continue;  			}  			Vertices newP = AddTriangle (triangulated [index]' poly);  			if (newP == null)  				continue;  			// is this right  			if (newP.Count > Settings.MaxPolygonVertices)  				continue;  			if (newP.IsConvex ()) {  				//Or should it be IsUsable?  Maybe re-write IsConvex to apply the angle threshold from Box2d  				poly = new Vertices (newP);  				covered [index] = true;  			}  		}  		//We have a maximum of polygons that we need to keep under.  		if (polyIndex < maxPolys) {  			//SimplifyTools.MergeParallelEdges(poly' tolerance);  			//If identical points are present' a triangle gets  			//borked by the MergeParallelEdges function' hence  			//the vertex number check  			if (poly.Count >= 3)  				polys.Add (new Vertices (poly));  			//else  			//    printf("Skipping corrupt poly\n");  		}  		if (poly.Count >= 3)  			polyIndex++;  		//Must be outside (polyIndex < polysLength) test  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: while (notDone) {  	int currTri = -1;  	for (int i = 0; i < triangulated.Count; ++i) {  		if (covered [i])  			continue;  		currTri = i;  		break;  	}  	if (currTri == -1) {  		notDone = false;  	}  	else {  		Vertices poly = new Vertices (3);  		for (int i = 0; i < 3; i++) {  			poly.Add (new Vector2 (triangulated [currTri].X [i]' triangulated [currTri].Y [i]));  		}  		covered [currTri] = true;  		int index = 0;  		for (int i = 0; i < 2 * triangulated.Count; ++i' ++index) {  			while (index >= triangulated.Count)  				index -= triangulated.Count;  			if (covered [index]) {  				continue;  			}  			Vertices newP = AddTriangle (triangulated [index]' poly);  			if (newP == null)  				continue;  			// is this right  			if (newP.Count > Settings.MaxPolygonVertices)  				continue;  			if (newP.IsConvex ()) {  				//Or should it be IsUsable?  Maybe re-write IsConvex to apply the angle threshold from Box2d  				poly = new Vertices (newP);  				covered [index] = true;  			}  		}  		//We have a maximum of polygons that we need to keep under.  		if (polyIndex < maxPolys) {  			//SimplifyTools.MergeParallelEdges(poly' tolerance);  			//If identical points are present' a triangle gets  			//borked by the MergeParallelEdges function' hence  			//the vertex number check  			if (poly.Count >= 3)  				polys.Add (new Vertices (poly));  			//else  			//    printf("Skipping corrupt poly\n");  		}  		if (poly.Count >= 3)  			polyIndex++;  		//Must be outside (polyIndex < polysLength) test  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: while (notDone) {  	int currTri = -1;  	for (int i = 0; i < triangulated.Count; ++i) {  		if (covered [i])  			continue;  		currTri = i;  		break;  	}  	if (currTri == -1) {  		notDone = false;  	}  	else {  		Vertices poly = new Vertices (3);  		for (int i = 0; i < 3; i++) {  			poly.Add (new Vector2 (triangulated [currTri].X [i]' triangulated [currTri].Y [i]));  		}  		covered [currTri] = true;  		int index = 0;  		for (int i = 0; i < 2 * triangulated.Count; ++i' ++index) {  			while (index >= triangulated.Count)  				index -= triangulated.Count;  			if (covered [index]) {  				continue;  			}  			Vertices newP = AddTriangle (triangulated [index]' poly);  			if (newP == null)  				continue;  			// is this right  			if (newP.Count > Settings.MaxPolygonVertices)  				continue;  			if (newP.IsConvex ()) {  				//Or should it be IsUsable?  Maybe re-write IsConvex to apply the angle threshold from Box2d  				poly = new Vertices (newP);  				covered [index] = true;  			}  		}  		//We have a maximum of polygons that we need to keep under.  		if (polyIndex < maxPolys) {  			//SimplifyTools.MergeParallelEdges(poly' tolerance);  			//If identical points are present' a triangle gets  			//borked by the MergeParallelEdges function' hence  			//the vertex number check  			if (poly.Count >= 3)  				polys.Add (new Vertices (poly));  			//else  			//    printf("Skipping corrupt poly\n");  		}  		if (poly.Count >= 3)  			polyIndex++;  		//Must be outside (polyIndex < polysLength) test  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: while (notDone) {  	int currTri = -1;  	for (int i = 0; i < triangulated.Count; ++i) {  		if (covered [i])  			continue;  		currTri = i;  		break;  	}  	if (currTri == -1) {  		notDone = false;  	}  	else {  		Vertices poly = new Vertices (3);  		for (int i = 0; i < 3; i++) {  			poly.Add (new Vector2 (triangulated [currTri].X [i]' triangulated [currTri].Y [i]));  		}  		covered [currTri] = true;  		int index = 0;  		for (int i = 0; i < 2 * triangulated.Count; ++i' ++index) {  			while (index >= triangulated.Count)  				index -= triangulated.Count;  			if (covered [index]) {  				continue;  			}  			Vertices newP = AddTriangle (triangulated [index]' poly);  			if (newP == null)  				continue;  			// is this right  			if (newP.Count > Settings.MaxPolygonVertices)  				continue;  			if (newP.IsConvex ()) {  				//Or should it be IsUsable?  Maybe re-write IsConvex to apply the angle threshold from Box2d  				poly = new Vertices (newP);  				covered [index] = true;  			}  		}  		//We have a maximum of polygons that we need to keep under.  		if (polyIndex < maxPolys) {  			//SimplifyTools.MergeParallelEdges(poly' tolerance);  			//If identical points are present' a triangle gets  			//borked by the MergeParallelEdges function' hence  			//the vertex number check  			if (poly.Count >= 3)  				polys.Add (new Vertices (poly));  			//else  			//    printf("Skipping corrupt poly\n");  		}  		if (poly.Count >= 3)  			polyIndex++;  		//Must be outside (polyIndex < polysLength) test  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: while (notDone) {  	int currTri = -1;  	for (int i = 0; i < triangulated.Count; ++i) {  		if (covered [i])  			continue;  		currTri = i;  		break;  	}  	if (currTri == -1) {  		notDone = false;  	}  	else {  		Vertices poly = new Vertices (3);  		for (int i = 0; i < 3; i++) {  			poly.Add (new Vector2 (triangulated [currTri].X [i]' triangulated [currTri].Y [i]));  		}  		covered [currTri] = true;  		int index = 0;  		for (int i = 0; i < 2 * triangulated.Count; ++i' ++index) {  			while (index >= triangulated.Count)  				index -= triangulated.Count;  			if (covered [index]) {  				continue;  			}  			Vertices newP = AddTriangle (triangulated [index]' poly);  			if (newP == null)  				continue;  			// is this right  			if (newP.Count > Settings.MaxPolygonVertices)  				continue;  			if (newP.IsConvex ()) {  				//Or should it be IsUsable?  Maybe re-write IsConvex to apply the angle threshold from Box2d  				poly = new Vertices (newP);  				covered [index] = true;  			}  		}  		//We have a maximum of polygons that we need to keep under.  		if (polyIndex < maxPolys) {  			//SimplifyTools.MergeParallelEdges(poly' tolerance);  			//If identical points are present' a triangle gets  			//borked by the MergeParallelEdges function' hence  			//the vertex number check  			if (poly.Count >= 3)  				polys.Add (new Vertices (poly));  			//else  			//    printf("Skipping corrupt poly\n");  		}  		if (poly.Count >= 3)  			polyIndex++;  		//Must be outside (polyIndex < polysLength) test  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: if (currTri == -1) {  	notDone = false;  }  else {  	Vertices poly = new Vertices (3);  	for (int i = 0; i < 3; i++) {  		poly.Add (new Vector2 (triangulated [currTri].X [i]' triangulated [currTri].Y [i]));  	}  	covered [currTri] = true;  	int index = 0;  	for (int i = 0; i < 2 * triangulated.Count; ++i' ++index) {  		while (index >= triangulated.Count)  			index -= triangulated.Count;  		if (covered [index]) {  			continue;  		}  		Vertices newP = AddTriangle (triangulated [index]' poly);  		if (newP == null)  			continue;  		// is this right  		if (newP.Count > Settings.MaxPolygonVertices)  			continue;  		if (newP.IsConvex ()) {  			//Or should it be IsUsable?  Maybe re-write IsConvex to apply the angle threshold from Box2d  			poly = new Vertices (newP);  			covered [index] = true;  		}  	}  	//We have a maximum of polygons that we need to keep under.  	if (polyIndex < maxPolys) {  		//SimplifyTools.MergeParallelEdges(poly' tolerance);  		//If identical points are present' a triangle gets  		//borked by the MergeParallelEdges function' hence  		//the vertex number check  		if (poly.Count >= 3)  			polys.Add (new Vertices (poly));  		//else  		//    printf("Skipping corrupt poly\n");  	}  	if (poly.Count >= 3)  		polyIndex++;  	//Must be outside (polyIndex < polysLength) test  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: if (currTri == -1) {  	notDone = false;  }  else {  	Vertices poly = new Vertices (3);  	for (int i = 0; i < 3; i++) {  		poly.Add (new Vector2 (triangulated [currTri].X [i]' triangulated [currTri].Y [i]));  	}  	covered [currTri] = true;  	int index = 0;  	for (int i = 0; i < 2 * triangulated.Count; ++i' ++index) {  		while (index >= triangulated.Count)  			index -= triangulated.Count;  		if (covered [index]) {  			continue;  		}  		Vertices newP = AddTriangle (triangulated [index]' poly);  		if (newP == null)  			continue;  		// is this right  		if (newP.Count > Settings.MaxPolygonVertices)  			continue;  		if (newP.IsConvex ()) {  			//Or should it be IsUsable?  Maybe re-write IsConvex to apply the angle threshold from Box2d  			poly = new Vertices (newP);  			covered [index] = true;  		}  	}  	//We have a maximum of polygons that we need to keep under.  	if (polyIndex < maxPolys) {  		//SimplifyTools.MergeParallelEdges(poly' tolerance);  		//If identical points are present' a triangle gets  		//borked by the MergeParallelEdges function' hence  		//the vertex number check  		if (poly.Count >= 3)  			polys.Add (new Vertices (poly));  		//else  		//    printf("Skipping corrupt poly\n");  	}  	if (poly.Count >= 3)  		polyIndex++;  	//Must be outside (polyIndex < polysLength) test  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: if (currTri == -1) {  	notDone = false;  }  else {  	Vertices poly = new Vertices (3);  	for (int i = 0; i < 3; i++) {  		poly.Add (new Vector2 (triangulated [currTri].X [i]' triangulated [currTri].Y [i]));  	}  	covered [currTri] = true;  	int index = 0;  	for (int i = 0; i < 2 * triangulated.Count; ++i' ++index) {  		while (index >= triangulated.Count)  			index -= triangulated.Count;  		if (covered [index]) {  			continue;  		}  		Vertices newP = AddTriangle (triangulated [index]' poly);  		if (newP == null)  			continue;  		// is this right  		if (newP.Count > Settings.MaxPolygonVertices)  			continue;  		if (newP.IsConvex ()) {  			//Or should it be IsUsable?  Maybe re-write IsConvex to apply the angle threshold from Box2d  			poly = new Vertices (newP);  			covered [index] = true;  		}  	}  	//We have a maximum of polygons that we need to keep under.  	if (polyIndex < maxPolys) {  		//SimplifyTools.MergeParallelEdges(poly' tolerance);  		//If identical points are present' a triangle gets  		//borked by the MergeParallelEdges function' hence  		//the vertex number check  		if (poly.Count >= 3)  			polys.Add (new Vertices (poly));  		//else  		//    printf("Skipping corrupt poly\n");  	}  	if (poly.Count >= 3)  		polyIndex++;  	//Must be outside (polyIndex < polysLength) test  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: if (currTri == -1) {  	notDone = false;  }  else {  	Vertices poly = new Vertices (3);  	for (int i = 0; i < 3; i++) {  		poly.Add (new Vector2 (triangulated [currTri].X [i]' triangulated [currTri].Y [i]));  	}  	covered [currTri] = true;  	int index = 0;  	for (int i = 0; i < 2 * triangulated.Count; ++i' ++index) {  		while (index >= triangulated.Count)  			index -= triangulated.Count;  		if (covered [index]) {  			continue;  		}  		Vertices newP = AddTriangle (triangulated [index]' poly);  		if (newP == null)  			continue;  		// is this right  		if (newP.Count > Settings.MaxPolygonVertices)  			continue;  		if (newP.IsConvex ()) {  			//Or should it be IsUsable?  Maybe re-write IsConvex to apply the angle threshold from Box2d  			poly = new Vertices (newP);  			covered [index] = true;  		}  	}  	//We have a maximum of polygons that we need to keep under.  	if (polyIndex < maxPolys) {  		//SimplifyTools.MergeParallelEdges(poly' tolerance);  		//If identical points are present' a triangle gets  		//borked by the MergeParallelEdges function' hence  		//the vertex number check  		if (poly.Count >= 3)  			polys.Add (new Vertices (poly));  		//else  		//    printf("Skipping corrupt poly\n");  	}  	if (poly.Count >= 3)  		polyIndex++;  	//Must be outside (polyIndex < polysLength) test  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: if (currTri == -1) {  	notDone = false;  }  else {  	Vertices poly = new Vertices (3);  	for (int i = 0; i < 3; i++) {  		poly.Add (new Vector2 (triangulated [currTri].X [i]' triangulated [currTri].Y [i]));  	}  	covered [currTri] = true;  	int index = 0;  	for (int i = 0; i < 2 * triangulated.Count; ++i' ++index) {  		while (index >= triangulated.Count)  			index -= triangulated.Count;  		if (covered [index]) {  			continue;  		}  		Vertices newP = AddTriangle (triangulated [index]' poly);  		if (newP == null)  			continue;  		// is this right  		if (newP.Count > Settings.MaxPolygonVertices)  			continue;  		if (newP.IsConvex ()) {  			//Or should it be IsUsable?  Maybe re-write IsConvex to apply the angle threshold from Box2d  			poly = new Vertices (newP);  			covered [index] = true;  		}  	}  	//We have a maximum of polygons that we need to keep under.  	if (polyIndex < maxPolys) {  		//SimplifyTools.MergeParallelEdges(poly' tolerance);  		//If identical points are present' a triangle gets  		//borked by the MergeParallelEdges function' hence  		//the vertex number check  		if (poly.Count >= 3)  			polys.Add (new Vertices (poly));  		//else  		//    printf("Skipping corrupt poly\n");  	}  	if (poly.Count >= 3)  		polyIndex++;  	//Must be outside (polyIndex < polysLength) test  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	poly.Add (new Vector2 (triangulated [currTri].X [i]' triangulated [currTri].Y [i]));  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: for (int i = 0; i < 2 * triangulated.Count; ++i' ++index) {  	while (index >= triangulated.Count)  		index -= triangulated.Count;  	if (covered [index]) {  		continue;  	}  	Vertices newP = AddTriangle (triangulated [index]' poly);  	if (newP == null)  		continue;  	// is this right  	if (newP.Count > Settings.MaxPolygonVertices)  		continue;  	if (newP.IsConvex ()) {  		//Or should it be IsUsable?  Maybe re-write IsConvex to apply the angle threshold from Box2d  		poly = new Vertices (newP);  		covered [index] = true;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: if (polyIndex < maxPolys) {  	//SimplifyTools.MergeParallelEdges(poly' tolerance);  	//If identical points are present' a triangle gets  	//borked by the MergeParallelEdges function' hence  	//the vertex number check  	if (poly.Count >= 3)  		polys.Add (new Vertices (poly));  	//else  	//    printf("Skipping corrupt poly\n");  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: if (poly.Count >= 3)  	polys.Add (new Vertices (poly));  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: if (poly.Count >= 3)  	polyIndex++;  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: if (vertices.Count < 3)  	return new List<Triangle> ();  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: while (vNum > 3) {  	// Find an ear  	int earIndex = -1;  	float earMaxMinCross = -10.0f;  	for (int i = 0; i < vNum; ++i) {  		if (IsEar (i' xrem' yrem' vNum)) {  			int lower = Remainder (i - 1' vNum);  			int upper = Remainder (i + 1' vNum);  			Vector2 d1 = new Vector2 (xrem [upper] - xrem [i]' yrem [upper] - yrem [i]);  			Vector2 d2 = new Vector2 (xrem [i] - xrem [lower]' yrem [i] - yrem [lower]);  			Vector2 d3 = new Vector2 (xrem [lower] - xrem [upper]' yrem [lower] - yrem [upper]);  			d1.Normalize ();  			d2.Normalize ();  			d3.Normalize ();  			float cross12;  			MathUtils.Cross (ref d1' ref d2' out cross12);  			cross12 = Math.Abs (cross12);  			float cross23;  			MathUtils.Cross (ref d2' ref d3' out cross23);  			cross23 = Math.Abs (cross23);  			float cross31;  			MathUtils.Cross (ref d3' ref d1' out cross31);  			cross31 = Math.Abs (cross31);  			//Find the maximum minimum angle  			float minCross = Math.Min (cross12' Math.Min (cross23' cross31));  			if (minCross > earMaxMinCross) {  				earIndex = i;  				earMaxMinCross = minCross;  			}  		}  	}  	// If we still haven't found an ear' we're screwed.  	// Note: sometimes this is happening because the  	// remaining points are collinear.  Really these  	// should just be thrown out without halting triangulation.  	if (earIndex == -1) {  		for (int i = 0; i < bufferSize; i++) {  			results.Add (new Triangle (buffer [i]));  		}  		return results;  	}  	// Clip off the ear:  	// - remove the ear tip from the list  	--vNum;  	float[] newx = new float[vNum];  	float[] newy = new float[vNum];  	int currDest = 0;  	for (int i = 0; i < vNum; ++i) {  		if (currDest == earIndex)  			++currDest;  		newx [i] = xrem [currDest];  		newy [i] = yrem [currDest];  		++currDest;  	}  	// - add the clipped triangle to the triangle list  	int under = (earIndex == 0) ? (vNum) : (earIndex - 1);  	int over = (earIndex == vNum) ? 0 : (earIndex + 1);  	Triangle toAdd = new Triangle (xrem [earIndex]' yrem [earIndex]' xrem [over]' yrem [over]' xrem [under]' yrem [under]);  	buffer [bufferSize] = toAdd;  	++bufferSize;  	// - replace the old list with the new one  	xrem = newx;  	yrem = newy;  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,ResolvePinchPoint,The following statement contains a magic number: if (pin.Count < 3)  	return false;  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,AddTriangle,The following statement contains a magic number: for (int i = 0; i < vertices.Count; i++) {  	if (t.X [0] == vertices [i].X && t.Y [0] == vertices [i].Y) {  		if (firstP == -1) {  			firstP = i;  			firstT = 0;  		}  		else {  			secondP = i;  			secondT = 0;  		}  	}  	else if (t.X [1] == vertices [i].X && t.Y [1] == vertices [i].Y) {  		if (firstP == -1) {  			firstP = i;  			firstT = 1;  		}  		else {  			secondP = i;  			secondT = 1;  		}  	}  	else if (t.X [2] == vertices [i].X && t.Y [2] == vertices [i].Y) {  		if (firstP == -1) {  			firstP = i;  			firstT = 2;  		}  		else {  			secondP = i;  			secondT = 2;  		}  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,AddTriangle,The following statement contains a magic number: for (int i = 0; i < vertices.Count; i++) {  	if (t.X [0] == vertices [i].X && t.Y [0] == vertices [i].Y) {  		if (firstP == -1) {  			firstP = i;  			firstT = 0;  		}  		else {  			secondP = i;  			secondT = 0;  		}  	}  	else if (t.X [1] == vertices [i].X && t.Y [1] == vertices [i].Y) {  		if (firstP == -1) {  			firstP = i;  			firstT = 1;  		}  		else {  			secondP = i;  			secondT = 1;  		}  	}  	else if (t.X [2] == vertices [i].X && t.Y [2] == vertices [i].Y) {  		if (firstP == -1) {  			firstP = i;  			firstT = 2;  		}  		else {  			secondP = i;  			secondT = 2;  		}  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,AddTriangle,The following statement contains a magic number: for (int i = 0; i < vertices.Count; i++) {  	if (t.X [0] == vertices [i].X && t.Y [0] == vertices [i].Y) {  		if (firstP == -1) {  			firstP = i;  			firstT = 0;  		}  		else {  			secondP = i;  			secondT = 0;  		}  	}  	else if (t.X [1] == vertices [i].X && t.Y [1] == vertices [i].Y) {  		if (firstP == -1) {  			firstP = i;  			firstT = 1;  		}  		else {  			secondP = i;  			secondT = 1;  		}  	}  	else if (t.X [2] == vertices [i].X && t.Y [2] == vertices [i].Y) {  		if (firstP == -1) {  			firstP = i;  			firstT = 2;  		}  		else {  			secondP = i;  			secondT = 2;  		}  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,AddTriangle,The following statement contains a magic number: for (int i = 0; i < vertices.Count; i++) {  	if (t.X [0] == vertices [i].X && t.Y [0] == vertices [i].Y) {  		if (firstP == -1) {  			firstP = i;  			firstT = 0;  		}  		else {  			secondP = i;  			secondT = 0;  		}  	}  	else if (t.X [1] == vertices [i].X && t.Y [1] == vertices [i].Y) {  		if (firstP == -1) {  			firstP = i;  			firstT = 1;  		}  		else {  			secondP = i;  			secondT = 1;  		}  	}  	else if (t.X [2] == vertices [i].X && t.Y [2] == vertices [i].Y) {  		if (firstP == -1) {  			firstP = i;  			firstT = 2;  		}  		else {  			secondP = i;  			secondT = 2;  		}  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,AddTriangle,The following statement contains a magic number: if (t.X [0] == vertices [i].X && t.Y [0] == vertices [i].Y) {  	if (firstP == -1) {  		firstP = i;  		firstT = 0;  	}  	else {  		secondP = i;  		secondT = 0;  	}  }  else if (t.X [1] == vertices [i].X && t.Y [1] == vertices [i].Y) {  	if (firstP == -1) {  		firstP = i;  		firstT = 1;  	}  	else {  		secondP = i;  		secondT = 1;  	}  }  else if (t.X [2] == vertices [i].X && t.Y [2] == vertices [i].Y) {  	if (firstP == -1) {  		firstP = i;  		firstT = 2;  	}  	else {  		secondP = i;  		secondT = 2;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,AddTriangle,The following statement contains a magic number: if (t.X [0] == vertices [i].X && t.Y [0] == vertices [i].Y) {  	if (firstP == -1) {  		firstP = i;  		firstT = 0;  	}  	else {  		secondP = i;  		secondT = 0;  	}  }  else if (t.X [1] == vertices [i].X && t.Y [1] == vertices [i].Y) {  	if (firstP == -1) {  		firstP = i;  		firstT = 1;  	}  	else {  		secondP = i;  		secondT = 1;  	}  }  else if (t.X [2] == vertices [i].X && t.Y [2] == vertices [i].Y) {  	if (firstP == -1) {  		firstP = i;  		firstT = 2;  	}  	else {  		secondP = i;  		secondT = 2;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,AddTriangle,The following statement contains a magic number: if (t.X [0] == vertices [i].X && t.Y [0] == vertices [i].Y) {  	if (firstP == -1) {  		firstP = i;  		firstT = 0;  	}  	else {  		secondP = i;  		secondT = 0;  	}  }  else if (t.X [1] == vertices [i].X && t.Y [1] == vertices [i].Y) {  	if (firstP == -1) {  		firstP = i;  		firstT = 1;  	}  	else {  		secondP = i;  		secondT = 1;  	}  }  else if (t.X [2] == vertices [i].X && t.Y [2] == vertices [i].Y) {  	if (firstP == -1) {  		firstP = i;  		firstT = 2;  	}  	else {  		secondP = i;  		secondT = 2;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,AddTriangle,The following statement contains a magic number: if (t.X [0] == vertices [i].X && t.Y [0] == vertices [i].Y) {  	if (firstP == -1) {  		firstP = i;  		firstT = 0;  	}  	else {  		secondP = i;  		secondT = 0;  	}  }  else if (t.X [1] == vertices [i].X && t.Y [1] == vertices [i].Y) {  	if (firstP == -1) {  		firstP = i;  		firstT = 1;  	}  	else {  		secondP = i;  		secondT = 1;  	}  }  else if (t.X [2] == vertices [i].X && t.Y [2] == vertices [i].Y) {  	if (firstP == -1) {  		firstP = i;  		firstT = 2;  	}  	else {  		secondP = i;  		secondT = 2;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,AddTriangle,The following statement contains a magic number: if (t.X [1] == vertices [i].X && t.Y [1] == vertices [i].Y) {  	if (firstP == -1) {  		firstP = i;  		firstT = 1;  	}  	else {  		secondP = i;  		secondT = 1;  	}  }  else if (t.X [2] == vertices [i].X && t.Y [2] == vertices [i].Y) {  	if (firstP == -1) {  		firstP = i;  		firstT = 2;  	}  	else {  		secondP = i;  		secondT = 2;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,AddTriangle,The following statement contains a magic number: if (t.X [1] == vertices [i].X && t.Y [1] == vertices [i].Y) {  	if (firstP == -1) {  		firstP = i;  		firstT = 1;  	}  	else {  		secondP = i;  		secondT = 1;  	}  }  else if (t.X [2] == vertices [i].X && t.Y [2] == vertices [i].Y) {  	if (firstP == -1) {  		firstP = i;  		firstT = 2;  	}  	else {  		secondP = i;  		secondT = 2;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,AddTriangle,The following statement contains a magic number: if (t.X [1] == vertices [i].X && t.Y [1] == vertices [i].Y) {  	if (firstP == -1) {  		firstP = i;  		firstT = 1;  	}  	else {  		secondP = i;  		secondT = 1;  	}  }  else if (t.X [2] == vertices [i].X && t.Y [2] == vertices [i].Y) {  	if (firstP == -1) {  		firstP = i;  		firstT = 2;  	}  	else {  		secondP = i;  		secondT = 2;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,AddTriangle,The following statement contains a magic number: if (t.X [1] == vertices [i].X && t.Y [1] == vertices [i].Y) {  	if (firstP == -1) {  		firstP = i;  		firstT = 1;  	}  	else {  		secondP = i;  		secondT = 1;  	}  }  else if (t.X [2] == vertices [i].X && t.Y [2] == vertices [i].Y) {  	if (firstP == -1) {  		firstP = i;  		firstT = 2;  	}  	else {  		secondP = i;  		secondT = 2;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,AddTriangle,The following statement contains a magic number: if (t.X [2] == vertices [i].X && t.Y [2] == vertices [i].Y) {  	if (firstP == -1) {  		firstP = i;  		firstT = 2;  	}  	else {  		secondP = i;  		secondT = 2;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,AddTriangle,The following statement contains a magic number: if (t.X [2] == vertices [i].X && t.Y [2] == vertices [i].Y) {  	if (firstP == -1) {  		firstP = i;  		firstT = 2;  	}  	else {  		secondP = i;  		secondT = 2;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,AddTriangle,The following statement contains a magic number: if (t.X [2] == vertices [i].X && t.Y [2] == vertices [i].Y) {  	if (firstP == -1) {  		firstP = i;  		firstT = 2;  	}  	else {  		secondP = i;  		secondT = 2;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,AddTriangle,The following statement contains a magic number: if (t.X [2] == vertices [i].X && t.Y [2] == vertices [i].Y) {  	if (firstP == -1) {  		firstP = i;  		firstT = 2;  	}  	else {  		secondP = i;  		secondT = 2;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,AddTriangle,The following statement contains a magic number: if (firstP == -1) {  	firstP = i;  	firstT = 2;  }  else {  	secondP = i;  	secondT = 2;  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,AddTriangle,The following statement contains a magic number: if (firstP == -1) {  	firstP = i;  	firstT = 2;  }  else {  	secondP = i;  	secondT = 2;  }  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,AddTriangle,The following statement contains a magic number: firstT = 2;  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,AddTriangle,The following statement contains a magic number: secondT = 2;  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,AddTriangle,The following statement contains a magic number: if (tipT == firstT || tipT == secondT)  	tipT = 2;  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,AddTriangle,The following statement contains a magic number: tipT = 2;  
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,IsEar,The following statement contains a magic number: if (i >= xvLength || i < 0 || xvLength < 3) {  	return false;  }  
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,Triangle,The following statement contains a magic number: X = new float[3];  
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,Triangle,The following statement contains a magic number: Y = new float[3];  
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,Triangle,The following statement contains a magic number: if (ccw) {  	X [0] = x1;  	X [1] = x2;  	X [2] = x3;  	Y [0] = y1;  	Y [1] = y2;  	Y [2] = y3;  }  else {  	X [0] = x1;  	X [1] = x3;  	X [2] = x2;  	Y [0] = y1;  	Y [1] = y3;  	Y [2] = y2;  }  
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,Triangle,The following statement contains a magic number: if (ccw) {  	X [0] = x1;  	X [1] = x2;  	X [2] = x3;  	Y [0] = y1;  	Y [1] = y2;  	Y [2] = y3;  }  else {  	X [0] = x1;  	X [1] = x3;  	X [2] = x2;  	Y [0] = y1;  	Y [1] = y3;  	Y [2] = y2;  }  
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,Triangle,The following statement contains a magic number: if (ccw) {  	X [0] = x1;  	X [1] = x2;  	X [2] = x3;  	Y [0] = y1;  	Y [1] = y2;  	Y [2] = y3;  }  else {  	X [0] = x1;  	X [1] = x3;  	X [2] = x2;  	Y [0] = y1;  	Y [1] = y3;  	Y [2] = y2;  }  
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,Triangle,The following statement contains a magic number: if (ccw) {  	X [0] = x1;  	X [1] = x2;  	X [2] = x3;  	Y [0] = y1;  	Y [1] = y2;  	Y [2] = y3;  }  else {  	X [0] = x1;  	X [1] = x3;  	X [2] = x2;  	Y [0] = y1;  	Y [1] = y3;  	Y [2] = y2;  }  
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,Triangle,The following statement contains a magic number: X [2] = x3;  
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,Triangle,The following statement contains a magic number: Y [2] = y3;  
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,Triangle,The following statement contains a magic number: X [2] = x2;  
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,Triangle,The following statement contains a magic number: Y [2] = y2;  
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,Triangle,The following statement contains a magic number: X = new float[3];  
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,Triangle,The following statement contains a magic number: Y = new float[3];  
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,Triangle,The following statement contains a magic number: X [2] = t.X [2];  
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,Triangle,The following statement contains a magic number: X [2] = t.X [2];  
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,Triangle,The following statement contains a magic number: Y [2] = t.Y [2];  
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,Triangle,The following statement contains a magic number: Y [2] = t.Y [2];  
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,IsInside,The following statement contains a magic number: if (x < X [0] && x < X [1] && x < X [2])  	return false;  
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,IsInside,The following statement contains a magic number: if (x > X [0] && x > X [1] && x > X [2])  	return false;  
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,IsInside,The following statement contains a magic number: if (y < Y [0] && y < Y [1] && y < Y [2])  	return false;  
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\EarclipDecomposer.cs,IsInside,The following statement contains a magic number: if (y > Y [0] && y > Y [1] && y > Y [2])  	return false;  
Magic Number,FarseerPhysics.Common.Decomposition,FlipcodeDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\FlipcodeDecomposer.cs,ConvexPartition,The following statement contains a magic number: if (n < 3)  	return new List<Vertices> ();  
Magic Number,FarseerPhysics.Common.Decomposition,FlipcodeDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\FlipcodeDecomposer.cs,ConvexPartition,The following statement contains a magic number: for (int v = nv - 1; nv > 2;) {  	// If we loop' it is probably a non-simple polygon   	if (0 >= (count--)) {  		// Triangulate: ERROR - probable bad polygon!  		return new List<Vertices> ();  	}  	// Three consecutive vertices in current polygon' <u'v'w>  	int u = v;  	if (nv <= u)  		u = 0;  	// Previous   	v = u + 1;  	if (nv <= v)  		v = 0;  	// New v     	int w = v + 1;  	if (nv <= w)  		w = 0;  	// Next   	_tmpA = contour [V [u]];  	_tmpB = contour [V [v]];  	_tmpC = contour [V [w]];  	if (Snip (contour' u' v' w' nv' V)) {  		int s' t;  		// Output Triangle  		Vertices triangle = new Vertices (3);  		triangle.Add (_tmpA);  		triangle.Add (_tmpB);  		triangle.Add (_tmpC);  		result.Add (triangle);  		// Remove v from remaining polygon   		for (s = v' t = v + 1; t < nv; s++' t++) {  			V [s] = V [t];  		}  		nv--;  		// Reset error detection counter  		count = 2 * nv;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,FlipcodeDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\FlipcodeDecomposer.cs,ConvexPartition,The following statement contains a magic number: for (int v = nv - 1; nv > 2;) {  	// If we loop' it is probably a non-simple polygon   	if (0 >= (count--)) {  		// Triangulate: ERROR - probable bad polygon!  		return new List<Vertices> ();  	}  	// Three consecutive vertices in current polygon' <u'v'w>  	int u = v;  	if (nv <= u)  		u = 0;  	// Previous   	v = u + 1;  	if (nv <= v)  		v = 0;  	// New v     	int w = v + 1;  	if (nv <= w)  		w = 0;  	// Next   	_tmpA = contour [V [u]];  	_tmpB = contour [V [v]];  	_tmpC = contour [V [w]];  	if (Snip (contour' u' v' w' nv' V)) {  		int s' t;  		// Output Triangle  		Vertices triangle = new Vertices (3);  		triangle.Add (_tmpA);  		triangle.Add (_tmpB);  		triangle.Add (_tmpC);  		result.Add (triangle);  		// Remove v from remaining polygon   		for (s = v' t = v + 1; t < nv; s++' t++) {  			V [s] = V [t];  		}  		nv--;  		// Reset error detection counter  		count = 2 * nv;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,FlipcodeDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\FlipcodeDecomposer.cs,ConvexPartition,The following statement contains a magic number: for (int v = nv - 1; nv > 2;) {  	// If we loop' it is probably a non-simple polygon   	if (0 >= (count--)) {  		// Triangulate: ERROR - probable bad polygon!  		return new List<Vertices> ();  	}  	// Three consecutive vertices in current polygon' <u'v'w>  	int u = v;  	if (nv <= u)  		u = 0;  	// Previous   	v = u + 1;  	if (nv <= v)  		v = 0;  	// New v     	int w = v + 1;  	if (nv <= w)  		w = 0;  	// Next   	_tmpA = contour [V [u]];  	_tmpB = contour [V [v]];  	_tmpC = contour [V [w]];  	if (Snip (contour' u' v' w' nv' V)) {  		int s' t;  		// Output Triangle  		Vertices triangle = new Vertices (3);  		triangle.Add (_tmpA);  		triangle.Add (_tmpB);  		triangle.Add (_tmpC);  		result.Add (triangle);  		// Remove v from remaining polygon   		for (s = v' t = v + 1; t < nv; s++' t++) {  			V [s] = V [t];  		}  		nv--;  		// Reset error detection counter  		count = 2 * nv;  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,FlipcodeDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\FlipcodeDecomposer.cs,ConvexPartition,The following statement contains a magic number: if (Snip (contour' u' v' w' nv' V)) {  	int s' t;  	// Output Triangle  	Vertices triangle = new Vertices (3);  	triangle.Add (_tmpA);  	triangle.Add (_tmpB);  	triangle.Add (_tmpC);  	result.Add (triangle);  	// Remove v from remaining polygon   	for (s = v' t = v + 1; t < nv; s++' t++) {  		V [s] = V [t];  	}  	nv--;  	// Reset error detection counter  	count = 2 * nv;  }  
Magic Number,FarseerPhysics.Common.Decomposition,FlipcodeDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\FlipcodeDecomposer.cs,ConvexPartition,The following statement contains a magic number: if (Snip (contour' u' v' w' nv' V)) {  	int s' t;  	// Output Triangle  	Vertices triangle = new Vertices (3);  	triangle.Add (_tmpA);  	triangle.Add (_tmpB);  	triangle.Add (_tmpC);  	result.Add (triangle);  	// Remove v from remaining polygon   	for (s = v' t = v + 1; t < nv; s++' t++) {  		V [s] = V [t];  	}  	nv--;  	// Reset error detection counter  	count = 2 * nv;  }  
Magic Number,FarseerPhysics.Common.Decomposition,FlipcodeDecomposer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\FlipcodeDecomposer.cs,ConvexPartition,The following statement contains a magic number: count = 2 * nv;  
Magic Number,FarseerPhysics.Common.Decomposition,MonotoneMountain,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\SeidelDecomposer.cs,Add,The following statement contains a magic number: if (_size == 0) {  	_head = point;  	_size = 1;  }  else if (_size == 1) {  	// Keep repeat points out of the list  	_tail = point;  	_tail.Prev = _head;  	_head.Next = _tail;  	_size = 2;  }  else {  	// Keep repeat points out of the list  	_tail.Next = point;  	point.Prev = _tail;  	_tail = point;  	_size += 1;  }  
Magic Number,FarseerPhysics.Common.Decomposition,MonotoneMountain,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\SeidelDecomposer.cs,Add,The following statement contains a magic number: if (_size == 1) {  	// Keep repeat points out of the list  	_tail = point;  	_tail.Prev = _head;  	_head.Next = _tail;  	_size = 2;  }  else {  	// Keep repeat points out of the list  	_tail.Next = point;  	point.Prev = _tail;  	_tail = point;  	_size += 1;  }  
Magic Number,FarseerPhysics.Common.Decomposition,MonotoneMountain,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\SeidelDecomposer.cs,Add,The following statement contains a magic number: _size = 2;  
Magic Number,FarseerPhysics.Common.Decomposition,MonotoneMountain,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\SeidelDecomposer.cs,Triangulate,The following statement contains a magic number: while (_convexPoints.Count != 0) {  	IEnumerator<Point> e = _convexPoints.GetEnumerator ();  	e.MoveNext ();  	Point ear = e.Current;  	_convexPoints.Remove (ear);  	Point a = ear.Prev;  	Point b = ear;  	Point c = ear.Next;  	List<Point> triangle = new List<Point> (3);  	triangle.Add (a);  	triangle.Add (b);  	triangle.Add (c);  	Triangles.Add (triangle);  	// Remove ear' update angles and convex list  	Remove (ear);  	if (Valid (a))  		_convexPoints.Add (a);  	if (Valid (c))  		_convexPoints.Add (c);  }  
Magic Number,FarseerPhysics.Common.Decomposition,MonotoneMountain,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\SeidelDecomposer.cs,Triangulate,The following statement contains a magic number: Debug.Assert (_size <= 3' "Triangulation bug' please report");  
Magic Number,FarseerPhysics.Common.Decomposition,TrapezoidalMap,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\SeidelDecomposer.cs,Case1,The following statement contains a magic number: trapezoids [2] = new Trapezoid (e.P' e.Q' e' t.Bottom);  
Magic Number,FarseerPhysics.Common.Decomposition,TrapezoidalMap,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\SeidelDecomposer.cs,Case1,The following statement contains a magic number: trapezoids [3] = new Trapezoid (e.Q' t.RightPoint' t.Top' t.Bottom);  
Magic Number,FarseerPhysics.Common.Decomposition,TrapezoidalMap,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\SeidelDecomposer.cs,Case1,The following statement contains a magic number: trapezoids [1].UpdateLeftRight (trapezoids [0]' null' trapezoids [3]' null);  
Magic Number,FarseerPhysics.Common.Decomposition,TrapezoidalMap,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\SeidelDecomposer.cs,Case1,The following statement contains a magic number: trapezoids [2].UpdateLeftRight (null' trapezoids [0]' null' trapezoids [3]);  
Magic Number,FarseerPhysics.Common.Decomposition,TrapezoidalMap,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\SeidelDecomposer.cs,Case1,The following statement contains a magic number: trapezoids [2].UpdateLeftRight (null' trapezoids [0]' null' trapezoids [3]);  
Magic Number,FarseerPhysics.Common.Decomposition,TrapezoidalMap,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\SeidelDecomposer.cs,Case1,The following statement contains a magic number: trapezoids [3].UpdateRight (t.UpperRight' t.LowerRight);  
Magic Number,FarseerPhysics.Common.Decomposition,TrapezoidalMap,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\SeidelDecomposer.cs,Case2,The following statement contains a magic number: trapezoids [2] = new Trapezoid (e.P' rp' e' t.Bottom);  
Magic Number,FarseerPhysics.Common.Decomposition,TrapezoidalMap,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\SeidelDecomposer.cs,Case2,The following statement contains a magic number: trapezoids [2].UpdateLeftRight (null' trapezoids [0]' null' t.LowerRight);  
Magic Number,FarseerPhysics.Common.Decomposition,TrapezoidalMap,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\SeidelDecomposer.cs,Case2,The following statement contains a magic number: e.Below = trapezoids [2];  
Magic Number,FarseerPhysics.Common.Decomposition,TrapezoidalMap,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\SeidelDecomposer.cs,Case4,The following statement contains a magic number: trapezoids [2] = new Trapezoid (e.Q' t.RightPoint' t.Top' t.Bottom);  
Magic Number,FarseerPhysics.Common.Decomposition,TrapezoidalMap,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\SeidelDecomposer.cs,Case4,The following statement contains a magic number: trapezoids [2].UpdateLeftRight (trapezoids [0]' trapezoids [1]' t.UpperRight' t.LowerRight);  
Magic Number,FarseerPhysics.Common.Decomposition,Triangulator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\SeidelDecomposer.cs,CreateMountains,The following statement contains a magic number: foreach (Edge edge in _edgeList) {  	if (edge.MPoints.Count > 2) {  		MonotoneMountain mountain = new MonotoneMountain ();  		// Sorting is a perfromance hit. Literature says this can be accomplised in  		// linear time' although I don't see a way around using traditional methods  		// when using a randomized incremental algorithm  		// Insertion sort is one of the fastest algorithms for sorting arrays containing   		// fewer than ten elements' or for lists that are already mostly sorted.  		List<Point> points = new List<Point> (edge.MPoints);  		points.Sort ((p1' p2) => p1.X.CompareTo (p2.X));  		foreach (Point p in points)  			mountain.Add (p);  		// Triangulate monotone mountain  		mountain.Process ();  		// Extract the triangles into a single list  		foreach (List<Point> t in mountain.Triangles) {  			Triangles.Add (t);  		}  		_xMonoPoly.Add (mountain);  	}  }  
Magic Number,FarseerPhysics.Common.Decomposition,Triangulator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\SeidelDecomposer.cs,CreateMountains,The following statement contains a magic number: if (edge.MPoints.Count > 2) {  	MonotoneMountain mountain = new MonotoneMountain ();  	// Sorting is a perfromance hit. Literature says this can be accomplised in  	// linear time' although I don't see a way around using traditional methods  	// when using a randomized incremental algorithm  	// Insertion sort is one of the fastest algorithms for sorting arrays containing   	// fewer than ten elements' or for lists that are already mostly sorted.  	List<Point> points = new List<Point> (edge.MPoints);  	points.Sort ((p1' p2) => p1.X.CompareTo (p2.X));  	foreach (Point p in points)  		mountain.Add (p);  	// Triangulate monotone mountain  	mountain.Process ();  	// Extract the triangles into a single list  	foreach (List<Point> t in mountain.Triangles) {  		Triangles.Add (t);  	}  	_xMonoPoly.Add (mountain);  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,DelaunayTriangle,The following statement contains a magic number: Points [2] = p3;  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,IndexCW,The following statement contains a magic number: switch (index) {  case 0:  	return 2;  case 1:  	return 0;  default:  	return 1;  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,IndexCW,The following statement contains a magic number: return 2;  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,IndexCCW,The following statement contains a magic number: switch (index) {  case 0:  	return 1;  case 1:  	return 2;  default:  	return 0;  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,IndexCCW,The following statement contains a magic number: return 2;  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,Contains,The following statement contains a magic number: return (p == Points [0] || p == Points [1] || p == Points [2]);  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if ((p1 == Points [2] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [2])) {  	Neighbors [0] = t;  }  else if ((p1 == Points [0] && p2 == Points [2]) || (p1 == Points [2] && p2 == Points [0])) {  	Neighbors [1] = t;  }  else if ((p1 == Points [0] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [0])) {  	Neighbors [2] = t;  }  else {  	Debug.WriteLine ("Neighbor error' please report!");  	// throw new Exception("Neighbor error' please report!");  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if ((p1 == Points [2] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [2])) {  	Neighbors [0] = t;  }  else if ((p1 == Points [0] && p2 == Points [2]) || (p1 == Points [2] && p2 == Points [0])) {  	Neighbors [1] = t;  }  else if ((p1 == Points [0] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [0])) {  	Neighbors [2] = t;  }  else {  	Debug.WriteLine ("Neighbor error' please report!");  	// throw new Exception("Neighbor error' please report!");  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if ((p1 == Points [2] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [2])) {  	Neighbors [0] = t;  }  else if ((p1 == Points [0] && p2 == Points [2]) || (p1 == Points [2] && p2 == Points [0])) {  	Neighbors [1] = t;  }  else if ((p1 == Points [0] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [0])) {  	Neighbors [2] = t;  }  else {  	Debug.WriteLine ("Neighbor error' please report!");  	// throw new Exception("Neighbor error' please report!");  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if ((p1 == Points [2] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [2])) {  	Neighbors [0] = t;  }  else if ((p1 == Points [0] && p2 == Points [2]) || (p1 == Points [2] && p2 == Points [0])) {  	Neighbors [1] = t;  }  else if ((p1 == Points [0] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [0])) {  	Neighbors [2] = t;  }  else {  	Debug.WriteLine ("Neighbor error' please report!");  	// throw new Exception("Neighbor error' please report!");  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if ((p1 == Points [2] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [2])) {  	Neighbors [0] = t;  }  else if ((p1 == Points [0] && p2 == Points [2]) || (p1 == Points [2] && p2 == Points [0])) {  	Neighbors [1] = t;  }  else if ((p1 == Points [0] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [0])) {  	Neighbors [2] = t;  }  else {  	Debug.WriteLine ("Neighbor error' please report!");  	// throw new Exception("Neighbor error' please report!");  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if ((p1 == Points [0] && p2 == Points [2]) || (p1 == Points [2] && p2 == Points [0])) {  	Neighbors [1] = t;  }  else if ((p1 == Points [0] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [0])) {  	Neighbors [2] = t;  }  else {  	Debug.WriteLine ("Neighbor error' please report!");  	// throw new Exception("Neighbor error' please report!");  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if ((p1 == Points [0] && p2 == Points [2]) || (p1 == Points [2] && p2 == Points [0])) {  	Neighbors [1] = t;  }  else if ((p1 == Points [0] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [0])) {  	Neighbors [2] = t;  }  else {  	Debug.WriteLine ("Neighbor error' please report!");  	// throw new Exception("Neighbor error' please report!");  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if ((p1 == Points [0] && p2 == Points [2]) || (p1 == Points [2] && p2 == Points [0])) {  	Neighbors [1] = t;  }  else if ((p1 == Points [0] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [0])) {  	Neighbors [2] = t;  }  else {  	Debug.WriteLine ("Neighbor error' please report!");  	// throw new Exception("Neighbor error' please report!");  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if ((p1 == Points [0] && p2 == Points [1]) || (p1 == Points [1] && p2 == Points [0])) {  	Neighbors [2] = t;  }  else {  	Debug.WriteLine ("Neighbor error' please report!");  	// throw new Exception("Neighbor error' please report!");  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: Neighbors [2] = t;  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if (t.Contains (Points [1]' Points [2])) {  	Neighbors [0] = t;  	t.MarkNeighbor (Points [1]' Points [2]' this);  }  else if (t.Contains (Points [0]' Points [2])) {  	Neighbors [1] = t;  	t.MarkNeighbor (Points [0]' Points [2]' this);  }  else if (t.Contains (Points [0]' Points [1])) {  	Neighbors [2] = t;  	t.MarkNeighbor (Points [0]' Points [1]' this);  }  else {  	Debug.WriteLine ("markNeighbor failed");  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if (t.Contains (Points [1]' Points [2])) {  	Neighbors [0] = t;  	t.MarkNeighbor (Points [1]' Points [2]' this);  }  else if (t.Contains (Points [0]' Points [2])) {  	Neighbors [1] = t;  	t.MarkNeighbor (Points [0]' Points [2]' this);  }  else if (t.Contains (Points [0]' Points [1])) {  	Neighbors [2] = t;  	t.MarkNeighbor (Points [0]' Points [1]' this);  }  else {  	Debug.WriteLine ("markNeighbor failed");  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if (t.Contains (Points [1]' Points [2])) {  	Neighbors [0] = t;  	t.MarkNeighbor (Points [1]' Points [2]' this);  }  else if (t.Contains (Points [0]' Points [2])) {  	Neighbors [1] = t;  	t.MarkNeighbor (Points [0]' Points [2]' this);  }  else if (t.Contains (Points [0]' Points [1])) {  	Neighbors [2] = t;  	t.MarkNeighbor (Points [0]' Points [1]' this);  }  else {  	Debug.WriteLine ("markNeighbor failed");  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if (t.Contains (Points [1]' Points [2])) {  	Neighbors [0] = t;  	t.MarkNeighbor (Points [1]' Points [2]' this);  }  else if (t.Contains (Points [0]' Points [2])) {  	Neighbors [1] = t;  	t.MarkNeighbor (Points [0]' Points [2]' this);  }  else if (t.Contains (Points [0]' Points [1])) {  	Neighbors [2] = t;  	t.MarkNeighbor (Points [0]' Points [1]' this);  }  else {  	Debug.WriteLine ("markNeighbor failed");  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if (t.Contains (Points [1]' Points [2])) {  	Neighbors [0] = t;  	t.MarkNeighbor (Points [1]' Points [2]' this);  }  else if (t.Contains (Points [0]' Points [2])) {  	Neighbors [1] = t;  	t.MarkNeighbor (Points [0]' Points [2]' this);  }  else if (t.Contains (Points [0]' Points [1])) {  	Neighbors [2] = t;  	t.MarkNeighbor (Points [0]' Points [1]' this);  }  else {  	Debug.WriteLine ("markNeighbor failed");  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: t.MarkNeighbor (Points [1]' Points [2]' this);  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if (t.Contains (Points [0]' Points [2])) {  	Neighbors [1] = t;  	t.MarkNeighbor (Points [0]' Points [2]' this);  }  else if (t.Contains (Points [0]' Points [1])) {  	Neighbors [2] = t;  	t.MarkNeighbor (Points [0]' Points [1]' this);  }  else {  	Debug.WriteLine ("markNeighbor failed");  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if (t.Contains (Points [0]' Points [2])) {  	Neighbors [1] = t;  	t.MarkNeighbor (Points [0]' Points [2]' this);  }  else if (t.Contains (Points [0]' Points [1])) {  	Neighbors [2] = t;  	t.MarkNeighbor (Points [0]' Points [1]' this);  }  else {  	Debug.WriteLine ("markNeighbor failed");  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if (t.Contains (Points [0]' Points [2])) {  	Neighbors [1] = t;  	t.MarkNeighbor (Points [0]' Points [2]' this);  }  else if (t.Contains (Points [0]' Points [1])) {  	Neighbors [2] = t;  	t.MarkNeighbor (Points [0]' Points [1]' this);  }  else {  	Debug.WriteLine ("markNeighbor failed");  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: t.MarkNeighbor (Points [0]' Points [2]' this);  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if (t.Contains (Points [0]' Points [1])) {  	Neighbors [2] = t;  	t.MarkNeighbor (Points [0]' Points [1]' this);  }  else {  	Debug.WriteLine ("markNeighbor failed");  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: Neighbors [2] = t;  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,ClearNeighbors,The following statement contains a magic number: Neighbors [0] = Neighbors [1] = Neighbors [2] = null;  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,ClearNeighbor,The following statement contains a magic number: if (Neighbors [0] == triangle) {  	Neighbors [0] = null;  }  else if (Neighbors [1] == triangle) {  	Neighbors [1] = null;  }  else {  	Neighbors [2] = null;  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,ClearNeighbor,The following statement contains a magic number: if (Neighbors [1] == triangle) {  	Neighbors [1] = null;  }  else {  	Neighbors [2] = null;  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,ClearNeighbor,The following statement contains a magic number: Neighbors [2] = null;  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,Clear,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	t = Neighbors [i];  	if (t != null) {  		t.ClearNeighbor (this);  	}  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,Clear,The following statement contains a magic number: Points [0] = Points [1] = Points [2] = null;  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,NeighborCW,The following statement contains a magic number: return Neighbors [(Points.IndexOf (point) + 1) % 3];  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,NeighborCCW,The following statement contains a magic number: return Neighbors [(Points.IndexOf (point) + 2) % 3];  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,NeighborCCW,The following statement contains a magic number: return Neighbors [(Points.IndexOf (point) + 2) % 3];  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,PointCCW,The following statement contains a magic number: return Points [(IndexOf (point) + 1) % 3];  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,PointCW,The following statement contains a magic number: return Points [(IndexOf (point) + 2) % 3];  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,PointCW,The following statement contains a magic number: return Points [(IndexOf (point) + 2) % 3];  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,RotateCW,The following statement contains a magic number: Points [2] = Points [1];  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,ToString,The following statement contains a magic number: return Points [0] + "'" + Points [1] + "'" + Points [2];  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighborEdges,The following statement contains a magic number: for (int i = 0; i < 3; i++)  	if (EdgeIsConstrained [i] && Neighbors [i] != null) {  		Neighbors [i].MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  	}  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighborEdges,The following statement contains a magic number: for (int i = 0; i < 3; i++)  	if (EdgeIsConstrained [i] && Neighbors [i] != null) {  		Neighbors [i].MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  	}  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighborEdges,The following statement contains a magic number: for (int i = 0; i < 3; i++)  	if (EdgeIsConstrained [i] && Neighbors [i] != null) {  		Neighbors [i].MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  	}  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighborEdges,The following statement contains a magic number: for (int i = 0; i < 3; i++)  	if (EdgeIsConstrained [i] && Neighbors [i] != null) {  		Neighbors [i].MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  	}  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighborEdges,The following statement contains a magic number: if (EdgeIsConstrained [i] && Neighbors [i] != null) {  	Neighbors [i].MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighborEdges,The following statement contains a magic number: if (EdgeIsConstrained [i] && Neighbors [i] != null) {  	Neighbors [i].MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighborEdges,The following statement contains a magic number: if (EdgeIsConstrained [i] && Neighbors [i] != null) {  	Neighbors [i].MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighborEdges,The following statement contains a magic number: Neighbors [i].MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighborEdges,The following statement contains a magic number: Neighbors [i].MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighborEdges,The following statement contains a magic number: Neighbors [i].MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: for (int i = 0; i < 3; i++)  	if (EdgeIsConstrained [i]) {  		triangle.MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  	}  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: for (int i = 0; i < 3; i++)  	if (EdgeIsConstrained [i]) {  		triangle.MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  	}  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: for (int i = 0; i < 3; i++)  	if (EdgeIsConstrained [i]) {  		triangle.MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  	}  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: for (int i = 0; i < 3; i++)  	if (EdgeIsConstrained [i]) {  		triangle.MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  	}  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: if (EdgeIsConstrained [i]) {  	triangle.MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: if (EdgeIsConstrained [i]) {  	triangle.MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: if (EdgeIsConstrained [i]) {  	triangle.MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: triangle.MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: triangle.MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: triangle.MarkConstrainedEdge (Points [(i + 1) % 3]' Points [(i + 2) % 3]);  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: foreach (DelaunayTriangle t in tList)  	for (int i = 0; i < 3; i++)  		if (t.EdgeIsConstrained [i]) {  			MarkConstrainedEdge (t.Points [(i + 1) % 3]' t.Points [(i + 2) % 3]);  		}  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: foreach (DelaunayTriangle t in tList)  	for (int i = 0; i < 3; i++)  		if (t.EdgeIsConstrained [i]) {  			MarkConstrainedEdge (t.Points [(i + 1) % 3]' t.Points [(i + 2) % 3]);  		}  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: foreach (DelaunayTriangle t in tList)  	for (int i = 0; i < 3; i++)  		if (t.EdgeIsConstrained [i]) {  			MarkConstrainedEdge (t.Points [(i + 1) % 3]' t.Points [(i + 2) % 3]);  		}  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: foreach (DelaunayTriangle t in tList)  	for (int i = 0; i < 3; i++)  		if (t.EdgeIsConstrained [i]) {  			MarkConstrainedEdge (t.Points [(i + 1) % 3]' t.Points [(i + 2) % 3]);  		}  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: for (int i = 0; i < 3; i++)  	if (t.EdgeIsConstrained [i]) {  		MarkConstrainedEdge (t.Points [(i + 1) % 3]' t.Points [(i + 2) % 3]);  	}  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: for (int i = 0; i < 3; i++)  	if (t.EdgeIsConstrained [i]) {  		MarkConstrainedEdge (t.Points [(i + 1) % 3]' t.Points [(i + 2) % 3]);  	}  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: for (int i = 0; i < 3; i++)  	if (t.EdgeIsConstrained [i]) {  		MarkConstrainedEdge (t.Points [(i + 1) % 3]' t.Points [(i + 2) % 3]);  	}  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: for (int i = 0; i < 3; i++)  	if (t.EdgeIsConstrained [i]) {  		MarkConstrainedEdge (t.Points [(i + 1) % 3]' t.Points [(i + 2) % 3]);  	}  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: if (t.EdgeIsConstrained [i]) {  	MarkConstrainedEdge (t.Points [(i + 1) % 3]' t.Points [(i + 2) % 3]);  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: if (t.EdgeIsConstrained [i]) {  	MarkConstrainedEdge (t.Points [(i + 1) % 3]' t.Points [(i + 2) % 3]);  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: if (t.EdgeIsConstrained [i]) {  	MarkConstrainedEdge (t.Points [(i + 1) % 3]' t.Points [(i + 2) % 3]);  }  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: MarkConstrainedEdge (t.Points [(i + 1) % 3]' t.Points [(i + 2) % 3]);  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: MarkConstrainedEdge (t.Points [(i + 1) % 3]' t.Points [(i + 2) % 3]);  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: MarkConstrainedEdge (t.Points [(i + 1) % 3]' t.Points [(i + 2) % 3]);  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,EdgeIndex,The following statement contains a magic number: if (a && b)  	return 2;  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,EdgeIndex,The following statement contains a magic number: return 2;  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,GetConstrainedEdgeCCW,The following statement contains a magic number: return EdgeIsConstrained [(IndexOf (p) + 2) % 3];  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,GetConstrainedEdgeCCW,The following statement contains a magic number: return EdgeIsConstrained [(IndexOf (p) + 2) % 3];  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,GetConstrainedEdgeCW,The following statement contains a magic number: return EdgeIsConstrained [(IndexOf (p) + 1) % 3];  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,SetConstrainedEdgeCCW,The following statement contains a magic number: EdgeIsConstrained [(IndexOf (p) + 2) % 3] = ce;  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,SetConstrainedEdgeCCW,The following statement contains a magic number: EdgeIsConstrained [(IndexOf (p) + 2) % 3] = ce;  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,SetConstrainedEdgeCW,The following statement contains a magic number: EdgeIsConstrained [(IndexOf (p) + 1) % 3] = ce;  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,GetDelaunayEdgeCCW,The following statement contains a magic number: return EdgeIsDelaunay [(IndexOf (p) + 2) % 3];  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,GetDelaunayEdgeCCW,The following statement contains a magic number: return EdgeIsDelaunay [(IndexOf (p) + 2) % 3];  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,GetDelaunayEdgeCW,The following statement contains a magic number: return EdgeIsDelaunay [(IndexOf (p) + 1) % 3];  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,SetDelaunayEdgeCCW,The following statement contains a magic number: EdgeIsDelaunay [(IndexOf (p) + 2) % 3] = ce;  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,SetDelaunayEdgeCCW,The following statement contains a magic number: EdgeIsDelaunay [(IndexOf (p) + 2) % 3] = ce;  
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,SetDelaunayEdgeCW,The following statement contains a magic number: EdgeIsDelaunay [(IndexOf (p) + 1) % 3] = ce;  
Magic Number,Poly2Tri.Triangulation.Delaunay.Sweep,DTSweep,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\Sweep\DTSweep.cs,Legalize,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	// TODO: fix so that cEdge is always valid when creating new triangles then we can check it here  	//       instead of below with ot  	if (t.EdgeIsDelaunay [i]) {  		continue;  	}  	ot = t.Neighbors [i];  	if (ot != null) {  		p = t.Points [i];  		op = ot.OppositePoint (t' p);  		oi = ot.IndexOf (op);  		// If this is a Constrained Edge or a Delaunay Edge(only during recursive legalization)  		// then we should not try to legalize  		if (ot.EdgeIsConstrained [oi] || ot.EdgeIsDelaunay [oi]) {  			t.EdgeIsConstrained [i] = ot.EdgeIsConstrained [oi];  			// XXX: have no good way of setting this property when creating new triangles so lets set it here  			continue;  		}  		inside = TriangulationUtil.SmartIncircle (p' t.PointCCW (p)' t.PointCW (p)' op);  		if (inside) {  			bool notLegalized;  			// Lets mark this shared edge as Delaunay   			t.EdgeIsDelaunay [i] = true;  			ot.EdgeIsDelaunay [oi] = true;  			// Lets rotate shared edge one vertex CW to legalize it  			RotateTrianglePair (t' p' ot' op);  			// We now got one valid Delaunay Edge shared by two triangles  			// This gives us 4 new edges to check for Delaunay  			// Make sure that triangle to node mapping is done only one time for a specific triangle  			notLegalized = !Legalize (tcx' t);  			if (notLegalized) {  				tcx.MapTriangleToNodes (t);  			}  			notLegalized = !Legalize (tcx' ot);  			if (notLegalized) {  				tcx.MapTriangleToNodes (ot);  			}  			// Reset the Delaunay edges' since they only are valid Delaunay edges  			// until we add a new triangle or point.  			// XXX: need to think about this. Can these edges be tried after we   			//      return to previous recursive level?  			t.EdgeIsDelaunay [i] = false;  			ot.EdgeIsDelaunay [oi] = false;  			// If triangle have been legalized no need to check the other edges since  			// the recursive legalization will handles those so we can end here.  			return true;  		}  	}  }  
Magic Number,Poly2Tri.Triangulation.Delaunay.Sweep,DTSweepContext,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\Sweep\DTSweepContext.cs,MeshCleanReq,The following statement contains a magic number: if (triangle != null && !triangle.IsInterior) {  	triangle.IsInterior = true;  	Triangulatable.AddTriangle (triangle);  	for (int i = 0; i < 3; i++) {  		if (!triangle.EdgeIsConstrained [i]) {  			MeshCleanReq (triangle.Neighbors [i]);  		}  	}  }  
Magic Number,Poly2Tri.Triangulation.Delaunay.Sweep,DTSweepContext,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\Sweep\DTSweepContext.cs,MeshCleanReq,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	if (!triangle.EdgeIsConstrained [i]) {  		MeshCleanReq (triangle.Neighbors [i]);  	}  }  
Magic Number,Poly2Tri.Triangulation.Delaunay.Sweep,DTSweepContext,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\Sweep\DTSweepContext.cs,CreateAdvancingFront,The following statement contains a magic number: tail = new AdvancingFrontNode (iTriangle.Points [2]);  
Magic Number,Poly2Tri.Triangulation.Delaunay.Sweep,DTSweepContext,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Delaunay\Sweep\DTSweepContext.cs,MapTriangleToNodes,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	if (t.Neighbors [i] == null) {  		n = aFront.LocatePoint (t.PointCW (t.Points [i]));  		if (n != null) {  			n.Triangle = t;  		}  	}  }  
Magic Number,Poly2Tri.Triangulation.Polygon,Polygon,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Polygon\Polygon.cs,Polygon,The following statement contains a magic number: if (points.Count < 3)  	throw new ArgumentException ("List has fewer than 3 points"' "points");  
Magic Number,Poly2Tri.Triangulation.Sets,ConstrainedPointSet,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Sets\ConstrainedPointSet.cs,PrepareTriangulation,The following statement contains a magic number: if (_constrainedPointList != null) {  	TriangulationPoint p1' p2;  	List<TriangulationPoint>.Enumerator iterator = _constrainedPointList.GetEnumerator ();  	while (iterator.MoveNext ()) {  		p1 = iterator.Current;  		iterator.MoveNext ();  		p2 = iterator.Current;  		tcx.NewConstraint (p1' p2);  	}  }  else {  	for (int i = 0; i < EdgeIndex.Length; i += 2) {  		// XXX: must change!!  		tcx.NewConstraint (Points [EdgeIndex [i]]' Points [EdgeIndex [i + 1]]);  	}  }  
Magic Number,Poly2Tri.Triangulation.Sets,ConstrainedPointSet,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Sets\ConstrainedPointSet.cs,PrepareTriangulation,The following statement contains a magic number: for (int i = 0; i < EdgeIndex.Length; i += 2) {  	// XXX: must change!!  	tcx.NewConstraint (Points [EdgeIndex [i]]' Points [EdgeIndex [i + 1]]);  }  
Magic Number,Poly2Tri.Triangulation.Sets,ConstrainedPointSet,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Sets\ConstrainedPointSet.cs,PrepareTriangulation,The following statement contains a magic number: i += 2
Magic Number,Poly2Tri.Triangulation.Util,FixedArray3,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\FixedArray3.cs,Contains,The following statement contains a magic number: for (int i = 0; i < 3; ++i)  	if (this [i] == value)  		return true;  
Magic Number,Poly2Tri.Triangulation.Util,FixedArray3,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\FixedArray3.cs,IndexOf,The following statement contains a magic number: for (int i = 0; i < 3; ++i)  	if (this [i] == value)  		return i;  
Magic Number,Poly2Tri.Triangulation.Util,FixedArray3,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\FixedArray3.cs,Clear,The following statement contains a magic number: for (int i = 0; i < 3; ++i)  	if (this [i] == value)  		this [i] = null;  
Magic Number,Poly2Tri.Triangulation.Util,FixedArray3,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\FixedArray3.cs,Enumerate,The following statement contains a magic number: for (int i = 0; i < 3; ++i)  	yield return this [i];  
Magic Number,Poly2Tri.Triangulation.Util,FixedBitArray3,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\FixedBitArray3.cs,Contains,The following statement contains a magic number: for (int i = 0; i < 3; ++i)  	if (this [i] == value)  		return true;  
Magic Number,Poly2Tri.Triangulation.Util,FixedBitArray3,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\FixedBitArray3.cs,IndexOf,The following statement contains a magic number: for (int i = 0; i < 3; ++i)  	if (this [i] == value)  		return i;  
Magic Number,Poly2Tri.Triangulation.Util,FixedBitArray3,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\FixedBitArray3.cs,Clear,The following statement contains a magic number: for (int i = 0; i < 3; ++i)  	if (this [i] == value)  		this [i] = false;  
Magic Number,Poly2Tri.Triangulation.Util,FixedBitArray3,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\FixedBitArray3.cs,Enumerate,The following statement contains a magic number: for (int i = 0; i < 3; ++i)  	yield return this [i];  
Magic Number,Poly2Tri.Triangulation.Util,PointGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PointGenerator.cs,UniformDistribution,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	points.Add (new TriangulationPoint (scale * (0.5 - RNG.NextDouble ())' scale * (0.5 - RNG.NextDouble ())));  }  
Magic Number,Poly2Tri.Triangulation.Util,PointGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PointGenerator.cs,UniformDistribution,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	points.Add (new TriangulationPoint (scale * (0.5 - RNG.NextDouble ())' scale * (0.5 - RNG.NextDouble ())));  }  
Magic Number,Poly2Tri.Triangulation.Util,PointGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PointGenerator.cs,UniformDistribution,The following statement contains a magic number: points.Add (new TriangulationPoint (scale * (0.5 - RNG.NextDouble ())' scale * (0.5 - RNG.NextDouble ())));  
Magic Number,Poly2Tri.Triangulation.Util,PointGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PointGenerator.cs,UniformDistribution,The following statement contains a magic number: points.Add (new TriangulationPoint (scale * (0.5 - RNG.NextDouble ())' scale * (0.5 - RNG.NextDouble ())));  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		if (i % 250 == 0) {  			radius += scale / 2 * (0.5 - RNG.NextDouble ());  		}  		else if (i % 50 == 0) {  			radius += scale / 5 * (0.5 - RNG.NextDouble ());  		}  		else {  			radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  		}  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		if (i % 250 == 0) {  			radius += scale / 2 * (0.5 - RNG.NextDouble ());  		}  		else if (i % 50 == 0) {  			radius += scale / 5 * (0.5 - RNG.NextDouble ());  		}  		else {  			radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  		}  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		if (i % 250 == 0) {  			radius += scale / 2 * (0.5 - RNG.NextDouble ());  		}  		else if (i % 50 == 0) {  			radius += scale / 5 * (0.5 - RNG.NextDouble ());  		}  		else {  			radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  		}  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		if (i % 250 == 0) {  			radius += scale / 2 * (0.5 - RNG.NextDouble ());  		}  		else if (i % 50 == 0) {  			radius += scale / 5 * (0.5 - RNG.NextDouble ());  		}  		else {  			radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  		}  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		if (i % 250 == 0) {  			radius += scale / 2 * (0.5 - RNG.NextDouble ());  		}  		else if (i % 50 == 0) {  			radius += scale / 5 * (0.5 - RNG.NextDouble ());  		}  		else {  			radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  		}  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		if (i % 250 == 0) {  			radius += scale / 2 * (0.5 - RNG.NextDouble ());  		}  		else if (i % 50 == 0) {  			radius += scale / 5 * (0.5 - RNG.NextDouble ());  		}  		else {  			radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  		}  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		if (i % 250 == 0) {  			radius += scale / 2 * (0.5 - RNG.NextDouble ());  		}  		else if (i % 50 == 0) {  			radius += scale / 5 * (0.5 - RNG.NextDouble ());  		}  		else {  			radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  		}  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		if (i % 250 == 0) {  			radius += scale / 2 * (0.5 - RNG.NextDouble ());  		}  		else if (i % 50 == 0) {  			radius += scale / 5 * (0.5 - RNG.NextDouble ());  		}  		else {  			radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  		}  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		if (i % 250 == 0) {  			radius += scale / 2 * (0.5 - RNG.NextDouble ());  		}  		else if (i % 50 == 0) {  			radius += scale / 5 * (0.5 - RNG.NextDouble ());  		}  		else {  			radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  		}  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		if (i % 250 == 0) {  			radius += scale / 2 * (0.5 - RNG.NextDouble ());  		}  		else if (i % 50 == 0) {  			radius += scale / 5 * (0.5 - RNG.NextDouble ());  		}  		else {  			radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  		}  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		if (i % 250 == 0) {  			radius += scale / 2 * (0.5 - RNG.NextDouble ());  		}  		else if (i % 50 == 0) {  			radius += scale / 5 * (0.5 - RNG.NextDouble ());  		}  		else {  			radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  		}  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		if (i % 250 == 0) {  			radius += scale / 2 * (0.5 - RNG.NextDouble ());  		}  		else if (i % 50 == 0) {  			radius += scale / 5 * (0.5 - RNG.NextDouble ());  		}  		else {  			radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  		}  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		if (i % 250 == 0) {  			radius += scale / 2 * (0.5 - RNG.NextDouble ());  		}  		else if (i % 50 == 0) {  			radius += scale / 5 * (0.5 - RNG.NextDouble ());  		}  		else {  			radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  		}  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		if (i % 250 == 0) {  			radius += scale / 2 * (0.5 - RNG.NextDouble ());  		}  		else if (i % 50 == 0) {  			radius += scale / 5 * (0.5 - RNG.NextDouble ());  		}  		else {  			radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  		}  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: do {  	if (i % 250 == 0) {  		radius += scale / 2 * (0.5 - RNG.NextDouble ());  	}  	else if (i % 50 == 0) {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  	}  	else {  		radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  	}  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: do {  	if (i % 250 == 0) {  		radius += scale / 2 * (0.5 - RNG.NextDouble ());  	}  	else if (i % 50 == 0) {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  	}  	else {  		radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  	}  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: do {  	if (i % 250 == 0) {  		radius += scale / 2 * (0.5 - RNG.NextDouble ());  	}  	else if (i % 50 == 0) {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  	}  	else {  		radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  	}  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: do {  	if (i % 250 == 0) {  		radius += scale / 2 * (0.5 - RNG.NextDouble ());  	}  	else if (i % 50 == 0) {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  	}  	else {  		radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  	}  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: do {  	if (i % 250 == 0) {  		radius += scale / 2 * (0.5 - RNG.NextDouble ());  	}  	else if (i % 50 == 0) {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  	}  	else {  		radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  	}  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: do {  	if (i % 250 == 0) {  		radius += scale / 2 * (0.5 - RNG.NextDouble ());  	}  	else if (i % 50 == 0) {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  	}  	else {  		radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  	}  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: do {  	if (i % 250 == 0) {  		radius += scale / 2 * (0.5 - RNG.NextDouble ());  	}  	else if (i % 50 == 0) {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  	}  	else {  		radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  	}  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: do {  	if (i % 250 == 0) {  		radius += scale / 2 * (0.5 - RNG.NextDouble ());  	}  	else if (i % 50 == 0) {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  	}  	else {  		radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  	}  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: do {  	if (i % 250 == 0) {  		radius += scale / 2 * (0.5 - RNG.NextDouble ());  	}  	else if (i % 50 == 0) {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  	}  	else {  		radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  	}  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: do {  	if (i % 250 == 0) {  		radius += scale / 2 * (0.5 - RNG.NextDouble ());  	}  	else if (i % 50 == 0) {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  	}  	else {  		radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  	}  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: do {  	if (i % 250 == 0) {  		radius += scale / 2 * (0.5 - RNG.NextDouble ());  	}  	else if (i % 50 == 0) {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  	}  	else {  		radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  	}  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: do {  	if (i % 250 == 0) {  		radius += scale / 2 * (0.5 - RNG.NextDouble ());  	}  	else if (i % 50 == 0) {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  	}  	else {  		radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  	}  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: do {  	if (i % 250 == 0) {  		radius += scale / 2 * (0.5 - RNG.NextDouble ());  	}  	else if (i % 50 == 0) {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  	}  	else {  		radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  	}  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: do {  	if (i % 250 == 0) {  		radius += scale / 2 * (0.5 - RNG.NextDouble ());  	}  	else if (i % 50 == 0) {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  	}  	else {  		radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  	}  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: if (i % 250 == 0) {  	radius += scale / 2 * (0.5 - RNG.NextDouble ());  }  else if (i % 50 == 0) {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  }  else {  	radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: if (i % 250 == 0) {  	radius += scale / 2 * (0.5 - RNG.NextDouble ());  }  else if (i % 50 == 0) {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  }  else {  	radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: if (i % 250 == 0) {  	radius += scale / 2 * (0.5 - RNG.NextDouble ());  }  else if (i % 50 == 0) {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  }  else {  	radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: if (i % 250 == 0) {  	radius += scale / 2 * (0.5 - RNG.NextDouble ());  }  else if (i % 50 == 0) {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  }  else {  	radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: if (i % 250 == 0) {  	radius += scale / 2 * (0.5 - RNG.NextDouble ());  }  else if (i % 50 == 0) {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  }  else {  	radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: if (i % 250 == 0) {  	radius += scale / 2 * (0.5 - RNG.NextDouble ());  }  else if (i % 50 == 0) {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  }  else {  	radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: if (i % 250 == 0) {  	radius += scale / 2 * (0.5 - RNG.NextDouble ());  }  else if (i % 50 == 0) {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  }  else {  	radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: if (i % 250 == 0) {  	radius += scale / 2 * (0.5 - RNG.NextDouble ());  }  else if (i % 50 == 0) {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  }  else {  	radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: radius += scale / 2 * (0.5 - RNG.NextDouble ());  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: radius += scale / 2 * (0.5 - RNG.NextDouble ());  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: if (i % 50 == 0) {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  }  else {  	radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: if (i % 50 == 0) {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  }  else {  	radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: if (i % 50 == 0) {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  }  else {  	radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: if (i % 50 == 0) {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  }  else {  	radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: if (i % 50 == 0) {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  }  else {  	radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: radius += scale / 5 * (0.5 - RNG.NextDouble ());  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: radius += scale / 5 * (0.5 - RNG.NextDouble ());  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: radius += 25 * scale / vertexCount * (0.5 - RNG.NextDouble ());  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: radius = radius > scale / 2 ? scale / 2 : radius;  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: radius = radius > scale / 2 ? scale / 2 : radius;  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: radius = radius < scale / 10 ? scale / 10 : radius;  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: radius = radius < scale / 10 ? scale / 10 : radius;  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++) {  	do {  		radius += scale / 5 * (0.5 - RNG.NextDouble ());  		radius = radius > scale / 2 ? scale / 2 : radius;  		radius = radius < scale / 10 ? scale / 10 : radius;  	}  	while (radius < scale / 10 || radius > scale / 2);  	point = new PolygonPoint (radius * Math.Cos ((PI_2 * i) / vertexCount)' radius * Math.Sin ((PI_2 * i) / vertexCount));  	points [i] = point;  }  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: do {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: do {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: do {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: do {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: do {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: do {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: do {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: do {  	radius += scale / 5 * (0.5 - RNG.NextDouble ());  	radius = radius > scale / 2 ? scale / 2 : radius;  	radius = radius < scale / 10 ? scale / 10 : radius;  }  while (radius < scale / 10 || radius > scale / 2);  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: radius += scale / 5 * (0.5 - RNG.NextDouble ());  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: radius += scale / 5 * (0.5 - RNG.NextDouble ());  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: radius = radius > scale / 2 ? scale / 2 : radius;  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: radius = radius > scale / 2 ? scale / 2 : radius;  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: radius = radius < scale / 10 ? scale / 10 : radius;  
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: radius = radius < scale / 10 ? scale / 10 : radius;  
Magic Number,FarseerPhysics.Common,MathUtils,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Math.cs,VectorAngle,The following statement contains a magic number: while (dtheta > Math.PI)  	dtheta -= (2 * Math.PI);  
Magic Number,FarseerPhysics.Common,MathUtils,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Math.cs,VectorAngle,The following statement contains a magic number: dtheta -= (2 * Math.PI);  
Magic Number,FarseerPhysics.Common,MathUtils,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Math.cs,VectorAngle,The following statement contains a magic number: while (dtheta < -Math.PI)  	dtheta += (2 * Math.PI);  
Magic Number,FarseerPhysics.Common,MathUtils,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Math.cs,VectorAngle,The following statement contains a magic number: dtheta += (2 * Math.PI);  
Magic Number,FarseerPhysics.Common,Path,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Path.cs,GetPosition,The following statement contains a magic number: if (ControlPoints.Count < 2)  	throw new Exception ("You need at least 2 control points to calculate a position.");  
Magic Number,FarseerPhysics.Common,Path,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Path.cs,GetPosition,The following statement contains a magic number: if (Closed) {  	Add (ControlPoints [0]);  	_deltaT = 1f / (ControlPoints.Count - 1);  	int p = (int)(time / _deltaT);  	// use a circular indexing system  	int p0 = p - 1;  	if (p0 < 0)  		p0 = p0 + (ControlPoints.Count - 1);  	else if (p0 >= ControlPoints.Count - 1)  		p0 = p0 - (ControlPoints.Count - 1);  	int p1 = p;  	if (p1 < 0)  		p1 = p1 + (ControlPoints.Count - 1);  	else if (p1 >= ControlPoints.Count - 1)  		p1 = p1 - (ControlPoints.Count - 1);  	int p2 = p + 1;  	if (p2 < 0)  		p2 = p2 + (ControlPoints.Count - 1);  	else if (p2 >= ControlPoints.Count - 1)  		p2 = p2 - (ControlPoints.Count - 1);  	int p3 = p + 2;  	if (p3 < 0)  		p3 = p3 + (ControlPoints.Count - 1);  	else if (p3 >= ControlPoints.Count - 1)  		p3 = p3 - (ControlPoints.Count - 1);  	// relative time  	float lt = (time - _deltaT * p) / _deltaT;  	temp = Vector2.CatmullRom (ControlPoints [p0]' ControlPoints [p1]' ControlPoints [p2]' ControlPoints [p3]' lt);  	RemoveAt (ControlPoints.Count - 1);  }  else {  	int p = (int)(time / _deltaT);  	//   	int p0 = p - 1;  	if (p0 < 0)  		p0 = 0;  	else if (p0 >= ControlPoints.Count - 1)  		p0 = ControlPoints.Count - 1;  	int p1 = p;  	if (p1 < 0)  		p1 = 0;  	else if (p1 >= ControlPoints.Count - 1)  		p1 = ControlPoints.Count - 1;  	int p2 = p + 1;  	if (p2 < 0)  		p2 = 0;  	else if (p2 >= ControlPoints.Count - 1)  		p2 = ControlPoints.Count - 1;  	int p3 = p + 2;  	if (p3 < 0)  		p3 = 0;  	else if (p3 >= ControlPoints.Count - 1)  		p3 = ControlPoints.Count - 1;  	// relative time  	float lt = (time - _deltaT * p) / _deltaT;  	temp = Vector2.CatmullRom (ControlPoints [p0]' ControlPoints [p1]' ControlPoints [p2]' ControlPoints [p3]' lt);  }  
Magic Number,FarseerPhysics.Common,Path,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Path.cs,GetPosition,The following statement contains a magic number: if (Closed) {  	Add (ControlPoints [0]);  	_deltaT = 1f / (ControlPoints.Count - 1);  	int p = (int)(time / _deltaT);  	// use a circular indexing system  	int p0 = p - 1;  	if (p0 < 0)  		p0 = p0 + (ControlPoints.Count - 1);  	else if (p0 >= ControlPoints.Count - 1)  		p0 = p0 - (ControlPoints.Count - 1);  	int p1 = p;  	if (p1 < 0)  		p1 = p1 + (ControlPoints.Count - 1);  	else if (p1 >= ControlPoints.Count - 1)  		p1 = p1 - (ControlPoints.Count - 1);  	int p2 = p + 1;  	if (p2 < 0)  		p2 = p2 + (ControlPoints.Count - 1);  	else if (p2 >= ControlPoints.Count - 1)  		p2 = p2 - (ControlPoints.Count - 1);  	int p3 = p + 2;  	if (p3 < 0)  		p3 = p3 + (ControlPoints.Count - 1);  	else if (p3 >= ControlPoints.Count - 1)  		p3 = p3 - (ControlPoints.Count - 1);  	// relative time  	float lt = (time - _deltaT * p) / _deltaT;  	temp = Vector2.CatmullRom (ControlPoints [p0]' ControlPoints [p1]' ControlPoints [p2]' ControlPoints [p3]' lt);  	RemoveAt (ControlPoints.Count - 1);  }  else {  	int p = (int)(time / _deltaT);  	//   	int p0 = p - 1;  	if (p0 < 0)  		p0 = 0;  	else if (p0 >= ControlPoints.Count - 1)  		p0 = ControlPoints.Count - 1;  	int p1 = p;  	if (p1 < 0)  		p1 = 0;  	else if (p1 >= ControlPoints.Count - 1)  		p1 = ControlPoints.Count - 1;  	int p2 = p + 1;  	if (p2 < 0)  		p2 = 0;  	else if (p2 >= ControlPoints.Count - 1)  		p2 = ControlPoints.Count - 1;  	int p3 = p + 2;  	if (p3 < 0)  		p3 = 0;  	else if (p3 >= ControlPoints.Count - 1)  		p3 = ControlPoints.Count - 1;  	// relative time  	float lt = (time - _deltaT * p) / _deltaT;  	temp = Vector2.CatmullRom (ControlPoints [p0]' ControlPoints [p1]' ControlPoints [p2]' ControlPoints [p3]' lt);  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateRectangle,The following statement contains a magic number: for (int i = 0; i < 4; ++i) {  	vertices [i] = MathUtils.Multiply (ref xf' vertices [i]);  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (yRadius > height / 2 || xRadius > width / 2)  	throw new Exception ("Rounding amount can't be more than half the height and width respectively.");  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (yRadius > height / 2 || xRadius > width / 2)  	throw new Exception ("Rounding amount can't be more than half the height and width respectively.");  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: Debug.Assert (Settings.MaxPolygonVertices >= 8);  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (segments == 0) {  	vertices.Add (new Vector2 (width * .5f - xRadius' -height * .5f));  	vertices.Add (new Vector2 (width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (width * .5f - xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f + xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (-width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (-width * .5f + xRadius' -height * .5f));  }  else {  	int numberOfEdges = (segments * 4 + 8);  	float stepSize = MathHelper.TwoPi / (numberOfEdges - 4);  	int perPhase = numberOfEdges / 4;  	Vector2 posOffset = new Vector2 (width / 2 - xRadius' height / 2 - yRadius);  	vertices.Add (posOffset + new Vector2 (xRadius' -yRadius + yRadius));  	short phase = 0;  	for (int i = 1; i < numberOfEdges; i++) {  		if (i - perPhase == 0 || i - perPhase * 3 == 0) {  			posOffset.X *= -1;  			phase--;  		}  		else if (i - perPhase * 2 == 0) {  			posOffset.Y *= -1;  			phase--;  		}  		vertices.Add (posOffset + new Vector2 (xRadius * (float)Math.Cos (stepSize * -(i + phase))' -yRadius * (float)Math.Sin (stepSize * -(i + phase))));  	}  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (segments == 0) {  	vertices.Add (new Vector2 (width * .5f - xRadius' -height * .5f));  	vertices.Add (new Vector2 (width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (width * .5f - xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f + xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (-width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (-width * .5f + xRadius' -height * .5f));  }  else {  	int numberOfEdges = (segments * 4 + 8);  	float stepSize = MathHelper.TwoPi / (numberOfEdges - 4);  	int perPhase = numberOfEdges / 4;  	Vector2 posOffset = new Vector2 (width / 2 - xRadius' height / 2 - yRadius);  	vertices.Add (posOffset + new Vector2 (xRadius' -yRadius + yRadius));  	short phase = 0;  	for (int i = 1; i < numberOfEdges; i++) {  		if (i - perPhase == 0 || i - perPhase * 3 == 0) {  			posOffset.X *= -1;  			phase--;  		}  		else if (i - perPhase * 2 == 0) {  			posOffset.Y *= -1;  			phase--;  		}  		vertices.Add (posOffset + new Vector2 (xRadius * (float)Math.Cos (stepSize * -(i + phase))' -yRadius * (float)Math.Sin (stepSize * -(i + phase))));  	}  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (segments == 0) {  	vertices.Add (new Vector2 (width * .5f - xRadius' -height * .5f));  	vertices.Add (new Vector2 (width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (width * .5f - xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f + xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (-width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (-width * .5f + xRadius' -height * .5f));  }  else {  	int numberOfEdges = (segments * 4 + 8);  	float stepSize = MathHelper.TwoPi / (numberOfEdges - 4);  	int perPhase = numberOfEdges / 4;  	Vector2 posOffset = new Vector2 (width / 2 - xRadius' height / 2 - yRadius);  	vertices.Add (posOffset + new Vector2 (xRadius' -yRadius + yRadius));  	short phase = 0;  	for (int i = 1; i < numberOfEdges; i++) {  		if (i - perPhase == 0 || i - perPhase * 3 == 0) {  			posOffset.X *= -1;  			phase--;  		}  		else if (i - perPhase * 2 == 0) {  			posOffset.Y *= -1;  			phase--;  		}  		vertices.Add (posOffset + new Vector2 (xRadius * (float)Math.Cos (stepSize * -(i + phase))' -yRadius * (float)Math.Sin (stepSize * -(i + phase))));  	}  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (segments == 0) {  	vertices.Add (new Vector2 (width * .5f - xRadius' -height * .5f));  	vertices.Add (new Vector2 (width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (width * .5f - xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f + xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (-width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (-width * .5f + xRadius' -height * .5f));  }  else {  	int numberOfEdges = (segments * 4 + 8);  	float stepSize = MathHelper.TwoPi / (numberOfEdges - 4);  	int perPhase = numberOfEdges / 4;  	Vector2 posOffset = new Vector2 (width / 2 - xRadius' height / 2 - yRadius);  	vertices.Add (posOffset + new Vector2 (xRadius' -yRadius + yRadius));  	short phase = 0;  	for (int i = 1; i < numberOfEdges; i++) {  		if (i - perPhase == 0 || i - perPhase * 3 == 0) {  			posOffset.X *= -1;  			phase--;  		}  		else if (i - perPhase * 2 == 0) {  			posOffset.Y *= -1;  			phase--;  		}  		vertices.Add (posOffset + new Vector2 (xRadius * (float)Math.Cos (stepSize * -(i + phase))' -yRadius * (float)Math.Sin (stepSize * -(i + phase))));  	}  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (segments == 0) {  	vertices.Add (new Vector2 (width * .5f - xRadius' -height * .5f));  	vertices.Add (new Vector2 (width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (width * .5f - xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f + xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (-width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (-width * .5f + xRadius' -height * .5f));  }  else {  	int numberOfEdges = (segments * 4 + 8);  	float stepSize = MathHelper.TwoPi / (numberOfEdges - 4);  	int perPhase = numberOfEdges / 4;  	Vector2 posOffset = new Vector2 (width / 2 - xRadius' height / 2 - yRadius);  	vertices.Add (posOffset + new Vector2 (xRadius' -yRadius + yRadius));  	short phase = 0;  	for (int i = 1; i < numberOfEdges; i++) {  		if (i - perPhase == 0 || i - perPhase * 3 == 0) {  			posOffset.X *= -1;  			phase--;  		}  		else if (i - perPhase * 2 == 0) {  			posOffset.Y *= -1;  			phase--;  		}  		vertices.Add (posOffset + new Vector2 (xRadius * (float)Math.Cos (stepSize * -(i + phase))' -yRadius * (float)Math.Sin (stepSize * -(i + phase))));  	}  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (segments == 0) {  	vertices.Add (new Vector2 (width * .5f - xRadius' -height * .5f));  	vertices.Add (new Vector2 (width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (width * .5f - xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f + xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (-width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (-width * .5f + xRadius' -height * .5f));  }  else {  	int numberOfEdges = (segments * 4 + 8);  	float stepSize = MathHelper.TwoPi / (numberOfEdges - 4);  	int perPhase = numberOfEdges / 4;  	Vector2 posOffset = new Vector2 (width / 2 - xRadius' height / 2 - yRadius);  	vertices.Add (posOffset + new Vector2 (xRadius' -yRadius + yRadius));  	short phase = 0;  	for (int i = 1; i < numberOfEdges; i++) {  		if (i - perPhase == 0 || i - perPhase * 3 == 0) {  			posOffset.X *= -1;  			phase--;  		}  		else if (i - perPhase * 2 == 0) {  			posOffset.Y *= -1;  			phase--;  		}  		vertices.Add (posOffset + new Vector2 (xRadius * (float)Math.Cos (stepSize * -(i + phase))' -yRadius * (float)Math.Sin (stepSize * -(i + phase))));  	}  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (segments == 0) {  	vertices.Add (new Vector2 (width * .5f - xRadius' -height * .5f));  	vertices.Add (new Vector2 (width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (width * .5f - xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f + xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (-width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (-width * .5f + xRadius' -height * .5f));  }  else {  	int numberOfEdges = (segments * 4 + 8);  	float stepSize = MathHelper.TwoPi / (numberOfEdges - 4);  	int perPhase = numberOfEdges / 4;  	Vector2 posOffset = new Vector2 (width / 2 - xRadius' height / 2 - yRadius);  	vertices.Add (posOffset + new Vector2 (xRadius' -yRadius + yRadius));  	short phase = 0;  	for (int i = 1; i < numberOfEdges; i++) {  		if (i - perPhase == 0 || i - perPhase * 3 == 0) {  			posOffset.X *= -1;  			phase--;  		}  		else if (i - perPhase * 2 == 0) {  			posOffset.Y *= -1;  			phase--;  		}  		vertices.Add (posOffset + new Vector2 (xRadius * (float)Math.Cos (stepSize * -(i + phase))' -yRadius * (float)Math.Sin (stepSize * -(i + phase))));  	}  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (segments == 0) {  	vertices.Add (new Vector2 (width * .5f - xRadius' -height * .5f));  	vertices.Add (new Vector2 (width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (width * .5f - xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f + xRadius' height * .5f));  	vertices.Add (new Vector2 (-width * .5f' height * .5f - yRadius));  	vertices.Add (new Vector2 (-width * .5f' -height * .5f + yRadius));  	vertices.Add (new Vector2 (-width * .5f + xRadius' -height * .5f));  }  else {  	int numberOfEdges = (segments * 4 + 8);  	float stepSize = MathHelper.TwoPi / (numberOfEdges - 4);  	int perPhase = numberOfEdges / 4;  	Vector2 posOffset = new Vector2 (width / 2 - xRadius' height / 2 - yRadius);  	vertices.Add (posOffset + new Vector2 (xRadius' -yRadius + yRadius));  	short phase = 0;  	for (int i = 1; i < numberOfEdges; i++) {  		if (i - perPhase == 0 || i - perPhase * 3 == 0) {  			posOffset.X *= -1;  			phase--;  		}  		else if (i - perPhase * 2 == 0) {  			posOffset.Y *= -1;  			phase--;  		}  		vertices.Add (posOffset + new Vector2 (xRadius * (float)Math.Cos (stepSize * -(i + phase))' -yRadius * (float)Math.Sin (stepSize * -(i + phase))));  	}  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: for (int i = 1; i < numberOfEdges; i++) {  	if (i - perPhase == 0 || i - perPhase * 3 == 0) {  		posOffset.X *= -1;  		phase--;  	}  	else if (i - perPhase * 2 == 0) {  		posOffset.Y *= -1;  		phase--;  	}  	vertices.Add (posOffset + new Vector2 (xRadius * (float)Math.Cos (stepSize * -(i + phase))' -yRadius * (float)Math.Sin (stepSize * -(i + phase))));  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: for (int i = 1; i < numberOfEdges; i++) {  	if (i - perPhase == 0 || i - perPhase * 3 == 0) {  		posOffset.X *= -1;  		phase--;  	}  	else if (i - perPhase * 2 == 0) {  		posOffset.Y *= -1;  		phase--;  	}  	vertices.Add (posOffset + new Vector2 (xRadius * (float)Math.Cos (stepSize * -(i + phase))' -yRadius * (float)Math.Sin (stepSize * -(i + phase))));  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (i - perPhase == 0 || i - perPhase * 3 == 0) {  	posOffset.X *= -1;  	phase--;  }  else if (i - perPhase * 2 == 0) {  	posOffset.Y *= -1;  	phase--;  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (i - perPhase == 0 || i - perPhase * 3 == 0) {  	posOffset.X *= -1;  	phase--;  }  else if (i - perPhase * 2 == 0) {  	posOffset.Y *= -1;  	phase--;  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (i - perPhase * 2 == 0) {  	posOffset.Y *= -1;  	phase--;  }  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateCapsule,The following statement contains a magic number: if (endRadius >= height / 2)  	throw new ArgumentException ("The radius must be lower than height / 2. Higher values of radius would create a circle' and not a half circle."' "endRadius");  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateCapsule,The following statement contains a magic number: if (topRadius >= height / 2)  	throw new ArgumentException ("The top radius must be lower than height / 2. Higher values of top radius would create a circle' and not a half circle."' "topRadius");  
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonTools.cs,CreateCapsule,The following statement contains a magic number: if (bottomRadius >= height / 2)  	throw new ArgumentException ("The bottom radius must be lower than height / 2. Higher values of bottom radius would create a circle' and not a half circle."' "bottomRadius");  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,DetectSquares,The following statement contains a magic number: for (int y = 0; y < yn; y++) {  	float y0 = y * cellHeight + domain.LowerBound.Y;  	float y1;  	if (y == yn - 1)  		y1 = domain.UpperBound.Y;  	else  		y1 = y0 + cellHeight;  	GeomPoly pre = null;  	for (int x = 0; x < xn; x++) {  		float x0 = x * cellWidth + domain.LowerBound.X;  		float x1;  		if (x == xn - 1)  			x1 = domain.UpperBound.X;  		else  			x1 = x0 + cellWidth;  		gp = new GeomPoly ();  		int key = MarchSquare (f' fs' ref gp' x' y' x0' y0' x1' y1' lerpCount);  		if (gp.Length != 0) {  			if (combine && pre != null && (key & 9) != 0) {  				combLeft (ref pre' ref gp);  				gp = pre;  			}  			else  				ret.Add (gp);  			ps [x' y] = new GeomPolyVal (gp' key);  		}  		else  			gp = null;  		pre = gp;  	}  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,DetectSquares,The following statement contains a magic number: for (int x = 0; x < xn; x++) {  	float x0 = x * cellWidth + domain.LowerBound.X;  	float x1;  	if (x == xn - 1)  		x1 = domain.UpperBound.X;  	else  		x1 = x0 + cellWidth;  	gp = new GeomPoly ();  	int key = MarchSquare (f' fs' ref gp' x' y' x0' y0' x1' y1' lerpCount);  	if (gp.Length != 0) {  		if (combine && pre != null && (key & 9) != 0) {  			combLeft (ref pre' ref gp);  			gp = pre;  		}  		else  			ret.Add (gp);  		ps [x' y] = new GeomPolyVal (gp' key);  	}  	else  		gp = null;  	pre = gp;  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,DetectSquares,The following statement contains a magic number: if (gp.Length != 0) {  	if (combine && pre != null && (key & 9) != 0) {  		combLeft (ref pre' ref gp);  		gp = pre;  	}  	else  		ret.Add (gp);  	ps [x' y] = new GeomPolyVal (gp' key);  }  else  	gp = null;  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,DetectSquares,The following statement contains a magic number: if (combine && pre != null && (key & 9) != 0) {  	combLeft (ref pre' ref gp);  	gp = pre;  }  else  	ret.Add (gp);  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,DetectSquares,The following statement contains a magic number: for (int y = 1; y < yn; y++) {  	int x = 0;  	while (x < xn) {  		GeomPolyVal p = ps [x' y];  		//skip along scan line if no polygon exists at this point  		if (p == null) {  			x++;  			continue;  		}  		//skip along if current polygon cannot be combined above.  		if ((p.Key & 12) == 0) {  			x++;  			continue;  		}  		//skip along if no polygon exists above.  		GeomPolyVal u = ps [x' y - 1];  		if (u == null) {  			x++;  			continue;  		}  		//skip along if polygon above cannot be combined with.  		if ((u.Key & 3) == 0) {  			x++;  			continue;  		}  		float ax = x * cellWidth + domain.LowerBound.X;  		float ay = y * cellHeight + domain.LowerBound.Y;  		CxFastList<Vector2> bp = p.GeomP.Points;  		CxFastList<Vector2> ap = u.GeomP.Points;  		//skip if it's already been combined with above polygon  		if (u.GeomP == p.GeomP) {  			x++;  			continue;  		}  		//combine above (but disallow the hole thingies  		CxFastListNode<Vector2> bi = bp.Begin ();  		while (Square (bi.Elem ().Y - ay) > Settings.Epsilon || bi.Elem ().X < ax)  			bi = bi.Next ();  		//NOTE: Unused  		//Vector2 b0 = bi.elem();  		Vector2 b1 = bi.Next ().Elem ();  		if (Square (b1.Y - ay) > Settings.Epsilon) {  			x++;  			continue;  		}  		bool brk = true;  		CxFastListNode<Vector2> ai = ap.Begin ();  		while (ai != ap.End ()) {  			if (VecDsq (ai.Elem ()' b1) < Settings.Epsilon) {  				brk = false;  				break;  			}  			ai = ai.Next ();  		}  		if (brk) {  			x++;  			continue;  		}  		CxFastListNode<Vector2> bj = bi.Next ().Next ();  		if (bj == bp.End ())  			bj = bp.Begin ();  		while (bj != bi) {  			ai = ap.Insert (ai' bj.Elem ());  			// .clone()  			bj = bj.Next ();  			if (bj == bp.End ())  				bj = bp.Begin ();  			u.GeomP.Length++;  		}  		//u.p.simplify(float.Epsilon'float.Epsilon);  		//  		ax = x + 1;  		while (ax < xn) {  			GeomPolyVal p2 = ps [(int)ax' y];  			if (p2 == null || p2.GeomP != p.GeomP) {  				ax++;  				continue;  			}  			p2.GeomP = u.GeomP;  			ax++;  		}  		ax = x - 1;  		while (ax >= 0) {  			GeomPolyVal p2 = ps [(int)ax' y];  			if (p2 == null || p2.GeomP != p.GeomP) {  				ax--;  				continue;  			}  			p2.GeomP = u.GeomP;  			ax--;  		}  		ret.Remove (p.GeomP);  		p.GeomP = u.GeomP;  		x = (int)((bi.Next ().Elem ().X - domain.LowerBound.X) / cellWidth) + 1;  		//x++; this was already commented out!  	}  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,DetectSquares,The following statement contains a magic number: for (int y = 1; y < yn; y++) {  	int x = 0;  	while (x < xn) {  		GeomPolyVal p = ps [x' y];  		//skip along scan line if no polygon exists at this point  		if (p == null) {  			x++;  			continue;  		}  		//skip along if current polygon cannot be combined above.  		if ((p.Key & 12) == 0) {  			x++;  			continue;  		}  		//skip along if no polygon exists above.  		GeomPolyVal u = ps [x' y - 1];  		if (u == null) {  			x++;  			continue;  		}  		//skip along if polygon above cannot be combined with.  		if ((u.Key & 3) == 0) {  			x++;  			continue;  		}  		float ax = x * cellWidth + domain.LowerBound.X;  		float ay = y * cellHeight + domain.LowerBound.Y;  		CxFastList<Vector2> bp = p.GeomP.Points;  		CxFastList<Vector2> ap = u.GeomP.Points;  		//skip if it's already been combined with above polygon  		if (u.GeomP == p.GeomP) {  			x++;  			continue;  		}  		//combine above (but disallow the hole thingies  		CxFastListNode<Vector2> bi = bp.Begin ();  		while (Square (bi.Elem ().Y - ay) > Settings.Epsilon || bi.Elem ().X < ax)  			bi = bi.Next ();  		//NOTE: Unused  		//Vector2 b0 = bi.elem();  		Vector2 b1 = bi.Next ().Elem ();  		if (Square (b1.Y - ay) > Settings.Epsilon) {  			x++;  			continue;  		}  		bool brk = true;  		CxFastListNode<Vector2> ai = ap.Begin ();  		while (ai != ap.End ()) {  			if (VecDsq (ai.Elem ()' b1) < Settings.Epsilon) {  				brk = false;  				break;  			}  			ai = ai.Next ();  		}  		if (brk) {  			x++;  			continue;  		}  		CxFastListNode<Vector2> bj = bi.Next ().Next ();  		if (bj == bp.End ())  			bj = bp.Begin ();  		while (bj != bi) {  			ai = ap.Insert (ai' bj.Elem ());  			// .clone()  			bj = bj.Next ();  			if (bj == bp.End ())  				bj = bp.Begin ();  			u.GeomP.Length++;  		}  		//u.p.simplify(float.Epsilon'float.Epsilon);  		//  		ax = x + 1;  		while (ax < xn) {  			GeomPolyVal p2 = ps [(int)ax' y];  			if (p2 == null || p2.GeomP != p.GeomP) {  				ax++;  				continue;  			}  			p2.GeomP = u.GeomP;  			ax++;  		}  		ax = x - 1;  		while (ax >= 0) {  			GeomPolyVal p2 = ps [(int)ax' y];  			if (p2 == null || p2.GeomP != p.GeomP) {  				ax--;  				continue;  			}  			p2.GeomP = u.GeomP;  			ax--;  		}  		ret.Remove (p.GeomP);  		p.GeomP = u.GeomP;  		x = (int)((bi.Next ().Elem ().X - domain.LowerBound.X) / cellWidth) + 1;  		//x++; this was already commented out!  	}  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,DetectSquares,The following statement contains a magic number: while (x < xn) {  	GeomPolyVal p = ps [x' y];  	//skip along scan line if no polygon exists at this point  	if (p == null) {  		x++;  		continue;  	}  	//skip along if current polygon cannot be combined above.  	if ((p.Key & 12) == 0) {  		x++;  		continue;  	}  	//skip along if no polygon exists above.  	GeomPolyVal u = ps [x' y - 1];  	if (u == null) {  		x++;  		continue;  	}  	//skip along if polygon above cannot be combined with.  	if ((u.Key & 3) == 0) {  		x++;  		continue;  	}  	float ax = x * cellWidth + domain.LowerBound.X;  	float ay = y * cellHeight + domain.LowerBound.Y;  	CxFastList<Vector2> bp = p.GeomP.Points;  	CxFastList<Vector2> ap = u.GeomP.Points;  	//skip if it's already been combined with above polygon  	if (u.GeomP == p.GeomP) {  		x++;  		continue;  	}  	//combine above (but disallow the hole thingies  	CxFastListNode<Vector2> bi = bp.Begin ();  	while (Square (bi.Elem ().Y - ay) > Settings.Epsilon || bi.Elem ().X < ax)  		bi = bi.Next ();  	//NOTE: Unused  	//Vector2 b0 = bi.elem();  	Vector2 b1 = bi.Next ().Elem ();  	if (Square (b1.Y - ay) > Settings.Epsilon) {  		x++;  		continue;  	}  	bool brk = true;  	CxFastListNode<Vector2> ai = ap.Begin ();  	while (ai != ap.End ()) {  		if (VecDsq (ai.Elem ()' b1) < Settings.Epsilon) {  			brk = false;  			break;  		}  		ai = ai.Next ();  	}  	if (brk) {  		x++;  		continue;  	}  	CxFastListNode<Vector2> bj = bi.Next ().Next ();  	if (bj == bp.End ())  		bj = bp.Begin ();  	while (bj != bi) {  		ai = ap.Insert (ai' bj.Elem ());  		// .clone()  		bj = bj.Next ();  		if (bj == bp.End ())  			bj = bp.Begin ();  		u.GeomP.Length++;  	}  	//u.p.simplify(float.Epsilon'float.Epsilon);  	//  	ax = x + 1;  	while (ax < xn) {  		GeomPolyVal p2 = ps [(int)ax' y];  		if (p2 == null || p2.GeomP != p.GeomP) {  			ax++;  			continue;  		}  		p2.GeomP = u.GeomP;  		ax++;  	}  	ax = x - 1;  	while (ax >= 0) {  		GeomPolyVal p2 = ps [(int)ax' y];  		if (p2 == null || p2.GeomP != p.GeomP) {  			ax--;  			continue;  		}  		p2.GeomP = u.GeomP;  		ax--;  	}  	ret.Remove (p.GeomP);  	p.GeomP = u.GeomP;  	x = (int)((bi.Next ().Elem ().X - domain.LowerBound.X) / cellWidth) + 1;  	//x++; this was already commented out!  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,DetectSquares,The following statement contains a magic number: while (x < xn) {  	GeomPolyVal p = ps [x' y];  	//skip along scan line if no polygon exists at this point  	if (p == null) {  		x++;  		continue;  	}  	//skip along if current polygon cannot be combined above.  	if ((p.Key & 12) == 0) {  		x++;  		continue;  	}  	//skip along if no polygon exists above.  	GeomPolyVal u = ps [x' y - 1];  	if (u == null) {  		x++;  		continue;  	}  	//skip along if polygon above cannot be combined with.  	if ((u.Key & 3) == 0) {  		x++;  		continue;  	}  	float ax = x * cellWidth + domain.LowerBound.X;  	float ay = y * cellHeight + domain.LowerBound.Y;  	CxFastList<Vector2> bp = p.GeomP.Points;  	CxFastList<Vector2> ap = u.GeomP.Points;  	//skip if it's already been combined with above polygon  	if (u.GeomP == p.GeomP) {  		x++;  		continue;  	}  	//combine above (but disallow the hole thingies  	CxFastListNode<Vector2> bi = bp.Begin ();  	while (Square (bi.Elem ().Y - ay) > Settings.Epsilon || bi.Elem ().X < ax)  		bi = bi.Next ();  	//NOTE: Unused  	//Vector2 b0 = bi.elem();  	Vector2 b1 = bi.Next ().Elem ();  	if (Square (b1.Y - ay) > Settings.Epsilon) {  		x++;  		continue;  	}  	bool brk = true;  	CxFastListNode<Vector2> ai = ap.Begin ();  	while (ai != ap.End ()) {  		if (VecDsq (ai.Elem ()' b1) < Settings.Epsilon) {  			brk = false;  			break;  		}  		ai = ai.Next ();  	}  	if (brk) {  		x++;  		continue;  	}  	CxFastListNode<Vector2> bj = bi.Next ().Next ();  	if (bj == bp.End ())  		bj = bp.Begin ();  	while (bj != bi) {  		ai = ap.Insert (ai' bj.Elem ());  		// .clone()  		bj = bj.Next ();  		if (bj == bp.End ())  			bj = bp.Begin ();  		u.GeomP.Length++;  	}  	//u.p.simplify(float.Epsilon'float.Epsilon);  	//  	ax = x + 1;  	while (ax < xn) {  		GeomPolyVal p2 = ps [(int)ax' y];  		if (p2 == null || p2.GeomP != p.GeomP) {  			ax++;  			continue;  		}  		p2.GeomP = u.GeomP;  		ax++;  	}  	ax = x - 1;  	while (ax >= 0) {  		GeomPolyVal p2 = ps [(int)ax' y];  		if (p2 == null || p2.GeomP != p.GeomP) {  			ax--;  			continue;  		}  		p2.GeomP = u.GeomP;  		ax--;  	}  	ret.Remove (p.GeomP);  	p.GeomP = u.GeomP;  	x = (int)((bi.Next ().Elem ().X - domain.LowerBound.X) / cellWidth) + 1;  	//x++; this was already commented out!  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,DetectSquares,The following statement contains a magic number: if ((p.Key & 12) == 0) {  	x++;  	continue;  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,DetectSquares,The following statement contains a magic number: if ((u.Key & 3) == 0) {  	x++;  	continue;  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (v0 < 0)  	key |= 8;  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: key |= 8;  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (v1 < 0)  	key |= 4;  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: key |= 4;  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (v2 < 0)  	key |= 2;  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: key |= 2;  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (val != 0) {  	CxFastListNode<Vector2> pi = null;  	for (int i = 0; i < 8; i++) {  		Vector2 p;  		if ((val & (1 << i)) != 0) {  			if (i == 7 && (val & 1) == 0)  				poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  			else {  				if (i == 0)  					p = new Vector2 (x0' y0);  				else if (i == 2)  					p = new Vector2 (x1' y0);  				else if (i == 4)  					p = new Vector2 (x1' y1);  				else if (i == 6)  					p = new Vector2 (x0' y1);  				else if (i == 1)  					p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  				else if (i == 5)  					p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  				else if (i == 3)  					p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  				else  					p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  				pi = poly.Points.Insert (pi' p);  			}  			poly.Length++;  		}  	}  	//poly.simplify(float.Epsilon'float.Epsilon);  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (val != 0) {  	CxFastListNode<Vector2> pi = null;  	for (int i = 0; i < 8; i++) {  		Vector2 p;  		if ((val & (1 << i)) != 0) {  			if (i == 7 && (val & 1) == 0)  				poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  			else {  				if (i == 0)  					p = new Vector2 (x0' y0);  				else if (i == 2)  					p = new Vector2 (x1' y0);  				else if (i == 4)  					p = new Vector2 (x1' y1);  				else if (i == 6)  					p = new Vector2 (x0' y1);  				else if (i == 1)  					p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  				else if (i == 5)  					p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  				else if (i == 3)  					p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  				else  					p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  				pi = poly.Points.Insert (pi' p);  			}  			poly.Length++;  		}  	}  	//poly.simplify(float.Epsilon'float.Epsilon);  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (val != 0) {  	CxFastListNode<Vector2> pi = null;  	for (int i = 0; i < 8; i++) {  		Vector2 p;  		if ((val & (1 << i)) != 0) {  			if (i == 7 && (val & 1) == 0)  				poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  			else {  				if (i == 0)  					p = new Vector2 (x0' y0);  				else if (i == 2)  					p = new Vector2 (x1' y0);  				else if (i == 4)  					p = new Vector2 (x1' y1);  				else if (i == 6)  					p = new Vector2 (x0' y1);  				else if (i == 1)  					p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  				else if (i == 5)  					p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  				else if (i == 3)  					p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  				else  					p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  				pi = poly.Points.Insert (pi' p);  			}  			poly.Length++;  		}  	}  	//poly.simplify(float.Epsilon'float.Epsilon);  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (val != 0) {  	CxFastListNode<Vector2> pi = null;  	for (int i = 0; i < 8; i++) {  		Vector2 p;  		if ((val & (1 << i)) != 0) {  			if (i == 7 && (val & 1) == 0)  				poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  			else {  				if (i == 0)  					p = new Vector2 (x0' y0);  				else if (i == 2)  					p = new Vector2 (x1' y0);  				else if (i == 4)  					p = new Vector2 (x1' y1);  				else if (i == 6)  					p = new Vector2 (x0' y1);  				else if (i == 1)  					p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  				else if (i == 5)  					p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  				else if (i == 3)  					p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  				else  					p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  				pi = poly.Points.Insert (pi' p);  			}  			poly.Length++;  		}  	}  	//poly.simplify(float.Epsilon'float.Epsilon);  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (val != 0) {  	CxFastListNode<Vector2> pi = null;  	for (int i = 0; i < 8; i++) {  		Vector2 p;  		if ((val & (1 << i)) != 0) {  			if (i == 7 && (val & 1) == 0)  				poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  			else {  				if (i == 0)  					p = new Vector2 (x0' y0);  				else if (i == 2)  					p = new Vector2 (x1' y0);  				else if (i == 4)  					p = new Vector2 (x1' y1);  				else if (i == 6)  					p = new Vector2 (x0' y1);  				else if (i == 1)  					p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  				else if (i == 5)  					p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  				else if (i == 3)  					p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  				else  					p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  				pi = poly.Points.Insert (pi' p);  			}  			poly.Length++;  		}  	}  	//poly.simplify(float.Epsilon'float.Epsilon);  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (val != 0) {  	CxFastListNode<Vector2> pi = null;  	for (int i = 0; i < 8; i++) {  		Vector2 p;  		if ((val & (1 << i)) != 0) {  			if (i == 7 && (val & 1) == 0)  				poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  			else {  				if (i == 0)  					p = new Vector2 (x0' y0);  				else if (i == 2)  					p = new Vector2 (x1' y0);  				else if (i == 4)  					p = new Vector2 (x1' y1);  				else if (i == 6)  					p = new Vector2 (x0' y1);  				else if (i == 1)  					p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  				else if (i == 5)  					p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  				else if (i == 3)  					p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  				else  					p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  				pi = poly.Points.Insert (pi' p);  			}  			poly.Length++;  		}  	}  	//poly.simplify(float.Epsilon'float.Epsilon);  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (val != 0) {  	CxFastListNode<Vector2> pi = null;  	for (int i = 0; i < 8; i++) {  		Vector2 p;  		if ((val & (1 << i)) != 0) {  			if (i == 7 && (val & 1) == 0)  				poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  			else {  				if (i == 0)  					p = new Vector2 (x0' y0);  				else if (i == 2)  					p = new Vector2 (x1' y0);  				else if (i == 4)  					p = new Vector2 (x1' y1);  				else if (i == 6)  					p = new Vector2 (x0' y1);  				else if (i == 1)  					p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  				else if (i == 5)  					p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  				else if (i == 3)  					p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  				else  					p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  				pi = poly.Points.Insert (pi' p);  			}  			poly.Length++;  		}  	}  	//poly.simplify(float.Epsilon'float.Epsilon);  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	Vector2 p;  	if ((val & (1 << i)) != 0) {  		if (i == 7 && (val & 1) == 0)  			poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  		else {  			if (i == 0)  				p = new Vector2 (x0' y0);  			else if (i == 2)  				p = new Vector2 (x1' y0);  			else if (i == 4)  				p = new Vector2 (x1' y1);  			else if (i == 6)  				p = new Vector2 (x0' y1);  			else if (i == 1)  				p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  			else if (i == 5)  				p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  			else if (i == 3)  				p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  			else  				p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  			pi = poly.Points.Insert (pi' p);  		}  		poly.Length++;  	}  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	Vector2 p;  	if ((val & (1 << i)) != 0) {  		if (i == 7 && (val & 1) == 0)  			poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  		else {  			if (i == 0)  				p = new Vector2 (x0' y0);  			else if (i == 2)  				p = new Vector2 (x1' y0);  			else if (i == 4)  				p = new Vector2 (x1' y1);  			else if (i == 6)  				p = new Vector2 (x0' y1);  			else if (i == 1)  				p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  			else if (i == 5)  				p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  			else if (i == 3)  				p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  			else  				p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  			pi = poly.Points.Insert (pi' p);  		}  		poly.Length++;  	}  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	Vector2 p;  	if ((val & (1 << i)) != 0) {  		if (i == 7 && (val & 1) == 0)  			poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  		else {  			if (i == 0)  				p = new Vector2 (x0' y0);  			else if (i == 2)  				p = new Vector2 (x1' y0);  			else if (i == 4)  				p = new Vector2 (x1' y1);  			else if (i == 6)  				p = new Vector2 (x0' y1);  			else if (i == 1)  				p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  			else if (i == 5)  				p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  			else if (i == 3)  				p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  			else  				p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  			pi = poly.Points.Insert (pi' p);  		}  		poly.Length++;  	}  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	Vector2 p;  	if ((val & (1 << i)) != 0) {  		if (i == 7 && (val & 1) == 0)  			poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  		else {  			if (i == 0)  				p = new Vector2 (x0' y0);  			else if (i == 2)  				p = new Vector2 (x1' y0);  			else if (i == 4)  				p = new Vector2 (x1' y1);  			else if (i == 6)  				p = new Vector2 (x0' y1);  			else if (i == 1)  				p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  			else if (i == 5)  				p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  			else if (i == 3)  				p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  			else  				p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  			pi = poly.Points.Insert (pi' p);  		}  		poly.Length++;  	}  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	Vector2 p;  	if ((val & (1 << i)) != 0) {  		if (i == 7 && (val & 1) == 0)  			poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  		else {  			if (i == 0)  				p = new Vector2 (x0' y0);  			else if (i == 2)  				p = new Vector2 (x1' y0);  			else if (i == 4)  				p = new Vector2 (x1' y1);  			else if (i == 6)  				p = new Vector2 (x0' y1);  			else if (i == 1)  				p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  			else if (i == 5)  				p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  			else if (i == 3)  				p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  			else  				p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  			pi = poly.Points.Insert (pi' p);  		}  		poly.Length++;  	}  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	Vector2 p;  	if ((val & (1 << i)) != 0) {  		if (i == 7 && (val & 1) == 0)  			poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  		else {  			if (i == 0)  				p = new Vector2 (x0' y0);  			else if (i == 2)  				p = new Vector2 (x1' y0);  			else if (i == 4)  				p = new Vector2 (x1' y1);  			else if (i == 6)  				p = new Vector2 (x0' y1);  			else if (i == 1)  				p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  			else if (i == 5)  				p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  			else if (i == 3)  				p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  			else  				p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  			pi = poly.Points.Insert (pi' p);  		}  		poly.Length++;  	}  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	Vector2 p;  	if ((val & (1 << i)) != 0) {  		if (i == 7 && (val & 1) == 0)  			poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  		else {  			if (i == 0)  				p = new Vector2 (x0' y0);  			else if (i == 2)  				p = new Vector2 (x1' y0);  			else if (i == 4)  				p = new Vector2 (x1' y1);  			else if (i == 6)  				p = new Vector2 (x0' y1);  			else if (i == 1)  				p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  			else if (i == 5)  				p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  			else if (i == 3)  				p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  			else  				p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  			pi = poly.Points.Insert (pi' p);  		}  		poly.Length++;  	}  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if ((val & (1 << i)) != 0) {  	if (i == 7 && (val & 1) == 0)  		poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  	else {  		if (i == 0)  			p = new Vector2 (x0' y0);  		else if (i == 2)  			p = new Vector2 (x1' y0);  		else if (i == 4)  			p = new Vector2 (x1' y1);  		else if (i == 6)  			p = new Vector2 (x0' y1);  		else if (i == 1)  			p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  		else if (i == 5)  			p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  		else if (i == 3)  			p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  		else  			p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  		pi = poly.Points.Insert (pi' p);  	}  	poly.Length++;  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if ((val & (1 << i)) != 0) {  	if (i == 7 && (val & 1) == 0)  		poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  	else {  		if (i == 0)  			p = new Vector2 (x0' y0);  		else if (i == 2)  			p = new Vector2 (x1' y0);  		else if (i == 4)  			p = new Vector2 (x1' y1);  		else if (i == 6)  			p = new Vector2 (x0' y1);  		else if (i == 1)  			p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  		else if (i == 5)  			p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  		else if (i == 3)  			p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  		else  			p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  		pi = poly.Points.Insert (pi' p);  	}  	poly.Length++;  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if ((val & (1 << i)) != 0) {  	if (i == 7 && (val & 1) == 0)  		poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  	else {  		if (i == 0)  			p = new Vector2 (x0' y0);  		else if (i == 2)  			p = new Vector2 (x1' y0);  		else if (i == 4)  			p = new Vector2 (x1' y1);  		else if (i == 6)  			p = new Vector2 (x0' y1);  		else if (i == 1)  			p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  		else if (i == 5)  			p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  		else if (i == 3)  			p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  		else  			p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  		pi = poly.Points.Insert (pi' p);  	}  	poly.Length++;  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if ((val & (1 << i)) != 0) {  	if (i == 7 && (val & 1) == 0)  		poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  	else {  		if (i == 0)  			p = new Vector2 (x0' y0);  		else if (i == 2)  			p = new Vector2 (x1' y0);  		else if (i == 4)  			p = new Vector2 (x1' y1);  		else if (i == 6)  			p = new Vector2 (x0' y1);  		else if (i == 1)  			p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  		else if (i == 5)  			p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  		else if (i == 3)  			p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  		else  			p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  		pi = poly.Points.Insert (pi' p);  	}  	poly.Length++;  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if ((val & (1 << i)) != 0) {  	if (i == 7 && (val & 1) == 0)  		poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  	else {  		if (i == 0)  			p = new Vector2 (x0' y0);  		else if (i == 2)  			p = new Vector2 (x1' y0);  		else if (i == 4)  			p = new Vector2 (x1' y1);  		else if (i == 6)  			p = new Vector2 (x0' y1);  		else if (i == 1)  			p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  		else if (i == 5)  			p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  		else if (i == 3)  			p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  		else  			p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  		pi = poly.Points.Insert (pi' p);  	}  	poly.Length++;  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if ((val & (1 << i)) != 0) {  	if (i == 7 && (val & 1) == 0)  		poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  	else {  		if (i == 0)  			p = new Vector2 (x0' y0);  		else if (i == 2)  			p = new Vector2 (x1' y0);  		else if (i == 4)  			p = new Vector2 (x1' y1);  		else if (i == 6)  			p = new Vector2 (x0' y1);  		else if (i == 1)  			p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  		else if (i == 5)  			p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  		else if (i == 3)  			p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  		else  			p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  		pi = poly.Points.Insert (pi' p);  	}  	poly.Length++;  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 7 && (val & 1) == 0)  	poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  else {  	if (i == 0)  		p = new Vector2 (x0' y0);  	else if (i == 2)  		p = new Vector2 (x1' y0);  	else if (i == 4)  		p = new Vector2 (x1' y1);  	else if (i == 6)  		p = new Vector2 (x0' y1);  	else if (i == 1)  		p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  	else if (i == 5)  		p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  	else if (i == 3)  		p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  	else  		p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  	pi = poly.Points.Insert (pi' p);  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 7 && (val & 1) == 0)  	poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  else {  	if (i == 0)  		p = new Vector2 (x0' y0);  	else if (i == 2)  		p = new Vector2 (x1' y0);  	else if (i == 4)  		p = new Vector2 (x1' y1);  	else if (i == 6)  		p = new Vector2 (x0' y1);  	else if (i == 1)  		p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  	else if (i == 5)  		p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  	else if (i == 3)  		p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  	else  		p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  	pi = poly.Points.Insert (pi' p);  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 7 && (val & 1) == 0)  	poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  else {  	if (i == 0)  		p = new Vector2 (x0' y0);  	else if (i == 2)  		p = new Vector2 (x1' y0);  	else if (i == 4)  		p = new Vector2 (x1' y1);  	else if (i == 6)  		p = new Vector2 (x0' y1);  	else if (i == 1)  		p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  	else if (i == 5)  		p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  	else if (i == 3)  		p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  	else  		p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  	pi = poly.Points.Insert (pi' p);  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 7 && (val & 1) == 0)  	poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  else {  	if (i == 0)  		p = new Vector2 (x0' y0);  	else if (i == 2)  		p = new Vector2 (x1' y0);  	else if (i == 4)  		p = new Vector2 (x1' y1);  	else if (i == 6)  		p = new Vector2 (x0' y1);  	else if (i == 1)  		p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  	else if (i == 5)  		p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  	else if (i == 3)  		p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  	else  		p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  	pi = poly.Points.Insert (pi' p);  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 7 && (val & 1) == 0)  	poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  else {  	if (i == 0)  		p = new Vector2 (x0' y0);  	else if (i == 2)  		p = new Vector2 (x1' y0);  	else if (i == 4)  		p = new Vector2 (x1' y1);  	else if (i == 6)  		p = new Vector2 (x0' y1);  	else if (i == 1)  		p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  	else if (i == 5)  		p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  	else if (i == 3)  		p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  	else  		p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  	pi = poly.Points.Insert (pi' p);  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 7 && (val & 1) == 0)  	poly.Points.Add (p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin)));  else {  	if (i == 0)  		p = new Vector2 (x0' y0);  	else if (i == 2)  		p = new Vector2 (x1' y0);  	else if (i == 4)  		p = new Vector2 (x1' y1);  	else if (i == 6)  		p = new Vector2 (x0' y1);  	else if (i == 1)  		p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  	else if (i == 5)  		p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  	else if (i == 3)  		p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  	else  		p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  	pi = poly.Points.Insert (pi' p);  }  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 0)  	p = new Vector2 (x0' y0);  else if (i == 2)  	p = new Vector2 (x1' y0);  else if (i == 4)  	p = new Vector2 (x1' y1);  else if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 0)  	p = new Vector2 (x0' y0);  else if (i == 2)  	p = new Vector2 (x1' y0);  else if (i == 4)  	p = new Vector2 (x1' y1);  else if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 0)  	p = new Vector2 (x0' y0);  else if (i == 2)  	p = new Vector2 (x1' y0);  else if (i == 4)  	p = new Vector2 (x1' y1);  else if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 0)  	p = new Vector2 (x0' y0);  else if (i == 2)  	p = new Vector2 (x1' y0);  else if (i == 4)  	p = new Vector2 (x1' y1);  else if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 0)  	p = new Vector2 (x0' y0);  else if (i == 2)  	p = new Vector2 (x1' y0);  else if (i == 4)  	p = new Vector2 (x1' y1);  else if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 2)  	p = new Vector2 (x1' y0);  else if (i == 4)  	p = new Vector2 (x1' y1);  else if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 2)  	p = new Vector2 (x1' y0);  else if (i == 4)  	p = new Vector2 (x1' y1);  else if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 2)  	p = new Vector2 (x1' y0);  else if (i == 4)  	p = new Vector2 (x1' y1);  else if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 2)  	p = new Vector2 (x1' y0);  else if (i == 4)  	p = new Vector2 (x1' y1);  else if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 2)  	p = new Vector2 (x1' y0);  else if (i == 4)  	p = new Vector2 (x1' y1);  else if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 4)  	p = new Vector2 (x1' y1);  else if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 4)  	p = new Vector2 (x1' y1);  else if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 4)  	p = new Vector2 (x1' y1);  else if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 4)  	p = new Vector2 (x1' y1);  else if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 6)  	p = new Vector2 (x0' y1);  else if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 1)  	p = new Vector2 (Xlerp (x0' x1' y0' v0' v1' f' bin)' y0);  else if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 5)  	p = new Vector2 (Xlerp (x0' x1' y1' v3' v2' f' bin)' y1);  else if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (i == 3)  	p = new Vector2 (x1' Ylerp (y0' y1' x1' v1' v2' f' bin));  else  	p = new Vector2 (x0' Ylerp (y0' y1' x0' v0' v3' f' bin));  
Magic Number,FarseerPhysics.Common,MSTerrain,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MSTerrain.cs,MSTerrain,The following statement contains a magic number: Width = area.Extents.X * 2;  
Magic Number,FarseerPhysics.Common,MSTerrain,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MSTerrain.cs,MSTerrain,The following statement contains a magic number: Height = area.Extents.Y * 2;  
Magic Number,FarseerPhysics.Common,MSTerrain,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MSTerrain.cs,GenerateTerrain,The following statement contains a magic number: foreach (var item in polys) {  	// does this need to be negative?  	item.Scale (ref scale);  	item.Translate (ref _topLeft);  	item.ForceCounterClockWise ();  	Vertices p = FarseerPhysics.Common.PolygonManipulation.SimplifyTools.CollinearSimplify (item);  	List<Vertices> decompPolys = new List<Vertices> ();  	switch (Decomposer) {  	case Decomposer.Bayazit:  		decompPolys = Decomposition.BayazitDecomposer.ConvexPartition (p);  		break;  	case Decomposer.CDT:  		decompPolys = Decomposition.CDTDecomposer.ConvexPartition (p);  		break;  	case Decomposer.Earclip:  		decompPolys = Decomposition.EarclipDecomposer.ConvexPartition (p);  		break;  	case Decomposer.Flipcode:  		decompPolys = Decomposition.FlipcodeDecomposer.ConvexPartition (p);  		break;  	case Decomposer.Seidel:  		decompPolys = Decomposition.SeidelDecomposer.ConvexPartition (p' 0.001f);  		break;  	default:  		break;  	}  	foreach (Vertices poly in decompPolys) {  		if (poly.Count > 2)  			_bodyMap [gx' gy].Add (BodyFactory.CreatePolygon (World' poly' 1));  	}  }  
Magic Number,FarseerPhysics.Common,MSTerrain,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MSTerrain.cs,GenerateTerrain,The following statement contains a magic number: foreach (Vertices poly in decompPolys) {  	if (poly.Count > 2)  		_bodyMap [gx' gy].Add (BodyFactory.CreatePolygon (World' poly' 1));  }  
Magic Number,FarseerPhysics.Common,MSTerrain,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\MSTerrain.cs,GenerateTerrain,The following statement contains a magic number: if (poly.Count > 2)  	_bodyMap [gx' gy].Add (BodyFactory.CreatePolygon (World' poly' 1));  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,Initialize,The following statement contains a magic number: if (alphaTolerance.HasValue)  	AlphaTolerance = alphaTolerance.Value;  else  	AlphaTolerance = 20;  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,Initialize,The following statement contains a magic number: AlphaTolerance = 20;  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,SetTextureData,The following statement contains a magic number: if (data.Length < 4)  	throw new ArgumentOutOfRangeException ("data"' "'data' length can't be less then 4. Your texture must be at least 2 x 2 pixels in size.");  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,SetTextureData,The following statement contains a magic number: if (width < 2)  	throw new ArgumentOutOfRangeException ("width"' "'width' can't be less then 2. Your texture must be at least 2 x 2 pixels in size.");  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: if (_data.Length < 4)  	throw new Exception ("'_data' length can't be less then 4. Your texture must be at least 2 x 2 pixels in size. " + "You have to use SetTextureData(uint[] data' int width) before calling this method.");  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: if (_width < 2)  	throw new Exception ("'_width' can't be less then 2. Your texture must be at least 2 x 2 pixels in size. " + "You have to use SetTextureData(uint[] data' int width) before calling this method.");  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: do {  	if (detectedPolygons.Count == 0) {  		// First pass / single polygon  		polygon = new DetectedVertices (CreateSimplePolygon (Vector2.Zero' Vector2.Zero));  		if (polygon.Count > 2)  			polygonEntrance = GetTopMostVertex (polygon);  	}  	else if (polygonEntrance.HasValue) {  		// Multi pass / multiple polygons  		polygon = new DetectedVertices (CreateSimplePolygon (polygonEntrance.Value' new Vector2 (polygonEntrance.Value.X - 1f' polygonEntrance.Value.Y)));  	}  	else  		break;  	searchOn = false;  	if (polygon.Count > 2) {  		if (_holeDetection) {  			do {  				holeEntrance = SearchHoleEntrance (polygon' holeEntrance);  				if (holeEntrance.HasValue) {  					if (!blackList.Contains (holeEntrance.Value)) {  						blackList.Add (holeEntrance.Value);  						holePolygon = CreateSimplePolygon (holeEntrance.Value' new Vector2 (holeEntrance.Value.X + 1' holeEntrance.Value.Y));  						if (holePolygon != null && holePolygon.Count > 2) {  							switch (_polygonDetectionType) {  							case VerticesDetectionType.Integrated:  								// Add first hole polygon vertex to close the hole polygon.  								holePolygon.Add (holePolygon [0]);  								int vertex1Index' vertex2Index;  								if (SplitPolygonEdge (polygon' holeEntrance.Value' out vertex1Index' out vertex2Index))  									polygon.InsertRange (vertex2Index' holePolygon);  								break;  							case VerticesDetectionType.Separated:  								if (polygon.Holes == null)  									polygon.Holes = new List<Vertices> ();  								polygon.Holes.Add (holePolygon);  								break;  							}  						}  					}  					else  						break;  				}  				else  					break;  			}  			while (true);  		}  		detectedPolygons.Add (polygon);  	}  	if (_multipartDetection || polygon.Count <= 2) {  		if (SearchNextHullEntrance (detectedPolygons' polygonEntrance.Value' out polygonEntrance))  			searchOn = true;  	}  }  while (searchOn);  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: do {  	if (detectedPolygons.Count == 0) {  		// First pass / single polygon  		polygon = new DetectedVertices (CreateSimplePolygon (Vector2.Zero' Vector2.Zero));  		if (polygon.Count > 2)  			polygonEntrance = GetTopMostVertex (polygon);  	}  	else if (polygonEntrance.HasValue) {  		// Multi pass / multiple polygons  		polygon = new DetectedVertices (CreateSimplePolygon (polygonEntrance.Value' new Vector2 (polygonEntrance.Value.X - 1f' polygonEntrance.Value.Y)));  	}  	else  		break;  	searchOn = false;  	if (polygon.Count > 2) {  		if (_holeDetection) {  			do {  				holeEntrance = SearchHoleEntrance (polygon' holeEntrance);  				if (holeEntrance.HasValue) {  					if (!blackList.Contains (holeEntrance.Value)) {  						blackList.Add (holeEntrance.Value);  						holePolygon = CreateSimplePolygon (holeEntrance.Value' new Vector2 (holeEntrance.Value.X + 1' holeEntrance.Value.Y));  						if (holePolygon != null && holePolygon.Count > 2) {  							switch (_polygonDetectionType) {  							case VerticesDetectionType.Integrated:  								// Add first hole polygon vertex to close the hole polygon.  								holePolygon.Add (holePolygon [0]);  								int vertex1Index' vertex2Index;  								if (SplitPolygonEdge (polygon' holeEntrance.Value' out vertex1Index' out vertex2Index))  									polygon.InsertRange (vertex2Index' holePolygon);  								break;  							case VerticesDetectionType.Separated:  								if (polygon.Holes == null)  									polygon.Holes = new List<Vertices> ();  								polygon.Holes.Add (holePolygon);  								break;  							}  						}  					}  					else  						break;  				}  				else  					break;  			}  			while (true);  		}  		detectedPolygons.Add (polygon);  	}  	if (_multipartDetection || polygon.Count <= 2) {  		if (SearchNextHullEntrance (detectedPolygons' polygonEntrance.Value' out polygonEntrance))  			searchOn = true;  	}  }  while (searchOn);  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: do {  	if (detectedPolygons.Count == 0) {  		// First pass / single polygon  		polygon = new DetectedVertices (CreateSimplePolygon (Vector2.Zero' Vector2.Zero));  		if (polygon.Count > 2)  			polygonEntrance = GetTopMostVertex (polygon);  	}  	else if (polygonEntrance.HasValue) {  		// Multi pass / multiple polygons  		polygon = new DetectedVertices (CreateSimplePolygon (polygonEntrance.Value' new Vector2 (polygonEntrance.Value.X - 1f' polygonEntrance.Value.Y)));  	}  	else  		break;  	searchOn = false;  	if (polygon.Count > 2) {  		if (_holeDetection) {  			do {  				holeEntrance = SearchHoleEntrance (polygon' holeEntrance);  				if (holeEntrance.HasValue) {  					if (!blackList.Contains (holeEntrance.Value)) {  						blackList.Add (holeEntrance.Value);  						holePolygon = CreateSimplePolygon (holeEntrance.Value' new Vector2 (holeEntrance.Value.X + 1' holeEntrance.Value.Y));  						if (holePolygon != null && holePolygon.Count > 2) {  							switch (_polygonDetectionType) {  							case VerticesDetectionType.Integrated:  								// Add first hole polygon vertex to close the hole polygon.  								holePolygon.Add (holePolygon [0]);  								int vertex1Index' vertex2Index;  								if (SplitPolygonEdge (polygon' holeEntrance.Value' out vertex1Index' out vertex2Index))  									polygon.InsertRange (vertex2Index' holePolygon);  								break;  							case VerticesDetectionType.Separated:  								if (polygon.Holes == null)  									polygon.Holes = new List<Vertices> ();  								polygon.Holes.Add (holePolygon);  								break;  							}  						}  					}  					else  						break;  				}  				else  					break;  			}  			while (true);  		}  		detectedPolygons.Add (polygon);  	}  	if (_multipartDetection || polygon.Count <= 2) {  		if (SearchNextHullEntrance (detectedPolygons' polygonEntrance.Value' out polygonEntrance))  			searchOn = true;  	}  }  while (searchOn);  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: do {  	if (detectedPolygons.Count == 0) {  		// First pass / single polygon  		polygon = new DetectedVertices (CreateSimplePolygon (Vector2.Zero' Vector2.Zero));  		if (polygon.Count > 2)  			polygonEntrance = GetTopMostVertex (polygon);  	}  	else if (polygonEntrance.HasValue) {  		// Multi pass / multiple polygons  		polygon = new DetectedVertices (CreateSimplePolygon (polygonEntrance.Value' new Vector2 (polygonEntrance.Value.X - 1f' polygonEntrance.Value.Y)));  	}  	else  		break;  	searchOn = false;  	if (polygon.Count > 2) {  		if (_holeDetection) {  			do {  				holeEntrance = SearchHoleEntrance (polygon' holeEntrance);  				if (holeEntrance.HasValue) {  					if (!blackList.Contains (holeEntrance.Value)) {  						blackList.Add (holeEntrance.Value);  						holePolygon = CreateSimplePolygon (holeEntrance.Value' new Vector2 (holeEntrance.Value.X + 1' holeEntrance.Value.Y));  						if (holePolygon != null && holePolygon.Count > 2) {  							switch (_polygonDetectionType) {  							case VerticesDetectionType.Integrated:  								// Add first hole polygon vertex to close the hole polygon.  								holePolygon.Add (holePolygon [0]);  								int vertex1Index' vertex2Index;  								if (SplitPolygonEdge (polygon' holeEntrance.Value' out vertex1Index' out vertex2Index))  									polygon.InsertRange (vertex2Index' holePolygon);  								break;  							case VerticesDetectionType.Separated:  								if (polygon.Holes == null)  									polygon.Holes = new List<Vertices> ();  								polygon.Holes.Add (holePolygon);  								break;  							}  						}  					}  					else  						break;  				}  				else  					break;  			}  			while (true);  		}  		detectedPolygons.Add (polygon);  	}  	if (_multipartDetection || polygon.Count <= 2) {  		if (SearchNextHullEntrance (detectedPolygons' polygonEntrance.Value' out polygonEntrance))  			searchOn = true;  	}  }  while (searchOn);  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: if (detectedPolygons.Count == 0) {  	// First pass / single polygon  	polygon = new DetectedVertices (CreateSimplePolygon (Vector2.Zero' Vector2.Zero));  	if (polygon.Count > 2)  		polygonEntrance = GetTopMostVertex (polygon);  }  else if (polygonEntrance.HasValue) {  	// Multi pass / multiple polygons  	polygon = new DetectedVertices (CreateSimplePolygon (polygonEntrance.Value' new Vector2 (polygonEntrance.Value.X - 1f' polygonEntrance.Value.Y)));  }  else  	break;  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: if (polygon.Count > 2)  	polygonEntrance = GetTopMostVertex (polygon);  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: if (polygon.Count > 2) {  	if (_holeDetection) {  		do {  			holeEntrance = SearchHoleEntrance (polygon' holeEntrance);  			if (holeEntrance.HasValue) {  				if (!blackList.Contains (holeEntrance.Value)) {  					blackList.Add (holeEntrance.Value);  					holePolygon = CreateSimplePolygon (holeEntrance.Value' new Vector2 (holeEntrance.Value.X + 1' holeEntrance.Value.Y));  					if (holePolygon != null && holePolygon.Count > 2) {  						switch (_polygonDetectionType) {  						case VerticesDetectionType.Integrated:  							// Add first hole polygon vertex to close the hole polygon.  							holePolygon.Add (holePolygon [0]);  							int vertex1Index' vertex2Index;  							if (SplitPolygonEdge (polygon' holeEntrance.Value' out vertex1Index' out vertex2Index))  								polygon.InsertRange (vertex2Index' holePolygon);  							break;  						case VerticesDetectionType.Separated:  							if (polygon.Holes == null)  								polygon.Holes = new List<Vertices> ();  							polygon.Holes.Add (holePolygon);  							break;  						}  					}  				}  				else  					break;  			}  			else  				break;  		}  		while (true);  	}  	detectedPolygons.Add (polygon);  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: if (polygon.Count > 2) {  	if (_holeDetection) {  		do {  			holeEntrance = SearchHoleEntrance (polygon' holeEntrance);  			if (holeEntrance.HasValue) {  				if (!blackList.Contains (holeEntrance.Value)) {  					blackList.Add (holeEntrance.Value);  					holePolygon = CreateSimplePolygon (holeEntrance.Value' new Vector2 (holeEntrance.Value.X + 1' holeEntrance.Value.Y));  					if (holePolygon != null && holePolygon.Count > 2) {  						switch (_polygonDetectionType) {  						case VerticesDetectionType.Integrated:  							// Add first hole polygon vertex to close the hole polygon.  							holePolygon.Add (holePolygon [0]);  							int vertex1Index' vertex2Index;  							if (SplitPolygonEdge (polygon' holeEntrance.Value' out vertex1Index' out vertex2Index))  								polygon.InsertRange (vertex2Index' holePolygon);  							break;  						case VerticesDetectionType.Separated:  							if (polygon.Holes == null)  								polygon.Holes = new List<Vertices> ();  							polygon.Holes.Add (holePolygon);  							break;  						}  					}  				}  				else  					break;  			}  			else  				break;  		}  		while (true);  	}  	detectedPolygons.Add (polygon);  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: if (_holeDetection) {  	do {  		holeEntrance = SearchHoleEntrance (polygon' holeEntrance);  		if (holeEntrance.HasValue) {  			if (!blackList.Contains (holeEntrance.Value)) {  				blackList.Add (holeEntrance.Value);  				holePolygon = CreateSimplePolygon (holeEntrance.Value' new Vector2 (holeEntrance.Value.X + 1' holeEntrance.Value.Y));  				if (holePolygon != null && holePolygon.Count > 2) {  					switch (_polygonDetectionType) {  					case VerticesDetectionType.Integrated:  						// Add first hole polygon vertex to close the hole polygon.  						holePolygon.Add (holePolygon [0]);  						int vertex1Index' vertex2Index;  						if (SplitPolygonEdge (polygon' holeEntrance.Value' out vertex1Index' out vertex2Index))  							polygon.InsertRange (vertex2Index' holePolygon);  						break;  					case VerticesDetectionType.Separated:  						if (polygon.Holes == null)  							polygon.Holes = new List<Vertices> ();  						polygon.Holes.Add (holePolygon);  						break;  					}  				}  			}  			else  				break;  		}  		else  			break;  	}  	while (true);  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: do {  	holeEntrance = SearchHoleEntrance (polygon' holeEntrance);  	if (holeEntrance.HasValue) {  		if (!blackList.Contains (holeEntrance.Value)) {  			blackList.Add (holeEntrance.Value);  			holePolygon = CreateSimplePolygon (holeEntrance.Value' new Vector2 (holeEntrance.Value.X + 1' holeEntrance.Value.Y));  			if (holePolygon != null && holePolygon.Count > 2) {  				switch (_polygonDetectionType) {  				case VerticesDetectionType.Integrated:  					// Add first hole polygon vertex to close the hole polygon.  					holePolygon.Add (holePolygon [0]);  					int vertex1Index' vertex2Index;  					if (SplitPolygonEdge (polygon' holeEntrance.Value' out vertex1Index' out vertex2Index))  						polygon.InsertRange (vertex2Index' holePolygon);  					break;  				case VerticesDetectionType.Separated:  					if (polygon.Holes == null)  						polygon.Holes = new List<Vertices> ();  					polygon.Holes.Add (holePolygon);  					break;  				}  			}  		}  		else  			break;  	}  	else  		break;  }  while (true);  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: if (holeEntrance.HasValue) {  	if (!blackList.Contains (holeEntrance.Value)) {  		blackList.Add (holeEntrance.Value);  		holePolygon = CreateSimplePolygon (holeEntrance.Value' new Vector2 (holeEntrance.Value.X + 1' holeEntrance.Value.Y));  		if (holePolygon != null && holePolygon.Count > 2) {  			switch (_polygonDetectionType) {  			case VerticesDetectionType.Integrated:  				// Add first hole polygon vertex to close the hole polygon.  				holePolygon.Add (holePolygon [0]);  				int vertex1Index' vertex2Index;  				if (SplitPolygonEdge (polygon' holeEntrance.Value' out vertex1Index' out vertex2Index))  					polygon.InsertRange (vertex2Index' holePolygon);  				break;  			case VerticesDetectionType.Separated:  				if (polygon.Holes == null)  					polygon.Holes = new List<Vertices> ();  				polygon.Holes.Add (holePolygon);  				break;  			}  		}  	}  	else  		break;  }  else  	break;  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: if (!blackList.Contains (holeEntrance.Value)) {  	blackList.Add (holeEntrance.Value);  	holePolygon = CreateSimplePolygon (holeEntrance.Value' new Vector2 (holeEntrance.Value.X + 1' holeEntrance.Value.Y));  	if (holePolygon != null && holePolygon.Count > 2) {  		switch (_polygonDetectionType) {  		case VerticesDetectionType.Integrated:  			// Add first hole polygon vertex to close the hole polygon.  			holePolygon.Add (holePolygon [0]);  			int vertex1Index' vertex2Index;  			if (SplitPolygonEdge (polygon' holeEntrance.Value' out vertex1Index' out vertex2Index))  				polygon.InsertRange (vertex2Index' holePolygon);  			break;  		case VerticesDetectionType.Separated:  			if (polygon.Holes == null)  				polygon.Holes = new List<Vertices> ();  			polygon.Holes.Add (holePolygon);  			break;  		}  	}  }  else  	break;  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: if (holePolygon != null && holePolygon.Count > 2) {  	switch (_polygonDetectionType) {  	case VerticesDetectionType.Integrated:  		// Add first hole polygon vertex to close the hole polygon.  		holePolygon.Add (holePolygon [0]);  		int vertex1Index' vertex2Index;  		if (SplitPolygonEdge (polygon' holeEntrance.Value' out vertex1Index' out vertex2Index))  			polygon.InsertRange (vertex2Index' holePolygon);  		break;  	case VerticesDetectionType.Separated:  		if (polygon.Holes == null)  			polygon.Holes = new List<Vertices> ();  		polygon.Holes.Add (holePolygon);  		break;  	}  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: if (_multipartDetection || polygon.Count <= 2) {  	if (SearchNextHullEntrance (detectedPolygons' polygonEntrance.Value' out polygonEntrance))  		searchOn = true;  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: if (polygon.Count < 3)  	throw new ArgumentException ("'polygon.MainPolygon.Count' can't be less then 3.");  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: if (startY > 0 && startY < _height && endY > 0 && endY < _height) {  	// go from top to bottom of the polygon  	for (int y = startY; y <= endY; y++) {  		// get x-coord of every polygon edge which crosses y  		xCoords = SearchCrossingEdges (polygon' y);  		// We need an even number of crossing edges.   		// It's always a pair of start and end edge: nothing | polygon | hole | polygon | nothing ...  		// If it's not then don't bother' it's probably a peak ...  		// ...which should be filtered out by SearchCrossingEdges() anyway.  		if (xCoords.Count > 1 && xCoords.Count % 2 == 0) {  			// Ok' this is short' but probably a little bit confusing.  			// This part searches from left to right between the edges inside the polygon.  			// The problem: We are using the polygon data to search in the texture data.  			// That's simply not accurate' but necessary because of performance.  			for (int i = 0; i < xCoords.Count; i += 2) {  				foundSolid = false;  				foundTransparent = false;  				// We search between the edges inside the polygon.  				for (int x = (int)xCoords [i]; x <= (int)xCoords [i + 1]; x++) {  					// First pass: IsSolid might return false.  					// In that case the polygon edge doesn't lie on the texture's solid pixel' because of the hull tolearance.  					// If the edge lies before the first solid pixel then we need to skip our transparent pixel finds.  					// The algorithm starts to search for a relevant transparent pixel (which indicates a possible hole)   					// after it has found a solid pixel.  					// After we've found a solid and a transparent pixel (a hole's left edge)   					// we search for a solid pixel again (a hole's right edge).  					// When found the distance of that coodrinate has to be greater then the hull tolerance.  					if (IsSolid (ref x' ref y)) {  						if (!foundTransparent) {  							foundSolid = true;  							lastSolid = x;  						}  						if (foundSolid && foundTransparent) {  							entrance = new Vector2 (lastSolid' y);  							if (DistanceToHullAcceptable (polygon' entrance.Value' true))  								return entrance;  							entrance = null;  							break;  						}  					}  					else {  						if (foundSolid)  							foundTransparent = true;  					}  				}  			}  		}  		else {  			if (xCoords.Count % 2 == 0)  				Debug.WriteLine ("SearchCrossingEdges() % 2 != 0");  		}  	}  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: if (startY > 0 && startY < _height && endY > 0 && endY < _height) {  	// go from top to bottom of the polygon  	for (int y = startY; y <= endY; y++) {  		// get x-coord of every polygon edge which crosses y  		xCoords = SearchCrossingEdges (polygon' y);  		// We need an even number of crossing edges.   		// It's always a pair of start and end edge: nothing | polygon | hole | polygon | nothing ...  		// If it's not then don't bother' it's probably a peak ...  		// ...which should be filtered out by SearchCrossingEdges() anyway.  		if (xCoords.Count > 1 && xCoords.Count % 2 == 0) {  			// Ok' this is short' but probably a little bit confusing.  			// This part searches from left to right between the edges inside the polygon.  			// The problem: We are using the polygon data to search in the texture data.  			// That's simply not accurate' but necessary because of performance.  			for (int i = 0; i < xCoords.Count; i += 2) {  				foundSolid = false;  				foundTransparent = false;  				// We search between the edges inside the polygon.  				for (int x = (int)xCoords [i]; x <= (int)xCoords [i + 1]; x++) {  					// First pass: IsSolid might return false.  					// In that case the polygon edge doesn't lie on the texture's solid pixel' because of the hull tolearance.  					// If the edge lies before the first solid pixel then we need to skip our transparent pixel finds.  					// The algorithm starts to search for a relevant transparent pixel (which indicates a possible hole)   					// after it has found a solid pixel.  					// After we've found a solid and a transparent pixel (a hole's left edge)   					// we search for a solid pixel again (a hole's right edge).  					// When found the distance of that coodrinate has to be greater then the hull tolerance.  					if (IsSolid (ref x' ref y)) {  						if (!foundTransparent) {  							foundSolid = true;  							lastSolid = x;  						}  						if (foundSolid && foundTransparent) {  							entrance = new Vector2 (lastSolid' y);  							if (DistanceToHullAcceptable (polygon' entrance.Value' true))  								return entrance;  							entrance = null;  							break;  						}  					}  					else {  						if (foundSolid)  							foundTransparent = true;  					}  				}  			}  		}  		else {  			if (xCoords.Count % 2 == 0)  				Debug.WriteLine ("SearchCrossingEdges() % 2 != 0");  		}  	}  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: if (startY > 0 && startY < _height && endY > 0 && endY < _height) {  	// go from top to bottom of the polygon  	for (int y = startY; y <= endY; y++) {  		// get x-coord of every polygon edge which crosses y  		xCoords = SearchCrossingEdges (polygon' y);  		// We need an even number of crossing edges.   		// It's always a pair of start and end edge: nothing | polygon | hole | polygon | nothing ...  		// If it's not then don't bother' it's probably a peak ...  		// ...which should be filtered out by SearchCrossingEdges() anyway.  		if (xCoords.Count > 1 && xCoords.Count % 2 == 0) {  			// Ok' this is short' but probably a little bit confusing.  			// This part searches from left to right between the edges inside the polygon.  			// The problem: We are using the polygon data to search in the texture data.  			// That's simply not accurate' but necessary because of performance.  			for (int i = 0; i < xCoords.Count; i += 2) {  				foundSolid = false;  				foundTransparent = false;  				// We search between the edges inside the polygon.  				for (int x = (int)xCoords [i]; x <= (int)xCoords [i + 1]; x++) {  					// First pass: IsSolid might return false.  					// In that case the polygon edge doesn't lie on the texture's solid pixel' because of the hull tolearance.  					// If the edge lies before the first solid pixel then we need to skip our transparent pixel finds.  					// The algorithm starts to search for a relevant transparent pixel (which indicates a possible hole)   					// after it has found a solid pixel.  					// After we've found a solid and a transparent pixel (a hole's left edge)   					// we search for a solid pixel again (a hole's right edge).  					// When found the distance of that coodrinate has to be greater then the hull tolerance.  					if (IsSolid (ref x' ref y)) {  						if (!foundTransparent) {  							foundSolid = true;  							lastSolid = x;  						}  						if (foundSolid && foundTransparent) {  							entrance = new Vector2 (lastSolid' y);  							if (DistanceToHullAcceptable (polygon' entrance.Value' true))  								return entrance;  							entrance = null;  							break;  						}  					}  					else {  						if (foundSolid)  							foundTransparent = true;  					}  				}  			}  		}  		else {  			if (xCoords.Count % 2 == 0)  				Debug.WriteLine ("SearchCrossingEdges() % 2 != 0");  		}  	}  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: for (int y = startY; y <= endY; y++) {  	// get x-coord of every polygon edge which crosses y  	xCoords = SearchCrossingEdges (polygon' y);  	// We need an even number of crossing edges.   	// It's always a pair of start and end edge: nothing | polygon | hole | polygon | nothing ...  	// If it's not then don't bother' it's probably a peak ...  	// ...which should be filtered out by SearchCrossingEdges() anyway.  	if (xCoords.Count > 1 && xCoords.Count % 2 == 0) {  		// Ok' this is short' but probably a little bit confusing.  		// This part searches from left to right between the edges inside the polygon.  		// The problem: We are using the polygon data to search in the texture data.  		// That's simply not accurate' but necessary because of performance.  		for (int i = 0; i < xCoords.Count; i += 2) {  			foundSolid = false;  			foundTransparent = false;  			// We search between the edges inside the polygon.  			for (int x = (int)xCoords [i]; x <= (int)xCoords [i + 1]; x++) {  				// First pass: IsSolid might return false.  				// In that case the polygon edge doesn't lie on the texture's solid pixel' because of the hull tolearance.  				// If the edge lies before the first solid pixel then we need to skip our transparent pixel finds.  				// The algorithm starts to search for a relevant transparent pixel (which indicates a possible hole)   				// after it has found a solid pixel.  				// After we've found a solid and a transparent pixel (a hole's left edge)   				// we search for a solid pixel again (a hole's right edge).  				// When found the distance of that coodrinate has to be greater then the hull tolerance.  				if (IsSolid (ref x' ref y)) {  					if (!foundTransparent) {  						foundSolid = true;  						lastSolid = x;  					}  					if (foundSolid && foundTransparent) {  						entrance = new Vector2 (lastSolid' y);  						if (DistanceToHullAcceptable (polygon' entrance.Value' true))  							return entrance;  						entrance = null;  						break;  					}  				}  				else {  					if (foundSolid)  						foundTransparent = true;  				}  			}  		}  	}  	else {  		if (xCoords.Count % 2 == 0)  			Debug.WriteLine ("SearchCrossingEdges() % 2 != 0");  	}  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: for (int y = startY; y <= endY; y++) {  	// get x-coord of every polygon edge which crosses y  	xCoords = SearchCrossingEdges (polygon' y);  	// We need an even number of crossing edges.   	// It's always a pair of start and end edge: nothing | polygon | hole | polygon | nothing ...  	// If it's not then don't bother' it's probably a peak ...  	// ...which should be filtered out by SearchCrossingEdges() anyway.  	if (xCoords.Count > 1 && xCoords.Count % 2 == 0) {  		// Ok' this is short' but probably a little bit confusing.  		// This part searches from left to right between the edges inside the polygon.  		// The problem: We are using the polygon data to search in the texture data.  		// That's simply not accurate' but necessary because of performance.  		for (int i = 0; i < xCoords.Count; i += 2) {  			foundSolid = false;  			foundTransparent = false;  			// We search between the edges inside the polygon.  			for (int x = (int)xCoords [i]; x <= (int)xCoords [i + 1]; x++) {  				// First pass: IsSolid might return false.  				// In that case the polygon edge doesn't lie on the texture's solid pixel' because of the hull tolearance.  				// If the edge lies before the first solid pixel then we need to skip our transparent pixel finds.  				// The algorithm starts to search for a relevant transparent pixel (which indicates a possible hole)   				// after it has found a solid pixel.  				// After we've found a solid and a transparent pixel (a hole's left edge)   				// we search for a solid pixel again (a hole's right edge).  				// When found the distance of that coodrinate has to be greater then the hull tolerance.  				if (IsSolid (ref x' ref y)) {  					if (!foundTransparent) {  						foundSolid = true;  						lastSolid = x;  					}  					if (foundSolid && foundTransparent) {  						entrance = new Vector2 (lastSolid' y);  						if (DistanceToHullAcceptable (polygon' entrance.Value' true))  							return entrance;  						entrance = null;  						break;  					}  				}  				else {  					if (foundSolid)  						foundTransparent = true;  				}  			}  		}  	}  	else {  		if (xCoords.Count % 2 == 0)  			Debug.WriteLine ("SearchCrossingEdges() % 2 != 0");  	}  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: for (int y = startY; y <= endY; y++) {  	// get x-coord of every polygon edge which crosses y  	xCoords = SearchCrossingEdges (polygon' y);  	// We need an even number of crossing edges.   	// It's always a pair of start and end edge: nothing | polygon | hole | polygon | nothing ...  	// If it's not then don't bother' it's probably a peak ...  	// ...which should be filtered out by SearchCrossingEdges() anyway.  	if (xCoords.Count > 1 && xCoords.Count % 2 == 0) {  		// Ok' this is short' but probably a little bit confusing.  		// This part searches from left to right between the edges inside the polygon.  		// The problem: We are using the polygon data to search in the texture data.  		// That's simply not accurate' but necessary because of performance.  		for (int i = 0; i < xCoords.Count; i += 2) {  			foundSolid = false;  			foundTransparent = false;  			// We search between the edges inside the polygon.  			for (int x = (int)xCoords [i]; x <= (int)xCoords [i + 1]; x++) {  				// First pass: IsSolid might return false.  				// In that case the polygon edge doesn't lie on the texture's solid pixel' because of the hull tolearance.  				// If the edge lies before the first solid pixel then we need to skip our transparent pixel finds.  				// The algorithm starts to search for a relevant transparent pixel (which indicates a possible hole)   				// after it has found a solid pixel.  				// After we've found a solid and a transparent pixel (a hole's left edge)   				// we search for a solid pixel again (a hole's right edge).  				// When found the distance of that coodrinate has to be greater then the hull tolerance.  				if (IsSolid (ref x' ref y)) {  					if (!foundTransparent) {  						foundSolid = true;  						lastSolid = x;  					}  					if (foundSolid && foundTransparent) {  						entrance = new Vector2 (lastSolid' y);  						if (DistanceToHullAcceptable (polygon' entrance.Value' true))  							return entrance;  						entrance = null;  						break;  					}  				}  				else {  					if (foundSolid)  						foundTransparent = true;  				}  			}  		}  	}  	else {  		if (xCoords.Count % 2 == 0)  			Debug.WriteLine ("SearchCrossingEdges() % 2 != 0");  	}  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: if (xCoords.Count > 1 && xCoords.Count % 2 == 0) {  	// Ok' this is short' but probably a little bit confusing.  	// This part searches from left to right between the edges inside the polygon.  	// The problem: We are using the polygon data to search in the texture data.  	// That's simply not accurate' but necessary because of performance.  	for (int i = 0; i < xCoords.Count; i += 2) {  		foundSolid = false;  		foundTransparent = false;  		// We search between the edges inside the polygon.  		for (int x = (int)xCoords [i]; x <= (int)xCoords [i + 1]; x++) {  			// First pass: IsSolid might return false.  			// In that case the polygon edge doesn't lie on the texture's solid pixel' because of the hull tolearance.  			// If the edge lies before the first solid pixel then we need to skip our transparent pixel finds.  			// The algorithm starts to search for a relevant transparent pixel (which indicates a possible hole)   			// after it has found a solid pixel.  			// After we've found a solid and a transparent pixel (a hole's left edge)   			// we search for a solid pixel again (a hole's right edge).  			// When found the distance of that coodrinate has to be greater then the hull tolerance.  			if (IsSolid (ref x' ref y)) {  				if (!foundTransparent) {  					foundSolid = true;  					lastSolid = x;  				}  				if (foundSolid && foundTransparent) {  					entrance = new Vector2 (lastSolid' y);  					if (DistanceToHullAcceptable (polygon' entrance.Value' true))  						return entrance;  					entrance = null;  					break;  				}  			}  			else {  				if (foundSolid)  					foundTransparent = true;  			}  		}  	}  }  else {  	if (xCoords.Count % 2 == 0)  		Debug.WriteLine ("SearchCrossingEdges() % 2 != 0");  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: if (xCoords.Count > 1 && xCoords.Count % 2 == 0) {  	// Ok' this is short' but probably a little bit confusing.  	// This part searches from left to right between the edges inside the polygon.  	// The problem: We are using the polygon data to search in the texture data.  	// That's simply not accurate' but necessary because of performance.  	for (int i = 0; i < xCoords.Count; i += 2) {  		foundSolid = false;  		foundTransparent = false;  		// We search between the edges inside the polygon.  		for (int x = (int)xCoords [i]; x <= (int)xCoords [i + 1]; x++) {  			// First pass: IsSolid might return false.  			// In that case the polygon edge doesn't lie on the texture's solid pixel' because of the hull tolearance.  			// If the edge lies before the first solid pixel then we need to skip our transparent pixel finds.  			// The algorithm starts to search for a relevant transparent pixel (which indicates a possible hole)   			// after it has found a solid pixel.  			// After we've found a solid and a transparent pixel (a hole's left edge)   			// we search for a solid pixel again (a hole's right edge).  			// When found the distance of that coodrinate has to be greater then the hull tolerance.  			if (IsSolid (ref x' ref y)) {  				if (!foundTransparent) {  					foundSolid = true;  					lastSolid = x;  				}  				if (foundSolid && foundTransparent) {  					entrance = new Vector2 (lastSolid' y);  					if (DistanceToHullAcceptable (polygon' entrance.Value' true))  						return entrance;  					entrance = null;  					break;  				}  			}  			else {  				if (foundSolid)  					foundTransparent = true;  			}  		}  	}  }  else {  	if (xCoords.Count % 2 == 0)  		Debug.WriteLine ("SearchCrossingEdges() % 2 != 0");  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: if (xCoords.Count > 1 && xCoords.Count % 2 == 0) {  	// Ok' this is short' but probably a little bit confusing.  	// This part searches from left to right between the edges inside the polygon.  	// The problem: We are using the polygon data to search in the texture data.  	// That's simply not accurate' but necessary because of performance.  	for (int i = 0; i < xCoords.Count; i += 2) {  		foundSolid = false;  		foundTransparent = false;  		// We search between the edges inside the polygon.  		for (int x = (int)xCoords [i]; x <= (int)xCoords [i + 1]; x++) {  			// First pass: IsSolid might return false.  			// In that case the polygon edge doesn't lie on the texture's solid pixel' because of the hull tolearance.  			// If the edge lies before the first solid pixel then we need to skip our transparent pixel finds.  			// The algorithm starts to search for a relevant transparent pixel (which indicates a possible hole)   			// after it has found a solid pixel.  			// After we've found a solid and a transparent pixel (a hole's left edge)   			// we search for a solid pixel again (a hole's right edge).  			// When found the distance of that coodrinate has to be greater then the hull tolerance.  			if (IsSolid (ref x' ref y)) {  				if (!foundTransparent) {  					foundSolid = true;  					lastSolid = x;  				}  				if (foundSolid && foundTransparent) {  					entrance = new Vector2 (lastSolid' y);  					if (DistanceToHullAcceptable (polygon' entrance.Value' true))  						return entrance;  					entrance = null;  					break;  				}  			}  			else {  				if (foundSolid)  					foundTransparent = true;  			}  		}  	}  }  else {  	if (xCoords.Count % 2 == 0)  		Debug.WriteLine ("SearchCrossingEdges() % 2 != 0");  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: for (int i = 0; i < xCoords.Count; i += 2) {  	foundSolid = false;  	foundTransparent = false;  	// We search between the edges inside the polygon.  	for (int x = (int)xCoords [i]; x <= (int)xCoords [i + 1]; x++) {  		// First pass: IsSolid might return false.  		// In that case the polygon edge doesn't lie on the texture's solid pixel' because of the hull tolearance.  		// If the edge lies before the first solid pixel then we need to skip our transparent pixel finds.  		// The algorithm starts to search for a relevant transparent pixel (which indicates a possible hole)   		// after it has found a solid pixel.  		// After we've found a solid and a transparent pixel (a hole's left edge)   		// we search for a solid pixel again (a hole's right edge).  		// When found the distance of that coodrinate has to be greater then the hull tolerance.  		if (IsSolid (ref x' ref y)) {  			if (!foundTransparent) {  				foundSolid = true;  				lastSolid = x;  			}  			if (foundSolid && foundTransparent) {  				entrance = new Vector2 (lastSolid' y);  				if (DistanceToHullAcceptable (polygon' entrance.Value' true))  					return entrance;  				entrance = null;  				break;  			}  		}  		else {  			if (foundSolid)  				foundTransparent = true;  		}  	}  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: i += 2
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: if (xCoords.Count % 2 == 0)  	Debug.WriteLine ("SearchCrossingEdges() % 2 != 0");  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,DistanceToHullAcceptable,The following statement contains a magic number: if (polygon.Count < 3)  	throw new ArgumentException ("'polygon.MainPolygon.Count' can't be less then 3.");  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,DistanceToHullAcceptable,The following statement contains a magic number: if (polygon.Count < 3)  	throw new ArgumentException ("'polygon.Count' can't be less then 3.");  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,InPolygon,The following statement contains a magic number: if (!inPolygon) {  	List<float> xCoords = SearchCrossingEdges (polygon' (int)point.Y);  	if (xCoords.Count > 0 && xCoords.Count % 2 == 0) {  		for (int i = 0; i < xCoords.Count; i += 2) {  			if (xCoords [i] <= point.X && xCoords [i + 1] >= point.X)  				return true;  		}  	}  	return false;  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,InPolygon,The following statement contains a magic number: if (!inPolygon) {  	List<float> xCoords = SearchCrossingEdges (polygon' (int)point.Y);  	if (xCoords.Count > 0 && xCoords.Count % 2 == 0) {  		for (int i = 0; i < xCoords.Count; i += 2) {  			if (xCoords [i] <= point.X && xCoords [i + 1] >= point.X)  				return true;  		}  	}  	return false;  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,InPolygon,The following statement contains a magic number: if (xCoords.Count > 0 && xCoords.Count % 2 == 0) {  	for (int i = 0; i < xCoords.Count; i += 2) {  		if (xCoords [i] <= point.X && xCoords [i + 1] >= point.X)  			return true;  	}  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,InPolygon,The following statement contains a magic number: if (xCoords.Count > 0 && xCoords.Count % 2 == 0) {  	for (int i = 0; i < xCoords.Count; i += 2) {  		if (xCoords [i] <= point.X && xCoords [i + 1] >= point.X)  			return true;  	}  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,InPolygon,The following statement contains a magic number: for (int i = 0; i < xCoords.Count; i += 2) {  	if (xCoords [i] <= point.X && xCoords [i + 1] >= point.X)  		return true;  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,InPolygon,The following statement contains a magic number: i += 2
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,SearchCrossingEdges,The following statement contains a magic number: if (polygon.Count < 3)  	throw new ArgumentException ("'polygon.MainPolygon.Count' can't be less then 3.");  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,SearchCrossingEdges,The following statement contains a magic number: if (polygon.Count > 2) {  	// There is a gap between the last and the first vertex in the vertex list.  	// We will bridge that by setting the last vertex (vertex2) to the last   	// vertex in the list.  	vertex2 = polygon [polygon.Count - 1];  	// We are moving along the polygon edges.  	for (int i = 0; i < polygon.Count; i++) {  		vertex1 = polygon [i];  		// Approx. check if the edge crosses our y coord.  		if ((vertex1.Y >= y && vertex2.Y <= y) || (vertex1.Y <= y && vertex2.Y >= y)) {  			// Ignore edges that are parallel to y.  			if (vertex1.Y != vertex2.Y) {  				addFind = true;  				slope = vertex2 - vertex1;  				// Special threatment for edges that end at the y coord.  				if (vertex1.Y == y) {  					// Create preview of the next edge.  					nextVertex = polygon [(i + 1) % polygon.Count];  					nextSlope = vertex1 - nextVertex;  					// Ignore peaks.   					// If thwo edges are aligned like this: /\ and the y coordinate lies on the top'  					// then we get the same x coord twice and we don't need that.  					if (slope.Y > 0)  						addFind = (nextSlope.Y <= 0);  					else  						addFind = (nextSlope.Y >= 0);  				}  				if (addFind)  					edges.Add ((y - vertex1.Y) / slope.Y * slope.X + vertex1.X);  				// Calculate and add the x coord.  			}  		}  		// vertex1 becomes vertex2 :).  		vertex2 = vertex1;  	}  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,SplitPolygonEdge,The following statement contains a magic number: if (xCoords != null && xCoords.Count > 1 && xCoords.Count % 2 == 0) {  	float distance;  	for (int i = 0; i < xCoords.Count; i++) {  		if (xCoords [i] < coordInsideThePolygon.X) {  			distance = coordInsideThePolygon.X - xCoords [i];  			if (distance < shortestDistance) {  				shortestDistance = distance;  				foundEdgeCoord.X = xCoords [i];  				edgeCoordFound = true;  			}  		}  	}  	if (edgeCoordFound) {  		shortestDistance = float.MaxValue;  		int edgeVertex2Index = polygon.Count - 1;  		int edgeVertex1Index;  		for (edgeVertex1Index = 0; edgeVertex1Index < polygon.Count; edgeVertex1Index++) {  			Vector2 tempVector1 = polygon [edgeVertex1Index];  			Vector2 tempVector2 = polygon [edgeVertex2Index];  			distance = LineTools.DistanceBetweenPointAndLineSegment (ref foundEdgeCoord' ref tempVector1' ref tempVector2);  			if (distance < shortestDistance) {  				shortestDistance = distance;  				nearestEdgeVertex1Index = edgeVertex1Index;  				nearestEdgeVertex2Index = edgeVertex2Index;  				edgeFound = true;  			}  			edgeVertex2Index = edgeVertex1Index;  		}  		if (edgeFound) {  			slope = polygon [nearestEdgeVertex2Index] - polygon [nearestEdgeVertex1Index];  			slope.Normalize ();  			Vector2 tempVector = polygon [nearestEdgeVertex1Index];  			distance = LineTools.DistanceBetweenPointAndPoint (ref tempVector' ref foundEdgeCoord);  			vertex1Index = nearestEdgeVertex1Index;  			vertex2Index = nearestEdgeVertex1Index + 1;  			polygon.Insert (nearestEdgeVertex1Index' distance * slope + polygon [vertex1Index]);  			polygon.Insert (nearestEdgeVertex1Index' distance * slope + polygon [vertex2Index]);  			return true;  		}  	}  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,SearchForOutstandingVertex,The following statement contains a magic number: if (hullArea.Count > 2) {  	int hullAreaLastPoint = hullArea.Count - 1;  	Vector2 tempVector1;  	Vector2 tempVector2 = hullArea [0];  	Vector2 tempVector3 = hullArea [hullAreaLastPoint];  	// Search between the first and last hull point.  	for (int i = 1; i < hullAreaLastPoint; i++) {  		tempVector1 = hullArea [i];  		// Check if the distance is over the one that's tolerable.  		if (LineTools.DistanceBetweenPointAndLineSegment (ref tempVector1' ref tempVector2' ref tempVector3) >= _hullTolerance) {  			outstandingResult = hullArea [i];  			found = true;  			break;  		}  	}  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.X - last.X)) {  case 1:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 1;  	case 0:  		return 0;  	case -1:  		return 7;  	}  	break;  case 0:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 2;  	case -1:  		return 6;  	}  	break;  case -1:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 3;  	case 0:  		return 4;  	case -1:  		return 5;  	}  	break;  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.X - last.X)) {  case 1:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 1;  	case 0:  		return 0;  	case -1:  		return 7;  	}  	break;  case 0:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 2;  	case -1:  		return 6;  	}  	break;  case -1:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 3;  	case 0:  		return 4;  	case -1:  		return 5;  	}  	break;  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.X - last.X)) {  case 1:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 1;  	case 0:  		return 0;  	case -1:  		return 7;  	}  	break;  case 0:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 2;  	case -1:  		return 6;  	}  	break;  case -1:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 3;  	case 0:  		return 4;  	case -1:  		return 5;  	}  	break;  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.X - last.X)) {  case 1:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 1;  	case 0:  		return 0;  	case -1:  		return 7;  	}  	break;  case 0:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 2;  	case -1:  		return 6;  	}  	break;  case -1:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 3;  	case 0:  		return 4;  	case -1:  		return 5;  	}  	break;  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.X - last.X)) {  case 1:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 1;  	case 0:  		return 0;  	case -1:  		return 7;  	}  	break;  case 0:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 2;  	case -1:  		return 6;  	}  	break;  case -1:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 3;  	case 0:  		return 4;  	case -1:  		return 5;  	}  	break;  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.X - last.X)) {  case 1:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 1;  	case 0:  		return 0;  	case -1:  		return 7;  	}  	break;  case 0:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 2;  	case -1:  		return 6;  	}  	break;  case -1:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 3;  	case 0:  		return 4;  	case -1:  		return 5;  	}  	break;  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.Y - last.Y)) {  case 1:  	return 1;  case 0:  	return 0;  case -1:  	return 7;  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: return 7;  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.Y - last.Y)) {  case 1:  	return 2;  case -1:  	return 6;  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.Y - last.Y)) {  case 1:  	return 2;  case -1:  	return 6;  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: return 2;  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: return 6;  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.Y - last.Y)) {  case 1:  	return 3;  case 0:  	return 4;  case -1:  	return 5;  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.Y - last.Y)) {  case 1:  	return 3;  case 0:  	return 4;  case -1:  	return 5;  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.Y - last.Y)) {  case 1:  	return 3;  case 0:  	return 4;  case -1:  	return 5;  }  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: return 3;  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: return 4;  
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: return 5;  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,IsCounterClockWise,The following statement contains a magic number: if (Count < 3)  	return true;  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: if (Count < 3 || Count > Settings.MaxPolygonVertices) {  	error = 0;  }  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: if (!IsSimple ()) {  	error = 2;  }  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: error = 2;  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: if (GetArea () < Settings.Epsilon) {  	error = 3;  }  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: error = 3;  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: for (int i = 0; i < Count; ++i) {  	int iminus = (i == 0) ? Count - 1 : i - 1;  	//Parallel sides check  	float cross = MathUtils.Cross (normals [iminus]' normals [i]);  	cross = MathUtils.Clamp (cross' -1.0f' 1.0f);  	float angle = (float)Math.Asin (cross);  	if (angle <= Settings.AngularSlop) {  		error = 4;  		break;  	}  	//Too skinny check  	for (int j = 0; j < Count; ++j) {  		if (j == i || j == (i + 1) % Count) {  			continue;  		}  		float s = Vector2.Dot (normals [i]' vertices [j] - vertices [i]);  		if (s >= -Settings.LinearSlop) {  			error = 5;  		}  	}  	Vector2 centroid = vertices.GetCentroid ();  	Vector2 n1 = normals [iminus];  	Vector2 n2 = normals [i];  	Vector2 v = vertices [i] - centroid;  	Vector2 d = new Vector2 ();  	d.X = Vector2.Dot (n1' v);  	// - toiSlop;  	d.Y = Vector2.Dot (n2' v);  	// - toiSlop;  	// Shifting the edge inward by toiSlop should  	// not cause the plane to pass the centroid.  	if ((d.X < 0.0f) || (d.Y < 0.0f)) {  		error = 6;  	}  }  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: for (int i = 0; i < Count; ++i) {  	int iminus = (i == 0) ? Count - 1 : i - 1;  	//Parallel sides check  	float cross = MathUtils.Cross (normals [iminus]' normals [i]);  	cross = MathUtils.Clamp (cross' -1.0f' 1.0f);  	float angle = (float)Math.Asin (cross);  	if (angle <= Settings.AngularSlop) {  		error = 4;  		break;  	}  	//Too skinny check  	for (int j = 0; j < Count; ++j) {  		if (j == i || j == (i + 1) % Count) {  			continue;  		}  		float s = Vector2.Dot (normals [i]' vertices [j] - vertices [i]);  		if (s >= -Settings.LinearSlop) {  			error = 5;  		}  	}  	Vector2 centroid = vertices.GetCentroid ();  	Vector2 n1 = normals [iminus];  	Vector2 n2 = normals [i];  	Vector2 v = vertices [i] - centroid;  	Vector2 d = new Vector2 ();  	d.X = Vector2.Dot (n1' v);  	// - toiSlop;  	d.Y = Vector2.Dot (n2' v);  	// - toiSlop;  	// Shifting the edge inward by toiSlop should  	// not cause the plane to pass the centroid.  	if ((d.X < 0.0f) || (d.Y < 0.0f)) {  		error = 6;  	}  }  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: for (int i = 0; i < Count; ++i) {  	int iminus = (i == 0) ? Count - 1 : i - 1;  	//Parallel sides check  	float cross = MathUtils.Cross (normals [iminus]' normals [i]);  	cross = MathUtils.Clamp (cross' -1.0f' 1.0f);  	float angle = (float)Math.Asin (cross);  	if (angle <= Settings.AngularSlop) {  		error = 4;  		break;  	}  	//Too skinny check  	for (int j = 0; j < Count; ++j) {  		if (j == i || j == (i + 1) % Count) {  			continue;  		}  		float s = Vector2.Dot (normals [i]' vertices [j] - vertices [i]);  		if (s >= -Settings.LinearSlop) {  			error = 5;  		}  	}  	Vector2 centroid = vertices.GetCentroid ();  	Vector2 n1 = normals [iminus];  	Vector2 n2 = normals [i];  	Vector2 v = vertices [i] - centroid;  	Vector2 d = new Vector2 ();  	d.X = Vector2.Dot (n1' v);  	// - toiSlop;  	d.Y = Vector2.Dot (n2' v);  	// - toiSlop;  	// Shifting the edge inward by toiSlop should  	// not cause the plane to pass the centroid.  	if ((d.X < 0.0f) || (d.Y < 0.0f)) {  		error = 6;  	}  }  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: if (angle <= Settings.AngularSlop) {  	error = 4;  	break;  }  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: error = 4;  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: for (int j = 0; j < Count; ++j) {  	if (j == i || j == (i + 1) % Count) {  		continue;  	}  	float s = Vector2.Dot (normals [i]' vertices [j] - vertices [i]);  	if (s >= -Settings.LinearSlop) {  		error = 5;  	}  }  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: if (s >= -Settings.LinearSlop) {  	error = 5;  }  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: error = 5;  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: if ((d.X < 0.0f) || (d.Y < 0.0f)) {  	error = 6;  }  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: error = 6;  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: if (error != -1) {  	Debug.WriteLine ("Found invalid polygon' ");  	switch (error) {  	case 0:  		Debug.WriteLine (string.Format ("must have between 3 and {0} vertices.\n"' Settings.MaxPolygonVertices));  		break;  	case 1:  		Debug.WriteLine ("must be convex.\n");  		break;  	case 2:  		Debug.WriteLine ("must be simple (cannot intersect itself).\n");  		break;  	case 3:  		Debug.WriteLine ("area is too small.\n");  		break;  	case 4:  		Debug.WriteLine ("sides are too close to parallel.\n");  		break;  	case 5:  		Debug.WriteLine ("polygon is too thin.\n");  		break;  	case 6:  		Debug.WriteLine ("core shape generation would move edge past centroid (too thin).\n");  		break;  	default:  		Debug.WriteLine ("don't know why.\n");  		break;  	}  }  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: if (error != -1) {  	Debug.WriteLine ("Found invalid polygon' ");  	switch (error) {  	case 0:  		Debug.WriteLine (string.Format ("must have between 3 and {0} vertices.\n"' Settings.MaxPolygonVertices));  		break;  	case 1:  		Debug.WriteLine ("must be convex.\n");  		break;  	case 2:  		Debug.WriteLine ("must be simple (cannot intersect itself).\n");  		break;  	case 3:  		Debug.WriteLine ("area is too small.\n");  		break;  	case 4:  		Debug.WriteLine ("sides are too close to parallel.\n");  		break;  	case 5:  		Debug.WriteLine ("polygon is too thin.\n");  		break;  	case 6:  		Debug.WriteLine ("core shape generation would move edge past centroid (too thin).\n");  		break;  	default:  		Debug.WriteLine ("don't know why.\n");  		break;  	}  }  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: if (error != -1) {  	Debug.WriteLine ("Found invalid polygon' ");  	switch (error) {  	case 0:  		Debug.WriteLine (string.Format ("must have between 3 and {0} vertices.\n"' Settings.MaxPolygonVertices));  		break;  	case 1:  		Debug.WriteLine ("must be convex.\n");  		break;  	case 2:  		Debug.WriteLine ("must be simple (cannot intersect itself).\n");  		break;  	case 3:  		Debug.WriteLine ("area is too small.\n");  		break;  	case 4:  		Debug.WriteLine ("sides are too close to parallel.\n");  		break;  	case 5:  		Debug.WriteLine ("polygon is too thin.\n");  		break;  	case 6:  		Debug.WriteLine ("core shape generation would move edge past centroid (too thin).\n");  		break;  	default:  		Debug.WriteLine ("don't know why.\n");  		break;  	}  }  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: if (error != -1) {  	Debug.WriteLine ("Found invalid polygon' ");  	switch (error) {  	case 0:  		Debug.WriteLine (string.Format ("must have between 3 and {0} vertices.\n"' Settings.MaxPolygonVertices));  		break;  	case 1:  		Debug.WriteLine ("must be convex.\n");  		break;  	case 2:  		Debug.WriteLine ("must be simple (cannot intersect itself).\n");  		break;  	case 3:  		Debug.WriteLine ("area is too small.\n");  		break;  	case 4:  		Debug.WriteLine ("sides are too close to parallel.\n");  		break;  	case 5:  		Debug.WriteLine ("polygon is too thin.\n");  		break;  	case 6:  		Debug.WriteLine ("core shape generation would move edge past centroid (too thin).\n");  		break;  	default:  		Debug.WriteLine ("don't know why.\n");  		break;  	}  }  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: if (error != -1) {  	Debug.WriteLine ("Found invalid polygon' ");  	switch (error) {  	case 0:  		Debug.WriteLine (string.Format ("must have between 3 and {0} vertices.\n"' Settings.MaxPolygonVertices));  		break;  	case 1:  		Debug.WriteLine ("must be convex.\n");  		break;  	case 2:  		Debug.WriteLine ("must be simple (cannot intersect itself).\n");  		break;  	case 3:  		Debug.WriteLine ("area is too small.\n");  		break;  	case 4:  		Debug.WriteLine ("sides are too close to parallel.\n");  		break;  	case 5:  		Debug.WriteLine ("polygon is too thin.\n");  		break;  	case 6:  		Debug.WriteLine ("core shape generation would move edge past centroid (too thin).\n");  		break;  	default:  		Debug.WriteLine ("don't know why.\n");  		break;  	}  }  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: switch (error) {  case 0:  	Debug.WriteLine (string.Format ("must have between 3 and {0} vertices.\n"' Settings.MaxPolygonVertices));  	break;  case 1:  	Debug.WriteLine ("must be convex.\n");  	break;  case 2:  	Debug.WriteLine ("must be simple (cannot intersect itself).\n");  	break;  case 3:  	Debug.WriteLine ("area is too small.\n");  	break;  case 4:  	Debug.WriteLine ("sides are too close to parallel.\n");  	break;  case 5:  	Debug.WriteLine ("polygon is too thin.\n");  	break;  case 6:  	Debug.WriteLine ("core shape generation would move edge past centroid (too thin).\n");  	break;  default:  	Debug.WriteLine ("don't know why.\n");  	break;  }  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: switch (error) {  case 0:  	Debug.WriteLine (string.Format ("must have between 3 and {0} vertices.\n"' Settings.MaxPolygonVertices));  	break;  case 1:  	Debug.WriteLine ("must be convex.\n");  	break;  case 2:  	Debug.WriteLine ("must be simple (cannot intersect itself).\n");  	break;  case 3:  	Debug.WriteLine ("area is too small.\n");  	break;  case 4:  	Debug.WriteLine ("sides are too close to parallel.\n");  	break;  case 5:  	Debug.WriteLine ("polygon is too thin.\n");  	break;  case 6:  	Debug.WriteLine ("core shape generation would move edge past centroid (too thin).\n");  	break;  default:  	Debug.WriteLine ("don't know why.\n");  	break;  }  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: switch (error) {  case 0:  	Debug.WriteLine (string.Format ("must have between 3 and {0} vertices.\n"' Settings.MaxPolygonVertices));  	break;  case 1:  	Debug.WriteLine ("must be convex.\n");  	break;  case 2:  	Debug.WriteLine ("must be simple (cannot intersect itself).\n");  	break;  case 3:  	Debug.WriteLine ("area is too small.\n");  	break;  case 4:  	Debug.WriteLine ("sides are too close to parallel.\n");  	break;  case 5:  	Debug.WriteLine ("polygon is too thin.\n");  	break;  case 6:  	Debug.WriteLine ("core shape generation would move edge past centroid (too thin).\n");  	break;  default:  	Debug.WriteLine ("don't know why.\n");  	break;  }  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: switch (error) {  case 0:  	Debug.WriteLine (string.Format ("must have between 3 and {0} vertices.\n"' Settings.MaxPolygonVertices));  	break;  case 1:  	Debug.WriteLine ("must be convex.\n");  	break;  case 2:  	Debug.WriteLine ("must be simple (cannot intersect itself).\n");  	break;  case 3:  	Debug.WriteLine ("area is too small.\n");  	break;  case 4:  	Debug.WriteLine ("sides are too close to parallel.\n");  	break;  case 5:  	Debug.WriteLine ("polygon is too thin.\n");  	break;  case 6:  	Debug.WriteLine ("core shape generation would move edge past centroid (too thin).\n");  	break;  default:  	Debug.WriteLine ("don't know why.\n");  	break;  }  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: switch (error) {  case 0:  	Debug.WriteLine (string.Format ("must have between 3 and {0} vertices.\n"' Settings.MaxPolygonVertices));  	break;  case 1:  	Debug.WriteLine ("must be convex.\n");  	break;  case 2:  	Debug.WriteLine ("must be simple (cannot intersect itself).\n");  	break;  case 3:  	Debug.WriteLine ("area is too small.\n");  	break;  case 4:  	Debug.WriteLine ("sides are too close to parallel.\n");  	break;  case 5:  	Debug.WriteLine ("polygon is too thin.\n");  	break;  case 6:  	Debug.WriteLine ("core shape generation would move edge past centroid (too thin).\n");  	break;  default:  	Debug.WriteLine ("don't know why.\n");  	break;  }  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,TraceEdge,The following statement contains a magic number: while (foundDupe) {  	foundDupe = false;  	for (int i = 0; i < nNodes; ++i) {  		if (nodes [i].NConnected == 0)  			continue;  		for (int j = i + 1; j < nNodes; ++j) {  			if (nodes [j].NConnected == 0)  				continue;  			Vector2 diff = nodes [i].Position - nodes [j].Position;  			if (diff.LengthSquared () <= Settings.Epsilon * Settings.Epsilon) {  				if (nActive <= 3)  					return new Vertices ();  				//printf("Found dupe' %d left\n"'nActive);  				--nActive;  				foundDupe = true;  				PolyNode inode = nodes [i];  				PolyNode jnode = nodes [j];  				//Move all of j's connections to i' and orphan j  				int njConn = jnode.NConnected;  				for (int k = 0; k < njConn; ++k) {  					PolyNode knode = jnode.Connected [k];  					Debug.Assert (knode != jnode);  					if (knode != inode) {  						inode.AddConnection (knode);  						knode.AddConnection (inode);  					}  					knode.RemoveConnection (jnode);  				}  				jnode.NConnected = 0;  			}  		}  	}  }  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,TraceEdge,The following statement contains a magic number: for (int i = 0; i < nNodes; ++i) {  	if (nodes [i].NConnected == 0)  		continue;  	for (int j = i + 1; j < nNodes; ++j) {  		if (nodes [j].NConnected == 0)  			continue;  		Vector2 diff = nodes [i].Position - nodes [j].Position;  		if (diff.LengthSquared () <= Settings.Epsilon * Settings.Epsilon) {  			if (nActive <= 3)  				return new Vertices ();  			//printf("Found dupe' %d left\n"'nActive);  			--nActive;  			foundDupe = true;  			PolyNode inode = nodes [i];  			PolyNode jnode = nodes [j];  			//Move all of j's connections to i' and orphan j  			int njConn = jnode.NConnected;  			for (int k = 0; k < njConn; ++k) {  				PolyNode knode = jnode.Connected [k];  				Debug.Assert (knode != jnode);  				if (knode != inode) {  					inode.AddConnection (knode);  					knode.AddConnection (inode);  				}  				knode.RemoveConnection (jnode);  			}  			jnode.NConnected = 0;  		}  	}  }  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,TraceEdge,The following statement contains a magic number: for (int j = i + 1; j < nNodes; ++j) {  	if (nodes [j].NConnected == 0)  		continue;  	Vector2 diff = nodes [i].Position - nodes [j].Position;  	if (diff.LengthSquared () <= Settings.Epsilon * Settings.Epsilon) {  		if (nActive <= 3)  			return new Vertices ();  		//printf("Found dupe' %d left\n"'nActive);  		--nActive;  		foundDupe = true;  		PolyNode inode = nodes [i];  		PolyNode jnode = nodes [j];  		//Move all of j's connections to i' and orphan j  		int njConn = jnode.NConnected;  		for (int k = 0; k < njConn; ++k) {  			PolyNode knode = jnode.Connected [k];  			Debug.Assert (knode != jnode);  			if (knode != inode) {  				inode.AddConnection (knode);  				knode.AddConnection (inode);  			}  			knode.RemoveConnection (jnode);  		}  		jnode.NConnected = 0;  	}  }  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,TraceEdge,The following statement contains a magic number: if (diff.LengthSquared () <= Settings.Epsilon * Settings.Epsilon) {  	if (nActive <= 3)  		return new Vertices ();  	//printf("Found dupe' %d left\n"'nActive);  	--nActive;  	foundDupe = true;  	PolyNode inode = nodes [i];  	PolyNode jnode = nodes [j];  	//Move all of j's connections to i' and orphan j  	int njConn = jnode.NConnected;  	for (int k = 0; k < njConn; ++k) {  		PolyNode knode = jnode.Connected [k];  		Debug.Assert (knode != jnode);  		if (knode != inode) {  			inode.AddConnection (knode);  			knode.AddConnection (inode);  		}  		knode.RemoveConnection (jnode);  	}  	jnode.NConnected = 0;  }  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,TraceEdge,The following statement contains a magic number: if (nActive <= 3)  	return new Vertices ();  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,TraceEdge,The following statement contains a magic number: while (nextNode != startNode) {  	if (nResultVecs > 4 * nNodes) {  		Debug.Assert (false);  	}  	resultVecs [nResultVecs++] = nextNode.Position;  	PolyNode oldNode = currentNode;  	currentNode = nextNode;  	nextNode = currentNode.GetRightestConnection (oldNode);  	if (nextNode == null) {  		Vertices vertices = new Vertices (nResultVecs);  		for (int i = 0; i < nResultVecs; ++i) {  			vertices.Add (resultVecs [i]);  		}  		return vertices;  	}  	// There was a problem' so jump out of the loop and use whatever garbage we've generated so far  }  
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Vertices.cs,TraceEdge,The following statement contains a magic number: if (nResultVecs > 4 * nNodes) {  	Debug.Assert (false);  }  
Magic Number,FarseerPhysics.Factories,BodyFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\BodyFactory.cs,CreateCapsule,The following statement contains a magic number: topCircle.Position = new Vector2 (0' height / 2);  
Magic Number,FarseerPhysics.Factories,BodyFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\BodyFactory.cs,CreateCapsule,The following statement contains a magic number: bottomCircle.Position = new Vector2 (0' -(height / 2));  
Magic Number,FarseerPhysics.Factories,FixtureFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\FixtureFactory.cs,AttachCompoundPolygon,The following statement contains a magic number: foreach (Vertices vertices in list) {  	if (vertices.Count == 2) {  		EdgeShape shape = new EdgeShape (vertices [0]' vertices [1]);  		res.Add (body.CreateFixture (shape' userData));  	}  	else {  		PolygonShape shape = new PolygonShape (vertices' density);  		res.Add (body.CreateFixture (shape' userData));  	}  }  
Magic Number,FarseerPhysics.Factories,FixtureFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\FixtureFactory.cs,AttachCompoundPolygon,The following statement contains a magic number: if (vertices.Count == 2) {  	EdgeShape shape = new EdgeShape (vertices [0]' vertices [1]);  	res.Add (body.CreateFixture (shape' userData));  }  else {  	PolygonShape shape = new PolygonShape (vertices' density);  	res.Add (body.CreateFixture (shape' userData));  }  
Magic Number,FarseerPhysics.Factories,FixtureFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\FixtureFactory.cs,AttachLineArc,The following statement contains a magic number: arc.Rotate ((MathHelper.Pi - radians) / 2 + angle);  
Magic Number,FarseerPhysics.Factories,FixtureFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\FixtureFactory.cs,AttachSolidArc,The following statement contains a magic number: arc.Rotate ((MathHelper.Pi - radians) / 2 + angle);  
Magic Number,FarseerPhysics.Factories,LinkFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\LinkFactory.cs,CreateChain,The following statement contains a magic number: if (fixStart) {  	//Fix the first chainlink to the world  	JointFactory.CreateFixedRevoluteJoint (world' chainLinks [0]' new Vector2 (0' -(linkHeight / 2))' chainLinks [0].Position);  }  
Magic Number,FarseerPhysics.Factories,LinkFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\LinkFactory.cs,CreateChain,The following statement contains a magic number: JointFactory.CreateFixedRevoluteJoint (world' chainLinks [0]' new Vector2 (0' -(linkHeight / 2))' chainLinks [0].Position);  
Magic Number,FarseerPhysics.Factories,LinkFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\LinkFactory.cs,CreateChain,The following statement contains a magic number: if (fixEnd) {  	//Fix the last chainlink to the world  	JointFactory.CreateFixedRevoluteJoint (world' chainLinks [chainLinks.Count - 1]' new Vector2 (0' (linkHeight / 2))' chainLinks [chainLinks.Count - 1].Position);  }  
Magic Number,FarseerPhysics.Factories,LinkFactory,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Factories\LinkFactory.cs,CreateChain,The following statement contains a magic number: JointFactory.CreateFixedRevoluteJoint (world' chainLinks [chainLinks.Count - 1]' new Vector2 (0' (linkHeight / 2))' chainLinks [chainLinks.Count - 1].Position);  
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: for (int i = 0; i < shapeCount; ++i) {  	PolygonShape ps;  	CircleShape cs = shapes [i].Shape as CircleShape;  	if (cs != null) {  		// We create a "diamond" approximation of the circle  		Vertices v = new Vertices ();  		Vector2 vec = Vector2.Zero + new Vector2 (cs.Radius' 0);  		v.Add (vec);  		vec = Vector2.Zero + new Vector2 (0' cs.Radius);  		v.Add (vec);  		vec = Vector2.Zero + new Vector2 (-cs.Radius' cs.Radius);  		v.Add (vec);  		vec = Vector2.Zero + new Vector2 (0' -cs.Radius);  		v.Add (vec);  		ps = new PolygonShape (v' 0);  	}  	else  		ps = shapes [i].Shape as PolygonShape;  	if ((shapes [i].Body.BodyType == BodyType.Dynamic) && ps != null) {  		Vector2 toCentroid = shapes [i].Body.GetWorldPoint (ps.MassData.Centroid) - pos;  		float angleToCentroid = (float)Math.Atan2 (toCentroid.Y' toCentroid.X);  		float min = float.MaxValue;  		float max = float.MinValue;  		float minAbsolute = 0.0f;  		float maxAbsolute = 0.0f;  		for (int j = 0; j < (ps.Vertices.Count ()); ++j) {  			Vector2 toVertex = (shapes [i].Body.GetWorldPoint (ps.Vertices [j]) - pos);  			float newAngle = (float)Math.Atan2 (toVertex.Y' toVertex.X);  			float diff = (newAngle - angleToCentroid);  			diff = (diff - MathHelper.Pi) % (2 * MathHelper.Pi);  			// the minus pi is important. It means cutoff for going other direction is at 180 deg where it needs to be  			if (diff < 0.0f)  				diff += 2 * MathHelper.Pi;  			// correction for not handling negs  			diff -= MathHelper.Pi;  			if (Math.Abs (diff) > MathHelper.Pi)  				throw new ArgumentException ("OMG!");  			// Something's wrong' point not in shape but exists angle diff > 180  			if (diff > max) {  				max = diff;  				maxAbsolute = newAngle;  			}  			if (diff < min) {  				min = diff;  				minAbsolute = newAngle;  			}  		}  		vals [valIndex] = minAbsolute;  		++valIndex;  		vals [valIndex] = maxAbsolute;  		++valIndex;  	}  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: for (int i = 0; i < shapeCount; ++i) {  	PolygonShape ps;  	CircleShape cs = shapes [i].Shape as CircleShape;  	if (cs != null) {  		// We create a "diamond" approximation of the circle  		Vertices v = new Vertices ();  		Vector2 vec = Vector2.Zero + new Vector2 (cs.Radius' 0);  		v.Add (vec);  		vec = Vector2.Zero + new Vector2 (0' cs.Radius);  		v.Add (vec);  		vec = Vector2.Zero + new Vector2 (-cs.Radius' cs.Radius);  		v.Add (vec);  		vec = Vector2.Zero + new Vector2 (0' -cs.Radius);  		v.Add (vec);  		ps = new PolygonShape (v' 0);  	}  	else  		ps = shapes [i].Shape as PolygonShape;  	if ((shapes [i].Body.BodyType == BodyType.Dynamic) && ps != null) {  		Vector2 toCentroid = shapes [i].Body.GetWorldPoint (ps.MassData.Centroid) - pos;  		float angleToCentroid = (float)Math.Atan2 (toCentroid.Y' toCentroid.X);  		float min = float.MaxValue;  		float max = float.MinValue;  		float minAbsolute = 0.0f;  		float maxAbsolute = 0.0f;  		for (int j = 0; j < (ps.Vertices.Count ()); ++j) {  			Vector2 toVertex = (shapes [i].Body.GetWorldPoint (ps.Vertices [j]) - pos);  			float newAngle = (float)Math.Atan2 (toVertex.Y' toVertex.X);  			float diff = (newAngle - angleToCentroid);  			diff = (diff - MathHelper.Pi) % (2 * MathHelper.Pi);  			// the minus pi is important. It means cutoff for going other direction is at 180 deg where it needs to be  			if (diff < 0.0f)  				diff += 2 * MathHelper.Pi;  			// correction for not handling negs  			diff -= MathHelper.Pi;  			if (Math.Abs (diff) > MathHelper.Pi)  				throw new ArgumentException ("OMG!");  			// Something's wrong' point not in shape but exists angle diff > 180  			if (diff > max) {  				max = diff;  				maxAbsolute = newAngle;  			}  			if (diff < min) {  				min = diff;  				minAbsolute = newAngle;  			}  		}  		vals [valIndex] = minAbsolute;  		++valIndex;  		vals [valIndex] = maxAbsolute;  		++valIndex;  	}  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: if ((shapes [i].Body.BodyType == BodyType.Dynamic) && ps != null) {  	Vector2 toCentroid = shapes [i].Body.GetWorldPoint (ps.MassData.Centroid) - pos;  	float angleToCentroid = (float)Math.Atan2 (toCentroid.Y' toCentroid.X);  	float min = float.MaxValue;  	float max = float.MinValue;  	float minAbsolute = 0.0f;  	float maxAbsolute = 0.0f;  	for (int j = 0; j < (ps.Vertices.Count ()); ++j) {  		Vector2 toVertex = (shapes [i].Body.GetWorldPoint (ps.Vertices [j]) - pos);  		float newAngle = (float)Math.Atan2 (toVertex.Y' toVertex.X);  		float diff = (newAngle - angleToCentroid);  		diff = (diff - MathHelper.Pi) % (2 * MathHelper.Pi);  		// the minus pi is important. It means cutoff for going other direction is at 180 deg where it needs to be  		if (diff < 0.0f)  			diff += 2 * MathHelper.Pi;  		// correction for not handling negs  		diff -= MathHelper.Pi;  		if (Math.Abs (diff) > MathHelper.Pi)  			throw new ArgumentException ("OMG!");  		// Something's wrong' point not in shape but exists angle diff > 180  		if (diff > max) {  			max = diff;  			maxAbsolute = newAngle;  		}  		if (diff < min) {  			min = diff;  			minAbsolute = newAngle;  		}  	}  	vals [valIndex] = minAbsolute;  	++valIndex;  	vals [valIndex] = maxAbsolute;  	++valIndex;  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: if ((shapes [i].Body.BodyType == BodyType.Dynamic) && ps != null) {  	Vector2 toCentroid = shapes [i].Body.GetWorldPoint (ps.MassData.Centroid) - pos;  	float angleToCentroid = (float)Math.Atan2 (toCentroid.Y' toCentroid.X);  	float min = float.MaxValue;  	float max = float.MinValue;  	float minAbsolute = 0.0f;  	float maxAbsolute = 0.0f;  	for (int j = 0; j < (ps.Vertices.Count ()); ++j) {  		Vector2 toVertex = (shapes [i].Body.GetWorldPoint (ps.Vertices [j]) - pos);  		float newAngle = (float)Math.Atan2 (toVertex.Y' toVertex.X);  		float diff = (newAngle - angleToCentroid);  		diff = (diff - MathHelper.Pi) % (2 * MathHelper.Pi);  		// the minus pi is important. It means cutoff for going other direction is at 180 deg where it needs to be  		if (diff < 0.0f)  			diff += 2 * MathHelper.Pi;  		// correction for not handling negs  		diff -= MathHelper.Pi;  		if (Math.Abs (diff) > MathHelper.Pi)  			throw new ArgumentException ("OMG!");  		// Something's wrong' point not in shape but exists angle diff > 180  		if (diff > max) {  			max = diff;  			maxAbsolute = newAngle;  		}  		if (diff < min) {  			min = diff;  			minAbsolute = newAngle;  		}  	}  	vals [valIndex] = minAbsolute;  	++valIndex;  	vals [valIndex] = maxAbsolute;  	++valIndex;  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: for (int j = 0; j < (ps.Vertices.Count ()); ++j) {  	Vector2 toVertex = (shapes [i].Body.GetWorldPoint (ps.Vertices [j]) - pos);  	float newAngle = (float)Math.Atan2 (toVertex.Y' toVertex.X);  	float diff = (newAngle - angleToCentroid);  	diff = (diff - MathHelper.Pi) % (2 * MathHelper.Pi);  	// the minus pi is important. It means cutoff for going other direction is at 180 deg where it needs to be  	if (diff < 0.0f)  		diff += 2 * MathHelper.Pi;  	// correction for not handling negs  	diff -= MathHelper.Pi;  	if (Math.Abs (diff) > MathHelper.Pi)  		throw new ArgumentException ("OMG!");  	// Something's wrong' point not in shape but exists angle diff > 180  	if (diff > max) {  		max = diff;  		maxAbsolute = newAngle;  	}  	if (diff < min) {  		min = diff;  		minAbsolute = newAngle;  	}  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: for (int j = 0; j < (ps.Vertices.Count ()); ++j) {  	Vector2 toVertex = (shapes [i].Body.GetWorldPoint (ps.Vertices [j]) - pos);  	float newAngle = (float)Math.Atan2 (toVertex.Y' toVertex.X);  	float diff = (newAngle - angleToCentroid);  	diff = (diff - MathHelper.Pi) % (2 * MathHelper.Pi);  	// the minus pi is important. It means cutoff for going other direction is at 180 deg where it needs to be  	if (diff < 0.0f)  		diff += 2 * MathHelper.Pi;  	// correction for not handling negs  	diff -= MathHelper.Pi;  	if (Math.Abs (diff) > MathHelper.Pi)  		throw new ArgumentException ("OMG!");  	// Something's wrong' point not in shape but exists angle diff > 180  	if (diff > max) {  		max = diff;  		maxAbsolute = newAngle;  	}  	if (diff < min) {  		min = diff;  		minAbsolute = newAngle;  	}  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: diff = (diff - MathHelper.Pi) % (2 * MathHelper.Pi);  
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: if (diff < 0.0f)  	diff += 2 * MathHelper.Pi;  
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: diff += 2 * MathHelper.Pi;  
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: for (int i = 0; i < valIndex; ++i) {  	Fixture shape = null;  	float midpt;  	int iplus = (i == valIndex - 1 ? 0 : i + 1);  	if (vals [i] == vals [iplus])  		continue;  	if (i == valIndex - 1) {  		// the single edgecase  		midpt = (vals [0] + MathHelper.Pi * 2 + vals [i]);  	}  	else {  		midpt = (vals [i + 1] + vals [i]);  	}  	midpt = midpt / 2;  	Vector2 p1 = pos;  	Vector2 p2 = radius * new Vector2 ((float)Math.Cos (midpt)' (float)Math.Sin (midpt)) + pos;  	// RaycastOne  	bool hitClosest = false;  	World.RayCast ((f' p' n' fr) =>  {  		Body body = f.Body;  		if (!IsActiveOn (body))  			return 0;  		if (body.UserData != null) {  			int index = (int)body.UserData;  			if (index == 0) {  				// filter  				return -1.0f;  			}  		}  		hitClosest = true;  		shape = f;  		return fr;  	}' p1' p2);  	//draws radius points  	if ((hitClosest) && (shape.Body.BodyType == BodyType.Dynamic)) {  		if ((_data.Count () > 0) && (_data.Last ().Body == shape.Body) && (!rayMissed)) {  			int laPos = _data.Count - 1;  			ShapeData la = _data [laPos];  			la.Max = vals [iplus];  			_data [laPos] = la;  		}  		else {  			// make new  			ShapeData d;  			d.Body = shape.Body;  			d.Min = vals [i];  			d.Max = vals [iplus];  			_data.Add (d);  		}  		if ((_data.Count () > 1) && (i == valIndex - 1) && (_data.Last ().Body == _data.First ().Body) && (_data.Last ().Max == _data.First ().Min)) {  			ShapeData fi = _data [0];  			fi.Min = _data.Last ().Min;  			_data.RemoveAt (_data.Count () - 1);  			_data [0] = fi;  			while (_data.First ().Min >= _data.First ().Max) {  				fi.Min -= MathHelper.Pi * 2;  				_data [0] = fi;  			}  		}  		int lastPos = _data.Count - 1;  		ShapeData last = _data [lastPos];  		while ((_data.Count () > 0) && (_data.Last ().Min >= _data.Last ().Max))// just making sure min<max  		 {  			last.Min = _data.Last ().Min - 2 * MathHelper.Pi;  			_data [lastPos] = last;  		}  		rayMissed = false;  	}  	else {  		rayMissed = true;  		// raycast did not find a shape  	}  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: for (int i = 0; i < valIndex; ++i) {  	Fixture shape = null;  	float midpt;  	int iplus = (i == valIndex - 1 ? 0 : i + 1);  	if (vals [i] == vals [iplus])  		continue;  	if (i == valIndex - 1) {  		// the single edgecase  		midpt = (vals [0] + MathHelper.Pi * 2 + vals [i]);  	}  	else {  		midpt = (vals [i + 1] + vals [i]);  	}  	midpt = midpt / 2;  	Vector2 p1 = pos;  	Vector2 p2 = radius * new Vector2 ((float)Math.Cos (midpt)' (float)Math.Sin (midpt)) + pos;  	// RaycastOne  	bool hitClosest = false;  	World.RayCast ((f' p' n' fr) =>  {  		Body body = f.Body;  		if (!IsActiveOn (body))  			return 0;  		if (body.UserData != null) {  			int index = (int)body.UserData;  			if (index == 0) {  				// filter  				return -1.0f;  			}  		}  		hitClosest = true;  		shape = f;  		return fr;  	}' p1' p2);  	//draws radius points  	if ((hitClosest) && (shape.Body.BodyType == BodyType.Dynamic)) {  		if ((_data.Count () > 0) && (_data.Last ().Body == shape.Body) && (!rayMissed)) {  			int laPos = _data.Count - 1;  			ShapeData la = _data [laPos];  			la.Max = vals [iplus];  			_data [laPos] = la;  		}  		else {  			// make new  			ShapeData d;  			d.Body = shape.Body;  			d.Min = vals [i];  			d.Max = vals [iplus];  			_data.Add (d);  		}  		if ((_data.Count () > 1) && (i == valIndex - 1) && (_data.Last ().Body == _data.First ().Body) && (_data.Last ().Max == _data.First ().Min)) {  			ShapeData fi = _data [0];  			fi.Min = _data.Last ().Min;  			_data.RemoveAt (_data.Count () - 1);  			_data [0] = fi;  			while (_data.First ().Min >= _data.First ().Max) {  				fi.Min -= MathHelper.Pi * 2;  				_data [0] = fi;  			}  		}  		int lastPos = _data.Count - 1;  		ShapeData last = _data [lastPos];  		while ((_data.Count () > 0) && (_data.Last ().Min >= _data.Last ().Max))// just making sure min<max  		 {  			last.Min = _data.Last ().Min - 2 * MathHelper.Pi;  			_data [lastPos] = last;  		}  		rayMissed = false;  	}  	else {  		rayMissed = true;  		// raycast did not find a shape  	}  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: for (int i = 0; i < valIndex; ++i) {  	Fixture shape = null;  	float midpt;  	int iplus = (i == valIndex - 1 ? 0 : i + 1);  	if (vals [i] == vals [iplus])  		continue;  	if (i == valIndex - 1) {  		// the single edgecase  		midpt = (vals [0] + MathHelper.Pi * 2 + vals [i]);  	}  	else {  		midpt = (vals [i + 1] + vals [i]);  	}  	midpt = midpt / 2;  	Vector2 p1 = pos;  	Vector2 p2 = radius * new Vector2 ((float)Math.Cos (midpt)' (float)Math.Sin (midpt)) + pos;  	// RaycastOne  	bool hitClosest = false;  	World.RayCast ((f' p' n' fr) =>  {  		Body body = f.Body;  		if (!IsActiveOn (body))  			return 0;  		if (body.UserData != null) {  			int index = (int)body.UserData;  			if (index == 0) {  				// filter  				return -1.0f;  			}  		}  		hitClosest = true;  		shape = f;  		return fr;  	}' p1' p2);  	//draws radius points  	if ((hitClosest) && (shape.Body.BodyType == BodyType.Dynamic)) {  		if ((_data.Count () > 0) && (_data.Last ().Body == shape.Body) && (!rayMissed)) {  			int laPos = _data.Count - 1;  			ShapeData la = _data [laPos];  			la.Max = vals [iplus];  			_data [laPos] = la;  		}  		else {  			// make new  			ShapeData d;  			d.Body = shape.Body;  			d.Min = vals [i];  			d.Max = vals [iplus];  			_data.Add (d);  		}  		if ((_data.Count () > 1) && (i == valIndex - 1) && (_data.Last ().Body == _data.First ().Body) && (_data.Last ().Max == _data.First ().Min)) {  			ShapeData fi = _data [0];  			fi.Min = _data.Last ().Min;  			_data.RemoveAt (_data.Count () - 1);  			_data [0] = fi;  			while (_data.First ().Min >= _data.First ().Max) {  				fi.Min -= MathHelper.Pi * 2;  				_data [0] = fi;  			}  		}  		int lastPos = _data.Count - 1;  		ShapeData last = _data [lastPos];  		while ((_data.Count () > 0) && (_data.Last ().Min >= _data.Last ().Max))// just making sure min<max  		 {  			last.Min = _data.Last ().Min - 2 * MathHelper.Pi;  			_data [lastPos] = last;  		}  		rayMissed = false;  	}  	else {  		rayMissed = true;  		// raycast did not find a shape  	}  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: for (int i = 0; i < valIndex; ++i) {  	Fixture shape = null;  	float midpt;  	int iplus = (i == valIndex - 1 ? 0 : i + 1);  	if (vals [i] == vals [iplus])  		continue;  	if (i == valIndex - 1) {  		// the single edgecase  		midpt = (vals [0] + MathHelper.Pi * 2 + vals [i]);  	}  	else {  		midpt = (vals [i + 1] + vals [i]);  	}  	midpt = midpt / 2;  	Vector2 p1 = pos;  	Vector2 p2 = radius * new Vector2 ((float)Math.Cos (midpt)' (float)Math.Sin (midpt)) + pos;  	// RaycastOne  	bool hitClosest = false;  	World.RayCast ((f' p' n' fr) =>  {  		Body body = f.Body;  		if (!IsActiveOn (body))  			return 0;  		if (body.UserData != null) {  			int index = (int)body.UserData;  			if (index == 0) {  				// filter  				return -1.0f;  			}  		}  		hitClosest = true;  		shape = f;  		return fr;  	}' p1' p2);  	//draws radius points  	if ((hitClosest) && (shape.Body.BodyType == BodyType.Dynamic)) {  		if ((_data.Count () > 0) && (_data.Last ().Body == shape.Body) && (!rayMissed)) {  			int laPos = _data.Count - 1;  			ShapeData la = _data [laPos];  			la.Max = vals [iplus];  			_data [laPos] = la;  		}  		else {  			// make new  			ShapeData d;  			d.Body = shape.Body;  			d.Min = vals [i];  			d.Max = vals [iplus];  			_data.Add (d);  		}  		if ((_data.Count () > 1) && (i == valIndex - 1) && (_data.Last ().Body == _data.First ().Body) && (_data.Last ().Max == _data.First ().Min)) {  			ShapeData fi = _data [0];  			fi.Min = _data.Last ().Min;  			_data.RemoveAt (_data.Count () - 1);  			_data [0] = fi;  			while (_data.First ().Min >= _data.First ().Max) {  				fi.Min -= MathHelper.Pi * 2;  				_data [0] = fi;  			}  		}  		int lastPos = _data.Count - 1;  		ShapeData last = _data [lastPos];  		while ((_data.Count () > 0) && (_data.Last ().Min >= _data.Last ().Max))// just making sure min<max  		 {  			last.Min = _data.Last ().Min - 2 * MathHelper.Pi;  			_data [lastPos] = last;  		}  		rayMissed = false;  	}  	else {  		rayMissed = true;  		// raycast did not find a shape  	}  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: if (i == valIndex - 1) {  	// the single edgecase  	midpt = (vals [0] + MathHelper.Pi * 2 + vals [i]);  }  else {  	midpt = (vals [i + 1] + vals [i]);  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: midpt = (vals [0] + MathHelper.Pi * 2 + vals [i]);  
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: midpt = midpt / 2;  
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: if ((hitClosest) && (shape.Body.BodyType == BodyType.Dynamic)) {  	if ((_data.Count () > 0) && (_data.Last ().Body == shape.Body) && (!rayMissed)) {  		int laPos = _data.Count - 1;  		ShapeData la = _data [laPos];  		la.Max = vals [iplus];  		_data [laPos] = la;  	}  	else {  		// make new  		ShapeData d;  		d.Body = shape.Body;  		d.Min = vals [i];  		d.Max = vals [iplus];  		_data.Add (d);  	}  	if ((_data.Count () > 1) && (i == valIndex - 1) && (_data.Last ().Body == _data.First ().Body) && (_data.Last ().Max == _data.First ().Min)) {  		ShapeData fi = _data [0];  		fi.Min = _data.Last ().Min;  		_data.RemoveAt (_data.Count () - 1);  		_data [0] = fi;  		while (_data.First ().Min >= _data.First ().Max) {  			fi.Min -= MathHelper.Pi * 2;  			_data [0] = fi;  		}  	}  	int lastPos = _data.Count - 1;  	ShapeData last = _data [lastPos];  	while ((_data.Count () > 0) && (_data.Last ().Min >= _data.Last ().Max))// just making sure min<max  	 {  		last.Min = _data.Last ().Min - 2 * MathHelper.Pi;  		_data [lastPos] = last;  	}  	rayMissed = false;  }  else {  	rayMissed = true;  	// raycast did not find a shape  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: if ((hitClosest) && (shape.Body.BodyType == BodyType.Dynamic)) {  	if ((_data.Count () > 0) && (_data.Last ().Body == shape.Body) && (!rayMissed)) {  		int laPos = _data.Count - 1;  		ShapeData la = _data [laPos];  		la.Max = vals [iplus];  		_data [laPos] = la;  	}  	else {  		// make new  		ShapeData d;  		d.Body = shape.Body;  		d.Min = vals [i];  		d.Max = vals [iplus];  		_data.Add (d);  	}  	if ((_data.Count () > 1) && (i == valIndex - 1) && (_data.Last ().Body == _data.First ().Body) && (_data.Last ().Max == _data.First ().Min)) {  		ShapeData fi = _data [0];  		fi.Min = _data.Last ().Min;  		_data.RemoveAt (_data.Count () - 1);  		_data [0] = fi;  		while (_data.First ().Min >= _data.First ().Max) {  			fi.Min -= MathHelper.Pi * 2;  			_data [0] = fi;  		}  	}  	int lastPos = _data.Count - 1;  	ShapeData last = _data [lastPos];  	while ((_data.Count () > 0) && (_data.Last ().Min >= _data.Last ().Max))// just making sure min<max  	 {  		last.Min = _data.Last ().Min - 2 * MathHelper.Pi;  		_data [lastPos] = last;  	}  	rayMissed = false;  }  else {  	rayMissed = true;  	// raycast did not find a shape  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: if ((_data.Count () > 1) && (i == valIndex - 1) && (_data.Last ().Body == _data.First ().Body) && (_data.Last ().Max == _data.First ().Min)) {  	ShapeData fi = _data [0];  	fi.Min = _data.Last ().Min;  	_data.RemoveAt (_data.Count () - 1);  	_data [0] = fi;  	while (_data.First ().Min >= _data.First ().Max) {  		fi.Min -= MathHelper.Pi * 2;  		_data [0] = fi;  	}  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: while (_data.First ().Min >= _data.First ().Max) {  	fi.Min -= MathHelper.Pi * 2;  	_data [0] = fi;  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: fi.Min -= MathHelper.Pi * 2;  
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: while ((_data.Count () > 0) && (_data.Last ().Min >= _data.Last ().Max))// just making sure min<max   {  	last.Min = _data.Last ().Min - 2 * MathHelper.Pi;  	_data [lastPos] = last;  }  
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: last.Min = _data.Last ().Min - 2 * MathHelper.Pi;  
Magic Number,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\CuttingTools.cs,SplitShape,The following statement contains a magic number: for (int n = 0; n < 2; n++) {  	Vector2 offset;  	if (cutAdded [n] > 0) {  		offset = (newPolygon [n] [cutAdded [n] - 1] - newPolygon [n] [cutAdded [n]]);  	}  	else {  		offset = (newPolygon [n] [newPolygon [n].Count - 1] - newPolygon [n] [0]);  	}  	offset.Normalize ();  	newPolygon [n] [cutAdded [n]] += splitSize * offset;  	if (cutAdded [n] < newPolygon [n].Count - 2) {  		offset = (newPolygon [n] [cutAdded [n] + 2] - newPolygon [n] [cutAdded [n] + 1]);  	}  	else {  		offset = (newPolygon [n] [0] - newPolygon [n] [newPolygon [n].Count - 1]);  	}  	offset.Normalize ();  	newPolygon [n] [cutAdded [n] + 1] += splitSize * offset;  }  
Magic Number,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\CuttingTools.cs,SplitShape,The following statement contains a magic number: for (int n = 0; n < 2; n++) {  	Vector2 offset;  	if (cutAdded [n] > 0) {  		offset = (newPolygon [n] [cutAdded [n] - 1] - newPolygon [n] [cutAdded [n]]);  	}  	else {  		offset = (newPolygon [n] [newPolygon [n].Count - 1] - newPolygon [n] [0]);  	}  	offset.Normalize ();  	newPolygon [n] [cutAdded [n]] += splitSize * offset;  	if (cutAdded [n] < newPolygon [n].Count - 2) {  		offset = (newPolygon [n] [cutAdded [n] + 2] - newPolygon [n] [cutAdded [n] + 1]);  	}  	else {  		offset = (newPolygon [n] [0] - newPolygon [n] [newPolygon [n].Count - 1]);  	}  	offset.Normalize ();  	newPolygon [n] [cutAdded [n] + 1] += splitSize * offset;  }  
Magic Number,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\CuttingTools.cs,SplitShape,The following statement contains a magic number: for (int n = 0; n < 2; n++) {  	Vector2 offset;  	if (cutAdded [n] > 0) {  		offset = (newPolygon [n] [cutAdded [n] - 1] - newPolygon [n] [cutAdded [n]]);  	}  	else {  		offset = (newPolygon [n] [newPolygon [n].Count - 1] - newPolygon [n] [0]);  	}  	offset.Normalize ();  	newPolygon [n] [cutAdded [n]] += splitSize * offset;  	if (cutAdded [n] < newPolygon [n].Count - 2) {  		offset = (newPolygon [n] [cutAdded [n] + 2] - newPolygon [n] [cutAdded [n] + 1]);  	}  	else {  		offset = (newPolygon [n] [0] - newPolygon [n] [newPolygon [n].Count - 1]);  	}  	offset.Normalize ();  	newPolygon [n] [cutAdded [n] + 1] += splitSize * offset;  }  
Magic Number,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\CuttingTools.cs,SplitShape,The following statement contains a magic number: if (cutAdded [n] < newPolygon [n].Count - 2) {  	offset = (newPolygon [n] [cutAdded [n] + 2] - newPolygon [n] [cutAdded [n] + 1]);  }  else {  	offset = (newPolygon [n] [0] - newPolygon [n] [newPolygon [n].Count - 1]);  }  
Magic Number,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\CuttingTools.cs,SplitShape,The following statement contains a magic number: if (cutAdded [n] < newPolygon [n].Count - 2) {  	offset = (newPolygon [n] [cutAdded [n] + 2] - newPolygon [n] [cutAdded [n] + 1]);  }  else {  	offset = (newPolygon [n] [0] - newPolygon [n] [newPolygon [n].Count - 1]);  }  
Magic Number,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\CuttingTools.cs,SplitShape,The following statement contains a magic number: offset = (newPolygon [n] [cutAdded [n] + 2] - newPolygon [n] [cutAdded [n] + 1]);  
Magic Number,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\CuttingTools.cs,Cut,The following statement contains a magic number: if (entryPoints.Count + exitPoints.Count < 2)  	return;  
Magic Number,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\CuttingTools.cs,SanityCheck,The following statement contains a magic number: if (vertices.Count < 3)  	return false;  
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\SimplifyTools.cs,CollinearSimplify,The following statement contains a magic number: if (vertices.Count < 3)  	return vertices;  
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\SimplifyTools.cs,ReduceByArea,The following statement contains a magic number: if (vertices.Count <= 3)  	return vertices;  
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\SimplifyTools.cs,ReduceByArea,The following statement contains a magic number: v1 = vertices [vertices.Count - 2];  
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\SimplifyTools.cs,ReduceByArea,The following statement contains a magic number: areaTolerance *= 2;  
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\SimplifyTools.cs,MergeParallelEdges,The following statement contains a magic number: if (vertices.Count <= 3)  	return;  
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\SimplifyTools.cs,MergeParallelEdges,The following statement contains a magic number: for (int i = 0; i < vertices.Count; ++i) {  	int lower = (i == 0) ? (vertices.Count - 1) : (i - 1);  	int middle = i;  	int upper = (i == vertices.Count - 1) ? (0) : (i + 1);  	float dx0 = vertices [middle].X - vertices [lower].X;  	float dy0 = vertices [middle].Y - vertices [lower].Y;  	float dx1 = vertices [upper].Y - vertices [middle].X;  	float dy1 = vertices [upper].Y - vertices [middle].Y;  	float norm0 = (float)Math.Sqrt (dx0 * dx0 + dy0 * dy0);  	float norm1 = (float)Math.Sqrt (dx1 * dx1 + dy1 * dy1);  	if (!(norm0 > 0.0f && norm1 > 0.0f) && newNVertices > 3) {  		//Merge identical points  		mergeMe [i] = true;  		--newNVertices;  	}  	dx0 /= norm0;  	dy0 /= norm0;  	dx1 /= norm1;  	dy1 /= norm1;  	float cross = dx0 * dy1 - dx1 * dy0;  	float dot = dx0 * dx1 + dy0 * dy1;  	if (Math.Abs (cross) < tolerance && dot > 0 && newNVertices > 3) {  		mergeMe [i] = true;  		--newNVertices;  	}  	else  		mergeMe [i] = false;  }  
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\SimplifyTools.cs,MergeParallelEdges,The following statement contains a magic number: for (int i = 0; i < vertices.Count; ++i) {  	int lower = (i == 0) ? (vertices.Count - 1) : (i - 1);  	int middle = i;  	int upper = (i == vertices.Count - 1) ? (0) : (i + 1);  	float dx0 = vertices [middle].X - vertices [lower].X;  	float dy0 = vertices [middle].Y - vertices [lower].Y;  	float dx1 = vertices [upper].Y - vertices [middle].X;  	float dy1 = vertices [upper].Y - vertices [middle].Y;  	float norm0 = (float)Math.Sqrt (dx0 * dx0 + dy0 * dy0);  	float norm1 = (float)Math.Sqrt (dx1 * dx1 + dy1 * dy1);  	if (!(norm0 > 0.0f && norm1 > 0.0f) && newNVertices > 3) {  		//Merge identical points  		mergeMe [i] = true;  		--newNVertices;  	}  	dx0 /= norm0;  	dy0 /= norm0;  	dx1 /= norm1;  	dy1 /= norm1;  	float cross = dx0 * dy1 - dx1 * dy0;  	float dot = dx0 * dx1 + dy0 * dy1;  	if (Math.Abs (cross) < tolerance && dot > 0 && newNVertices > 3) {  		mergeMe [i] = true;  		--newNVertices;  	}  	else  		mergeMe [i] = false;  }  
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\SimplifyTools.cs,MergeParallelEdges,The following statement contains a magic number: if (!(norm0 > 0.0f && norm1 > 0.0f) && newNVertices > 3) {  	//Merge identical points  	mergeMe [i] = true;  	--newNVertices;  }  
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\SimplifyTools.cs,MergeParallelEdges,The following statement contains a magic number: if (Math.Abs (cross) < tolerance && dot > 0 && newNVertices > 3) {  	mergeMe [i] = true;  	--newNVertices;  }  else  	mergeMe [i] = false;  
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\SimplifyTools.cs,ReduceByDistance,The following statement contains a magic number: if (vertices.Count < 3)  	return vertices;  
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\SimplifyTools.cs,ReduceByNth,The following statement contains a magic number: if (vertices.Count < 3)  	return vertices;  
Magic Number,FarseerPhysics.Common.PolygonManipulation,YuPengClipper,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\YuPengClipper.cs,BuildPolygonsFromChain,The following statement contains a magic number: while (simplicies.Count > 0) {  	Vertices output = new Vertices ();  	output.Add (simplicies [0].EdgeStart);  	output.Add (simplicies [0].EdgeEnd);  	simplicies.RemoveAt (0);  	bool closed = false;  	int index = 0;  	int count = simplicies.Count;  	// Needed to catch infinite loops  	while (!closed && simplicies.Count > 0) {  		if (VectorEqual (output [output.Count - 1]' simplicies [index].EdgeStart)) {  			if (VectorEqual (simplicies [index].EdgeEnd' output [0])) {  				closed = true;  			}  			else {  				output.Add (simplicies [index].EdgeEnd);  			}  			simplicies.RemoveAt (index);  			--index;  		}  		else if (VectorEqual (output [output.Count - 1]' simplicies [index].EdgeEnd)) {  			if (VectorEqual (simplicies [index].EdgeStart' output [0])) {  				closed = true;  			}  			else {  				output.Add (simplicies [index].EdgeStart);  			}  			simplicies.RemoveAt (index);  			--index;  		}  		if (!closed) {  			if (++index == simplicies.Count) {  				if (count == simplicies.Count) {  					result = new List<Vertices> ();  					Debug.WriteLine ("Undefined error while building result polygon(s).");  					return PolyClipError.BrokenResult;  				}  				index = 0;  				count = simplicies.Count;  			}  		}  	}  	if (output.Count < 3) {  		errVal = PolyClipError.DegeneratedOutput;  		Debug.WriteLine ("Degenerated output polygon produced (vertices < 3).");  	}  	result.Add (output);  }  
Magic Number,FarseerPhysics.Common.PolygonManipulation,YuPengClipper,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\PolygonManipulation\YuPengClipper.cs,BuildPolygonsFromChain,The following statement contains a magic number: if (output.Count < 3) {  	errVal = PolyClipError.DegeneratedOutput;  	Debug.WriteLine ("Degenerated output polygon produced (vertices < 3).");  }  
Magic Number,FarseerPhysics.Controllers,AbstractForceController,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Controllers\AbstractForceController.cs,AbstractForceController,The following statement contains a magic number: Randomize = new Random (1234);  
Magic Number,FarseerPhysics.Controllers,AbstractForceController,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Controllers\AbstractForceController.cs,AbstractForceController,The following statement contains a magic number: StrengthCurve.Keys.Add (new CurveKey (0' 5));  
Magic Number,FarseerPhysics.Controllers,AbstractForceController,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Controllers\AbstractForceController.cs,AbstractForceController,The following statement contains a magic number: StrengthCurve.Keys.Add (new CurveKey (0.1f' 5));  
Magic Number,FarseerPhysics.Controllers,AbstractForceController,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Controllers\AbstractForceController.cs,AbstractForceController,The following statement contains a magic number: StrengthCurve.Keys.Add (new CurveKey (0.2f' -4));  
Magic Number,FarseerPhysics.Dynamics,Body,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Body.cs,Body,The following statement contains a magic number: FixtureList = new List<Fixture> (32);  
Magic Number,FarseerPhysics.Dynamics,Body,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Body.cs,Body,The following statement contains a magic number: FixtureList = new List<Fixture> (32);  
Magic Number,FarseerPhysics.Dynamics,Island,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Island.cs,Reset,The following statement contains a magic number: if (_contacts == null || _contacts.Length < contactCapacity) {  	_contacts = new Contact[contactCapacity * 2];  }  
Magic Number,FarseerPhysics.Dynamics,Island,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Island.cs,Reset,The following statement contains a magic number: _contacts = new Contact[contactCapacity * 2];  
Magic Number,FarseerPhysics.Dynamics,Island,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Island.cs,Reset,The following statement contains a magic number: if (_joints == null || _joints.Length < jointCapacity) {  	_joints = new Joint[jointCapacity * 2];  }  
Magic Number,FarseerPhysics.Dynamics,Island,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Island.cs,Reset,The following statement contains a magic number: _joints = new Joint[jointCapacity * 2];  
Magic Number,FarseerPhysics.Dynamics,World,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\World.cs,World,The following statement contains a magic number: BodyList = new List<Body> (32);  
Magic Number,FarseerPhysics.Dynamics,World,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\World.cs,World,The following statement contains a magic number: JointList = new List<Joint> (32);  
Magic Number,FarseerPhysics.Dynamics,World,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\World.cs,Solve,The following statement contains a magic number: if (stackSize > _stack.Length)  	_stack = new Body[Math.Max (_stack.Length * 2' stackSize)];  
Magic Number,FarseerPhysics.Dynamics,World,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\World.cs,Solve,The following statement contains a magic number: _stack = new Body[Math.Max (_stack.Length * 2' stackSize)];  
Magic Number,FarseerPhysics.Dynamics,World,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\World.cs,SolveTOI,The following statement contains a magic number: Island.Reset (2 * Settings.MaxTOIContacts' Settings.MaxTOIContacts' 0' ContactManager);  
Magic Number,FarseerPhysics.Dynamics,World,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\World.cs,SolveTOI,The following statement contains a magic number: for (; ;) {  	// Find the first TOI.  	Contact minContact = null;  	float minAlpha = 1.0f;  	for (int i = 0; i < ContactManager.ContactList.Count; i++) {  		Contact c = ContactManager.ContactList [i];  		// Is this contact disabled?  		if (c.Enabled == false) {  			continue;  		}  		// Prevent excessive sub-stepping.  		if (c.TOICount > Settings.MaxSubSteps) {  			continue;  		}  		float alpha;  		if ((c.Flags & ContactFlags.TOI) == ContactFlags.TOI) {  			// This contact has a valid cached TOI.  			alpha = c.TOI;  		}  		else {  			Fixture fA = c.FixtureA;  			Fixture fB = c.FixtureB;  			// Is there a sensor?  			if (fA.IsSensor || fB.IsSensor) {  				continue;  			}  			Body bA = fA.Body;  			Body bB = fB.Body;  			BodyType typeA = bA.BodyType;  			BodyType typeB = bB.BodyType;  			Debug.Assert (typeA == BodyType.Dynamic || typeB == BodyType.Dynamic);  			bool awakeA = bA.Awake && typeA != BodyType.Static;  			bool awakeB = bB.Awake && typeB != BodyType.Static;  			// Is at least one body awake?  			if (awakeA == false && awakeB == false) {  				continue;  			}  			bool collideA = (bA.IsBullet || typeA != BodyType.Dynamic) && !bA.IgnoreCCD;  			bool collideB = (bB.IsBullet || typeB != BodyType.Dynamic) && !bB.IgnoreCCD;  			// Are these two non-bullet dynamic bodies?  			if (collideA == false && collideB == false) {  				continue;  			}  			// Compute the TOI for this contact.  			// Put the sweeps onto the same time interval.  			float alpha0 = bA.Sweep.Alpha0;  			if (bA.Sweep.Alpha0 < bB.Sweep.Alpha0) {  				alpha0 = bB.Sweep.Alpha0;  				bA.Sweep.Advance (alpha0);  			}  			else if (bB.Sweep.Alpha0 < bA.Sweep.Alpha0) {  				alpha0 = bA.Sweep.Alpha0;  				bB.Sweep.Advance (alpha0);  			}  			Debug.Assert (alpha0 < 1.0f);  			// Compute the time of impact in interval [0' minTOI]  			_input.ProxyA.Set (fA.Shape' c.ChildIndexA);  			_input.ProxyB.Set (fB.Shape' c.ChildIndexB);  			_input.SweepA = bA.Sweep;  			_input.SweepB = bB.Sweep;  			_input.TMax = 1.0f;  			TOIOutput output;  			TimeOfImpact.CalculateTimeOfImpact (out output' _input);  			// Beta is the fraction of the remaining portion of the .  			float beta = output.T;  			if (output.State == TOIOutputState.Touching) {  				alpha = Math.Min (alpha0 + (1.0f - alpha0) * beta' 1.0f);  			}  			else {  				alpha = 1.0f;  			}  			c.TOI = alpha;  			c.Flags |= ContactFlags.TOI;  		}  		if (alpha < minAlpha) {  			// This is the minimum TOI found so far.  			minContact = c;  			minAlpha = alpha;  		}  	}  	if (minContact == null || 1.0f - 10.0f * Settings.Epsilon < minAlpha) {  		// No more TOI events. Done!  		_stepComplete = true;  		break;  	}  	// Advance the bodies to the TOI.  	Fixture fA1 = minContact.FixtureA;  	Fixture fB1 = minContact.FixtureB;  	Body bA1 = fA1.Body;  	Body bB1 = fB1.Body;  	Sweep backup1 = bA1.Sweep;  	Sweep backup2 = bB1.Sweep;  	bA1.Advance (minAlpha);  	bB1.Advance (minAlpha);  	// The TOI contact likely has some new contact points.  	minContact.Update (ContactManager);  	minContact.Flags &= ~ContactFlags.TOI;  	++minContact.TOICount;  	// Is the contact solid?  	if (minContact.Enabled == false || minContact.IsTouching () == false) {  		// Restore the sweeps.  		minContact.Enabled = false;  		bA1.Sweep = backup1;  		bB1.Sweep = backup2;  		bA1.SynchronizeTransform ();  		bB1.SynchronizeTransform ();  		continue;  	}  	bA1.Awake = true;  	bB1.Awake = true;  	// Build the island  	Island.Clear ();  	Island.Add (bA1);  	Island.Add (bB1);  	Island.Add (minContact);  	bA1.Flags |= BodyFlags.Island;  	bB1.Flags |= BodyFlags.Island;  	minContact.Flags |= ContactFlags.Island;  	// Get contacts on bodyA and bodyB.  	Body[] bodies =  {  		bA1'  		bB1  	};  	for (int i = 0; i < 2; ++i) {  		Body body = bodies [i];  		if (body.BodyType == BodyType.Dynamic) {  			// for (ContactEdge ce = body.ContactList; ce && Island.BodyCount < Settings.MaxTOIContacts; ce = ce.Next)  			for (ContactEdge ce = body.ContactList; ce != null; ce = ce.Next) {  				Contact contact = ce.Contact;  				// Has this contact already been added to the island?  				if ((contact.Flags & ContactFlags.Island) == ContactFlags.Island) {  					continue;  				}  				// Only add static' kinematic' or bullet bodies.  				Body other = ce.Other;  				if (other.BodyType == BodyType.Dynamic && body.IsBullet == false && other.IsBullet == false) {  					continue;  				}  				// Skip sensors.  				if (contact.FixtureA.IsSensor || contact.FixtureB.IsSensor) {  					continue;  				}  				// Tentatively advance the body to the TOI.  				Sweep backup = other.Sweep;  				if ((other.Flags & BodyFlags.Island) == 0) {  					other.Advance (minAlpha);  				}  				// Update the contact points  				contact.Update (ContactManager);  				// Was the contact disabled by the user?  				if (contact.Enabled == false) {  					other.Sweep = backup;  					other.SynchronizeTransform ();  					continue;  				}  				// Are there contact points?  				if (contact.IsTouching () == false) {  					other.Sweep = backup;  					other.SynchronizeTransform ();  					continue;  				}  				// Add the contact to the island  				contact.Flags |= ContactFlags.Island;  				Island.Add (contact);  				// Has the other body already been added to the island?  				if ((other.Flags & BodyFlags.Island) == BodyFlags.Island) {  					continue;  				}  				// Add the other body to the island.  				other.Flags |= BodyFlags.Island;  				if (other.BodyType != BodyType.Static) {  					other.Awake = true;  				}  				Island.Add (other);  			}  		}  	}  	TimeStep subStep;  	subStep.dt = (1.0f - minAlpha) * step.dt;  	subStep.inv_dt = 1.0f / subStep.dt;  	subStep.dtRatio = 1.0f;  	//subStep.positionIterations = 20;  	//subStep.velocityIterations = step.velocityIterations;  	//subStep.warmStarting = false;  	Island.SolveTOI (ref subStep);  	// Reset island flags and synchronize broad-phase proxies.  	for (int i = 0; i < Island.BodyCount; ++i) {  		Body body = Island.Bodies [i];  		body.Flags &= ~BodyFlags.Island;  		if (body.BodyType != BodyType.Dynamic) {  			continue;  		}  		body.SynchronizeFixtures ();  		// Invalidate all contact TOIs on this displaced body.  		for (ContactEdge ce = body.ContactList; ce != null; ce = ce.Next) {  			ce.Contact.Flags &= ~(ContactFlags.TOI | ContactFlags.Island);  		}  	}  	// Commit fixture proxy movements to the broad-phase so that new contacts are created.  	// Also' some contacts can be destroyed.  	ContactManager.FindNewContacts ();  	if (EnableSubStepping) {  		_stepComplete = false;  		break;  	}  }  
Magic Number,FarseerPhysics.Dynamics,World,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\World.cs,SolveTOI,The following statement contains a magic number: for (int i = 0; i < 2; ++i) {  	Body body = bodies [i];  	if (body.BodyType == BodyType.Dynamic) {  		// for (ContactEdge ce = body.ContactList; ce && Island.BodyCount < Settings.MaxTOIContacts; ce = ce.Next)  		for (ContactEdge ce = body.ContactList; ce != null; ce = ce.Next) {  			Contact contact = ce.Contact;  			// Has this contact already been added to the island?  			if ((contact.Flags & ContactFlags.Island) == ContactFlags.Island) {  				continue;  			}  			// Only add static' kinematic' or bullet bodies.  			Body other = ce.Other;  			if (other.BodyType == BodyType.Dynamic && body.IsBullet == false && other.IsBullet == false) {  				continue;  			}  			// Skip sensors.  			if (contact.FixtureA.IsSensor || contact.FixtureB.IsSensor) {  				continue;  			}  			// Tentatively advance the body to the TOI.  			Sweep backup = other.Sweep;  			if ((other.Flags & BodyFlags.Island) == 0) {  				other.Advance (minAlpha);  			}  			// Update the contact points  			contact.Update (ContactManager);  			// Was the contact disabled by the user?  			if (contact.Enabled == false) {  				other.Sweep = backup;  				other.SynchronizeTransform ();  				continue;  			}  			// Are there contact points?  			if (contact.IsTouching () == false) {  				other.Sweep = backup;  				other.SynchronizeTransform ();  				continue;  			}  			// Add the contact to the island  			contact.Flags |= ContactFlags.Island;  			Island.Add (contact);  			// Has the other body already been added to the island?  			if ((other.Flags & BodyFlags.Island) == BodyFlags.Island) {  				continue;  			}  			// Add the other body to the island.  			other.Flags |= BodyFlags.Island;  			if (other.BodyType != BodyType.Static) {  				other.Awake = true;  			}  			Island.Add (other);  		}  	}  }  
Magic Number,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\ContactSolver.cs,Reset,The following statement contains a magic number: if (Constraints == null || Constraints.Length < _constraintCount) {  	Constraints = new ContactConstraint[_constraintCount * 2];  	for (int i = 0; i < Constraints.Length; i++) {  		Constraints [i] = new ContactConstraint ();  	}  }  
Magic Number,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\ContactSolver.cs,Reset,The following statement contains a magic number: Constraints = new ContactConstraint[_constraintCount * 2];  
Magic Number,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\ContactSolver.cs,InitializeVelocityConstraints,The following statement contains a magic number: for (int i = 0; i < _constraintCount; ++i) {  	ContactConstraint cc = Constraints [i];  	float radiusA = cc.RadiusA;  	float radiusB = cc.RadiusB;  	Body bodyA = cc.BodyA;  	Body bodyB = cc.BodyB;  	Manifold manifold = cc.Manifold;  	Vector2 vA = bodyA.LinearVelocity;  	Vector2 vB = bodyB.LinearVelocity;  	float wA = bodyA.AngularVelocity;  	float wB = bodyB.AngularVelocity;  	Debug.Assert (manifold.PointCount > 0);  	FixedArray2<Vector2> points;  	Collision.Collision.GetWorldManifold (ref manifold' ref bodyA.Xf' radiusA' ref bodyB.Xf' radiusB' out cc.Normal' out points);  	Vector2 tangent = new Vector2 (cc.Normal.Y' -cc.Normal.X);  	for (int j = 0; j < cc.PointCount; ++j) {  		ContactConstraintPoint ccp = cc.Points [j];  		ccp.rA = points [j] - bodyA.Sweep.C;  		ccp.rB = points [j] - bodyB.Sweep.C;  		float rnA = ccp.rA.X * cc.Normal.Y - ccp.rA.Y * cc.Normal.X;  		float rnB = ccp.rB.X * cc.Normal.Y - ccp.rB.Y * cc.Normal.X;  		rnA *= rnA;  		rnB *= rnB;  		float kNormal = bodyA.InvMass + bodyB.InvMass + bodyA.InvI * rnA + bodyB.InvI * rnB;  		Debug.Assert (kNormal > Settings.Epsilon);  		ccp.NormalMass = 1.0f / kNormal;  		float rtA = ccp.rA.X * tangent.Y - ccp.rA.Y * tangent.X;  		float rtB = ccp.rB.X * tangent.Y - ccp.rB.Y * tangent.X;  		rtA *= rtA;  		rtB *= rtB;  		float kTangent = bodyA.InvMass + bodyB.InvMass + bodyA.InvI * rtA + bodyB.InvI * rtB;  		Debug.Assert (kTangent > Settings.Epsilon);  		ccp.TangentMass = 1.0f / kTangent;  		// Setup a velocity bias for restitution.  		ccp.VelocityBias = 0.0f;  		float vRel = cc.Normal.X * (vB.X + -wB * ccp.rB.Y - vA.X - -wA * ccp.rA.Y) + cc.Normal.Y * (vB.Y + wB * ccp.rB.X - vA.Y - wA * ccp.rA.X);  		if (vRel < -Settings.VelocityThreshold) {  			ccp.VelocityBias = -cc.Restitution * vRel;  		}  	}  	// If we have two points' then prepare the block solver.  	if (cc.PointCount == 2) {  		ContactConstraintPoint ccp1 = cc.Points [0];  		ContactConstraintPoint ccp2 = cc.Points [1];  		float invMassA = bodyA.InvMass;  		float invIA = bodyA.InvI;  		float invMassB = bodyB.InvMass;  		float invIB = bodyB.InvI;  		float rn1A = ccp1.rA.X * cc.Normal.Y - ccp1.rA.Y * cc.Normal.X;  		float rn1B = ccp1.rB.X * cc.Normal.Y - ccp1.rB.Y * cc.Normal.X;  		float rn2A = ccp2.rA.X * cc.Normal.Y - ccp2.rA.Y * cc.Normal.X;  		float rn2B = ccp2.rB.X * cc.Normal.Y - ccp2.rB.Y * cc.Normal.X;  		float k11 = invMassA + invMassB + invIA * rn1A * rn1A + invIB * rn1B * rn1B;  		float k22 = invMassA + invMassB + invIA * rn2A * rn2A + invIB * rn2B * rn2B;  		float k12 = invMassA + invMassB + invIA * rn1A * rn2A + invIB * rn1B * rn2B;  		// Ensure a reasonable condition number.  		const float k_maxConditionNumber = 100.0f;  		if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {  			// K is safe to invert.  			cc.K.Col1.X = k11;  			cc.K.Col1.Y = k12;  			cc.K.Col2.X = k12;  			cc.K.Col2.Y = k22;  			float a = cc.K.Col1.X' b = cc.K.Col2.X' c = cc.K.Col1.Y' d = cc.K.Col2.Y;  			float det = a * d - b * c;  			if (det != 0.0f) {  				det = 1.0f / det;  			}  			cc.NormalMass.Col1.X = det * d;  			cc.NormalMass.Col1.Y = -det * c;  			cc.NormalMass.Col2.X = -det * b;  			cc.NormalMass.Col2.Y = det * a;  		}  		else {  			// The constraints are redundant' just use one.  			// TODO_ERIN use deepest?  			cc.PointCount = 1;  		}  	}  }  
Magic Number,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\ContactSolver.cs,InitializeVelocityConstraints,The following statement contains a magic number: if (cc.PointCount == 2) {  	ContactConstraintPoint ccp1 = cc.Points [0];  	ContactConstraintPoint ccp2 = cc.Points [1];  	float invMassA = bodyA.InvMass;  	float invIA = bodyA.InvI;  	float invMassB = bodyB.InvMass;  	float invIB = bodyB.InvI;  	float rn1A = ccp1.rA.X * cc.Normal.Y - ccp1.rA.Y * cc.Normal.X;  	float rn1B = ccp1.rB.X * cc.Normal.Y - ccp1.rB.Y * cc.Normal.X;  	float rn2A = ccp2.rA.X * cc.Normal.Y - ccp2.rA.Y * cc.Normal.X;  	float rn2B = ccp2.rB.X * cc.Normal.Y - ccp2.rB.Y * cc.Normal.X;  	float k11 = invMassA + invMassB + invIA * rn1A * rn1A + invIB * rn1B * rn1B;  	float k22 = invMassA + invMassB + invIA * rn2A * rn2A + invIB * rn2B * rn2B;  	float k12 = invMassA + invMassB + invIA * rn1A * rn2A + invIB * rn1B * rn2B;  	// Ensure a reasonable condition number.  	const float k_maxConditionNumber = 100.0f;  	if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {  		// K is safe to invert.  		cc.K.Col1.X = k11;  		cc.K.Col1.Y = k12;  		cc.K.Col2.X = k12;  		cc.K.Col2.Y = k22;  		float a = cc.K.Col1.X' b = cc.K.Col2.X' c = cc.K.Col1.Y' d = cc.K.Col2.Y;  		float det = a * d - b * c;  		if (det != 0.0f) {  			det = 1.0f / det;  		}  		cc.NormalMass.Col1.X = det * d;  		cc.NormalMass.Col1.Y = -det * c;  		cc.NormalMass.Col2.X = -det * b;  		cc.NormalMass.Col2.Y = det * a;  	}  	else {  		// The constraints are redundant' just use one.  		// TODO_ERIN use deepest?  		cc.PointCount = 1;  	}  }  
Magic Number,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\ContactSolver.cs,SolveVelocityConstraints,The following statement contains a magic number: for (int i = 0; i < _constraintCount; ++i) {  	ContactConstraint c = Constraints [i];  	float wA = c.BodyA.AngularVelocityInternal;  	float wB = c.BodyB.AngularVelocityInternal;  	float tangentx = c.Normal.Y;  	float tangenty = -c.Normal.X;  	float friction = c.Friction;  	Debug.Assert (c.PointCount == 1 || c.PointCount == 2);  	// Solve tangent constraints  	for (int j = 0; j < c.PointCount; ++j) {  		ContactConstraintPoint ccp = c.Points [j];  		float lambda = ccp.TangentMass * -((c.BodyB.LinearVelocityInternal.X + (-wB * ccp.rB.Y) - c.BodyA.LinearVelocityInternal.X - (-wA * ccp.rA.Y)) * tangentx + (c.BodyB.LinearVelocityInternal.Y + (wB * ccp.rB.X) - c.BodyA.LinearVelocityInternal.Y - (wA * ccp.rA.X)) * tangenty);  		// MathUtils.Clamp the accumulated force  		float maxFriction = friction * ccp.NormalImpulse;  		float newImpulse = Math.Max (-maxFriction' Math.Min (ccp.TangentImpulse + lambda' maxFriction));  		lambda = newImpulse - ccp.TangentImpulse;  		// Apply contact impulse  		float px = lambda * tangentx;  		float py = lambda * tangenty;  		c.BodyA.LinearVelocityInternal.X -= c.BodyA.InvMass * px;  		c.BodyA.LinearVelocityInternal.Y -= c.BodyA.InvMass * py;  		wA -= c.BodyA.InvI * (ccp.rA.X * py - ccp.rA.Y * px);  		c.BodyB.LinearVelocityInternal.X += c.BodyB.InvMass * px;  		c.BodyB.LinearVelocityInternal.Y += c.BodyB.InvMass * py;  		wB += c.BodyB.InvI * (ccp.rB.X * py - ccp.rB.Y * px);  		ccp.TangentImpulse = newImpulse;  	}  	// Solve normal constraints  	if (c.PointCount == 1) {  		ContactConstraintPoint ccp = c.Points [0];  		// Relative velocity at contact  		// Compute normal impulse  		float lambda = -ccp.NormalMass * ((c.BodyB.LinearVelocityInternal.X + (-wB * ccp.rB.Y) - c.BodyA.LinearVelocityInternal.X - (-wA * ccp.rA.Y)) * c.Normal.X + (c.BodyB.LinearVelocityInternal.Y + (wB * ccp.rB.X) - c.BodyA.LinearVelocityInternal.Y - (wA * ccp.rA.X)) * c.Normal.Y - ccp.VelocityBias);  		// Clamp the accumulated impulse  		float newImpulse = Math.Max (ccp.NormalImpulse + lambda' 0.0f);  		lambda = newImpulse - ccp.NormalImpulse;  		// Apply contact impulse  		float px = lambda * c.Normal.X;  		float py = lambda * c.Normal.Y;  		c.BodyA.LinearVelocityInternal.X -= c.BodyA.InvMass * px;  		c.BodyA.LinearVelocityInternal.Y -= c.BodyA.InvMass * py;  		wA -= c.BodyA.InvI * (ccp.rA.X * py - ccp.rA.Y * px);  		c.BodyB.LinearVelocityInternal.X += c.BodyB.InvMass * px;  		c.BodyB.LinearVelocityInternal.Y += c.BodyB.InvMass * py;  		wB += c.BodyB.InvI * (ccp.rB.X * py - ccp.rB.Y * px);  		ccp.NormalImpulse = newImpulse;  	}  	else {  		// Block solver developed in collaboration with Dirk Gregorius (back in 01/07 on Box2D_Lite).  		// Build the mini LCP for this contact patch  		//  		// vn = A * x + b' vn >= 0' ' vn >= 0' x >= 0 and vn_i * x_i = 0 with i = 1..2  		//  		// A = J * W * JT and J = ( -n' -r1 x n' n' r2 x n )  		// b = vn_0 - velocityBias  		//  		// The system is solved using the "Total enumeration method" (s. Murty). The complementary constraint vn_i * x_i  		// implies that we must have in any solution either vn_i = 0 or x_i = 0. So for the 2D contact problem the cases  		// vn1 = 0 and vn2 = 0' x1 = 0 and x2 = 0' x1 = 0 and vn2 = 0' x2 = 0 and vn1 = 0 need to be tested. The first valid  		// solution that satisfies the problem is chosen.  		//   		// In order to account of the accumulated impulse 'a' (because of the iterative nature of the solver which only requires  		// that the accumulated impulse is clamped and not the incremental impulse) we change the impulse variable (x_i).  		//  		// Substitute:  		//   		// x = x' - a  		//   		// Plug into above equation:  		//  		// vn = A * x + b  		//    = A * (x' - a) + b  		//    = A * x' + b - A * a  		//    = A * x' + b'  		// b' = b - A * a;  		ContactConstraintPoint cp1 = c.Points [0];  		ContactConstraintPoint cp2 = c.Points [1];  		float ax = cp1.NormalImpulse;  		float ay = cp2.NormalImpulse;  		Debug.Assert (ax >= 0.0f && ay >= 0.0f);  		// Relative velocity at contact  		// Compute normal velocity  		float vn1 = (c.BodyB.LinearVelocityInternal.X + (-wB * cp1.rB.Y) - c.BodyA.LinearVelocityInternal.X - (-wA * cp1.rA.Y)) * c.Normal.X + (c.BodyB.LinearVelocityInternal.Y + (wB * cp1.rB.X) - c.BodyA.LinearVelocityInternal.Y - (wA * cp1.rA.X)) * c.Normal.Y;  		float vn2 = (c.BodyB.LinearVelocityInternal.X + (-wB * cp2.rB.Y) - c.BodyA.LinearVelocityInternal.X - (-wA * cp2.rA.Y)) * c.Normal.X + (c.BodyB.LinearVelocityInternal.Y + (wB * cp2.rB.X) - c.BodyA.LinearVelocityInternal.Y - (wA * cp2.rA.X)) * c.Normal.Y;  		float bx = vn1 - cp1.VelocityBias - (c.K.Col1.X * ax + c.K.Col2.X * ay);  		float by = vn2 - cp2.VelocityBias - (c.K.Col1.Y * ax + c.K.Col2.Y * ay);  		float xx = -(c.NormalMass.Col1.X * bx + c.NormalMass.Col2.X * by);  		float xy = -(c.NormalMass.Col1.Y * bx + c.NormalMass.Col2.Y * by);  		while (true) {  			//  			// Case 1: vn = 0  			//  			// 0 = A * x' + b'  			//  			// Solve for x':  			//  			// x' = - inv(A) * b'  			//  			if (xx >= 0.0f && xy >= 0.0f) {  				// Resubstitute for the incremental impulse  				float dx = xx - ax;  				float dy = xy - ay;  				// Apply incremental impulse  				float p1x = dx * c.Normal.X;  				float p1y = dx * c.Normal.Y;  				float p2x = dy * c.Normal.X;  				float p2y = dy * c.Normal.Y;  				float p12x = p1x + p2x;  				float p12y = p1y + p2y;  				c.BodyA.LinearVelocityInternal.X -= c.BodyA.InvMass * p12x;  				c.BodyA.LinearVelocityInternal.Y -= c.BodyA.InvMass * p12y;  				wA -= c.BodyA.InvI * ((cp1.rA.X * p1y - cp1.rA.Y * p1x) + (cp2.rA.X * p2y - cp2.rA.Y * p2x));  				c.BodyB.LinearVelocityInternal.X += c.BodyB.InvMass * p12x;  				c.BodyB.LinearVelocityInternal.Y += c.BodyB.InvMass * p12y;  				wB += c.BodyB.InvI * ((cp1.rB.X * p1y - cp1.rB.Y * p1x) + (cp2.rB.X * p2y - cp2.rB.Y * p2x));  				// Accumulate  				cp1.NormalImpulse = xx;  				cp2.NormalImpulse = xy;  				#if B2_DEBUG_SOLVER  				                             			                float k_errorTol = 1e-3f;  					        // Postconditions 					        dv1 = vB + MathUtils.Cross(wB' cp1.rB) - vA - MathUtils.Cross(wA' cp1.rA); 					        dv2 = vB + MathUtils.Cross(wB' cp2.rB) - vA - MathUtils.Cross(wA' cp2.rA);  					        // Compute normal velocity 					        vn1 = Vector2.Dot(dv1' normal); 					        vn2 = Vector2.Dot(dv2' normal);  					        Debug.Assert(MathUtils.Abs(vn1 - cp1.velocityBias) < k_errorTol); 					        Debug.Assert(MathUtils.Abs(vn2 - cp2.velocityBias) < k_errorTol); #endif  				break;  			}  			//  			// Case 2: vn1 = 0 and x2 = 0  			//  			//   0 = a11 * x1' + a12 * 0 + b1'   			// vn2 = a21 * x1' + a22 * 0 + b2'  			//  			xx = -cp1.NormalMass * bx;  			xy = 0.0f;  			vn1 = 0.0f;  			vn2 = c.K.Col1.Y * xx + by;  			if (xx >= 0.0f && vn2 >= 0.0f) {  				// Resubstitute for the incremental impulse  				float dx = xx - ax;  				float dy = xy - ay;  				// Apply incremental impulse  				float p1x = dx * c.Normal.X;  				float p1y = dx * c.Normal.Y;  				float p2x = dy * c.Normal.X;  				float p2y = dy * c.Normal.Y;  				float p12x = p1x + p2x;  				float p12y = p1y + p2y;  				c.BodyA.LinearVelocityInternal.X -= c.BodyA.InvMass * p12x;  				c.BodyA.LinearVelocityInternal.Y -= c.BodyA.InvMass * p12y;  				wA -= c.BodyA.InvI * ((cp1.rA.X * p1y - cp1.rA.Y * p1x) + (cp2.rA.X * p2y - cp2.rA.Y * p2x));  				c.BodyB.LinearVelocityInternal.X += c.BodyB.InvMass * p12x;  				c.BodyB.LinearVelocityInternal.Y += c.BodyB.InvMass * p12y;  				wB += c.BodyB.InvI * ((cp1.rB.X * p1y - cp1.rB.Y * p1x) + (cp2.rB.X * p2y - cp2.rB.Y * p2x));  				// Accumulate  				cp1.NormalImpulse = xx;  				cp2.NormalImpulse = xy;  				#if B2_DEBUG_SOLVER  				    // Postconditions 					        dv1 = vB + MathUtils.Cross(wB' cp1.rB) - vA - MathUtils.Cross(wA' cp1.rA);  					        // Compute normal velocity 					        vn1 = Vector2.Dot(dv1' normal);  					        Debug.Assert(MathUtils.Abs(vn1 - cp1.velocityBias) < k_errorTol); #endif  				break;  			}  			//  			// Case 3: vn2 = 0 and x1 = 0  			//  			// vn1 = a11 * 0 + a12 * x2' + b1'   			//   0 = a21 * 0 + a22 * x2' + b2'  			//  			xx = 0.0f;  			xy = -cp2.NormalMass * by;  			vn1 = c.K.Col2.X * xy + bx;  			vn2 = 0.0f;  			if (xy >= 0.0f && vn1 >= 0.0f) {  				// Resubstitute for the incremental impulse  				float dx = xx - ax;  				float dy = xy - ay;  				// Apply incremental impulse  				float p1x = dx * c.Normal.X;  				float p1y = dx * c.Normal.Y;  				float p2x = dy * c.Normal.X;  				float p2y = dy * c.Normal.Y;  				float p12x = p1x + p2x;  				float p12y = p1y + p2y;  				c.BodyA.LinearVelocityInternal.X -= c.BodyA.InvMass * p12x;  				c.BodyA.LinearVelocityInternal.Y -= c.BodyA.InvMass * p12y;  				wA -= c.BodyA.InvI * ((cp1.rA.X * p1y - cp1.rA.Y * p1x) + (cp2.rA.X * p2y - cp2.rA.Y * p2x));  				c.BodyB.LinearVelocityInternal.X += c.BodyB.InvMass * p12x;  				c.BodyB.LinearVelocityInternal.Y += c.BodyB.InvMass * p12y;  				wB += c.BodyB.InvI * ((cp1.rB.X * p1y - cp1.rB.Y * p1x) + (cp2.rB.X * p2y - cp2.rB.Y * p2x));  				// Accumulate  				cp1.NormalImpulse = xx;  				cp2.NormalImpulse = xy;  				#if B2_DEBUG_SOLVER  				    // Postconditions 					        dv2 = vB + MathUtils.Cross(wB' cp2.rB) - vA - MathUtils.Cross(wA' cp2.rA);  					        // Compute normal velocity 					        vn2 = Vector2.Dot(dv2' normal);  					        Debug.Assert(MathUtils.Abs(vn2 - cp2.velocityBias) < k_errorTol); #endif  				break;  			}  			//  			// Case 4: x1 = 0 and x2 = 0  			//   			// vn1 = b1  			// vn2 = b2;  			xx = 0.0f;  			xy = 0.0f;  			vn1 = bx;  			vn2 = by;  			if (vn1 >= 0.0f && vn2 >= 0.0f) {  				// Resubstitute for the incremental impulse  				float dx = xx - ax;  				float dy = xy - ay;  				// Apply incremental impulse  				float p1x = dx * c.Normal.X;  				float p1y = dx * c.Normal.Y;  				float p2x = dy * c.Normal.X;  				float p2y = dy * c.Normal.Y;  				float p12x = p1x + p2x;  				float p12y = p1y + p2y;  				c.BodyA.LinearVelocityInternal.X -= c.BodyA.InvMass * p12x;  				c.BodyA.LinearVelocityInternal.Y -= c.BodyA.InvMass * p12y;  				wA -= c.BodyA.InvI * ((cp1.rA.X * p1y - cp1.rA.Y * p1x) + (cp2.rA.X * p2y - cp2.rA.Y * p2x));  				c.BodyB.LinearVelocityInternal.X += c.BodyB.InvMass * p12x;  				c.BodyB.LinearVelocityInternal.Y += c.BodyB.InvMass * p12y;  				wB += c.BodyB.InvI * ((cp1.rB.X * p1y - cp1.rB.Y * p1x) + (cp2.rB.X * p2y - cp2.rB.Y * p2x));  				// Accumulate  				cp1.NormalImpulse = xx;  				cp2.NormalImpulse = xy;  				break;  			}  			// No solution' give up. This is hit sometimes' but it doesn't seem to matter.  			break;  		}  	}  	c.BodyA.AngularVelocityInternal = wA;  	c.BodyB.AngularVelocityInternal = wB;  }  
Magic Number,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\ContactSolver.cs,SolveVelocityConstraints,The following statement contains a magic number: Debug.Assert (c.PointCount == 1 || c.PointCount == 2);  
Magic Number,FarseerPhysics.Helpers,Camera2D,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Helpers\Camera2D.cs,Update,The following statement contains a magic number: if (distance < 10f) {  	inertia = (float)Math.Pow (distance / 10.0' 2.0);  }  else {  	inertia = 1f;  }  
Magic Number,FarseerPhysics.Helpers,Camera2D,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Helpers\Camera2D.cs,Update,The following statement contains a magic number: if (distance < 10f) {  	inertia = (float)Math.Pow (distance / 10.0' 2.0);  }  else {  	inertia = 1f;  }  
Magic Number,FarseerPhysics.Helpers,Camera2D,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Helpers\Camera2D.cs,Update,The following statement contains a magic number: inertia = (float)Math.Pow (distance / 10.0' 2.0);  
Magic Number,FarseerPhysics.Helpers,Camera2D,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Helpers\Camera2D.cs,Update,The following statement contains a magic number: inertia = (float)Math.Pow (distance / 10.0' 2.0);  
Magic Number,FarseerPhysics.Helpers,Camera2D,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Helpers\Camera2D.cs,Update,The following statement contains a magic number: if (Math.Abs (rotDelta) < 5f) {  	rotInertia = (float)Math.Pow (rotDelta / 5.0' 2.0);  }  else {  	rotInertia = 1f;  }  
Magic Number,FarseerPhysics.Helpers,Camera2D,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Helpers\Camera2D.cs,Update,The following statement contains a magic number: if (Math.Abs (rotDelta) < 5f) {  	rotInertia = (float)Math.Pow (rotDelta / 5.0' 2.0);  }  else {  	rotInertia = 1f;  }  
Magic Number,FarseerPhysics.Helpers,Camera2D,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Helpers\Camera2D.cs,Update,The following statement contains a magic number: rotInertia = (float)Math.Pow (rotDelta / 5.0' 2.0);  
Magic Number,FarseerPhysics.Helpers,Camera2D,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Helpers\Camera2D.cs,Update,The following statement contains a magic number: rotInertia = (float)Math.Pow (rotDelta / 5.0' 2.0);  
Duplicate Code,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\ContactSolver.cs,SolveVelocityConstraints,The method contains a code clone-set at the following line numbers (starting from the method definition): ((101' 120)' (148' 167)' (189' 208))
Duplicate Code,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\ContactSolver.cs,SolveVelocityConstraints,The method contains a code clone-set at the following line numbers (starting from the method definition): ((148' 168)' (189' 209))
Missing Default,FarseerPhysics.Collision.Shapes,PolygonShape,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Collision\Shapes\PolygonShape.cs,ComputeSubmergedArea,The following switch statement is missing a default case: switch (diveCount) {  case 0:  	if (lastSubmerged) {  		//Completely submerged  		sc = MathUtils.Multiply (ref xf' MassData.Centroid);  		return MassData.Mass / Density;  	}  	else {  		//Completely dry  		return 0;  	}  	break;  case 1:  	if (intoIndex == -1) {  		intoIndex = Vertices.Count - 1;  	}  	else {  		outoIndex = Vertices.Count - 1;  	}  	break;  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower ()) {  case "vertices":  	{  		List<Vector2> verts = new List<Vector2> ();  		foreach (XMLFragmentElement vert in sn.Elements)  			verts.Add (ReadVector (vert));  		shape.Set (new Vertices (verts.ToArray ()));  	}  	break;  case "centroid":  	shape.MassData.Centroid = ReadVector (sn);  	break;  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower ()) {  case "shape":  	fixture.Shape = _shapes [int.Parse (sn.Value)];  	break;  case "density":  	fixture.Shape.Density = float.Parse (sn.Value);  	break;  case "filterdata":  	foreach (XMLFragmentElement ssn in sn.Elements) {  		switch (ssn.Name.ToLower ()) {  		case "categorybits":  			fixture._collisionCategories = (Category)int.Parse (ssn.Value);  			break;  		case "maskbits":  			fixture._collidesWith = (Category)int.Parse (ssn.Value);  			break;  		case "groupindex":  			fixture._collisionGroup = short.Parse (ssn.Value);  			break;  		}  	}  	break;  case "friction":  	fixture.Friction = float.Parse (sn.Value);  	break;  case "issensor":  	fixture.IsSensor = bool.Parse (sn.Value);  	break;  case "restitution":  	fixture.Restitution = float.Parse (sn.Value);  	break;  case "userdata":  	fixture.UserData = ReadSimpleType (sn' null' false);  	break;  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (ssn.Name.ToLower ()) {  case "categorybits":  	fixture._collisionCategories = (Category)int.Parse (ssn.Value);  	break;  case "maskbits":  	fixture._collidesWith = (Category)int.Parse (ssn.Value);  	break;  case "groupindex":  	fixture._collisionGroup = short.Parse (ssn.Value);  	break;  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower ()) {  case "active":  	if (bool.Parse (sn.Value))  		body.Flags |= BodyFlags.Enabled;  	else  		body.Flags &= ~BodyFlags.Enabled;  	break;  case "allowsleep":  	body.SleepingAllowed = bool.Parse (sn.Value);  	break;  case "angle":  	{  		Vector2 position = body.Position;  		body.SetTransformIgnoreContacts (ref position' float.Parse (sn.Value));  	}  	break;  case "angulardamping":  	body.AngularDamping = float.Parse (sn.Value);  	break;  case "angularvelocity":  	body.AngularVelocity = float.Parse (sn.Value);  	break;  case "awake":  	body.Awake = bool.Parse (sn.Value);  	break;  case "bullet":  	body.IsBullet = bool.Parse (sn.Value);  	break;  case "fixedrotation":  	body.FixedRotation = bool.Parse (sn.Value);  	break;  case "lineardamping":  	body.LinearDamping = float.Parse (sn.Value);  	break;  case "linearvelocity":  	body.LinearVelocity = ReadVector (sn);  	break;  case "position":  	{  		float rotation = body.Rotation;  		Vector2 position = ReadVector (sn);  		body.SetTransformIgnoreContacts (ref position' rotation);  	}  	break;  case "userdata":  	body.UserData = ReadSimpleType (sn' null' false);  	break;  case "fixtures": {  	foreach (XMLFragmentElement v in sn.Elements) {  		Fixture blueprint = _fixtures [int.Parse (v.Value)];  		Fixture f = new Fixture (body' blueprint.Shape);  		f.Restitution = blueprint.Restitution;  		f.UserData = blueprint.UserData;  		f.Friction = blueprint.Friction;  		f.CollidesWith = blueprint.CollidesWith;  		f.CollisionCategories = blueprint.CollisionCategories;  		f.CollisionGroup = blueprint.CollisionGroup;  	}  	break;  }  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower ()) {  case "bodya":  	bodyAIndex = int.Parse (sn.Value);  	break;  case "bodyb":  	bodyBIndex = int.Parse (sn.Value);  	break;  case "collideconnected":  	collideConnected = bool.Parse (sn.Value);  	break;  case "userdata":  	userData = ReadSimpleType (sn' null' false);  	break;  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (type) {  case JointType.Distance:  	{  		switch (sn.Name.ToLower ()) {  		case "dampingratio":  			((DistanceJoint)joint).DampingRatio = float.Parse (sn.Value);  			break;  		case "frequencyhz":  			((DistanceJoint)joint).Frequency = float.Parse (sn.Value);  			break;  		case "length":  			((DistanceJoint)joint).Length = float.Parse (sn.Value);  			break;  		case "localanchora":  			((DistanceJoint)joint).LocalAnchorA = ReadVector (sn);  			break;  		case "localanchorb":  			((DistanceJoint)joint).LocalAnchorB = ReadVector (sn);  			break;  		}  	}  	break;  case JointType.Friction:  	{  		switch (sn.Name.ToLower ()) {  		case "localanchora":  			((FrictionJoint)joint).LocalAnchorA = ReadVector (sn);  			break;  		case "localanchorb":  			((FrictionJoint)joint).LocalAnchorB = ReadVector (sn);  			break;  		case "maxforce":  			((FrictionJoint)joint).MaxForce = float.Parse (sn.Value);  			break;  		case "maxtorque":  			((FrictionJoint)joint).MaxTorque = float.Parse (sn.Value);  			break;  		}  	}  	break;  case JointType.Line:  	{  		switch (sn.Name.ToLower ()) {  		case "enablemotor":  			((LineJoint)joint).MotorEnabled = bool.Parse (sn.Value);  			break;  		case "localanchora":  			((LineJoint)joint).LocalAnchorA = ReadVector (sn);  			break;  		case "localanchorb":  			((LineJoint)joint).LocalAnchorB = ReadVector (sn);  			break;  		case "motorspeed":  			((LineJoint)joint).MotorSpeed = float.Parse (sn.Value);  			break;  		case "dampingratio":  			((LineJoint)joint).DampingRatio = float.Parse (sn.Value);  			break;  		case "maxmotortorque":  			((LineJoint)joint).MaxMotorTorque = float.Parse (sn.Value);  			break;  		case "frequencyhz":  			((LineJoint)joint).Frequency = float.Parse (sn.Value);  			break;  		case "localxaxis":  			((LineJoint)joint).LocalXAxis = ReadVector (sn);  			break;  		}  	}  	break;  case JointType.Prismatic:  	{  		switch (sn.Name.ToLower ()) {  		case "enablelimit":  			((PrismaticJoint)joint).LimitEnabled = bool.Parse (sn.Value);  			break;  		case "enablemotor":  			((PrismaticJoint)joint).MotorEnabled = bool.Parse (sn.Value);  			break;  		case "localanchora":  			((PrismaticJoint)joint).LocalAnchorA = ReadVector (sn);  			break;  		case "localanchorb":  			((PrismaticJoint)joint).LocalAnchorB = ReadVector (sn);  			break;  		case "local1axis1":  			((PrismaticJoint)joint).LocalXAxis1 = ReadVector (sn);  			break;  		case "maxmotorforce":  			((PrismaticJoint)joint).MaxMotorForce = float.Parse (sn.Value);  			break;  		case "motorspeed":  			((PrismaticJoint)joint).MotorSpeed = float.Parse (sn.Value);  			break;  		case "lowertranslation":  			((PrismaticJoint)joint).LowerLimit = float.Parse (sn.Value);  			break;  		case "uppertranslation":  			((PrismaticJoint)joint).UpperLimit = float.Parse (sn.Value);  			break;  		case "referenceangle":  			((PrismaticJoint)joint).ReferenceAngle = float.Parse (sn.Value);  			break;  		}  	}  	break;  case JointType.Pulley:  	{  		switch (sn.Name.ToLower ()) {  		case "groundanchora":  			((PulleyJoint)joint).GroundAnchorA = ReadVector (sn);  			break;  		case "groundanchorb":  			((PulleyJoint)joint).GroundAnchorB = ReadVector (sn);  			break;  		case "lengtha":  			((PulleyJoint)joint).LengthA = float.Parse (sn.Value);  			break;  		case "lengthb":  			((PulleyJoint)joint).LengthB = float.Parse (sn.Value);  			break;  		case "localanchora":  			((PulleyJoint)joint).LocalAnchorA = ReadVector (sn);  			break;  		case "localanchorb":  			((PulleyJoint)joint).LocalAnchorB = ReadVector (sn);  			break;  		case "maxlengtha":  			((PulleyJoint)joint).MaxLengthA = float.Parse (sn.Value);  			break;  		case "maxlengthb":  			((PulleyJoint)joint).MaxLengthB = float.Parse (sn.Value);  			break;  		case "ratio":  			((PulleyJoint)joint).Ratio = float.Parse (sn.Value);  			break;  		}  	}  	break;  case JointType.Revolute:  	{  		switch (sn.Name.ToLower ()) {  		case "enablelimit":  			((RevoluteJoint)joint).LimitEnabled = bool.Parse (sn.Value);  			break;  		case "enablemotor":  			((RevoluteJoint)joint).MotorEnabled = bool.Parse (sn.Value);  			break;  		case "localanchora":  			((RevoluteJoint)joint).LocalAnchorA = ReadVector (sn);  			break;  		case "localanchorb":  			((RevoluteJoint)joint).LocalAnchorB = ReadVector (sn);  			break;  		case "maxmotortorque":  			((RevoluteJoint)joint).MaxMotorTorque = float.Parse (sn.Value);  			break;  		case "motorspeed":  			((RevoluteJoint)joint).MotorSpeed = float.Parse (sn.Value);  			break;  		case "lowerangle":  			((RevoluteJoint)joint).LowerLimit = float.Parse (sn.Value);  			break;  		case "upperangle":  			((RevoluteJoint)joint).UpperLimit = float.Parse (sn.Value);  			break;  		case "referenceangle":  			((RevoluteJoint)joint).ReferenceAngle = float.Parse (sn.Value);  			break;  		}  	}  	break;  case JointType.Weld:  	{  		switch (sn.Name.ToLower ()) {  		case "localanchora":  			((WeldJoint)joint).LocalAnchorA = ReadVector (sn);  			break;  		case "localanchorb":  			((WeldJoint)joint).LocalAnchorB = ReadVector (sn);  			break;  		}  	}  	break;  case JointType.Rope:  	{  		switch (sn.Name.ToLower ()) {  		case "localanchora":  			((RopeJoint)joint).LocalAnchorA = ReadVector (sn);  			break;  		case "localanchorb":  			((RopeJoint)joint).LocalAnchorB = ReadVector (sn);  			break;  		case "maxlength":  			((RopeJoint)joint).MaxLength = float.Parse (sn.Value);  			break;  		}  	}  	break;  case JointType.Gear:  	throw new Exception ("Gear joint is unsupported");  case JointType.Angle:  	{  		switch (sn.Name.ToLower ()) {  		case "biasfactor":  			((AngleJoint)joint).BiasFactor = float.Parse (sn.Value);  			break;  		case "maximpulse":  			((AngleJoint)joint).MaxImpulse = float.Parse (sn.Value);  			break;  		case "softness":  			((AngleJoint)joint).Softness = float.Parse (sn.Value);  			break;  		case "targetangle":  			((AngleJoint)joint).TargetAngle = float.Parse (sn.Value);  			break;  		}  	}  	break;  case JointType.Slider:  	{  		switch (sn.Name.ToLower ()) {  		case "dampingratio":  			((SliderJoint)joint).DampingRatio = float.Parse (sn.Value);  			break;  		case "frequencyhz":  			((SliderJoint)joint).Frequency = float.Parse (sn.Value);  			break;  		case "maxlength":  			((SliderJoint)joint).MaxLength = float.Parse (sn.Value);  			break;  		case "minlength":  			((SliderJoint)joint).MinLength = float.Parse (sn.Value);  			break;  		case "localanchora":  			((SliderJoint)joint).LocalAnchorA = ReadVector (sn);  			break;  		case "localanchorb":  			((SliderJoint)joint).LocalAnchorB = ReadVector (sn);  			break;  		}  	}  	break;  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower ()) {  case "dampingratio":  	((DistanceJoint)joint).DampingRatio = float.Parse (sn.Value);  	break;  case "frequencyhz":  	((DistanceJoint)joint).Frequency = float.Parse (sn.Value);  	break;  case "length":  	((DistanceJoint)joint).Length = float.Parse (sn.Value);  	break;  case "localanchora":  	((DistanceJoint)joint).LocalAnchorA = ReadVector (sn);  	break;  case "localanchorb":  	((DistanceJoint)joint).LocalAnchorB = ReadVector (sn);  	break;  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower ()) {  case "localanchora":  	((FrictionJoint)joint).LocalAnchorA = ReadVector (sn);  	break;  case "localanchorb":  	((FrictionJoint)joint).LocalAnchorB = ReadVector (sn);  	break;  case "maxforce":  	((FrictionJoint)joint).MaxForce = float.Parse (sn.Value);  	break;  case "maxtorque":  	((FrictionJoint)joint).MaxTorque = float.Parse (sn.Value);  	break;  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower ()) {  case "enablemotor":  	((LineJoint)joint).MotorEnabled = bool.Parse (sn.Value);  	break;  case "localanchora":  	((LineJoint)joint).LocalAnchorA = ReadVector (sn);  	break;  case "localanchorb":  	((LineJoint)joint).LocalAnchorB = ReadVector (sn);  	break;  case "motorspeed":  	((LineJoint)joint).MotorSpeed = float.Parse (sn.Value);  	break;  case "dampingratio":  	((LineJoint)joint).DampingRatio = float.Parse (sn.Value);  	break;  case "maxmotortorque":  	((LineJoint)joint).MaxMotorTorque = float.Parse (sn.Value);  	break;  case "frequencyhz":  	((LineJoint)joint).Frequency = float.Parse (sn.Value);  	break;  case "localxaxis":  	((LineJoint)joint).LocalXAxis = ReadVector (sn);  	break;  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower ()) {  case "enablelimit":  	((PrismaticJoint)joint).LimitEnabled = bool.Parse (sn.Value);  	break;  case "enablemotor":  	((PrismaticJoint)joint).MotorEnabled = bool.Parse (sn.Value);  	break;  case "localanchora":  	((PrismaticJoint)joint).LocalAnchorA = ReadVector (sn);  	break;  case "localanchorb":  	((PrismaticJoint)joint).LocalAnchorB = ReadVector (sn);  	break;  case "local1axis1":  	((PrismaticJoint)joint).LocalXAxis1 = ReadVector (sn);  	break;  case "maxmotorforce":  	((PrismaticJoint)joint).MaxMotorForce = float.Parse (sn.Value);  	break;  case "motorspeed":  	((PrismaticJoint)joint).MotorSpeed = float.Parse (sn.Value);  	break;  case "lowertranslation":  	((PrismaticJoint)joint).LowerLimit = float.Parse (sn.Value);  	break;  case "uppertranslation":  	((PrismaticJoint)joint).UpperLimit = float.Parse (sn.Value);  	break;  case "referenceangle":  	((PrismaticJoint)joint).ReferenceAngle = float.Parse (sn.Value);  	break;  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower ()) {  case "groundanchora":  	((PulleyJoint)joint).GroundAnchorA = ReadVector (sn);  	break;  case "groundanchorb":  	((PulleyJoint)joint).GroundAnchorB = ReadVector (sn);  	break;  case "lengtha":  	((PulleyJoint)joint).LengthA = float.Parse (sn.Value);  	break;  case "lengthb":  	((PulleyJoint)joint).LengthB = float.Parse (sn.Value);  	break;  case "localanchora":  	((PulleyJoint)joint).LocalAnchorA = ReadVector (sn);  	break;  case "localanchorb":  	((PulleyJoint)joint).LocalAnchorB = ReadVector (sn);  	break;  case "maxlengtha":  	((PulleyJoint)joint).MaxLengthA = float.Parse (sn.Value);  	break;  case "maxlengthb":  	((PulleyJoint)joint).MaxLengthB = float.Parse (sn.Value);  	break;  case "ratio":  	((PulleyJoint)joint).Ratio = float.Parse (sn.Value);  	break;  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower ()) {  case "enablelimit":  	((RevoluteJoint)joint).LimitEnabled = bool.Parse (sn.Value);  	break;  case "enablemotor":  	((RevoluteJoint)joint).MotorEnabled = bool.Parse (sn.Value);  	break;  case "localanchora":  	((RevoluteJoint)joint).LocalAnchorA = ReadVector (sn);  	break;  case "localanchorb":  	((RevoluteJoint)joint).LocalAnchorB = ReadVector (sn);  	break;  case "maxmotortorque":  	((RevoluteJoint)joint).MaxMotorTorque = float.Parse (sn.Value);  	break;  case "motorspeed":  	((RevoluteJoint)joint).MotorSpeed = float.Parse (sn.Value);  	break;  case "lowerangle":  	((RevoluteJoint)joint).LowerLimit = float.Parse (sn.Value);  	break;  case "upperangle":  	((RevoluteJoint)joint).UpperLimit = float.Parse (sn.Value);  	break;  case "referenceangle":  	((RevoluteJoint)joint).ReferenceAngle = float.Parse (sn.Value);  	break;  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower ()) {  case "localanchora":  	((WeldJoint)joint).LocalAnchorA = ReadVector (sn);  	break;  case "localanchorb":  	((WeldJoint)joint).LocalAnchorB = ReadVector (sn);  	break;  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower ()) {  case "localanchora":  	((RopeJoint)joint).LocalAnchorA = ReadVector (sn);  	break;  case "localanchorb":  	((RopeJoint)joint).LocalAnchorB = ReadVector (sn);  	break;  case "maxlength":  	((RopeJoint)joint).MaxLength = float.Parse (sn.Value);  	break;  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower ()) {  case "biasfactor":  	((AngleJoint)joint).BiasFactor = float.Parse (sn.Value);  	break;  case "maximpulse":  	((AngleJoint)joint).MaxImpulse = float.Parse (sn.Value);  	break;  case "softness":  	((AngleJoint)joint).Softness = float.Parse (sn.Value);  	break;  case "targetangle":  	((AngleJoint)joint).TargetAngle = float.Parse (sn.Value);  	break;  }  
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower ()) {  case "dampingratio":  	((SliderJoint)joint).DampingRatio = float.Parse (sn.Value);  	break;  case "frequencyhz":  	((SliderJoint)joint).Frequency = float.Parse (sn.Value);  	break;  case "maxlength":  	((SliderJoint)joint).MaxLength = float.Parse (sn.Value);  	break;  case "minlength":  	((SliderJoint)joint).MinLength = float.Parse (sn.Value);  	break;  case "localanchora":  	((SliderJoint)joint).LocalAnchorA = ReadVector (sn);  	break;  case "localanchorb":  	((SliderJoint)joint).LocalAnchorB = ReadVector (sn);  	break;  }  
Missing Default,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,DetectVertices,The following switch statement is missing a default case: switch (_polygonDetectionType) {  case VerticesDetectionType.Integrated:  	// Add first hole polygon vertex to close the hole polygon.  	holePolygon.Add (holePolygon [0]);  	int vertex1Index' vertex2Index;  	if (SplitPolygonEdge (polygon' holeEntrance.Value' out vertex1Index' out vertex2Index))  		polygon.InsertRange (vertex2Index' holePolygon);  	break;  case VerticesDetectionType.Separated:  	if (polygon.Holes == null)  		polygon.Holes = new List<Vertices> ();  	polygon.Holes.Add (holePolygon);  	break;  }  
Missing Default,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following switch statement is missing a default case: switch ((int)(current.X - last.X)) {  case 1:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 1;  	case 0:  		return 0;  	case -1:  		return 7;  	}  	break;  case 0:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 2;  	case -1:  		return 6;  	}  	break;  case -1:  	switch ((int)(current.Y - last.Y)) {  	case 1:  		return 3;  	case 0:  		return 4;  	case -1:  		return 5;  	}  	break;  }  
Missing Default,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following switch statement is missing a default case: switch ((int)(current.Y - last.Y)) {  case 1:  	return 1;  case 0:  	return 0;  case -1:  	return 7;  }  
Missing Default,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following switch statement is missing a default case: switch ((int)(current.Y - last.Y)) {  case 1:  	return 2;  case -1:  	return 6;  }  
Missing Default,FarseerPhysics.Common,TextureConverter,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following switch statement is missing a default case: switch ((int)(current.Y - last.Y)) {  case 1:  	return 3;  case 0:  	return 4;  case -1:  	return 5;  }  
Missing Default,FarseerPhysics.Controllers,AbstractForceController,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Controllers\AbstractForceController.cs,AbstractForceController,The following switch statement is missing a default case: switch (mode) {  case TimingModes.Switched:  	Enabled = true;  	break;  case TimingModes.Triggered:  	Enabled = false;  	break;  case TimingModes.Curve:  	Enabled = false;  	break;  }  
Missing Default,FarseerPhysics.Controllers,AbstractForceController,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Controllers\AbstractForceController.cs,Update,The following switch statement is missing a default case: switch (TimingMode) {  case TimingModes.Switched: {  	if (Enabled) {  		ApplyForce (dt' Strength);  	}  	break;  }  case TimingModes.Triggered: {  	if (Enabled && Triggered) {  		if (ImpulseTime < ImpulseLength) {  			ApplyForce (dt' Strength);  			ImpulseTime += dt;  		}  		else {  			Triggered = false;  		}  	}  	break;  }  case TimingModes.Curve: {  	if (Enabled && Triggered) {  		if (ImpulseTime < ImpulseLength) {  			ApplyForce (dt' Strength * StrengthCurve.Evaluate (ImpulseTime));  			ImpulseTime += dt;  		}  		else {  			Triggered = false;  		}  	}  	break;  }  }  
Missing Default,FarseerPhysics.Controllers,GravityController,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Controllers\GravityController.cs,Update,The following switch statement is missing a default case: switch (GravityType) {  case GravityType.DistanceSquared:  	f = Strength / r2 / (float)Math.Sqrt (r2) * body1.Mass * body2.Mass * d;  	break;  case GravityType.Linear:  	f = Strength / r2 * body1.Mass * body2.Mass * d;  	break;  }  
Missing Default,FarseerPhysics.Controllers,GravityController,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Controllers\GravityController.cs,Update,The following switch statement is missing a default case: switch (GravityType) {  case GravityType.DistanceSquared:  	f = Strength / r2 / (float)Math.Sqrt (r2) * body1.Mass * d;  	break;  case GravityType.Linear:  	f = Strength / r2 * body1.Mass * d;  	break;  }  
Missing Default,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Contacts\Contact.cs,Evaluate,The following switch statement is missing a default case: switch (_type) {  case ContactType.Polygon:  	Collision.Collision.CollidePolygons (ref manifold' (PolygonShape)FixtureA.Shape' ref transformA' (PolygonShape)FixtureB.Shape' ref transformB);  	break;  case ContactType.PolygonAndCircle:  	Collision.Collision.CollidePolygonAndCircle (ref manifold' (PolygonShape)FixtureA.Shape' ref transformA' (CircleShape)FixtureB.Shape' ref transformB);  	break;  case ContactType.EdgeAndCircle:  	Collision.Collision.CollideEdgeAndCircle (ref manifold' (EdgeShape)FixtureA.Shape' ref transformA' (CircleShape)FixtureB.Shape' ref transformB);  	break;  case ContactType.EdgeAndPolygon:  	Collision.Collision.CollideEdgeAndPolygon (ref manifold' (EdgeShape)FixtureA.Shape' ref transformA' (PolygonShape)FixtureB.Shape' ref transformB);  	break;  case ContactType.LoopAndCircle:  	LoopShape loop = (LoopShape)FixtureA.Shape;  	loop.GetChildEdge (ref _edge' ChildIndexA);  	Collision.Collision.CollideEdgeAndCircle (ref manifold' _edge' ref transformA' (CircleShape)FixtureB.Shape' ref transformB);  	break;  case ContactType.LoopAndPolygon:  	LoopShape loop2 = (LoopShape)FixtureA.Shape;  	loop2.GetChildEdge (ref _edge' ChildIndexA);  	Collision.Collision.CollideEdgeAndPolygon (ref manifold' _edge' ref transformA' (PolygonShape)FixtureB.Shape' ref transformB);  	break;  case ContactType.Circle:  	Collision.Collision.CollideCircles (ref manifold' (CircleShape)FixtureA.Shape' ref transformA' (CircleShape)FixtureB.Shape' ref transformB);  	break;  }  
Missing Default,FarseerPhysics.Dynamics.Joints,GearJoint,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Joints\GearJoint.cs,GearJoint,The following switch statement is missing a default case: switch (type1) {  case JointType.Revolute:  	BodyA = jointA.BodyB;  	_revolute1 = (RevoluteJoint)jointA;  	LocalAnchor1 = _revolute1.LocalAnchorB;  	coordinate1 = _revolute1.JointAngle;  	break;  case JointType.Prismatic:  	BodyA = jointA.BodyB;  	_prismatic1 = (PrismaticJoint)jointA;  	LocalAnchor1 = _prismatic1.LocalAnchorB;  	coordinate1 = _prismatic1.JointTranslation;  	break;  case JointType.FixedRevolute:  	BodyA = jointA.BodyA;  	_fixedRevolute1 = (FixedRevoluteJoint)jointA;  	LocalAnchor1 = _fixedRevolute1.LocalAnchorA;  	coordinate1 = _fixedRevolute1.JointAngle;  	break;  case JointType.FixedPrismatic:  	BodyA = jointA.BodyA;  	_fixedPrismatic1 = (FixedPrismaticJoint)jointA;  	LocalAnchor1 = _fixedPrismatic1.LocalAnchorA;  	coordinate1 = _fixedPrismatic1.JointTranslation;  	break;  }  
Missing Default,FarseerPhysics.Dynamics.Joints,GearJoint,C:\repos\devedse_TurtleTurner2000\TurtleTurner2000\FarseerPhysicsMonogame\Dynamics\Joints\GearJoint.cs,GearJoint,The following switch statement is missing a default case: switch (type2) {  case JointType.Revolute:  	BodyB = jointB.BodyB;  	_revolute2 = (RevoluteJoint)jointB;  	LocalAnchor2 = _revolute2.LocalAnchorB;  	coordinate2 = _revolute2.JointAngle;  	break;  case JointType.Prismatic:  	BodyB = jointB.BodyB;  	_prismatic2 = (PrismaticJoint)jointB;  	LocalAnchor2 = _prismatic2.LocalAnchorB;  	coordinate2 = _prismatic2.JointTranslation;  	break;  case JointType.FixedRevolute:  	BodyB = jointB.BodyA;  	_fixedRevolute2 = (FixedRevoluteJoint)jointB;  	LocalAnchor2 = _fixedRevolute2.LocalAnchorA;  	coordinate2 = _fixedRevolute2.JointAngle;  	break;  case JointType.FixedPrismatic:  	BodyB = jointB.BodyA;  	_fixedPrismatic2 = (FixedPrismaticJoint)jointB;  	LocalAnchor2 = _fixedPrismatic2.LocalAnchorA;  	coordinate2 = _fixedPrismatic2.JointTranslation;  	break;  }  
