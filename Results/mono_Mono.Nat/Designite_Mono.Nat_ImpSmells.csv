Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,Mono.Nat.Pmp,PortMapAsyncResult,C:\repos\mono_Mono.Nat\src\Mono.Nat\Pmp\AsyncResults\PortMapAsyncResult.cs,PortMapAsyncResult,The method has 5 parameters. Parameters: protocol' port' lifetime' callback' asyncState
Long Identifier,Mono.Nat.Pmp,PmpConstants,C:\repos\mono_Mono.Nat\src\Mono.Nat\Pmp\PmpConstants.cs,,The length of the parameter ResultCodeUnsupportedOperationCode is 34.
Long Statement,Mono.Nat,Mapping,C:\repos\mono_Mono.Nat\src\Mono.Nat\Mapping.cs,ToString,The length of the statement  "            return String.Format( "Protocol: {0}' Public Port: {1}' Private Port: {2}' Description: {3}' Expiration: {4}' Lifetime: {5}"'  " is 125.
Long Statement,Mono.Nat.Pmp,PmpNatDevice,C:\repos\mono_Mono.Nat\src\Mono.Nat\Pmp\PmpNatDevice.cs,BeginCreatePortMap,The length of the statement  "			PortMapAsyncResult pmar = new PortMapAsyncResult (mapping.Protocol' mapping.PublicPort' PmpConstants.DefaultLeaseTime' callback' asyncState); " is 141.
Long Statement,Mono.Nat.Pmp,PmpNatDevice,C:\repos\mono_Mono.Nat\src\Mono.Nat\Pmp\PmpNatDevice.cs,CreatePortMap,The length of the statement  "				throw new MappingException (String.Format ("Failed to {0} portmap (protocol={1}' private port={2}"' type' mapping.Protocol' mapping.PrivatePort));" is 146.
Long Statement,Mono.Nat.Upnp,GetServicesMessage,C:\repos\mono_Mono.Nat\src\Mono.Nat\Upnp\Messages\GetServicesMessage.cs,Encode,The length of the statement  "            HttpWebRequest req = (HttpWebRequest)WebRequest.Create("http://" + this.hostAddress.ToString() + this.servicesDescriptionUrl); " is 126.
Long Statement,Mono.Nat.Upnp,CreatePortMappingMessage,C:\repos\mono_Mono.Nat\src\Mono.Nat\Upnp\Messages\Requests\CreatePortMappingMessage.cs,Encode,The length of the statement  "            WriteFullElement(writer' "NewPortMappingDescription"' string.IsNullOrEmpty(mapping.Description) ? "Mono.Nat" : mapping.Description); " is 132.
Long Statement,Mono.Nat.Upnp,MessageBase,C:\repos\mono_Mono.Nat\src\Mono.Nat\Upnp\Messages\UpnpMessage.cs,Decode,The length of the statement  "                return new ErrorMessage(Convert.ToInt32(node["errorCode"].InnerText' System.Globalization.CultureInfo.InvariantCulture)' " is 120.
Long Statement,Mono.Nat.Upnp,UpnpNatDevice,C:\repos\mono_Mono.Nat\src\Mono.Nat\Upnp\UpnpNatDevice.cs,EndGetAllMappingsInternal,The length of the statement  "			GetGenericPortMappingEntryResponseMessage message = mappingResult.SavedMessage as GetGenericPortMappingEntryResponseMessage; " is 124.
Long Statement,Mono.Nat.Upnp,UpnpNatDevice,C:\repos\mono_Mono.Nat\src\Mono.Nat\Upnp\UpnpNatDevice.cs,EndGetSpecificMappingInternal,The length of the statement  "			GetGenericPortMappingEntryResponseMessage message = mappingResult.SavedMessage as GetGenericPortMappingEntryResponseMessage; " is 124.
Long Statement,Mono.Nat.Upnp,UpnpNatDevice,C:\repos\mono_Mono.Nat\src\Mono.Nat\Upnp\UpnpNatDevice.cs,EndGetSpecificMappingInternal,The length of the statement  "				Mapping mapping = new Mapping(mappingResult.SpecificMapping.Protocol' message.InternalPort' mappingResult.SpecificMapping.PublicPort' message.LeaseDuration); " is 157.
Long Statement,Mono.Nat.Upnp,UpnpNatDevice,C:\repos\mono_Mono.Nat\src\Mono.Nat\Upnp\UpnpNatDevice.cs,ToString,The length of the statement  "                "UpnpNatDevice - EndPoint: {0}' External IP: {1}' Control Url: {2}' Service Description Url: {3}' Service Type: {4}' Last Seen: {5}"' " is 133.
Long Statement,Mono.Nat.Upnp,UpnpNatDevice,C:\repos\mono_Mono.Nat\src\Mono.Nat\Upnp\UpnpNatDevice.cs,ToString,The length of the statement  "                this.hostEndPoint' "Manually Check" /*this.GetExternalIP()*/' this.controlUrl' this.serviceDescriptionUrl' this.serviceType' this.LastSeen); " is 140.
Empty Catch Block,Mono.Nat,PmpSearcher,C:\repos\mono_Mono.Nat\src\Mono.Nat\PmpSearcher.cs,CreateSocketsAndAddGateways,The method has an empty catch block.
Empty Catch Block,Mono.Nat,PmpSearcher,C:\repos\mono_Mono.Nat\src\Mono.Nat\PmpSearcher.cs,Search,The method has an empty catch block.
Empty Catch Block,Mono.Nat,UpnpSearcher,C:\repos\mono_Mono.Nat\src\Mono.Nat\UpnpSearcher.cs,Search,The method has an empty catch block.
Magic Number,Mono.Nat,NatUtility,C:\repos\mono_Mono.Nat\src\Mono.Nat\NatUtility.cs,SearchAndListen,The following statement contains a magic number: while (true)             {                 searching.WaitOne();                  try                 { 					Receive(UpnpSearcher.Instance' UpnpSearcher.sockets); 					Receive(PmpSearcher.Instance' PmpSearcher.sockets);                      foreach (ISearcher s in controllers)                         if (s.NextSearch < DateTime.Now)                         {                             Log("Searching for: {0}"' s.GetType().Name); 							s.Search();                         }                 }                 catch (Exception e)                 {                     if (UnhandledException != null)                         UnhandledException(typeof(NatUtility)' new UnhandledExceptionEventArgs(e' false));                 } 				System.Threading.Thread.Sleep(10);             }
Magic Number,Mono.Nat,NatUtility,C:\repos\mono_Mono.Nat\src\Mono.Nat\NatUtility.cs,Receive,The following statement contains a magic number: IPEndPoint received = new IPEndPoint(IPAddress.Parse("192.168.0.1")' 5351);
Magic Number,Mono.Nat,NatUtility,C:\repos\mono_Mono.Nat\src\Mono.Nat\NatUtility.cs,IsPrivateAddressSpace,The following statement contains a magic number: switch ((int)ba[0]) { 			case 10: 				return true; //10.x.x.x 			case 172: 				return ((int)ba[1] & 16) != 0; //172.16-31.x.x 			case 192: 				return (int)ba[1] == 168; //192.168.x.x 			default: 				return false; 			}
Magic Number,Mono.Nat,NatUtility,C:\repos\mono_Mono.Nat\src\Mono.Nat\NatUtility.cs,IsPrivateAddressSpace,The following statement contains a magic number: switch ((int)ba[0]) { 			case 10: 				return true; //10.x.x.x 			case 172: 				return ((int)ba[1] & 16) != 0; //172.16-31.x.x 			case 192: 				return (int)ba[1] == 168; //192.168.x.x 			default: 				return false; 			}
Magic Number,Mono.Nat,NatUtility,C:\repos\mono_Mono.Nat\src\Mono.Nat\NatUtility.cs,IsPrivateAddressSpace,The following statement contains a magic number: switch ((int)ba[0]) { 			case 10: 				return true; //10.x.x.x 			case 172: 				return ((int)ba[1] & 16) != 0; //172.16-31.x.x 			case 192: 				return (int)ba[1] == 168; //192.168.x.x 			default: 				return false; 			}
Magic Number,Mono.Nat,NatUtility,C:\repos\mono_Mono.Nat\src\Mono.Nat\NatUtility.cs,IsPrivateAddressSpace,The following statement contains a magic number: switch ((int)ba[0]) { 			case 10: 				return true; //10.x.x.x 			case 172: 				return ((int)ba[1] & 16) != 0; //172.16-31.x.x 			case 192: 				return (int)ba[1] == 168; //192.168.x.x 			default: 				return false; 			}
Magic Number,Mono.Nat,NatUtility,C:\repos\mono_Mono.Nat\src\Mono.Nat\NatUtility.cs,IsPrivateAddressSpace,The following statement contains a magic number: switch ((int)ba[0]) { 			case 10: 				return true; //10.x.x.x 			case 172: 				return ((int)ba[1] & 16) != 0; //172.16-31.x.x 			case 192: 				return (int)ba[1] == 168; //192.168.x.x 			default: 				return false; 			}
Magic Number,Mono.Nat,PmpSearcher,C:\repos\mono_Mono.Nat\src\Mono.Nat\PmpSearcher.cs,PmpSearcher,The following statement contains a magic number: timeout = 250;
Magic Number,Mono.Nat,PmpSearcher,C:\repos\mono_Mono.Nat\src\Mono.Nat\PmpSearcher.cs,Search,The following statement contains a magic number: timeout *= 2;
Magic Number,Mono.Nat,PmpSearcher,C:\repos\mono_Mono.Nat\src\Mono.Nat\PmpSearcher.cs,Search,The following statement contains a magic number: if (timeout == 128 * 1000)             {                 timeout = 250;                 nextSearch = DateTime.Now.AddMinutes(10);                 return;             }
Magic Number,Mono.Nat,PmpSearcher,C:\repos\mono_Mono.Nat\src\Mono.Nat\PmpSearcher.cs,Search,The following statement contains a magic number: if (timeout == 128 * 1000)             {                 timeout = 250;                 nextSearch = DateTime.Now.AddMinutes(10);                 return;             }
Magic Number,Mono.Nat,PmpSearcher,C:\repos\mono_Mono.Nat\src\Mono.Nat\PmpSearcher.cs,Search,The following statement contains a magic number: if (timeout == 128 * 1000)             {                 timeout = 250;                 nextSearch = DateTime.Now.AddMinutes(10);                 return;             }
Magic Number,Mono.Nat,PmpSearcher,C:\repos\mono_Mono.Nat\src\Mono.Nat\PmpSearcher.cs,Search,The following statement contains a magic number: if (timeout == 128 * 1000)             {                 timeout = 250;                 nextSearch = DateTime.Now.AddMinutes(10);                 return;             }
Magic Number,Mono.Nat,PmpSearcher,C:\repos\mono_Mono.Nat\src\Mono.Nat\PmpSearcher.cs,Handle,The following statement contains a magic number: if (response.Length != 12)                 return;
Magic Number,Mono.Nat,PmpSearcher,C:\repos\mono_Mono.Nat\src\Mono.Nat\PmpSearcher.cs,Handle,The following statement contains a magic number: int errorcode = IPAddress.NetworkToHostOrder(BitConverter.ToInt16(response' 2));
Magic Number,Mono.Nat,PmpSearcher,C:\repos\mono_Mono.Nat\src\Mono.Nat\PmpSearcher.cs,Handle,The following statement contains a magic number: IPAddress publicIp = new IPAddress(new byte[] { response[8]' response[9]' response[10]' response[11] });
Magic Number,Mono.Nat,PmpSearcher,C:\repos\mono_Mono.Nat\src\Mono.Nat\PmpSearcher.cs,Handle,The following statement contains a magic number: IPAddress publicIp = new IPAddress(new byte[] { response[8]' response[9]' response[10]' response[11] });
Magic Number,Mono.Nat,PmpSearcher,C:\repos\mono_Mono.Nat\src\Mono.Nat\PmpSearcher.cs,Handle,The following statement contains a magic number: IPAddress publicIp = new IPAddress(new byte[] { response[8]' response[9]' response[10]' response[11] });
Magic Number,Mono.Nat,PmpSearcher,C:\repos\mono_Mono.Nat\src\Mono.Nat\PmpSearcher.cs,Handle,The following statement contains a magic number: IPAddress publicIp = new IPAddress(new byte[] { response[8]' response[9]' response[10]' response[11] });
Magic Number,Mono.Nat,PmpSearcher,C:\repos\mono_Mono.Nat\src\Mono.Nat\PmpSearcher.cs,Handle,The following statement contains a magic number: nextSearch = DateTime.Now.AddMinutes(5);
Magic Number,Mono.Nat,PmpSearcher,C:\repos\mono_Mono.Nat\src\Mono.Nat\PmpSearcher.cs,Handle,The following statement contains a magic number: timeout = 250;
Magic Number,Mono.Nat,UpnpSearcher,C:\repos\mono_Mono.Nat\src\Mono.Nat\UpnpSearcher.cs,UpnpSearcher,The following statement contains a magic number: searchEndpoint = new IPEndPoint(IPAddress.Parse("239.255.255.250")' 1900);
Magic Number,Mono.Nat,UpnpSearcher,C:\repos\mono_Mono.Nat\src\Mono.Nat\UpnpSearcher.cs,Search,The following statement contains a magic number: for (int i = 0; i < 3; i++)                 client.Send(data' data.Length' searchEndpoint);
Magic Number,Mono.Nat,UpnpSearcher,C:\repos\mono_Mono.Nat\src\Mono.Nat\UpnpSearcher.cs,Handle,The following statement contains a magic number: try             {                 dataString = Encoding.UTF8.GetString(response);  				if (NatUtility.Verbose) 					NatUtility.Log("UPnP Response: {0}"' dataString);                 // If this device does not have a WANIPConnection service' then ignore it                 // Technically i should be checking for WANIPConnection:1 and InternetGatewayDevice:1                 // but there are some routers missing the '1'.                 string log = "UPnP Response: Router advertised a '{0}' service";                 StringComparison c = StringComparison.OrdinalIgnoreCase;                 if (dataString.IndexOf("urn:schemas-upnp-org:service:WANIPConnection:"' c) != -1)                     NatUtility.Log(log' "urn:schemas-upnp-org:service:WANIPConnection:");                 else if (dataString.IndexOf("urn:schemas-upnp-org:device:InternetGatewayDevice:"' c) != -1)                     NatUtility.Log(log' "urn:schemas-upnp-org:device:InternetGatewayDevice:");                 else if (dataString.IndexOf("urn:schemas-upnp-org:service:WANPPPConnection:"' c) != -1)                     NatUtility.Log(log' "urn:schemas-upnp-org:service:WANPPPConnection:");                 else                     return;                  // We have an internet gateway device now                 UpnpNatDevice d = new UpnpNatDevice(localAddress' dataString' WanIPUrn);                  if (this.devices.Contains(d))                 {                     // We already have found this device' so we just refresh it to let people know it's                     // Still alive. If a device doesn't respond to a search' we dump it.                     this.devices[this.devices.IndexOf(d)].LastSeen = DateTime.Now;                 }                 else                 {  					// If we send 3 requests at a time' ensure we only fetch the services list once 					// even if three responses are received 					if (lastFetched.ContainsKey(endpoint.Address)) 					{ 						DateTime last = lastFetched[endpoint.Address]; 						if ((DateTime.Now - last) < TimeSpan.FromSeconds(20)) 							return; 					} 					lastFetched[endpoint.Address] = DateTime.Now; 					                     // Once we've parsed the information we need' we tell the device to retrieve it's service list                     // Once we successfully receive the service list' the callback provided will be invoked. 					NatUtility.Log("Fetching service list: {0}"' d.HostEndPoint);                     d.GetServicesList(new NatDeviceCallback(DeviceSetupComplete));                 }             }             catch (Exception ex)             {                 Trace.WriteLine("Unhandled exception when trying to decode a device's response Send me the following data: ");                 Trace.WriteLine("ErrorMessage:");                 Trace.WriteLine(ex.Message);                 Trace.WriteLine("Data string:");                 Trace.WriteLine(dataString);             }
Magic Number,Mono.Nat.Pmp,PmpNatDevice,C:\repos\mono_Mono.Nat\src\Mono.Nat\Pmp\PmpNatDevice.cs,CreatePortMapAsync,The following statement contains a magic number: while (attempt < PmpConstants.RetryAttempts && !listenState.Success) { 				udpClient.Send (state.Buffer' state.Buffer.Length' new IPEndPoint (localAddress' PmpConstants.ServerPort));                  listenState.UdpClientReady.Set();  				attempt++; 				delay *= 2; 				Thread.Sleep (delay); 			}
Magic Number,Mono.Nat.Pmp,PmpNatDevice,C:\repos\mono_Mono.Nat\src\Mono.Nat\Pmp\PmpNatDevice.cs,CreatePortMapListen,The following statement contains a magic number: while (!state.Success) {                  byte[] data;                  try                  {                      data = udpClient.Receive(ref endPoint);                  }                  catch (SocketException)                  {                      state.Success = false;                      return;                  } 			 				if (data.Length < 16) 					continue;  				if (data[0] != PmpConstants.Version) 					continue; 			 				byte opCode = (byte)(data[1] & (byte)127); 				 				Protocol protocol = Protocol.Tcp; 				if (opCode == PmpConstants.OperationCodeUdp) 					protocol = Protocol.Udp;  				short resultCode = IPAddress.NetworkToHostOrder (BitConverter.ToInt16 (data' 2)); 				uint epoch = (uint)IPAddress.NetworkToHostOrder (BitConverter.ToInt32 (data' 4));  				int privatePort = (ushort)IPAddress.NetworkToHostOrder (BitConverter.ToInt16 (data' 8)); 				int publicPort = (ushort)IPAddress.NetworkToHostOrder (BitConverter.ToInt16 (data' 10));  				uint lifetime = (uint)IPAddress.NetworkToHostOrder (BitConverter.ToInt32 (data' 12)); 				 				if (resultCode != PmpConstants.ResultCodeSuccess) { 					state.Success = false; 					return; 				} 				 				if (lifetime == 0) { 					//mapping was deleted 					state.Success = true; 					state.Mapping = null; 					return; 				} else { 					//mapping was created 					//TODO: verify that the private port+protocol are a match 					Mapping mapping = state.Mapping; 					mapping.PublicPort = publicPort;                      mapping.Protocol = protocol; 					mapping.Expiration = DateTime.Now.AddSeconds (lifetime);  					state.Success = true; 				} 			}
Magic Number,Mono.Nat.Pmp,PmpNatDevice,C:\repos\mono_Mono.Nat\src\Mono.Nat\Pmp\PmpNatDevice.cs,CreatePortMapListen,The following statement contains a magic number: while (!state.Success) {                  byte[] data;                  try                  {                      data = udpClient.Receive(ref endPoint);                  }                  catch (SocketException)                  {                      state.Success = false;                      return;                  } 			 				if (data.Length < 16) 					continue;  				if (data[0] != PmpConstants.Version) 					continue; 			 				byte opCode = (byte)(data[1] & (byte)127); 				 				Protocol protocol = Protocol.Tcp; 				if (opCode == PmpConstants.OperationCodeUdp) 					protocol = Protocol.Udp;  				short resultCode = IPAddress.NetworkToHostOrder (BitConverter.ToInt16 (data' 2)); 				uint epoch = (uint)IPAddress.NetworkToHostOrder (BitConverter.ToInt32 (data' 4));  				int privatePort = (ushort)IPAddress.NetworkToHostOrder (BitConverter.ToInt16 (data' 8)); 				int publicPort = (ushort)IPAddress.NetworkToHostOrder (BitConverter.ToInt16 (data' 10));  				uint lifetime = (uint)IPAddress.NetworkToHostOrder (BitConverter.ToInt32 (data' 12)); 				 				if (resultCode != PmpConstants.ResultCodeSuccess) { 					state.Success = false; 					return; 				} 				 				if (lifetime == 0) { 					//mapping was deleted 					state.Success = true; 					state.Mapping = null; 					return; 				} else { 					//mapping was created 					//TODO: verify that the private port+protocol are a match 					Mapping mapping = state.Mapping; 					mapping.PublicPort = publicPort;                      mapping.Protocol = protocol; 					mapping.Expiration = DateTime.Now.AddSeconds (lifetime);  					state.Success = true; 				} 			}
Magic Number,Mono.Nat.Pmp,PmpNatDevice,C:\repos\mono_Mono.Nat\src\Mono.Nat\Pmp\PmpNatDevice.cs,CreatePortMapListen,The following statement contains a magic number: while (!state.Success) {                  byte[] data;                  try                  {                      data = udpClient.Receive(ref endPoint);                  }                  catch (SocketException)                  {                      state.Success = false;                      return;                  } 			 				if (data.Length < 16) 					continue;  				if (data[0] != PmpConstants.Version) 					continue; 			 				byte opCode = (byte)(data[1] & (byte)127); 				 				Protocol protocol = Protocol.Tcp; 				if (opCode == PmpConstants.OperationCodeUdp) 					protocol = Protocol.Udp;  				short resultCode = IPAddress.NetworkToHostOrder (BitConverter.ToInt16 (data' 2)); 				uint epoch = (uint)IPAddress.NetworkToHostOrder (BitConverter.ToInt32 (data' 4));  				int privatePort = (ushort)IPAddress.NetworkToHostOrder (BitConverter.ToInt16 (data' 8)); 				int publicPort = (ushort)IPAddress.NetworkToHostOrder (BitConverter.ToInt16 (data' 10));  				uint lifetime = (uint)IPAddress.NetworkToHostOrder (BitConverter.ToInt32 (data' 12)); 				 				if (resultCode != PmpConstants.ResultCodeSuccess) { 					state.Success = false; 					return; 				} 				 				if (lifetime == 0) { 					//mapping was deleted 					state.Success = true; 					state.Mapping = null; 					return; 				} else { 					//mapping was created 					//TODO: verify that the private port+protocol are a match 					Mapping mapping = state.Mapping; 					mapping.PublicPort = publicPort;                      mapping.Protocol = protocol; 					mapping.Expiration = DateTime.Now.AddSeconds (lifetime);  					state.Success = true; 				} 			}
Magic Number,Mono.Nat.Pmp,PmpNatDevice,C:\repos\mono_Mono.Nat\src\Mono.Nat\Pmp\PmpNatDevice.cs,CreatePortMapListen,The following statement contains a magic number: while (!state.Success) {                  byte[] data;                  try                  {                      data = udpClient.Receive(ref endPoint);                  }                  catch (SocketException)                  {                      state.Success = false;                      return;                  } 			 				if (data.Length < 16) 					continue;  				if (data[0] != PmpConstants.Version) 					continue; 			 				byte opCode = (byte)(data[1] & (byte)127); 				 				Protocol protocol = Protocol.Tcp; 				if (opCode == PmpConstants.OperationCodeUdp) 					protocol = Protocol.Udp;  				short resultCode = IPAddress.NetworkToHostOrder (BitConverter.ToInt16 (data' 2)); 				uint epoch = (uint)IPAddress.NetworkToHostOrder (BitConverter.ToInt32 (data' 4));  				int privatePort = (ushort)IPAddress.NetworkToHostOrder (BitConverter.ToInt16 (data' 8)); 				int publicPort = (ushort)IPAddress.NetworkToHostOrder (BitConverter.ToInt16 (data' 10));  				uint lifetime = (uint)IPAddress.NetworkToHostOrder (BitConverter.ToInt32 (data' 12)); 				 				if (resultCode != PmpConstants.ResultCodeSuccess) { 					state.Success = false; 					return; 				} 				 				if (lifetime == 0) { 					//mapping was deleted 					state.Success = true; 					state.Mapping = null; 					return; 				} else { 					//mapping was created 					//TODO: verify that the private port+protocol are a match 					Mapping mapping = state.Mapping; 					mapping.PublicPort = publicPort;                      mapping.Protocol = protocol; 					mapping.Expiration = DateTime.Now.AddSeconds (lifetime);  					state.Success = true; 				} 			}
Magic Number,Mono.Nat.Pmp,PmpNatDevice,C:\repos\mono_Mono.Nat\src\Mono.Nat\Pmp\PmpNatDevice.cs,CreatePortMapListen,The following statement contains a magic number: while (!state.Success) {                  byte[] data;                  try                  {                      data = udpClient.Receive(ref endPoint);                  }                  catch (SocketException)                  {                      state.Success = false;                      return;                  } 			 				if (data.Length < 16) 					continue;  				if (data[0] != PmpConstants.Version) 					continue; 			 				byte opCode = (byte)(data[1] & (byte)127); 				 				Protocol protocol = Protocol.Tcp; 				if (opCode == PmpConstants.OperationCodeUdp) 					protocol = Protocol.Udp;  				short resultCode = IPAddress.NetworkToHostOrder (BitConverter.ToInt16 (data' 2)); 				uint epoch = (uint)IPAddress.NetworkToHostOrder (BitConverter.ToInt32 (data' 4));  				int privatePort = (ushort)IPAddress.NetworkToHostOrder (BitConverter.ToInt16 (data' 8)); 				int publicPort = (ushort)IPAddress.NetworkToHostOrder (BitConverter.ToInt16 (data' 10));  				uint lifetime = (uint)IPAddress.NetworkToHostOrder (BitConverter.ToInt32 (data' 12)); 				 				if (resultCode != PmpConstants.ResultCodeSuccess) { 					state.Success = false; 					return; 				} 				 				if (lifetime == 0) { 					//mapping was deleted 					state.Success = true; 					state.Mapping = null; 					return; 				} else { 					//mapping was created 					//TODO: verify that the private port+protocol are a match 					Mapping mapping = state.Mapping; 					mapping.PublicPort = publicPort;                      mapping.Protocol = protocol; 					mapping.Expiration = DateTime.Now.AddSeconds (lifetime);  					state.Success = true; 				} 			}
Magic Number,Mono.Nat.Pmp,PmpNatDevice,C:\repos\mono_Mono.Nat\src\Mono.Nat\Pmp\PmpNatDevice.cs,CreatePortMapListen,The following statement contains a magic number: while (!state.Success) {                  byte[] data;                  try                  {                      data = udpClient.Receive(ref endPoint);                  }                  catch (SocketException)                  {                      state.Success = false;                      return;                  } 			 				if (data.Length < 16) 					continue;  				if (data[0] != PmpConstants.Version) 					continue; 			 				byte opCode = (byte)(data[1] & (byte)127); 				 				Protocol protocol = Protocol.Tcp; 				if (opCode == PmpConstants.OperationCodeUdp) 					protocol = Protocol.Udp;  				short resultCode = IPAddress.NetworkToHostOrder (BitConverter.ToInt16 (data' 2)); 				uint epoch = (uint)IPAddress.NetworkToHostOrder (BitConverter.ToInt32 (data' 4));  				int privatePort = (ushort)IPAddress.NetworkToHostOrder (BitConverter.ToInt16 (data' 8)); 				int publicPort = (ushort)IPAddress.NetworkToHostOrder (BitConverter.ToInt16 (data' 10));  				uint lifetime = (uint)IPAddress.NetworkToHostOrder (BitConverter.ToInt32 (data' 12)); 				 				if (resultCode != PmpConstants.ResultCodeSuccess) { 					state.Success = false; 					return; 				} 				 				if (lifetime == 0) { 					//mapping was deleted 					state.Success = true; 					state.Mapping = null; 					return; 				} else { 					//mapping was created 					//TODO: verify that the private port+protocol are a match 					Mapping mapping = state.Mapping; 					mapping.PublicPort = publicPort;                      mapping.Protocol = protocol; 					mapping.Expiration = DateTime.Now.AddSeconds (lifetime);  					state.Success = true; 				} 			}
Magic Number,Mono.Nat.Pmp,PmpNatDevice,C:\repos\mono_Mono.Nat\src\Mono.Nat\Pmp\PmpNatDevice.cs,CreatePortMapListen,The following statement contains a magic number: while (!state.Success) {                  byte[] data;                  try                  {                      data = udpClient.Receive(ref endPoint);                  }                  catch (SocketException)                  {                      state.Success = false;                      return;                  } 			 				if (data.Length < 16) 					continue;  				if (data[0] != PmpConstants.Version) 					continue; 			 				byte opCode = (byte)(data[1] & (byte)127); 				 				Protocol protocol = Protocol.Tcp; 				if (opCode == PmpConstants.OperationCodeUdp) 					protocol = Protocol.Udp;  				short resultCode = IPAddress.NetworkToHostOrder (BitConverter.ToInt16 (data' 2)); 				uint epoch = (uint)IPAddress.NetworkToHostOrder (BitConverter.ToInt32 (data' 4));  				int privatePort = (ushort)IPAddress.NetworkToHostOrder (BitConverter.ToInt16 (data' 8)); 				int publicPort = (ushort)IPAddress.NetworkToHostOrder (BitConverter.ToInt16 (data' 10));  				uint lifetime = (uint)IPAddress.NetworkToHostOrder (BitConverter.ToInt32 (data' 12)); 				 				if (resultCode != PmpConstants.ResultCodeSuccess) { 					state.Success = false; 					return; 				} 				 				if (lifetime == 0) { 					//mapping was deleted 					state.Success = true; 					state.Mapping = null; 					return; 				} else { 					//mapping was created 					//TODO: verify that the private port+protocol are a match 					Mapping mapping = state.Mapping; 					mapping.PublicPort = publicPort;                      mapping.Protocol = protocol; 					mapping.Expiration = DateTime.Now.AddSeconds (lifetime);  					state.Success = true; 				} 			}
Magic Number,Mono.Nat.Upnp,CreatePortMappingMessage,C:\repos\mono_Mono.Nat\src\Mono.Nat\Upnp\Messages\Requests\CreatePortMappingMessage.cs,Encode,The following statement contains a magic number: StringBuilder builder = new StringBuilder(256);
Magic Number,Mono.Nat.Upnp,DeletePortMappingMessage,C:\repos\mono_Mono.Nat\src\Mono.Nat\Upnp\Messages\Requests\DeletePortMappingMessage.cs,Encode,The following statement contains a magic number: StringBuilder builder = new StringBuilder(256);
Magic Number,Mono.Nat.Upnp,GetGenericPortMappingEntry,C:\repos\mono_Mono.Nat\src\Mono.Nat\Upnp\Messages\Requests\GetGenericPortMappingEntry.cs,Encode,The following statement contains a magic number: StringBuilder sb = new StringBuilder(128);
Magic Number,Mono.Nat.Upnp,GetSpecificPortMappingEntryMessage,C:\repos\mono_Mono.Nat\src\Mono.Nat\Upnp\Messages\Requests\GetSpecificPortMappingEntryMessage.cs,Encode,The following statement contains a magic number: StringBuilder sb = new StringBuilder(64);
Magic Number,Mono.Nat.Upnp,UpnpNatDevice,C:\repos\mono_Mono.Nat\src\Mono.Nat\Upnp\UpnpNatDevice.cs,UpnpNatDevice,The following statement contains a magic number: string locationDetails = deviceDetails.Substring(deviceDetails.IndexOf("Location"' StringComparison.InvariantCultureIgnoreCase) + 9).Split('\r')[0];
Magic Number,Mono.Nat.Upnp,UpnpNatDevice,C:\repos\mono_Mono.Nat\src\Mono.Nat\Upnp\UpnpNatDevice.cs,UpnpNatDevice,The following statement contains a magic number: if (locationDetails.StartsWith("http://"' StringComparison.InvariantCultureIgnoreCase))  			{  				NatUtility.Log("Found device at: {0}"' locationDetails);  				// This bit strings out the "http://" from the string  				locationDetails = locationDetails.Substring(7);    				// We then split off the end of the string to get something like: 192.168.0.3:241 in our string  				string hostAddressAndPort = locationDetails.Remove(locationDetails.IndexOf('/'));    				// From this we parse out the IP address and Port                  if (hostAddressAndPort.IndexOf(':') > 0)                  {                      this.hostEndPoint = new IPEndPoint(IPAddress.Parse(hostAddressAndPort.Remove(hostAddressAndPort.IndexOf(':')))'                      Convert.ToUInt16(hostAddressAndPort.Substring(hostAddressAndPort.IndexOf(':') + 1)' System.Globalization.CultureInfo.InvariantCulture));                  }                  else                  {                      // there is no port specified' use default port (80)                      this.hostEndPoint = new IPEndPoint(IPAddress.Parse(hostAddressAndPort)' 80);                  }    				NatUtility.Log("Parsed device as: {0}"' this.hostEndPoint.ToString());  				  				// The service description URL is the remainder of the "locationDetails" string. The bit that was originally after the ip  				// and port information  				this.serviceDescriptionUrl = locationDetails.Substring(locationDetails.IndexOf('/'));  			}  			else  			{  				Trace.WriteLine("Couldn't decode address. Please send following string to the developer: ");  				Trace.WriteLine(deviceDetails);  			}
Magic Number,Mono.Nat.Upnp,UpnpNatDevice,C:\repos\mono_Mono.Nat\src\Mono.Nat\Upnp\UpnpNatDevice.cs,UpnpNatDevice,The following statement contains a magic number: if (locationDetails.StartsWith("http://"' StringComparison.InvariantCultureIgnoreCase))  			{  				NatUtility.Log("Found device at: {0}"' locationDetails);  				// This bit strings out the "http://" from the string  				locationDetails = locationDetails.Substring(7);    				// We then split off the end of the string to get something like: 192.168.0.3:241 in our string  				string hostAddressAndPort = locationDetails.Remove(locationDetails.IndexOf('/'));    				// From this we parse out the IP address and Port                  if (hostAddressAndPort.IndexOf(':') > 0)                  {                      this.hostEndPoint = new IPEndPoint(IPAddress.Parse(hostAddressAndPort.Remove(hostAddressAndPort.IndexOf(':')))'                      Convert.ToUInt16(hostAddressAndPort.Substring(hostAddressAndPort.IndexOf(':') + 1)' System.Globalization.CultureInfo.InvariantCulture));                  }                  else                  {                      // there is no port specified' use default port (80)                      this.hostEndPoint = new IPEndPoint(IPAddress.Parse(hostAddressAndPort)' 80);                  }    				NatUtility.Log("Parsed device as: {0}"' this.hostEndPoint.ToString());  				  				// The service description URL is the remainder of the "locationDetails" string. The bit that was originally after the ip  				// and port information  				this.serviceDescriptionUrl = locationDetails.Substring(locationDetails.IndexOf('/'));  			}  			else  			{  				Trace.WriteLine("Couldn't decode address. Please send following string to the developer: ");  				Trace.WriteLine(deviceDetails);  			}
Magic Number,Mono.Nat.Upnp,UpnpNatDevice,C:\repos\mono_Mono.Nat\src\Mono.Nat\Upnp\UpnpNatDevice.cs,EndGetAllMappings,The following statement contains a magic number: if (mappingResult.SavedMessage is ErrorMessage)  			{  				ErrorMessage msg = mappingResult.SavedMessage as ErrorMessage;  				if (msg.ErrorCode != 713)  					throw new MappingException(msg.ErrorCode' msg.Description);  			}
Magic Number,Mono.Nat.Upnp,UpnpNatDevice,C:\repos\mono_Mono.Nat\src\Mono.Nat\Upnp\UpnpNatDevice.cs,DecodeMessageFromResponse,The following statement contains a magic number: byte[] buffer = new byte[10240];
Magic Number,Mono.Nat.Upnp,UpnpNatDevice,C:\repos\mono_Mono.Nat\src\Mono.Nat\Upnp\UpnpNatDevice.cs,ServicesReceived,The following statement contains a magic number: try  			{  				int abortCount = 0;  				int bytesRead = 0;  				byte[] buffer = new byte[10240];  				StringBuilder servicesXml = new StringBuilder();  				XmlDocument xmldoc = new XmlDocument();  				HttpWebRequest request = result.AsyncState as HttpWebRequest;  				response = request.EndGetResponse(result) as HttpWebResponse;  				Stream s = response.GetResponseStream();    				if (response.StatusCode != HttpStatusCode.OK) {  					NatUtility.Log("{0}: Couldn't get services list: {1}"' HostEndPoint' response.StatusCode);  					return; // FIXME: This the best thing to do??  				}    				while (true)  				{  					bytesRead = s.Read(buffer' 0' buffer.Length);  					servicesXml.Append(Encoding.UTF8.GetString(buffer' 0' bytesRead));  					try  					{  						xmldoc.LoadXml(servicesXml.ToString());  						response.Close();  						break;  					}  					catch (XmlException)  					{  						// If we can't receive the entire XML within 500ms' then drop the connection  						// Unfortunately not all routers supply a valid ContentLength (mine doesn't)  						// so this hack is needed to keep testing our recieved data until it gets successfully  						// parsed by the xmldoc. Without this' the code will never pick up my router.  						if (abortCount++ > 50)  						{  						    response.Close();  						    return;  						}  						NatUtility.Log("{0}: Couldn't parse services list"' HostEndPoint);  						System.Threading.Thread.Sleep(10);  					}  				}    				NatUtility.Log("{0}: Parsed services list"' HostEndPoint);  				XmlNamespaceManager ns = new XmlNamespaceManager(xmldoc.NameTable);  				ns.AddNamespace("ns"' "urn:schemas-upnp-org:device-1-0");  				XmlNodeList nodes = xmldoc.SelectNodes("//*/ns:serviceList"' ns);    				foreach (XmlNode node in nodes)  				{  					//Go through each service there  					foreach (XmlNode service in node.ChildNodes)  					{  						//If the service is a WANIPConnection' then we have what we want                          string type = service["serviceType"].InnerText;  						NatUtility.Log("{0}: Found service: {1}"' HostEndPoint' type);                          StringComparison c = StringComparison.OrdinalIgnoreCase;                          if (type.Equals (this.serviceType' c))  						{  							this.controlUrl = service["controlURL"].InnerText;  							NatUtility.Log("{0}: Found upnp service at: {1}"' HostEndPoint' controlUrl);  							try  							{  								Uri u = new Uri(controlUrl);  								if (u.IsAbsoluteUri)  								{  									EndPoint old = hostEndPoint;  									this.hostEndPoint = new IPEndPoint(IPAddress.Parse(u.Host)' u.Port);  									NatUtility.Log("{0}: Absolute URI detected. Host address is now: {1}"' old' HostEndPoint);  									this.controlUrl = controlUrl.Substring(u.GetLeftPart(UriPartial.Authority).Length);  									NatUtility.Log("{0}: New control url: {1}"' HostEndPoint' controlUrl);  								}  							}  							catch  							{  								NatUtility.Log("{0}: Assuming control Uri is relative: {1}"' HostEndPoint' controlUrl);  							}  							NatUtility.Log("{0}: Handshake Complete"' HostEndPoint);  							this.callback(this);  							return;  						}  					}  				}    				//If we get here' it means that we didn't get WANIPConnection service' which means no uPnP forwarding  				//So we don't invoke the callback' so this device is never added to our lists  			}  			catch (WebException ex)  			{  				// Just drop the connection' FIXME: Should i retry?  				NatUtility.Log("{0}: Device denied the connection attempt: {1}"' HostEndPoint' ex);  			}  			finally  			{  				if (response != null)  					response.Close();  			}
Magic Number,Mono.Nat.Upnp,UpnpNatDevice,C:\repos\mono_Mono.Nat\src\Mono.Nat\Upnp\UpnpNatDevice.cs,ServicesReceived,The following statement contains a magic number: try  			{  				int abortCount = 0;  				int bytesRead = 0;  				byte[] buffer = new byte[10240];  				StringBuilder servicesXml = new StringBuilder();  				XmlDocument xmldoc = new XmlDocument();  				HttpWebRequest request = result.AsyncState as HttpWebRequest;  				response = request.EndGetResponse(result) as HttpWebResponse;  				Stream s = response.GetResponseStream();    				if (response.StatusCode != HttpStatusCode.OK) {  					NatUtility.Log("{0}: Couldn't get services list: {1}"' HostEndPoint' response.StatusCode);  					return; // FIXME: This the best thing to do??  				}    				while (true)  				{  					bytesRead = s.Read(buffer' 0' buffer.Length);  					servicesXml.Append(Encoding.UTF8.GetString(buffer' 0' bytesRead));  					try  					{  						xmldoc.LoadXml(servicesXml.ToString());  						response.Close();  						break;  					}  					catch (XmlException)  					{  						// If we can't receive the entire XML within 500ms' then drop the connection  						// Unfortunately not all routers supply a valid ContentLength (mine doesn't)  						// so this hack is needed to keep testing our recieved data until it gets successfully  						// parsed by the xmldoc. Without this' the code will never pick up my router.  						if (abortCount++ > 50)  						{  						    response.Close();  						    return;  						}  						NatUtility.Log("{0}: Couldn't parse services list"' HostEndPoint);  						System.Threading.Thread.Sleep(10);  					}  				}    				NatUtility.Log("{0}: Parsed services list"' HostEndPoint);  				XmlNamespaceManager ns = new XmlNamespaceManager(xmldoc.NameTable);  				ns.AddNamespace("ns"' "urn:schemas-upnp-org:device-1-0");  				XmlNodeList nodes = xmldoc.SelectNodes("//*/ns:serviceList"' ns);    				foreach (XmlNode node in nodes)  				{  					//Go through each service there  					foreach (XmlNode service in node.ChildNodes)  					{  						//If the service is a WANIPConnection' then we have what we want                          string type = service["serviceType"].InnerText;  						NatUtility.Log("{0}: Found service: {1}"' HostEndPoint' type);                          StringComparison c = StringComparison.OrdinalIgnoreCase;                          if (type.Equals (this.serviceType' c))  						{  							this.controlUrl = service["controlURL"].InnerText;  							NatUtility.Log("{0}: Found upnp service at: {1}"' HostEndPoint' controlUrl);  							try  							{  								Uri u = new Uri(controlUrl);  								if (u.IsAbsoluteUri)  								{  									EndPoint old = hostEndPoint;  									this.hostEndPoint = new IPEndPoint(IPAddress.Parse(u.Host)' u.Port);  									NatUtility.Log("{0}: Absolute URI detected. Host address is now: {1}"' old' HostEndPoint);  									this.controlUrl = controlUrl.Substring(u.GetLeftPart(UriPartial.Authority).Length);  									NatUtility.Log("{0}: New control url: {1}"' HostEndPoint' controlUrl);  								}  							}  							catch  							{  								NatUtility.Log("{0}: Assuming control Uri is relative: {1}"' HostEndPoint' controlUrl);  							}  							NatUtility.Log("{0}: Handshake Complete"' HostEndPoint);  							this.callback(this);  							return;  						}  					}  				}    				//If we get here' it means that we didn't get WANIPConnection service' which means no uPnP forwarding  				//So we don't invoke the callback' so this device is never added to our lists  			}  			catch (WebException ex)  			{  				// Just drop the connection' FIXME: Should i retry?  				NatUtility.Log("{0}: Device denied the connection attempt: {1}"' HostEndPoint' ex);  			}  			finally  			{  				if (response != null)  					response.Close();  			}
Magic Number,Mono.Nat.Upnp,UpnpNatDevice,C:\repos\mono_Mono.Nat\src\Mono.Nat\Upnp\UpnpNatDevice.cs,ServicesReceived,The following statement contains a magic number: try  			{  				int abortCount = 0;  				int bytesRead = 0;  				byte[] buffer = new byte[10240];  				StringBuilder servicesXml = new StringBuilder();  				XmlDocument xmldoc = new XmlDocument();  				HttpWebRequest request = result.AsyncState as HttpWebRequest;  				response = request.EndGetResponse(result) as HttpWebResponse;  				Stream s = response.GetResponseStream();    				if (response.StatusCode != HttpStatusCode.OK) {  					NatUtility.Log("{0}: Couldn't get services list: {1}"' HostEndPoint' response.StatusCode);  					return; // FIXME: This the best thing to do??  				}    				while (true)  				{  					bytesRead = s.Read(buffer' 0' buffer.Length);  					servicesXml.Append(Encoding.UTF8.GetString(buffer' 0' bytesRead));  					try  					{  						xmldoc.LoadXml(servicesXml.ToString());  						response.Close();  						break;  					}  					catch (XmlException)  					{  						// If we can't receive the entire XML within 500ms' then drop the connection  						// Unfortunately not all routers supply a valid ContentLength (mine doesn't)  						// so this hack is needed to keep testing our recieved data until it gets successfully  						// parsed by the xmldoc. Without this' the code will never pick up my router.  						if (abortCount++ > 50)  						{  						    response.Close();  						    return;  						}  						NatUtility.Log("{0}: Couldn't parse services list"' HostEndPoint);  						System.Threading.Thread.Sleep(10);  					}  				}    				NatUtility.Log("{0}: Parsed services list"' HostEndPoint);  				XmlNamespaceManager ns = new XmlNamespaceManager(xmldoc.NameTable);  				ns.AddNamespace("ns"' "urn:schemas-upnp-org:device-1-0");  				XmlNodeList nodes = xmldoc.SelectNodes("//*/ns:serviceList"' ns);    				foreach (XmlNode node in nodes)  				{  					//Go through each service there  					foreach (XmlNode service in node.ChildNodes)  					{  						//If the service is a WANIPConnection' then we have what we want                          string type = service["serviceType"].InnerText;  						NatUtility.Log("{0}: Found service: {1}"' HostEndPoint' type);                          StringComparison c = StringComparison.OrdinalIgnoreCase;                          if (type.Equals (this.serviceType' c))  						{  							this.controlUrl = service["controlURL"].InnerText;  							NatUtility.Log("{0}: Found upnp service at: {1}"' HostEndPoint' controlUrl);  							try  							{  								Uri u = new Uri(controlUrl);  								if (u.IsAbsoluteUri)  								{  									EndPoint old = hostEndPoint;  									this.hostEndPoint = new IPEndPoint(IPAddress.Parse(u.Host)' u.Port);  									NatUtility.Log("{0}: Absolute URI detected. Host address is now: {1}"' old' HostEndPoint);  									this.controlUrl = controlUrl.Substring(u.GetLeftPart(UriPartial.Authority).Length);  									NatUtility.Log("{0}: New control url: {1}"' HostEndPoint' controlUrl);  								}  							}  							catch  							{  								NatUtility.Log("{0}: Assuming control Uri is relative: {1}"' HostEndPoint' controlUrl);  							}  							NatUtility.Log("{0}: Handshake Complete"' HostEndPoint);  							this.callback(this);  							return;  						}  					}  				}    				//If we get here' it means that we didn't get WANIPConnection service' which means no uPnP forwarding  				//So we don't invoke the callback' so this device is never added to our lists  			}  			catch (WebException ex)  			{  				// Just drop the connection' FIXME: Should i retry?  				NatUtility.Log("{0}: Device denied the connection attempt: {1}"' HostEndPoint' ex);  			}  			finally  			{  				if (response != null)  					response.Close();  			}
