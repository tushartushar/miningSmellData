Implementation smell,Namespace,Class,File,Method,Description
Long Method,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,TryCreate,The method has 132 lines of code.
Complex Method,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,TryCreate,Cyclomatic complexity of the method is 12
Long Parameter List,PathLib,PureWindowsPath,C:\repos\nemec_pathlib\PathLib\PureWindowsPath.cs,PureWindowsPath,The method has 5 parameters. Parameters: drive' root' dirname' basename' extension
Long Parameter List,PathLib,PureWindowsPath,C:\repos\nemec_pathlib\PathLib\PureWindowsPath.cs,PurePathFactoryFromComponents,The method has 5 parameters. Parameters: drive' root' dirname' basename' extension
Long Parameter List,PathLib,PurePath<TPath>,C:\repos\nemec_pathlib\PathLib\PurePath.cs,PurePath,The method has 5 parameters. Parameters: drive' root' dirname' basename' extension
Long Parameter List,PathLib,PurePath<TPath>,C:\repos\nemec_pathlib\PathLib\PurePath.cs,PurePathFactoryFromComponents,The method has 6 parameters. Parameters: original' drive' root' dirname' basename' extension
Long Parameter List,PathLib,PurePath<TPath>,C:\repos\nemec_pathlib\PathLib\PurePath.cs,PurePathFactoryFromComponents,The method has 5 parameters. Parameters: drive' root' dirname' basename' extension
Long Parameter List,PathLib,PurePosixPath,C:\repos\nemec_pathlib\PathLib\PurePosixPath.cs,PurePosixPath,The method has 5 parameters. Parameters: drive' root' dirname' basename' extension
Long Parameter List,PathLib,PurePosixPath,C:\repos\nemec_pathlib\PathLib\PurePosixPath.cs,PurePathFactoryFromComponents,The method has 5 parameters. Parameters: drive' root' dirname' basename' extension
Long Parameter List,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,DeviceIoControl,The method has 8 parameters. Parameters: hDevice' dwIoControlCode' lpInBuffer' nInBufferSize' outBuffer' nOutBufferSize' lpBytesReturned' lpOverlapped
Long Parameter List,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,CreateFile,The method has 7 parameters. Parameters: fileName' fileAccess' fileShare' securityAttributes' creationDisposition' flags' template
Long Parameter List,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,AdjustTokenPrivileges,The method has 6 parameters. Parameters: TokenHandle' DisableAllPrivileges' NewState' BufferLength' PreviousState' ReturnLength
Long Identifier,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,,The length of the parameter MAXIMUM_REPARSE_DATA_BUFFER_SIZE is 32.
Long Identifier,PathLib.Utils,PathUtils,C:\repos\nemec_pathlib\PathLib\Utils\PathUtils.cs,,The length of the parameter PathSeparatorsForNormalization is 30.
Long Statement,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,TryCreate,The length of the statement  "            success = AdjustTokenPrivileges(token' false' ref tokenPrivileges' Marshal.SizeOf(tokenPrivileges)' IntPtr.Zero' IntPtr.Zero); " is 126.
Long Statement,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,TryCreate,The length of the statement  "            IntPtr handle = CreateFile(path' FileAccess.Read' FileShare.None' 0' FileMode.Open' FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS' IntPtr.Zero); " is 156.
Long Statement,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,TryCreate,The length of the statement  "            const uint controlCode = (FILE_DEVICE_FILE_SYSTEM << 16) | (FILE_ANY_ACCESS << 14) | (FSCTL_GET_REPARSE_POINT << 2) | METHOD_BUFFERED; " is 134.
Long Statement,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,TryCreate,The length of the statement  "            success = DeviceIoControl(handle' controlCode' IntPtr.Zero' 0' out buffer' MAXIMUM_REPARSE_DATA_BUFFER_SIZE' out bytesReturned' IntPtr.Zero); " is 141.
Long Statement,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,TryCreate,The length of the statement  "            Debug.Assert(!(string.IsNullOrEmpty(subsString) && string.IsNullOrEmpty(printString))' "Failed to retrieve parse point"); " is 121.
Long Statement,PathLib,WindowsPath,C:\repos\nemec_pathlib\PathLib\Windows\WindowsPath.cs,WalkDir,The length of the statement  "                using (FindFileNative.SafeFindHandle findHandle = FindFileNative.FindFirstFile(@"\\?\" + directory + @"\*"' out findData)) " is 122.
Complex Conditional,PathLib.Utils,PathUtils,C:\repos\nemec_pathlib\PathLib\Utils\PathUtils.cs,GetDirectoryName,The conditional expression  "l == 1 && separator[0] == '\\' && path.Length >= 2 && path[nLast] == DriveDelimiter"  is complex.
Complex Conditional,PathLib.Utils,PathUtils,C:\repos\nemec_pathlib\PathLib\Utils\PathUtils.cs,findExtension,The conditional expression  "iLastDot > iLastSep &&                      !(path.Length == 0 && iLastDot == 0) &&                       !(path.Length == 2 && iLastDot == 1 && path[0] == '.')"  is complex.
Magic Number,PathLib,PlatformChooser,C:\repos\nemec_pathlib\PathLib\Factories\PlatformChooser.cs,GetPlatform,The following statement contains a magic number: if (p == PlatformID.Unix || p == PlatformID.MacOSX || (int)p == 128)              {                  return Platform.Posix;              }
Magic Number,PathLib,FileSize,C:\repos\nemec_pathlib\PathLib\FileSize.cs,ToString,The following statement contains a magic number: const double lowerTolerance = 0.85;
Magic Number,PathLib,PosixParser,C:\repos\nemec_pathlib\PathLib\PurePosixPath.cs,ParseRoot,The following statement contains a magic number: if (remainingPath.StartsWith(PathSeparator + PathSeparator) &&                      (remainingPath.Length <= 2 || (remainingPath[2]) != PathSeparator[0]))                  {                      return PathSeparator + PathSeparator;                  }
Magic Number,PathLib,PosixParser,C:\repos\nemec_pathlib\PathLib\PurePosixPath.cs,ParseRoot,The following statement contains a magic number: if (remainingPath.StartsWith(PathSeparator + PathSeparator) &&                      (remainingPath.Length <= 2 || (remainingPath[2]) != PathSeparator[0]))                  {                      return PathSeparator + PathSeparator;                  }
Magic Number,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,TryCreate,The following statement contains a magic number: Debug.Assert(!string.IsNullOrEmpty(path) && path.Length > 2 && path[1] == ':' && path[2] == '\\');
Magic Number,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,TryCreate,The following statement contains a magic number: Debug.Assert(!string.IsNullOrEmpty(path) && path.Length > 2 && path[1] == ':' && path[2] == '\\');
Magic Number,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,TryCreate,The following statement contains a magic number: const uint controlCode = (FILE_DEVICE_FILE_SYSTEM << 16) | (FILE_ANY_ACCESS << 14) | (FSCTL_GET_REPARSE_POINT << 2) | METHOD_BUFFERED;
Magic Number,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,TryCreate,The following statement contains a magic number: const uint controlCode = (FILE_DEVICE_FILE_SYSTEM << 16) | (FILE_ANY_ACCESS << 14) | (FSCTL_GET_REPARSE_POINT << 2) | METHOD_BUFFERED;
Magic Number,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,TryCreate,The following statement contains a magic number: const uint controlCode = (FILE_DEVICE_FILE_SYSTEM << 16) | (FILE_ANY_ACCESS << 14) | (FSCTL_GET_REPARSE_POINT << 2) | METHOD_BUFFERED;
Magic Number,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,TryCreate,The following statement contains a magic number: if (buffer.ReparseTag == IO_REPARSE_TAG_SYMLINK)              {                  // for some reason symlinks seem to have an extra two characters on the front                  subsString = new string(buffer.ReparseTarget' (buffer.SubsNameOffset / 2 + 2)' buffer.SubsNameLength / 2);                  printString = new string(buffer.ReparseTarget' (buffer.PrintNameOffset / 2 + 2)' buffer.PrintNameLength / 2);                  tag = TagType.SymbolicLink;              }              else if (buffer.ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)              {                  // This could be a junction or a mounted drive - a mounted drive starts with "\\??\\Volume"                  subsString = new string(buffer.ReparseTarget' buffer.SubsNameOffset/2' buffer.SubsNameLength/2);                  printString = new string(buffer.ReparseTarget' buffer.PrintNameOffset / 2' buffer.PrintNameLength / 2);                  tag = subsString.StartsWith(@"\??\Volume") ? TagType.MountPoint : TagType.JunctionPoint;              }
Magic Number,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,TryCreate,The following statement contains a magic number: if (buffer.ReparseTag == IO_REPARSE_TAG_SYMLINK)              {                  // for some reason symlinks seem to have an extra two characters on the front                  subsString = new string(buffer.ReparseTarget' (buffer.SubsNameOffset / 2 + 2)' buffer.SubsNameLength / 2);                  printString = new string(buffer.ReparseTarget' (buffer.PrintNameOffset / 2 + 2)' buffer.PrintNameLength / 2);                  tag = TagType.SymbolicLink;              }              else if (buffer.ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)              {                  // This could be a junction or a mounted drive - a mounted drive starts with "\\??\\Volume"                  subsString = new string(buffer.ReparseTarget' buffer.SubsNameOffset/2' buffer.SubsNameLength/2);                  printString = new string(buffer.ReparseTarget' buffer.PrintNameOffset / 2' buffer.PrintNameLength / 2);                  tag = subsString.StartsWith(@"\??\Volume") ? TagType.MountPoint : TagType.JunctionPoint;              }
Magic Number,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,TryCreate,The following statement contains a magic number: if (buffer.ReparseTag == IO_REPARSE_TAG_SYMLINK)              {                  // for some reason symlinks seem to have an extra two characters on the front                  subsString = new string(buffer.ReparseTarget' (buffer.SubsNameOffset / 2 + 2)' buffer.SubsNameLength / 2);                  printString = new string(buffer.ReparseTarget' (buffer.PrintNameOffset / 2 + 2)' buffer.PrintNameLength / 2);                  tag = TagType.SymbolicLink;              }              else if (buffer.ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)              {                  // This could be a junction or a mounted drive - a mounted drive starts with "\\??\\Volume"                  subsString = new string(buffer.ReparseTarget' buffer.SubsNameOffset/2' buffer.SubsNameLength/2);                  printString = new string(buffer.ReparseTarget' buffer.PrintNameOffset / 2' buffer.PrintNameLength / 2);                  tag = subsString.StartsWith(@"\??\Volume") ? TagType.MountPoint : TagType.JunctionPoint;              }
Magic Number,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,TryCreate,The following statement contains a magic number: if (buffer.ReparseTag == IO_REPARSE_TAG_SYMLINK)              {                  // for some reason symlinks seem to have an extra two characters on the front                  subsString = new string(buffer.ReparseTarget' (buffer.SubsNameOffset / 2 + 2)' buffer.SubsNameLength / 2);                  printString = new string(buffer.ReparseTarget' (buffer.PrintNameOffset / 2 + 2)' buffer.PrintNameLength / 2);                  tag = TagType.SymbolicLink;              }              else if (buffer.ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)              {                  // This could be a junction or a mounted drive - a mounted drive starts with "\\??\\Volume"                  subsString = new string(buffer.ReparseTarget' buffer.SubsNameOffset/2' buffer.SubsNameLength/2);                  printString = new string(buffer.ReparseTarget' buffer.PrintNameOffset / 2' buffer.PrintNameLength / 2);                  tag = subsString.StartsWith(@"\??\Volume") ? TagType.MountPoint : TagType.JunctionPoint;              }
Magic Number,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,TryCreate,The following statement contains a magic number: if (buffer.ReparseTag == IO_REPARSE_TAG_SYMLINK)              {                  // for some reason symlinks seem to have an extra two characters on the front                  subsString = new string(buffer.ReparseTarget' (buffer.SubsNameOffset / 2 + 2)' buffer.SubsNameLength / 2);                  printString = new string(buffer.ReparseTarget' (buffer.PrintNameOffset / 2 + 2)' buffer.PrintNameLength / 2);                  tag = TagType.SymbolicLink;              }              else if (buffer.ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)              {                  // This could be a junction or a mounted drive - a mounted drive starts with "\\??\\Volume"                  subsString = new string(buffer.ReparseTarget' buffer.SubsNameOffset/2' buffer.SubsNameLength/2);                  printString = new string(buffer.ReparseTarget' buffer.PrintNameOffset / 2' buffer.PrintNameLength / 2);                  tag = subsString.StartsWith(@"\??\Volume") ? TagType.MountPoint : TagType.JunctionPoint;              }
Magic Number,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,TryCreate,The following statement contains a magic number: if (buffer.ReparseTag == IO_REPARSE_TAG_SYMLINK)              {                  // for some reason symlinks seem to have an extra two characters on the front                  subsString = new string(buffer.ReparseTarget' (buffer.SubsNameOffset / 2 + 2)' buffer.SubsNameLength / 2);                  printString = new string(buffer.ReparseTarget' (buffer.PrintNameOffset / 2 + 2)' buffer.PrintNameLength / 2);                  tag = TagType.SymbolicLink;              }              else if (buffer.ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)              {                  // This could be a junction or a mounted drive - a mounted drive starts with "\\??\\Volume"                  subsString = new string(buffer.ReparseTarget' buffer.SubsNameOffset/2' buffer.SubsNameLength/2);                  printString = new string(buffer.ReparseTarget' buffer.PrintNameOffset / 2' buffer.PrintNameLength / 2);                  tag = subsString.StartsWith(@"\??\Volume") ? TagType.MountPoint : TagType.JunctionPoint;              }
Magic Number,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,TryCreate,The following statement contains a magic number: if (buffer.ReparseTag == IO_REPARSE_TAG_SYMLINK)              {                  // for some reason symlinks seem to have an extra two characters on the front                  subsString = new string(buffer.ReparseTarget' (buffer.SubsNameOffset / 2 + 2)' buffer.SubsNameLength / 2);                  printString = new string(buffer.ReparseTarget' (buffer.PrintNameOffset / 2 + 2)' buffer.PrintNameLength / 2);                  tag = TagType.SymbolicLink;              }              else if (buffer.ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)              {                  // This could be a junction or a mounted drive - a mounted drive starts with "\\??\\Volume"                  subsString = new string(buffer.ReparseTarget' buffer.SubsNameOffset/2' buffer.SubsNameLength/2);                  printString = new string(buffer.ReparseTarget' buffer.PrintNameOffset / 2' buffer.PrintNameLength / 2);                  tag = subsString.StartsWith(@"\??\Volume") ? TagType.MountPoint : TagType.JunctionPoint;              }
Magic Number,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,TryCreate,The following statement contains a magic number: if (buffer.ReparseTag == IO_REPARSE_TAG_SYMLINK)              {                  // for some reason symlinks seem to have an extra two characters on the front                  subsString = new string(buffer.ReparseTarget' (buffer.SubsNameOffset / 2 + 2)' buffer.SubsNameLength / 2);                  printString = new string(buffer.ReparseTarget' (buffer.PrintNameOffset / 2 + 2)' buffer.PrintNameLength / 2);                  tag = TagType.SymbolicLink;              }              else if (buffer.ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)              {                  // This could be a junction or a mounted drive - a mounted drive starts with "\\??\\Volume"                  subsString = new string(buffer.ReparseTarget' buffer.SubsNameOffset/2' buffer.SubsNameLength/2);                  printString = new string(buffer.ReparseTarget' buffer.PrintNameOffset / 2' buffer.PrintNameLength / 2);                  tag = subsString.StartsWith(@"\??\Volume") ? TagType.MountPoint : TagType.JunctionPoint;              }
Magic Number,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,TryCreate,The following statement contains a magic number: if (buffer.ReparseTag == IO_REPARSE_TAG_SYMLINK)              {                  // for some reason symlinks seem to have an extra two characters on the front                  subsString = new string(buffer.ReparseTarget' (buffer.SubsNameOffset / 2 + 2)' buffer.SubsNameLength / 2);                  printString = new string(buffer.ReparseTarget' (buffer.PrintNameOffset / 2 + 2)' buffer.PrintNameLength / 2);                  tag = TagType.SymbolicLink;              }              else if (buffer.ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)              {                  // This could be a junction or a mounted drive - a mounted drive starts with "\\??\\Volume"                  subsString = new string(buffer.ReparseTarget' buffer.SubsNameOffset/2' buffer.SubsNameLength/2);                  printString = new string(buffer.ReparseTarget' buffer.PrintNameOffset / 2' buffer.PrintNameLength / 2);                  tag = subsString.StartsWith(@"\??\Volume") ? TagType.MountPoint : TagType.JunctionPoint;              }
Magic Number,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,TryCreate,The following statement contains a magic number: if (buffer.ReparseTag == IO_REPARSE_TAG_SYMLINK)              {                  // for some reason symlinks seem to have an extra two characters on the front                  subsString = new string(buffer.ReparseTarget' (buffer.SubsNameOffset / 2 + 2)' buffer.SubsNameLength / 2);                  printString = new string(buffer.ReparseTarget' (buffer.PrintNameOffset / 2 + 2)' buffer.PrintNameLength / 2);                  tag = TagType.SymbolicLink;              }              else if (buffer.ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)              {                  // This could be a junction or a mounted drive - a mounted drive starts with "\\??\\Volume"                  subsString = new string(buffer.ReparseTarget' buffer.SubsNameOffset/2' buffer.SubsNameLength/2);                  printString = new string(buffer.ReparseTarget' buffer.PrintNameOffset / 2' buffer.PrintNameLength / 2);                  tag = subsString.StartsWith(@"\??\Volume") ? TagType.MountPoint : TagType.JunctionPoint;              }
Magic Number,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,TryCreate,The following statement contains a magic number: if (!string.IsNullOrEmpty(printString))              {                  normalizedTarget = printString;              }              else              {                  // if not we can use the substring with a bit of tweaking                  normalizedTarget = subsString;                  Debug.Assert(normalizedTarget.Length > 2' "Target string too short");                  Debug.Assert(                      (normalizedTarget.StartsWith(@"\??\") && (normalizedTarget[5] == ':' || normalizedTarget.StartsWith(@"\??\Volume")) ||                      (!normalizedTarget.StartsWith(@"\??\") && normalizedTarget[1] != ':'))'                      "Malformed subsString");                  // Junction points must be absolute                  Debug.Assert(                          buffer.ReparseTag == IO_REPARSE_TAG_SYMLINK ||                           normalizedTarget.StartsWith(@"\??\Volume") ||                           normalizedTarget[1] == ':' ||                          normalizedTarget.StartsWith(@"\??\") && normalizedTarget[5] == ':''                      "Relative junction point");                  if (normalizedTarget.StartsWith(@"\??\"))                  {                      normalizedTarget = normalizedTarget.Substring(4);                  }              }
Magic Number,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,TryCreate,The following statement contains a magic number: if (!string.IsNullOrEmpty(printString))              {                  normalizedTarget = printString;              }              else              {                  // if not we can use the substring with a bit of tweaking                  normalizedTarget = subsString;                  Debug.Assert(normalizedTarget.Length > 2' "Target string too short");                  Debug.Assert(                      (normalizedTarget.StartsWith(@"\??\") && (normalizedTarget[5] == ':' || normalizedTarget.StartsWith(@"\??\Volume")) ||                      (!normalizedTarget.StartsWith(@"\??\") && normalizedTarget[1] != ':'))'                      "Malformed subsString");                  // Junction points must be absolute                  Debug.Assert(                          buffer.ReparseTag == IO_REPARSE_TAG_SYMLINK ||                           normalizedTarget.StartsWith(@"\??\Volume") ||                           normalizedTarget[1] == ':' ||                          normalizedTarget.StartsWith(@"\??\") && normalizedTarget[5] == ':''                      "Relative junction point");                  if (normalizedTarget.StartsWith(@"\??\"))                  {                      normalizedTarget = normalizedTarget.Substring(4);                  }              }
Magic Number,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,TryCreate,The following statement contains a magic number: if (!string.IsNullOrEmpty(printString))              {                  normalizedTarget = printString;              }              else              {                  // if not we can use the substring with a bit of tweaking                  normalizedTarget = subsString;                  Debug.Assert(normalizedTarget.Length > 2' "Target string too short");                  Debug.Assert(                      (normalizedTarget.StartsWith(@"\??\") && (normalizedTarget[5] == ':' || normalizedTarget.StartsWith(@"\??\Volume")) ||                      (!normalizedTarget.StartsWith(@"\??\") && normalizedTarget[1] != ':'))'                      "Malformed subsString");                  // Junction points must be absolute                  Debug.Assert(                          buffer.ReparseTag == IO_REPARSE_TAG_SYMLINK ||                           normalizedTarget.StartsWith(@"\??\Volume") ||                           normalizedTarget[1] == ':' ||                          normalizedTarget.StartsWith(@"\??\") && normalizedTarget[5] == ':''                      "Relative junction point");                  if (normalizedTarget.StartsWith(@"\??\"))                  {                      normalizedTarget = normalizedTarget.Substring(4);                  }              }
Magic Number,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,TryCreate,The following statement contains a magic number: if (!string.IsNullOrEmpty(printString))              {                  normalizedTarget = printString;              }              else              {                  // if not we can use the substring with a bit of tweaking                  normalizedTarget = subsString;                  Debug.Assert(normalizedTarget.Length > 2' "Target string too short");                  Debug.Assert(                      (normalizedTarget.StartsWith(@"\??\") && (normalizedTarget[5] == ':' || normalizedTarget.StartsWith(@"\??\Volume")) ||                      (!normalizedTarget.StartsWith(@"\??\") && normalizedTarget[1] != ':'))'                      "Malformed subsString");                  // Junction points must be absolute                  Debug.Assert(                          buffer.ReparseTag == IO_REPARSE_TAG_SYMLINK ||                           normalizedTarget.StartsWith(@"\??\Volume") ||                           normalizedTarget[1] == ':' ||                          normalizedTarget.StartsWith(@"\??\") && normalizedTarget[5] == ':''                      "Relative junction point");                  if (normalizedTarget.StartsWith(@"\??\"))                  {                      normalizedTarget = normalizedTarget.Substring(4);                  }              }
Magic Number,PathLib,ReparsePoint,C:\repos\nemec_pathlib\PathLib\Windows\ReparsePoints.cs,TryCreate,The following statement contains a magic number: if (buffer.ReparseTag == IO_REPARSE_TAG_SYMLINK && (normalizedTarget.Length < 2 || normalizedTarget[1] != ':'))              {                  // it's relative' we need to tack it onto the path                  if (normalizedTarget[0] == '\\')                  {                      normalizedTarget = normalizedTarget.Substring(1);                  }                  if (path.EndsWith(@"\"))                  {                      path = path.Substring(0' path.Length - 1);                  }                  // Need to take the symlink name off the path                  normalizedTarget = path.Substring(0' path.LastIndexOf('\\')) + @"\" + normalizedTarget;                  // Note that if the symlink target path contains any ..s these are not normalised but returned as is.              }
Magic Number,PathLib,WindowsPath,C:\repos\nemec_pathlib\PathLib\Windows\WindowsPath.cs,Resolve,The following statement contains a magic number: using (var fs = File.OpenRead(PurePath.ToString()))              {                  if (fs.SafeFileHandle == null)                  {                      return this;                  }                  var builder = new StringBuilder(512);                  GetFinalPathNameByHandle(fs.SafeFileHandle.DangerousGetHandle()'                      builder' builder.Capacity' 0);                  var newPath = builder.ToString();                    if (newPath.StartsWith(ExtendedLengthPrefix) &&                      !PurePath.ToString().StartsWith(ExtendedLengthPrefix))                  {                      newPath = newPath.Substring(ExtendedLengthPrefix.Length);                  }                  return (_cachedResolve = new WindowsPath(newPath));              }
Magic Number,PathLib,WindowsPath,C:\repos\nemec_pathlib\PathLib\Windows\WindowsPath.cs,ToShortPath,The following statement contains a magic number: var newPath = new StringBuilder(255);
Magic Number,PathLib,WindowsPath,C:\repos\nemec_pathlib\PathLib\Windows\WindowsPath.cs,ToLongPath,The following statement contains a magic number: var newPath = new StringBuilder(255);
Magic Number,PathLib.Utils,PathUtils,C:\repos\nemec_pathlib\PathLib\Utils\PathUtils.cs,GetPathRoot,The following statement contains a magic number: if(separator == "/")              {                  // UNIX                  return path[0] == separator[0] ? separator : String.Empty;              }              else              {                  // Windows                  int len = 2;                    if(path.Length == 1 && path[0] == separator[0])                  {                      return separator;                  }                  else if(path.Length < 2)                  {                      return String.Empty;                  }                    if(path[0] == separator[0] && path[1] == separator[0])                  {                      // UNC: \\server or \\server\share                      // Get server                      while(len < path.Length && path[len] != separator[0])                          len++;                        // Get share                      if(len < path.Length)                      {                          len++;                          while(len < path.Length && path[len] != separator[0])                              len++;                      }                      return separator + separator + path.Substring(2' len - 2);                  }                  else if(path[0] == separator[0])                  {                      // path starts with '\' or '/'                      return separator;                  }                  else if(path[1] == DriveDelimiter)                  {                      // C:\folder                      if(path.Length >= 3 && path[2] == separator[0])                          len++;                  }                  return path.Substring(0' len);              }
Magic Number,PathLib.Utils,PathUtils,C:\repos\nemec_pathlib\PathLib\Utils\PathUtils.cs,GetPathRoot,The following statement contains a magic number: if(separator == "/")              {                  // UNIX                  return path[0] == separator[0] ? separator : String.Empty;              }              else              {                  // Windows                  int len = 2;                    if(path.Length == 1 && path[0] == separator[0])                  {                      return separator;                  }                  else if(path.Length < 2)                  {                      return String.Empty;                  }                    if(path[0] == separator[0] && path[1] == separator[0])                  {                      // UNC: \\server or \\server\share                      // Get server                      while(len < path.Length && path[len] != separator[0])                          len++;                        // Get share                      if(len < path.Length)                      {                          len++;                          while(len < path.Length && path[len] != separator[0])                              len++;                      }                      return separator + separator + path.Substring(2' len - 2);                  }                  else if(path[0] == separator[0])                  {                      // path starts with '\' or '/'                      return separator;                  }                  else if(path[1] == DriveDelimiter)                  {                      // C:\folder                      if(path.Length >= 3 && path[2] == separator[0])                          len++;                  }                  return path.Substring(0' len);              }
Magic Number,PathLib.Utils,PathUtils,C:\repos\nemec_pathlib\PathLib\Utils\PathUtils.cs,GetPathRoot,The following statement contains a magic number: if(separator == "/")              {                  // UNIX                  return path[0] == separator[0] ? separator : String.Empty;              }              else              {                  // Windows                  int len = 2;                    if(path.Length == 1 && path[0] == separator[0])                  {                      return separator;                  }                  else if(path.Length < 2)                  {                      return String.Empty;                  }                    if(path[0] == separator[0] && path[1] == separator[0])                  {                      // UNC: \\server or \\server\share                      // Get server                      while(len < path.Length && path[len] != separator[0])                          len++;                        // Get share                      if(len < path.Length)                      {                          len++;                          while(len < path.Length && path[len] != separator[0])                              len++;                      }                      return separator + separator + path.Substring(2' len - 2);                  }                  else if(path[0] == separator[0])                  {                      // path starts with '\' or '/'                      return separator;                  }                  else if(path[1] == DriveDelimiter)                  {                      // C:\folder                      if(path.Length >= 3 && path[2] == separator[0])                          len++;                  }                  return path.Substring(0' len);              }
Magic Number,PathLib.Utils,PathUtils,C:\repos\nemec_pathlib\PathLib\Utils\PathUtils.cs,GetPathRoot,The following statement contains a magic number: if(separator == "/")              {                  // UNIX                  return path[0] == separator[0] ? separator : String.Empty;              }              else              {                  // Windows                  int len = 2;                    if(path.Length == 1 && path[0] == separator[0])                  {                      return separator;                  }                  else if(path.Length < 2)                  {                      return String.Empty;                  }                    if(path[0] == separator[0] && path[1] == separator[0])                  {                      // UNC: \\server or \\server\share                      // Get server                      while(len < path.Length && path[len] != separator[0])                          len++;                        // Get share                      if(len < path.Length)                      {                          len++;                          while(len < path.Length && path[len] != separator[0])                              len++;                      }                      return separator + separator + path.Substring(2' len - 2);                  }                  else if(path[0] == separator[0])                  {                      // path starts with '\' or '/'                      return separator;                  }                  else if(path[1] == DriveDelimiter)                  {                      // C:\folder                      if(path.Length >= 3 && path[2] == separator[0])                          len++;                  }                  return path.Substring(0' len);              }
Magic Number,PathLib.Utils,PathUtils,C:\repos\nemec_pathlib\PathLib\Utils\PathUtils.cs,GetPathRoot,The following statement contains a magic number: if(separator == "/")              {                  // UNIX                  return path[0] == separator[0] ? separator : String.Empty;              }              else              {                  // Windows                  int len = 2;                    if(path.Length == 1 && path[0] == separator[0])                  {                      return separator;                  }                  else if(path.Length < 2)                  {                      return String.Empty;                  }                    if(path[0] == separator[0] && path[1] == separator[0])                  {                      // UNC: \\server or \\server\share                      // Get server                      while(len < path.Length && path[len] != separator[0])                          len++;                        // Get share                      if(len < path.Length)                      {                          len++;                          while(len < path.Length && path[len] != separator[0])                              len++;                      }                      return separator + separator + path.Substring(2' len - 2);                  }                  else if(path[0] == separator[0])                  {                      // path starts with '\' or '/'                      return separator;                  }                  else if(path[1] == DriveDelimiter)                  {                      // C:\folder                      if(path.Length >= 3 && path[2] == separator[0])                          len++;                  }                  return path.Substring(0' len);              }
Magic Number,PathLib.Utils,PathUtils,C:\repos\nemec_pathlib\PathLib\Utils\PathUtils.cs,GetPathRoot,The following statement contains a magic number: if(separator == "/")              {                  // UNIX                  return path[0] == separator[0] ? separator : String.Empty;              }              else              {                  // Windows                  int len = 2;                    if(path.Length == 1 && path[0] == separator[0])                  {                      return separator;                  }                  else if(path.Length < 2)                  {                      return String.Empty;                  }                    if(path[0] == separator[0] && path[1] == separator[0])                  {                      // UNC: \\server or \\server\share                      // Get server                      while(len < path.Length && path[len] != separator[0])                          len++;                        // Get share                      if(len < path.Length)                      {                          len++;                          while(len < path.Length && path[len] != separator[0])                              len++;                      }                      return separator + separator + path.Substring(2' len - 2);                  }                  else if(path[0] == separator[0])                  {                      // path starts with '\' or '/'                      return separator;                  }                  else if(path[1] == DriveDelimiter)                  {                      // C:\folder                      if(path.Length >= 3 && path[2] == separator[0])                          len++;                  }                  return path.Substring(0' len);              }
Magic Number,PathLib.Utils,PathUtils,C:\repos\nemec_pathlib\PathLib\Utils\PathUtils.cs,GetDirectoryName,The following statement contains a magic number: if(nLast > 0)              {                  // Trim multiple separators in a row                  while (nLast - 1 >= 0 && path[nLast - 1] == separator[0])                  {                      nLast--;                  }                  string ret = path.Substring(0' nLast);                  int l = ret.Length;                    if(l >= 2 && separator[0] == '\\' && ret[l - 1] == DriveDelimiter)                  {                      return ret + separator;                  }                  else if(l == 1 && separator[0] == '\\' && path.Length >= 2 && path[nLast] == DriveDelimiter)                  {                      return ret + DriveDelimiter;                  }                  else                  {                      return ret;                  }              }
Magic Number,PathLib.Utils,PathUtils,C:\repos\nemec_pathlib\PathLib\Utils\PathUtils.cs,GetDirectoryName,The following statement contains a magic number: if(nLast > 0)              {                  // Trim multiple separators in a row                  while (nLast - 1 >= 0 && path[nLast - 1] == separator[0])                  {                      nLast--;                  }                  string ret = path.Substring(0' nLast);                  int l = ret.Length;                    if(l >= 2 && separator[0] == '\\' && ret[l - 1] == DriveDelimiter)                  {                      return ret + separator;                  }                  else if(l == 1 && separator[0] == '\\' && path.Length >= 2 && path[nLast] == DriveDelimiter)                  {                      return ret + DriveDelimiter;                  }                  else                  {                      return ret;                  }              }
Magic Number,PathLib.Utils,PathUtils,C:\repos\nemec_pathlib\PathLib\Utils\PathUtils.cs,findExtension,The following statement contains a magic number: if(path != null)              {                  int iLastDot = path.LastIndexOf('.');                  int iLastSep = path.LastIndexOf(separator);                    if (iLastDot > iLastSep &&                      !(path.Length == 0 && iLastDot == 0) &&                       !(path.Length == 2 && iLastDot == 1 && path[0] == '.'))  // . and .. are not extensions                  {                      return iLastDot;                  }              }
Missing Default,PathLib,PathFactory,C:\repos\nemec_pathlib\PathLib\Factories\PathFactory.cs,Create,The following switch statement is missing a default case: switch (PlatformChooser.GetPlatform())              {                  case Platform.Posix:                      ret =  new PosixPath(paths);                      break;                  case Platform.Windows:                      ret = new WindowsPath(paths);                      break;              }
Missing Default,PathLib,PathFactory,C:\repos\nemec_pathlib\PathLib\Factories\PathFactory.cs,Create,The following switch statement is missing a default case: switch (PlatformChooser.GetPlatform())              {                  case Platform.Posix:                      ret = new PosixPath(path);                      break;                  case Platform.Windows:                      ret =  new WindowsPath(path);                      break;              }
Missing Default,PathLib,PathFactory,C:\repos\nemec_pathlib\PathLib\Factories\PathFactory.cs,TryCreate,The following switch statement is missing a default case: switch (PlatformChooser.GetPlatform())              {                  case Platform.Posix:                      PurePosixPath purePosixPath;                      if (PurePosixPath.TryParse(path' out purePosixPath))                      {                          result = new PosixPath(purePosixPath);                          break;                      }                      return false;                  case Platform.Windows:                      PureWindowsPath pureWindowsPath;                      if (PureWindowsPath.TryParse(path' out pureWindowsPath))                      {                          result = new WindowsPath(path);                          break;                      }                      return false;              }
Missing Default,PathLib,PurePathFactory,C:\repos\nemec_pathlib\PathLib\Factories\PurePathFactory.cs,Create,The following switch statement is missing a default case: switch (PlatformChooser.GetPlatform())              {                  case Platform.Posix:                      ret =  new PurePosixPath(paths);                      break;                  case Platform.Windows:                      ret = new PureWindowsPath(paths);                      break;              }
Missing Default,PathLib,PurePathFactory,C:\repos\nemec_pathlib\PathLib\Factories\PurePathFactory.cs,Create,The following switch statement is missing a default case: switch (PlatformChooser.GetPlatform())              {                  case Platform.Posix:                      ret = new PurePosixPath(path);                      break;                  case Platform.Windows:                      ret =  new PureWindowsPath(path);                      break;              }
Missing Default,PathLib,PurePathFactory,C:\repos\nemec_pathlib\PathLib\Factories\PurePathFactory.cs,TryCreate,The following switch statement is missing a default case: switch (PlatformChooser.GetPlatform())              {                  case Platform.Posix:                      PurePosixPath purePosixPath;                      if (PurePosixPath.TryParse(path' out purePosixPath))                      {                          result = purePosixPath;                          break;                      }                      return false;                  case Platform.Windows:                      PureWindowsPath pureWindowsPath;                      if (PureWindowsPath.TryParse(path' out pureWindowsPath))                      {                          result = pureWindowsPath;                          break;                      }                      return false;              }
